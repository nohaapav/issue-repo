var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/descriptors-XM6FUHC6.mjs
var descriptors_XM6FUHC6_exports = {};
__export(descriptors_XM6FUHC6_exports, {
  Hub: () => Hub,
  Hydration: () => Hydration
});
var minified, commonTrees, tokens, replaceTokens, tokenizedCommonTrees, unwrap, getChainDescriptors, Hydration, Hub;
var init_descriptors_XM6FUHC6 = __esm({
  "node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/descriptors-XM6FUHC6.mjs"() {
    [minified, commonTrees, tokens] = JSON.parse(`[{"hydration":{"91":{"18":{"0":0,"1":1,"2":2,"3":3,"4":1,"5":4,"6":5,"7":1,"8":6,"9":7,"10":8,"11":1,"12":9,"13":10,"14":2,"15":2,"16":11,"17":12},"19":0,"20":{"AccountCurrencyMap":18,"AcceptedCurrencies":19,"AcceptedCurrencyPrice":19,"TransactionCurrencyOverride":18},"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":{"0":20},"30":0,"31":0,"32":{"ReferendumCount":1,"ReferendumInfoFor":21,"TrackQueue":22,"DecidingCount":23,"MetadataOf":4},"33":0,"34":0,"37":{"35":27,"36":1,"AssetIds":28,"AssetLocations":29,"BannedAssets":30,"LocationAssets":31,"ExistentialDepositCounter":32},"38":0,"41":{"35":33,"39":34,"40":32,"HubAssetTradability":1},"42":0,"43":0,"50":{"44":1,"45":32,"46":48,"47":49,"48":50,"49":51},"51":0,"52":0,"53":0,"54":0,"55":{"AssetFee":59,"AssetFeeConfiguration":60},"56":{"39":63,"40":32,"56":62,"Votes":64,"VotesRewarded":65,"PositionVotes":64,"ProcessedVotes":65,"SixSecBlocksSince":1},"57":{"Pools":68,"PoolPegs":69,"AssetTradability":51,"PoolSnapshots":70},"58":{"58":73,"BondIds":72},"59":0,"60":{"PoolData":74,"FeeCollectorWithAsset":75},"62":{"61":78,"ShareToken":18,"TotalLiquidity":77},"63":0,"64":0,"65":{"Collaterals":79,"HollarAmountReceived":19,"FlashMinter":80},"66":{"TotalIssuance":19,"Locks":81,"Accounts":82,"Reserves":81},"67":0,"68":0,"69":0,"70":{"5":88,"Pending":84,"CounterForPending":1,"CurrentBlock":85,"CurrentReceipts":86,"CurrentTransactionStatuses":87},"71":0,"72":0,"73":{"44":1,"45":32,"46":48,"47":89,"48":90,"49":91},"74":0,"75":0,"76":{"ValidationData":96},"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":{"Accumulator":107,"Oracles":108,"WhitelistedAssets":109},"90":0},"108":{"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":{"dispatch_as_treasury":24,"dispatch_as_aave_manager":24,"note_aave_manager":25,"dispatch_with_extra_gas":26,"dispatch_evm_call":24},"37":0,"38":0,"41":{"92":41,"93":42,"add_token":35,"add_liquidity":36,"add_liquidity_with_limit":37,"remove_liquidity":38,"remove_liquidity_with_limit":39,"sacrifice_position":40,"set_asset_tradable_state":43,"refund_refused_asset":44,"set_asset_weight_cap":45,"withdraw_protocol_liquidity":46,"remove_token":47},"42":0,"43":0,"50":0,"51":0,"52":0,"53":0,"54":{"92":54,"93":55,"set_route":56,"force_insert_route":56,"sell_all":57},"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":{"schedule":93,"terminate":94,"unlock_reserves":95},"75":0,"76":0,"77":{"94":97,"95":98,"96":98,"97":99,"98":100,"99":101,"100":102,"101":102,"102":103,"103":103,"104":104,"105":103,"106":105,"107":106},"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":0,"90":0},"109":{"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"37":0,"38":0,"41":0,"42":0,"43":0,"50":0,"51":0,"52":0,"53":0,"54":{"Executed":58},"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":{"Log":83},"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":0,"90":0},"124":{"18":{"110":13,"111":14,"112":1,"113":15,"114":16,"115":1},"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"37":0,"38":0,"41":{"116":32,"117":32,"118":32,"119":32,"HdxAssetId":1,"HubAssetId":1,"MinWithdrawalFee":1,"MinimumPoolLiquidity":32,"BurnProtocolFee":1},"42":0,"43":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":{"AssetFeeParameters":61,"ProtocolFeeParameters":61},"56":{"119":32,"120":66,"121":1,"PeriodLength":1,"MinStake":32,"TimePointsWeight":1,"ActionPointsWeight":1,"TimePointsPerPeriod":1,"UnclaimablePeriods":32,"CurrentStakeWeight":1,"MaxVotes":1},"57":{"122":32,"123":32,"AmplificationRange":71},"58":0,"59":0,"60":{"117":32,"118":32,"122":32,"123":32,"repay_fee":76},"62":{"117":32,"118":32,"121":1,"122":32,"123":32,"GetExchangeFee":76,"OracleSource":66},"63":0,"64":0,"65":{"120":66,"HollarId":1,"MinArbitrageAmount":32,"FlashLoanReceiver":80,"GasLimit":32},"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":{"116":32,"121":1,"MaxPriceDifferenceBetweenBlocks":1,"MaxConfigurablePriceDifferenceBetweenBlocks":1,"MaxSchedulePerBlock":1,"MaxNumberOfRetriesOnError":1,"MinimalPeriod":1,"BumpChance":1,"PolkadotNativeAssetId":1,"MinBudgetInNativeCurrency":32,"FeeReceiver":92,"NamedReserveId":66},"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":{"SlotDuration":32},"86":0,"87":0,"88":0,"89":0,"90":0},"125":{"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"37":0,"38":0,"41":0,"42":0,"43":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":0,"90":0},"135":{"131":{"127":131,"128":132,"129":133,"130":134},"134":{"132":135,"133":136},"CurrenciesApi":{"account":110,"accounts":111,"free_balance":112,"minimum_balance":113},"EthereumRuntimeRPCApi":{"126":121,"chain_id":114,"account_basic":115,"gas_price":116,"account_code_at":117,"author":118,"storage_at":119,"call":120,"current_block":122,"current_receipts":123,"current_transaction_statuses":124,"current_all":125,"extrinsic_filter":126,"elasticity":127,"gas_limit_multiplier_support":128,"pending_block":129,"initialize_pending_block":130},"AaveTradeExecutor":{"pairs":137,"liquidity_depth":138,"pool":139,"pools":140}}},"hub":{"91":{"18":{"0":0,"1":1,"2":2,"3":3,"4":1,"5":4,"6":5,"7":1,"8":6,"9":7,"10":141,"11":1,"12":9,"13":10,"14":2,"15":2,"16":11,"17":12,"ExtrinsicWeightReclaimed":142},"19":0,"21":0,"22":0,"23":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"35":{"0":157,"36":1,"138":156,"139":158,"140":159},"38":0,"56":0,"61":0,"68":0,"75":0,"76":0,"77":0,"78":0,"79":0,"83":0,"84":0,"136":0,"137":0,"141":0,"142":{"0":181,"36":184,"138":180,"139":182,"140":183},"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0},"108":{"18":0,"19":0,"21":0,"22":0,"23":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"35":{"126":160,"force_create":161,"start_destroy":162,"destroy_accounts":162,"destroy_approvals":162,"finish_destroy":162,"mint":163,"burn":164,"transfer":165,"transfer_keep_alive":165,"force_transfer":166,"freeze":167,"thaw":167,"freeze_asset":162,"thaw_asset":162,"transfer_ownership":168,"set_team":169,"set_metadata":170,"clear_metadata":162,"force_set_metadata":171,"force_clear_metadata":162,"force_asset_status":172,"approve_transfer":173,"cancel_approval":174,"force_cancel_approval":175,"transfer_approved":176,"touch":162,"refund":177,"set_min_balance":178,"touch_other":167,"refund_other":167,"block":167,"transfer_all":179},"38":0,"56":0,"61":0,"68":0,"75":0,"76":0,"77":{"94":144,"95":145,"96":145,"97":146,"98":147,"99":101,"100":148,"101":148,"102":149,"103":149,"104":104,"105":149,"106":150,"107":151,"add_authorized_alias":152,"remove_authorized_alias":153,"remove_all_authorized_aliases":154},"78":0,"79":0,"83":0,"84":0,"136":0,"137":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0},"109":{"18":0,"19":0,"21":0,"22":0,"23":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"35":0,"38":0,"56":0,"61":0,"68":0,"75":0,"76":0,"77":0,"78":0,"79":0,"83":0,"84":0,"136":0,"137":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0},"124":{"18":{"110":13,"111":14,"112":1,"113":15,"114":143,"115":1},"19":0,"21":0,"22":0,"23":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"35":0,"38":0,"56":0,"61":0,"68":0,"75":0,"76":0,"77":0,"78":0,"79":0,"83":0,"84":0,"136":0,"137":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0},"125":{"18":0,"19":0,"21":0,"22":0,"23":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"35":0,"38":0,"56":0,"61":0,"68":0,"75":0,"76":0,"77":0,"78":0,"79":0,"83":0,"84":0,"136":0,"137":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0},"135":{"131":{"127":187,"128":188,"129":189,"130":190},"134":{"132":191,"133":192},"AssetConversionApi":{"quote_price_tokens_for_exact_tokens":193,"quote_price_exact_tokens_for_tokens":193,"get_reserves":194}}}},[{}],["Account","ExtrinsicCount","InherentsApplied","BlockWeight","AllExtrinsicsLen","BlockHash","ExtrinsicData","Number","ParentHash","Digest","Events","EventCount","EventTopics","LastRuntimeUpgrade","UpgradedToU32RefCount","UpgradedToTripleRefCount","ExecutionPhase","AuthorizedUpgrade","System","Balances","MultiTransactionPayment","Treasury","Utility","Preimage","Identity","Democracy","TechnicalCommittee","Proxy","Multisig","Uniques","StateTrieMigration","ConvictionVoting","Referenda","Whitelist","Dispatcher","Assets","NextAssetId","AssetRegistry","Claims","Positions","NextPositionId","Omnipool","TransactionPause","Duster","FarmSequencer","DepositSequencer","GlobalFarm","YieldFarm","Deposit","ActiveYieldFarm","OmnipoolWarehouseLM","OmnipoolLiquidityMining","OTC","CircuitBreaker","Router","DynamicFees","Staking","Stableswap","Bonds","OtcSettlements","LBP","PoolAssets","XYK","Referrals","Liquidation","HSM","Tokens","Currencies","Vesting","EVM","Ethereum","EVMAccounts","XYKLiquidityMining","XYKWarehouseLM","DCA","Scheduler","ParachainSystem","PolkadotXcm","XcmpQueue","MessageQueue","OrmlXcm","XTokens","UnknownTokens","CollatorSelection","Session","Aura","Ismp","IsmpParachain","TokenGateway","EmaOracle","Broadcast","storage","sell","buy","send","teleport_assets","reserve_transfer_assets","execute","force_xcm_version","force_default_xcm_version","force_subscribe_version_notify","force_unsubscribe_version_notify","limited_reserve_transfer_assets","limited_teleport_assets","force_suspension","transfer_assets","claim_assets","transfer_assets_using_type_and_then","tx","events","BlockWeights","BlockLength","BlockHashCount","DbWeight","Version","SS58Prefix","MinimumTradingLimit","MaxInRatio","MaxOutRatio","NFTCollectionId","PalletId","NativeAssetId","MinPoolLiquidity","MinTradingLimit","constants","viewFns","create","query_acceptable_payment_assets","query_xcm_weight","query_weight_to_asset_fee","query_delivery_fees","XcmPaymentApi","dry_run_call","dry_run_xcm","DryRunApi","apis","SnowbridgeSystemFrontend","Indices","Asset","Approvals","Metadata","Nfts","ForeignAssets","AssetConversion","Bounties","ChildBounties","AssetRate","NominationPools","VoterList","DelegatedStaking","MultiBlockElection","MultiBlockElectionSigned","AhOps","AhMigrator"]]`);
    replaceTokens = (obj) => Object.fromEntries(
      Object.entries(obj).map(([key, value2]) => {
        const unwrappedValue = typeof value2 === "object" ? replaceTokens(value2) : value2;
        const numericKey = Number(key);
        if (Number.isNaN(numericKey)) {
          return [key, unwrappedValue];
        }
        return [tokens[numericKey], unwrappedValue];
      })
    );
    tokenizedCommonTrees = commonTrees.map(replaceTokens);
    unwrap = (obj, depth) => depth === 0 ? obj : Object.fromEntries(
      Object.entries(obj).map(([key, value2]) => [
        key,
        unwrap(
          typeof value2 === "object" ? value2 : tokenizedCommonTrees[value2],
          depth - 1
        )
      ])
    );
    getChainDescriptors = (key) => unwrap(replaceTokens(minified[key]), 2);
    Hydration = getChainDescriptors("hydration");
    Hub = getChainDescriptors("hub");
  }
});

// node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/metadataTypes-FWGCMXKE.mjs
var metadataTypes_FWGCMXKE_exports = {};
__export(metadataTypes_FWGCMXKE_exports, {
  default: () => metadataTypes_default
});
var content, metadataTypes_default;
var init_metadataTypes_FWGCMXKE = __esm({
  "node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/metadataTypes-FWGCMXKE.mjs"() {
    content = "DQMAAAAQAQEFAAQBAQUAFAEBBQAcAAQAIAAEACQBAQUAIAEBBQAwAQEFAGUEACAAaQQBAQUAbQQBAQUANAEBBQBxBAEBBQB9BAEBBQCBBAEBBQCFBAEBBQCRBAEBBQEBBQAAAAQABAAIAJUEAG0BAAQA1QQABADdBAAEAAQBAAQQY2FsbOUHAQEFAQAEHGFjY291bnQAAQEFAQAIEGNhbGzlByRleHRyYV9nYXMIAQEFAAQA6QcAJAAEAAQAEQIABABtAQARAgAEAQEFAAgABADtBwAIAPEHAQAQFGFzc2V0BDRpbml0aWFsX3ByaWNlCCh3ZWlnaHRfY2FwBDhwb3NpdGlvbl9vd25lcgABAQUBAAgUYXNzZXQEGGFtb3VudAgBAQUBAAwUYXNzZXQEGGFtb3VudAhAbWluX3NoYXJlc19saW1pdAgBAQUBAAgscG9zaXRpb25faWQIGGFtb3VudAgBAQUBAAwscG9zaXRpb25faWQIGGFtb3VudAgkbWluX2xpbWl0CAEBBQEABCxwb3NpdGlvbl9pZAgBAQUBABAgYXNzZXRfaW4EJGFzc2V0X291dAQYYW1vdW50CDhtaW5fYnV5X2Ftb3VudAgBAQUBABAkYXNzZXRfb3V0BCBhc3NldF9pbgQYYW1vdW50CDxtYXhfc2VsbF9hbW91bnQIAQEFAQAIIGFzc2V0X2lkBBRzdGF0ZQQBAQUBAAwgYXNzZXRfaWQEGGFtb3VudAgkcmVjaXBpZW50AAEBBQEACCBhc3NldF9pZAQMY2FwBAEBBQEAECBhc3NldF9pZAQYYW1vdW50CBRwcmljZWUCEGRlc3QAAQEFAQAIIGFzc2V0X2lkBCxiZW5lZmljaWFyeQABAQUABAD5BwD9BwABCAAIAA0IAEECAAQBAQUAnAEBBQCkAQAUIGFzc2V0X2luBCRhc3NldF9vdXQEJGFtb3VudF9pbgg4bWluX2Ftb3VudF9vdXQIFHJvdXRlFQMBAQUBABQgYXNzZXRfaW4EJGFzc2V0X291dAQoYW1vdW50X291dAg0bWF4X2Ftb3VudF9pbggUcm91dGUVAwEBBQEACChhc3NldF9wYWlyAQMkbmV3X3JvdXRlFQMBAQUBABAgYXNzZXRfaW4EJGFzc2V0X291dAQ4bWluX2Ftb3VudF9vdXQIFHJvdXRlFQMBAQUBAQUBABQgYXNzZXRfaW4EJGFzc2V0X291dAQkYW1vdW50X2luCChhbW91bnRfb3V0CCBldmVudF9pZAQABAARCAAEAFkCAQEFAFUCAQEFABUIAAgAGQgACAAlCAApCAAdCAEBBQBpAgEBBQC8AAQALQgABACBAgAEADkIAQEFAD0IANkEAAQABADZBAAAAKECACkIABQBAQUAQQIAAAAIAAAAQQIABABBCAEBBQD9AQApCABJCAApCABNCAEBBQEABAxsb2fZAgAEAGUIAQEFAHUIAQEFAHkIAQEFAH0IAPkEACAAgQgAAQgACACFCAApCAAEAQEFAAABAAggc2NoZWR1bGWhBlRzdGFydF9leGVjdXRpb25fYmxvY2vxAQEBBQEACCxzY2hlZHVsZV9pZARQbmV4dF9leGVjdXRpb25fYmxvY2vxAQEBBQEACAx3aG8AIGFzc2V0X2lkBAEBBQEBBQCtBgEACBBkZXN0vQMcbWVzc2FnZQkHAQEFAQAQEGRlc3S9AyxiZW5lZmljaWFyeb0DGGFzc2V0c7kDOGZlZV9hc3NldF9pdGVtBAEBBQEACBxtZXNzYWdlCQcobWF4X3dlaWdodBgBAQUBAAggbG9jYXRpb24RAhx2ZXJzaW9uBAEBBQEABERtYXliZV94Y21fdmVyc2lvbvEBAQEFAQAEIGxvY2F0aW9uvQMBAQUBABQQZGVzdL0DLGJlbmVmaWNpYXJ5vQMYYXNzZXRzuQM4ZmVlX2Fzc2V0X2l0ZW0EMHdlaWdodF9saW1pdHkDAQEFAQAEJHN1c3BlbmRlZBQBAQUBAAgYYXNzZXRzuQMsYmVuZWZpY2lhcnm9AwEBBQEAHBBkZXN0vQMYYXNzZXRzuQNQYXNzZXRzX3RyYW5zZmVyX3R5cGUNBzhyZW1vdGVfZmVlc19pZBEHSGZlZXNfdHJhbnNmZXJfdHlwZQ0HSGN1c3RvbV94Y21fb25fZGVzdAkHMHdlaWdodF9saW1pdHkDAQEFAQEFAKEIAKUIAKkIAQEFAK0IAQMIBAAATQgBAwQAALUIAQMIBAAACAEDBAQACAEDAAAIAQME/QEAuQgBAwAA+QQBAwT9AQAkAQMAAP0BAQMI/QH5BAAgAQMo/QH9AST5BPkEZQZlBmUGFL0IANEIAQMk/QEk+QT5BGUGZQZlBhS9CADZCAEDAADdCAEDAADhCAEDAADlCAEDAADpCAEDBP0DAG0IAQMAAPEBAQMAAG0BAQME/QMA7QgBAwTxCABtAQEDBAQA/QgBAwQJBwABCQEDCBgRBwAFCQEDCL0DCQcACQkBAwixBOUHACkJAQMIvQMJBwAxCQEDAABpBAEDCAQEAKkBAQMIBAQANQkBAwAAOQkBAQUAmQsBAQUAGAEBBQCdCwEACBBkZXN0gQocbWVzc2FnZaELAQEFAQAQEGRlc3SBCixiZW5lZmljaWFyeYEKGGFzc2V0c30KOGZlZV9hc3NldF9pdGVtBAEBBQEACBxtZXNzYWdloQsobWF4X3dlaWdodBgBAQUBAAggbG9jYXRpb24VChx2ZXJzaW9uBAEBBQEABCBsb2NhdGlvboEKAQEFAQAUEGRlc3SBCixiZW5lZmljaWFyeYEKGGFzc2V0c30KOGZlZV9hc3NldF9pdGVtBDB3ZWlnaHRfbGltaXR5AwEBBQEACBhhc3NldHN9CixiZW5lZmljaWFyeYEKAQEFAQAcEGRlc3SBChhhc3NldHN9ClBhc3NldHNfdHJhbnNmZXJfdHlwZaULOHJlbW90ZV9mZWVzX2lkqQtIZmVlc190cmFuc2Zlcl90eXBlpQtIY3VzdG9tX3hjbV9vbl9kZXN0oQswd2VpZ2h0X2xpbWl0eQMBAQUBAAgcYWxpYXNlcoEKHGV4cGlyZXOpAQEBBQEABBxhbGlhc2VygQoBAQUBAQUBAQUBAQUBAAgUaW5kZXgEFGVycm9yTQkABACxCwARCwC9CwDBCwDFCwAEAMkLAQAMCGlkBBRhZG1pbs0LLG1pbl9iYWxhbmNlCAEBBQEAEAhpZAQUb3duZXLNCzRpc19zdWZmaWNpZW50FCxtaW5fYmFsYW5jZQgBAQUBAAQIaWQEAQEFAQAMCGlkBCxiZW5lZmljaWFyec0LGGFtb3VudAgBAQUBAAwIaWQEDHdob80LGGFtb3VudAgBAQUBAAwIaWQEGHRhcmdldM0LGGFtb3VudAgBAQUBABAIaWQEGHNvdXJjZc0LEGRlc3TNCxhhbW91bnQIAQEFAQAICGlkBAx3aG/NCwEBBQEACAhpZAQUb3duZXLNCwEBBQEAEAhpZAQYaXNzdWVyzQsUYWRtaW7NCxxmcmVlemVyzQsBAQUBABAIaWQEEG5hbWUkGHN5bWJvbCQgZGVjaW1hbHMEAQEFAQAUCGlkBBBuYW1lJBhzeW1ib2wkIGRlY2ltYWxzBCRpc19mcm96ZW4UAQEFAQAgCGlkBBRvd25lcs0LGGlzc3Vlcs0LFGFkbWluzQscZnJlZXplcs0LLG1pbl9iYWxhbmNlCDRpc19zdWZmaWNpZW50FCRpc19mcm96ZW4UAQEFAQAMCGlkBCBkZWxlZ2F0Zc0LGGFtb3VudAgBAQUBAAgIaWQEIGRlbGVnYXRlzQsBAQUBAAwIaWQEFG93bmVyzQsgZGVsZWdhdGXNCwEBBQEAEAhpZAQUb3duZXLNCyxkZXN0aW5hdGlvbs0LGGFtb3VudAgBAQUBAAgIaWQEKGFsbG93X2J1cm4UAQEFAQAICGlkBCxtaW5fYmFsYW5jZQgBAQUBAAwIaWQEEGRlc3TNCyhrZWVwX2FsaXZlFAEBBQAVCgCxCwDRCwC9CwDVCwDFCwAVCgDJCwEBBQAVCgEBBQB5CQEBBQCBCQEDBAQA3QsBAwShCwABCQEDCBipCwAFCQEDCIEKoQsA4QsBAwzxC0EQBABdEAEDCIEKoQsAZRABAxAVChUKCBQAqQEBAwgVChUKAGkQbRABAQECAQMAEBBmcmVlCCByZXNlcnZlZAgYZnJvemVuCBRmbGFncwgAFBRub25jZQQkY29uc3VtZXJzBCRwcm92aWRlcnMELHN1ZmZpY2llbnRzBBBkYXRhDAEAAAggcmVmX3RpbWUIKHByb29mX3NpemUIAAwYbm9ybWFsGCxvcGVyYXRpb25hbBgkbWFuZGF0b3J5GAUBgAUABQEQAhQoUHJlUnVudGltZQADCCgkJENvbnNlbnN1cwADCCgkEFNlYWwAAwgoJBRPdGhlcgEkZFJ1bnRpbWVFbnZpcm9ubWVudFVwZGF0ZWQAAQUELAACDDhBcHBseUV4dHJpbnNpYwEEMEZpbmFsaXphdGlvbgABBThJbml0aWFsaXphdGlvbgABBQIMGE5vcm1hbAABBSxPcGVyYXRpb25hbAABBSRNYW5kYXRvcnkAAQUCCAxZZXMAAQUITm8AAQUADBh3ZWlnaHQYFGNsYXNzOCBwYXlzX2ZlZTwCJDxJbnZhbGlkU3BlY05hbWUAAQVoU3BlY1ZlcnNpb25OZWVkc1RvSW5jcmVhc2UAAQV0RmFpbGVkVG9FeHRyYWN0UnVudGltZVZlcnNpb24AAQVMTm9uRGVmYXVsdENvbXBvc2l0ZQABBTxOb25aZXJvUmVmQ291bnQAAQUwQ2FsbEZpbHRlcmVkAAEFbE11bHRpQmxvY2tNaWdyYXRpb25zT25nb2luZwABBUROb3RoaW5nQXV0aG9yaXplZAABBTBVbmF1dGhvcml6ZWQAAQUCMDhWZXN0aW5nQmFsYW5jZQABBVRMaXF1aWRpdHlSZXN0cmljdGlvbnMAAQVMSW5zdWZmaWNpZW50QmFsYW5jZQABBUhFeGlzdGVudGlhbERlcG9zaXQAAQU0RXhwZW5kYWJpbGl0eQABBVxFeGlzdGluZ1Zlc3RpbmdTY2hlZHVsZQABBSxEZWFkQWNjb3VudAABBTxUb29NYW55UmVzZXJ2ZXMAAQUwVG9vTWFueUhvbGRzAAEFOFRvb01hbnlGcmVlemVzAAEFTElzc3VhbmNlRGVhY3RpdmF0ZWQAAQUkRGVsdGFaZXJvAAEFAjBMVW5zdXBwb3J0ZWRDdXJyZW5jeQABBSxaZXJvQmFsYW5jZQABBTxBbHJlYWR5QWNjZXB0ZWQAAQVMQ29yZUFzc2V0Tm90QWxsb3dlZAABBSRaZXJvUHJpY2UAAQVURmFsbGJhY2tQcmljZU5vdEZvdW5kAAEFIE92ZXJmbG93AAEFUEV2bUFjY291bnROb3RBbGxvd2VkAAEFQEV2bVBlcm1pdEV4cGlyZWQAAQVARXZtUGVybWl0SW52YWxpZAABBWxFdm1QZXJtaXRDYWxsRXhlY3V0aW9uRXJyb3IAAQVQRXZtUGVybWl0UnVubmVyRXJyb3IAAQUCLDBJbnZhbGlkSW5kZXgAAQVAVG9vTWFueUFwcHJvdmFscwABBVhJbnN1ZmZpY2llbnRQZXJtaXNzaW9uAAEFTFByb3Bvc2FsTm90QXBwcm92ZWQAAQVYRmFpbGVkVG9Db252ZXJ0QmFsYW5jZQABBTBTcGVuZEV4cGlyZWQAAQUsRWFybHlQYXlvdXQAAQVAQWxyZWFkeUF0dGVtcHRlZAABBSxQYXlvdXRFcnJvcgABBTBOb3RBdHRlbXB0ZWQAAQUwSW5jb25jbHVzaXZlAAEFAgQwVG9vTWFueUNhbGxzAAEFAiAYVG9vQmlnAAEFMEFscmVhZHlOb3RlZAABBTROb3RBdXRob3JpemVkAAEFIE5vdE5vdGVkAAEFJFJlcXVlc3RlZAABBTBOb3RSZXF1ZXN0ZWQAAQUcVG9vTWFueQABBRhUb29GZXcAAQUCaEhUb29NYW55U3ViQWNjb3VudHMAAQUgTm90Rm91bmQAAQUgTm90TmFtZWQAAQUoRW1wdHlJbmRleAABBShGZWVDaGFuZ2VkAAEFKE5vSWRlbnRpdHkAAQU8U3RpY2t5SnVkZ2VtZW50AAEFOEp1ZGdlbWVudEdpdmVuAAEFQEludmFsaWRKdWRnZW1lbnQAAQUwSW52YWxpZEluZGV4AAEFNEludmFsaWRUYXJnZXQAAQVEVG9vTWFueVJlZ2lzdHJhcnMAAQU4QWxyZWFkeUNsYWltZWQAAQUYTm90U3ViAAEFIE5vdE93bmVkAAEFdEp1ZGdlbWVudEZvckRpZmZlcmVudElkZW50aXR5AAEFWEp1ZGdlbWVudFBheW1lbnRGYWlsZWQAAQU0SW52YWxpZFN1ZmZpeAABBVBOb3RVc2VybmFtZUF1dGhvcml0eQABBTBOb0FsbG9jYXRpb24AAQVASW52YWxpZFNpZ25hdHVyZQABBURSZXF1aXJlc1NpZ25hdHVyZQABBTxJbnZhbGlkVXNlcm5hbWUAAQU0VXNlcm5hbWVUYWtlbgABBShOb1VzZXJuYW1lAAEFKE5vdEV4cGlyZWQAAQUCYCBWYWx1ZUxvdwABBTxQcm9wb3NhbE1pc3NpbmcAAQU8QWxyZWFkeUNhbmNlbGVkAAEFRER1cGxpY2F0ZVByb3Bvc2FsAAEFTFByb3Bvc2FsQmxhY2tsaXN0ZWQAAQVETm90U2ltcGxlTWFqb3JpdHkAAQUsSW52YWxpZEhhc2gAAQUoTm9Qcm9wb3NhbAABBTRBbHJlYWR5VmV0b2VkAAEFRFJlZmVyZW5kdW1JbnZhbGlkAAEFLE5vbmVXYWl0aW5nAAEFIE5vdFZvdGVyAAEFME5vUGVybWlzc2lvbgABBURBbHJlYWR5RGVsZWdhdGluZwABBURJbnN1ZmZpY2llbnRGdW5kcwABBTROb3REZWxlZ2F0aW5nAAEFKFZvdGVzRXhpc3QAAQVESW5zdGFudE5vdEFsbG93ZWQAAQUgTm9uc2Vuc2UAAQU8V3JvbmdVcHBlckJvdW5kAAEFPE1heFZvdGVzUmVhY2hlZAABBRxUb29NYW55AAEFPFZvdGluZ1BlcmlvZExvdwABBUBQcmVpbWFnZU5vdEV4aXN0AAEFAiwkTm90TWVtYmVyAAEFRER1cGxpY2F0ZVByb3Bvc2FsAAEFPFByb3Bvc2FsTWlzc2luZwABBShXcm9uZ0luZGV4AAEFNER1cGxpY2F0ZVZvdGUAAQVIQWxyZWFkeUluaXRpYWxpemVkAAEFIFRvb0Vhcmx5AAEFQFRvb01hbnlQcm9wb3NhbHMAAQVMV3JvbmdQcm9wb3NhbFdlaWdodAABBUxXcm9uZ1Byb3Bvc2FsTGVuZ3RoAAEFVFByaW1lQWNjb3VudE5vdE1lbWJlcgABBQIgHFRvb01hbnkAAQUgTm90Rm91bmQAAQUgTm90UHJveHkAAQUsVW5wcm94eWFibGUAAQUkRHVwbGljYXRlAAEFME5vUGVybWlzc2lvbgABBSxVbmFubm91bmNlZAABBSxOb1NlbGZQcm94eQABBQI4QE1pbmltdW1UaHJlc2hvbGQAAQU8QWxyZWFkeUFwcHJvdmVkAAEFRE5vQXBwcm92YWxzTmVlZGVkAAEFRFRvb0Zld1NpZ25hdG9yaWVzAAEFSFRvb01hbnlTaWduYXRvcmllcwABBVRTaWduYXRvcmllc091dE9mT3JkZXIAAQVMU2VuZGVySW5TaWduYXRvcmllcwABBSBOb3RGb3VuZAABBSBOb3RPd25lcgABBSxOb1RpbWVwb2ludAABBThXcm9uZ1RpbWVwb2ludAABBUxVbmV4cGVjdGVkVGltZXBvaW50AAEFPE1heFdlaWdodFRvb0xvdwABBTRBbHJlYWR5U3RvcmVkAAEFAkgwTm9QZXJtaXNzaW9uAAEFRFVua25vd25Db2xsZWN0aW9uAAEFNEFscmVhZHlFeGlzdHMAAQUoV3JvbmdPd25lcgABBShCYWRXaXRuZXNzAAEFFEluVXNlAAEFGEZyb3plbgABBTRXcm9uZ0RlbGVnYXRlAAEFKE5vRGVsZWdhdGUAAQUoVW5hcHByb3ZlZAABBShVbmFjY2VwdGVkAAEFGExvY2tlZAABBUBNYXhTdXBwbHlSZWFjaGVkAAEFTE1heFN1cHBseUFscmVhZHlTZXQAAQVETWF4U3VwcGx5VG9vU21hbGwAAQUsVW5rbm93bkl0ZW0AAQUoTm90Rm9yU2FsZQABBSRCaWRUb29Mb3cAAQUCGDxNYXhTaWduZWRMaW1pdHMAAQUoS2V5VG9vTG9uZwABBThOb3RFbm91Z2hGdW5kcwABBShCYWRXaXRuZXNzAAEFZFNpZ25lZE1pZ3JhdGlvbk5vdEFsbG93ZWQAAQUwQmFkQ2hpbGRSb290AAEFAjAoTm90T25nb2luZwABBSBOb3RWb3RlcgABBTBOb1Blcm1pc3Npb24AAQU8Tm9QZXJtaXNzaW9uWWV0AAEFREFscmVhZHlEZWxlZ2F0aW5nAAEFNEFscmVhZHlWb3RpbmcAAQVESW5zdWZmaWNpZW50RnVuZHMAAQU0Tm90RGVsZWdhdGluZwABBSBOb25zZW5zZQABBTxNYXhWb3Rlc1JlYWNoZWQAAQUsQ2xhc3NOZWVkZWQAAQUgQmFkQ2xhc3MAAQUCOChOb3RPbmdvaW5nAAEFKEhhc0RlcG9zaXQAAQUgQmFkVHJhY2sAAQUQRnVsbAABBShRdWV1ZUVtcHR5AAEFNEJhZFJlZmVyZW5kdW0AAQUsTm90aGluZ1RvRG8AAQUcTm9UcmFjawABBShVbmZpbmlzaGVkAAEFME5vUGVybWlzc2lvbgABBSROb0RlcG9zaXQAAQUkQmFkU3RhdHVzAAEFQFByZWltYWdlTm90RXhpc3QAAQWEUHJlaW1hZ2VTdG9yZWRXaXRoRGlmZmVyZW50TGVuZ3RoAAEFAhRMVW5hdmFpbGFibGVQcmVJbWFnZQABBTxVbmRlY29kYWJsZUNhbGwAAQVgSW52YWxpZENhbGxXZWlnaHRXaXRuZXNzAAEFUENhbGxJc05vdFdoaXRlbGlzdGVkAAEFWENhbGxBbHJlYWR5V2hpdGVsaXN0ZWQAAQUCCDRFdm1DYWxsRmFpbGVkAAEFKE5vdEV2bUNhbGwAAQUCPDROb0lkQXZhaWxhYmxlAAEFNEFzc2V0Tm90Rm91bmQAAQUgVG9vU2hvcnQAAQU0SW52YWxpZFN5bWJvbAABBUhBc3NldE5vdFJlZ2lzdGVyZWQAAQVYQXNzZXRBbHJlYWR5UmVnaXN0ZXJlZAABBVRJbnZhbGlkU2hhcmVkQXNzZXRMZW4AAQVQQ2Fubm90VXBkYXRlTG9jYXRpb24AAQVITm90SW5SZXNlcnZlZFJhbmdlAAEFZExvY2F0aW9uQWxyZWFkeVJlZ2lzdGVyZWQAAQUkRm9yYmlkZGVuAAEFTEluc3VmZmljaWVudEJhbGFuY2UAAQVoRm9yYmlkZGVuU3VmZmljaWVuY3lDaGFuZ2UAAQVIQXNzZXRBbHJlYWR5QmFubmVkAAEFOEFzc2V0Tm90QmFubmVkAAEFAgxgSW52YWxpZEV0aGVyZXVtU2lnbmF0dXJlAAEFXE5vQ2xhaW1PckFscmVhZHlDbGFpbWVkAAEFPEJhbGFuY2VPdmVyZmxvdwABBQKATEluc3VmZmljaWVudEJhbGFuY2UAAQVEQXNzZXRBbHJlYWR5QWRkZWQAAQU0QXNzZXROb3RGb3VuZAABBThNaXNzaW5nQmFsYW5jZQABBWBJbnZhbGlkSW5pdGlhbEFzc2V0UHJpY2UAAQVIQnV5TGltaXROb3RSZWFjaGVkAAEFRFNlbGxMaW1pdEV4Y2VlZGVkAAEFQFBvc2l0aW9uTm90Rm91bmQAAQVISW5zdWZmaWNpZW50U2hhcmVzAAEFKE5vdEFsbG93ZWQAAQUkRm9yYmlkZGVuAAEFWEFzc2V0V2VpZ2h0Q2FwRXhjZWVkZWQAAQVIQXNzZXROb3RSZWdpc3RlcmVkAAEFVEluc3VmZmljaWVudExpcXVpZGl0eQABBWRJbnN1ZmZpY2llbnRUcmFkaW5nQW1vdW50AAEFYFNhbWVBc3NldFRyYWRlTm90QWxsb3dlZAABBUxIdWJBc3NldFVwZGF0ZUVycm9yAAEFTEludmFsaWRTaGFyZXNBbW91bnQAAQVwSW52YWxpZEh1YkFzc2V0VHJhZGFibGVTdGF0ZQABBVRBc3NldFJlZnVuZE5vdEFsbG93ZWQAAQVMTWF4T3V0UmF0aW9FeGNlZWRlZAABBUhNYXhJblJhdGlvRXhjZWVkZWQAAQVYUHJpY2VEaWZmZXJlbmNlVG9vSGlnaAABBUhJbnZhbGlkT3JhY2xlUHJpY2UAAQVQSW52YWxpZFdpdGhkcmF3YWxGZWUAAQUwRmVlT3ZlcmRyYWZ0AAEFPFNoYXJlc1JlbWFpbmluZwABBThBc3NldE5vdEZyb3plbgABBTRaZXJvQW1vdW50T3V0AAEFeEV4aXN0ZW50aWFsRGVwb3NpdE5vdEF2YWlsYWJsZQABBTRTbGlwcGFnZUxpbWl0AAEFWFByb3RvY29sRmVlTm90Q29uc3VtZWQAAQUCDCxDYW5ub3RQYXVzZQABBUBJbnZhbGlkQ2hhcmFjdGVyAAEFLE5hbWVUb29Mb25nAAEFAhhIQWNjb3VudFdoaXRlbGlzdGVkAAEFVEFjY291bnROb3RXaGl0ZWxpc3RlZAABBSxaZXJvQmFsYW5jZQABBThOb25aZXJvQmFsYW5jZQABBURCYWxhbmNlU3VmZmljaWVudAABBVBSZXNlcnZlQWNjb3VudE5vdFNldAABBQJERFlpZWxkRmFybU5vdEZvdW5kAAEFSEdsb2JhbEZhcm1Ob3RGb3VuZAABBVBMaXF1aWRpdHlJc05vdEFjdGl2ZQABBVRHbG9iYWxGYXJtSXNOb3RBY3RpdmUAAQU8RGVwb3NpdE5vdEZvdW5kAAEFNEludmFsaWRQZXJpb2QAAQVsTm90RW5vdWdoUmV3YXJkc0luWWllbGRGYXJtAAEFZEludmFsaWRMaXZlWWllbEZhcm1zQ291bnQAAQVsSW52YWxpZFRvdGFsWWllbGRGYXJtc0NvdW50AAEFcEludmFsaWRZaWVsZEZhcm1FbnRyaWVzQ291bnQAAQVISW52YWxpZFRvdGFsU2hhcmVzAAEFTEludmFsaWRWYWx1ZWRTaGFyZXMAAQVMSW52YWxpZFRvdGFsU2hhcmVzWgABBXRJbnZhbGlkUGFpZEFjY3VtdWxhdGVkUmV3YXJkcwABBTRJbnZhbGlkRmFybUlkAAEFYEludmFsaWRMb3lhbHR5TXVsdGlwbGllcgABBXBOb0V4aXN0ZW50aWFsRGVwb3NpdEZvckFzc2V0AAEFAnRIR2xvYmFsRmFybU5vdEZvdW5kAAEFRFlpZWxkRmFybU5vdEZvdW5kAAEFTERvdWJsZUNsYWltSW5QZXJpb2QAAQVcTGlxdWlkaXR5TWluaW5nQ2FuY2VsZWQAAQVcTGlxdWlkaXR5TWluaW5nSXNBY3RpdmUAAQVsTGlxdWlkaXR5TWluaW5nSXNOb3RTdG9wcGVkAAEFJEZvcmJpZGRlbgABBURJbnZhbGlkTXVsdGlwbGllcgABBVhZaWVsZEZhcm1BbHJlYWR5RXhpc3RzAAEFeEludmFsaWRJbml0aWFsUmV3YXJkUGVyY2VudGFnZQABBVBHbG9iYWxGYXJtSXNOb3RFbXB0eQABBWBNaXNzaW5nSW5jZW50aXZpemVkQXNzZXQAAQWESW5zdWZmaWNpZW50UmV3YXJkQ3VycmVuY3lCYWxhbmNlAAEFWEludmFsaWRCbG9ja3NQZXJQZXJpb2QAAQVUSW52YWxpZFlpZWxkUGVyUGVyaW9kAAEFTEludmFsaWRUb3RhbFJld2FyZHMAAQV0SW52YWxpZFBsYW5uZWRZaWVsZGluZ1BlcmlvZHMAAQVQTWF4RW50cmllc1BlckRlcG9zaXQAAQUoRG91YmxlTG9jawABBVhZaWVsZEZhcm1FbnRyeU5vdEZvdW5kAAEFQEdsb2JhbEZhcm1Jc0Z1bGwAAQVESW52YWxpZE1pbkRlcG9zaXQAAQVYSW52YWxpZFByaWNlQWRqdXN0bWVudAABBURFcnJvckdldEFjY291bnRJZAABBVRJbmNvcnJlY3RWYWx1ZWRTaGFyZXMAAQVsUmV3YXJkQ3VycmVuY3lOb3RSZWdpc3RlcmVkAAEFeEluY2VudGl2aXplZEFzc2V0Tm90UmVnaXN0ZXJlZAABBURBbW1Qb29sSWRNaXNtYXRjaAABBURJbmNvbnNpc3RlbnRTdGF0ZQGcAghETWlzc2luZ0xwUG9zaXRpb24AAQVMRGVwb3NpdERhdGFOb3RGb3VuZAABBQIcNEFzc2V0Tm90Rm91bmQAAQUkRm9yYmlkZGVuAAEFSFplcm9DbGFpbWVkUmV3YXJkcwABBURJbmNvbnNpc3RlbnRTdGF0ZQGkSE9yYWNsZU5vdEF2YWlsYWJsZQABBWxQcmljZUFkanVzdG1lbnROb3RBdmFpbGFibGUAAQVYTm9GYXJtRW50cmllc1NwZWNpZmllZAABBQIgSEFzc2V0Tm90UmVnaXN0ZXJlZAABBTRPcmRlck5vdEZvdW5kAAEFRE9yZGVySWRPdXRPZkJvdW5kAAEFZE9yZGVyTm90UGFydGlhbGx5RmlsbGFibGUAAQVMT3JkZXJBbW91bnRUb29TbWFsbAABBSRNYXRoRXJyb3IAAQUkRm9yYmlkZGVuAAEFaEluc3VmZmljaWVudFJlc2VydmVkQW1vdW50AAEFAiRESW52YWxpZExpbWl0VmFsdWUAAQV8TGlxdWlkaXR5TGltaXROb3RTdG9yZWRGb3JBc3NldAABBWBUb2tlbk91dGZsb3dMaW1pdFJlYWNoZWQAAQVcVG9rZW5JbmZsdXhMaW1pdFJlYWNoZWQAAQWATWF4TGlxdWlkaXR5TGltaXRQZXJCbG9ja1JlYWNoZWQAAQUoTm90QWxsb3dlZAABBTxBc3NldEluTG9ja2Rvd24AAQVIQXNzZXROb3RJbkxvY2tkb3duAAEFNEludmFsaWRBbW91bnQAAQUCKExUcmFkaW5nTGltaXRSZWFjaGVkAAEFRE1heFRyYWRlc0V4Y2VlZGVkAAEFQFBvb2xOb3RTdXBwb3J0ZWQAAQVMSW5zdWZmaWNpZW50QmFsYW5jZQABBVhSb3V0ZUNhbGN1bGF0aW9uRmFpbGVkAAEFMEludmFsaWRSb3V0ZQABBWhSb3V0ZVVwZGF0ZUlzTm90U3VjY2Vzc2Z1bAABBUBSb3V0ZUhhc05vT3JhY2xlAAEFVEludmFsaWRSb3V0ZUV4ZWN1dGlvbgABBShOb3RBbGxvd2VkAAEFAgRQSW52YWxpZEZlZVBhcmFtZXRlcnMAAQUCFEBQb3NpdGlvbk5vdEZvdW5kAAEFWE5lZ2F0aXZlUGVuZGluZ1Jld2FyZHMAAQVUTmVnYXRpdmVVbnBhaWRSZXdhcmRzAAEFQFRvb01hbnlQb3NpdGlvbnMAAQUoQXJpdGhtZXRpYwABBQI0TEluc3VmZmljaWVudEJhbGFuY2UAAQVESW5zdWZmaWNpZW50U3Rha2UAAQVAUG9zaXRpb25Ob3RGb3VuZAABBTxNYXhWb3Rlc1JlYWNoZWQAAQU4Tm90SW5pdGlhbGl6ZWQAAQVIQWxyZWFkeUluaXRpYWxpemVkAAEFKEFyaXRobWV0aWMAAQVETWlzc2luZ1BvdEJhbGFuY2UAAQVUUG9zaXRpb25BbHJlYWR5RXhpc3RzAAEFJEZvcmJpZGRlbgABBTRFeGlzdGluZ1ZvdGVzAAEFWEV4aXN0aW5nUHJvY2Vzc2VkVm90ZXMAAQVESW5jb25zaXN0ZW50U3RhdGUBvAJwPEluY29ycmVjdEFzc2V0cwABBURNYXhBc3NldHNFeGNlZWRlZAABBTBQb29sTm90Rm91bmQAAQUoUG9vbEV4aXN0cwABBThBc3NldE5vdEluUG9vbAABBVxTaGFyZUFzc2V0Tm90UmVnaXN0ZXJlZAABBVhTaGFyZUFzc2V0SW5Qb29sQXNzZXRzAAEFSEFzc2V0Tm90UmVnaXN0ZXJlZAABBUhJbnZhbGlkQXNzZXRBbW91bnQAAQVMSW5zdWZmaWNpZW50QmFsYW5jZQABBUhJbnN1ZmZpY2llbnRTaGFyZXMAAQVUSW5zdWZmaWNpZW50TGlxdWlkaXR5AAEFeEluc3VmZmljaWVudExpcXVpZGl0eVJlbWFpbmluZwABBWRJbnN1ZmZpY2llbnRUcmFkaW5nQW1vdW50AAEFSEJ1eUxpbWl0Tm90UmVhY2hlZAABBURTZWxsTGltaXRFeGNlZWRlZAABBVxJbnZhbGlkSW5pdGlhbExpcXVpZGl0eQABBVBJbnZhbGlkQW1wbGlmaWNhdGlvbgABBWBJbnN1ZmZpY2llbnRTaGFyZUJhbGFuY2UAAQUoTm90QWxsb3dlZAABBSRQYXN0QmxvY2sAAQVEU2FtZUFtcGxpZmljYXRpb24AAQU0U2xpcHBhZ2VMaW1pdAABBTxVbmtub3duRGVjaW1hbHMAAQVQSW5jb3JyZWN0SW5pdGlhbFBlZ3MAAQVYTWlzc2luZ1RhcmdldFBlZ09yYWNsZQABBVhJbmNvcnJlY3RBc3NldERlY2ltYWxzAAEFLE5vUGVnU291cmNlAAEFAhw0Tm90UmVnaXN0ZXJlZAABBSROb3RNYXR1cmUAAQU8SW52YWxpZE1hdHVyaXR5AAEFPERpc2FsbG93ZWRBc3NldAABBTRBc3NldE5vdEZvdW5kAAEFPEludmFsaWRCb25kTmFtZQABBTxGYWlsVG9QYXJzZU5hbWUAAQUCHDRPcmRlck5vdEZvdW5kAAEFUE5vdFBhcnRpYWxseUZpbGxhYmxlAAEFMEludmFsaWRSb3V0ZQABBVBCYWxhbmNlSW5jb25zaXN0ZW5jeQABBUhUcmFkZUFtb3VudFRvb0hpZ2gAAQVEVHJhZGVBbW91bnRUb29Mb3cAAQVEUHJpY2VOb3RBdmFpbGFibGUAAQUCXHhDYW5ub3RDcmVhdGVQb29sV2l0aFNhbWVBc3NldHMAAQUgTm90T3duZXIAAQUsU2FsZVN0YXJ0ZWQAAQUwU2FsZU5vdEVuZGVkAAEFQFNhbGVJc05vdFJ1bm5pbmcAAQVcTWF4U2FsZUR1cmF0aW9uRXhjZWVkZWQAAQVYQ2Fubm90QWRkWmVyb0xpcXVpZGl0eQABBWBJbnN1ZmZpY2llbnRBc3NldEJhbGFuY2UAAQUwUG9vbE5vdEZvdW5kAAEFRFBvb2xBbHJlYWR5RXhpc3RzAAEFREludmFsaWRCbG9ja1JhbmdlAAEFWFdlaWdodENhbGN1bGF0aW9uRXJyb3IAAQU0SW52YWxpZFdlaWdodAABBShaZXJvQW1vdW50AAEFSE1heEluUmF0aW9FeGNlZWRlZAABBUxNYXhPdXRSYXRpb0V4Y2VlZGVkAAEFQEZlZUFtb3VudEludmFsaWQAAQVMVHJhZGluZ0xpbWl0UmVhY2hlZAABBSBPdmVyZmxvdwABBTxOb3RoaW5nVG9VcGRhdGUAAQVUSW5zdWZmaWNpZW50TGlxdWlkaXR5AAEFZEluc3VmZmljaWVudFRyYWRpbmdBbW91bnQAAQWARmVlQ29sbGVjdG9yV2l0aEFzc2V0QWxyZWFkeVVzZWQAAQUCaHhDYW5ub3RDcmVhdGVQb29sV2l0aFNhbWVBc3NldHMAAQVUSW5zdWZmaWNpZW50TGlxdWlkaXR5AAEFZEluc3VmZmljaWVudFRyYWRpbmdBbW91bnQAAQU0WmVyb0xpcXVpZGl0eQABBUBaZXJvSW5pdGlhbFByaWNlAAEFcENyZWF0ZVBvb2xBc3NldEFtb3VudEludmFsaWQAAQVYSW52YWxpZE1pbnRlZExpcXVpZGl0eQABBVhJbnZhbGlkTGlxdWlkaXR5QW1vdW50AAEFYEFzc2V0QW1vdW50RXhjZWVkZWRMaW1pdAABBWhBc3NldEFtb3VudE5vdFJlYWNoZWRMaW1pdAABBWBJbnN1ZmZpY2llbnRBc3NldEJhbGFuY2UAAQVwSW5zdWZmaWNpZW50UG9vbEFzc2V0QmFsYW5jZQABBYRJbnN1ZmZpY2llbnROYXRpdmVDdXJyZW5jeUJhbGFuY2UAAQVEVG9rZW5Qb29sTm90Rm91bmQAAQVYVG9rZW5Qb29sQWxyZWFkeUV4aXN0cwABBVRBZGRBc3NldEFtb3VudEludmFsaWQAAQVgUmVtb3ZlQXNzZXRBbW91bnRJbnZhbGlkAAEFWFNlbGxBc3NldEFtb3VudEludmFsaWQAAQVUQnV5QXNzZXRBbW91bnRJbnZhbGlkAAEFQEZlZUFtb3VudEludmFsaWQAAQVMQ2Fubm90QXBwbHlEaXNjb3VudAABBUxNYXhPdXRSYXRpb0V4Y2VlZGVkAAEFSE1heEluUmF0aW9FeGNlZWRlZAABBSBPdmVyZmxvdwABBUBDYW5ub3RDcmVhdGVQb29sAAEFNFNsaXBwYWdlTGltaXQAAQUCOBxUb29Mb25nAAEFIFRvb1Nob3J0AAEFQEludmFsaWRDaGFyYWN0ZXIAAQU0QWxyZWFkeUV4aXN0cwABBSxJbnZhbGlkQ29kZQABBTRBbHJlYWR5TGlua2VkAAEFKFplcm9BbW91bnQAAQU4TGlua05vdEFsbG93ZWQAAQVoSW5jb3JyZWN0UmV3YXJkQ2FsY3VsYXRpb24AAQVkSW5jb3JyZWN0UmV3YXJkUGVyY2VudGFnZQABBURBbHJlYWR5UmVnaXN0ZXJlZAABBTRQcmljZU5vdEZvdW5kAAEFkENvbnZlcnNpb25NaW5UcmFkaW5nQW1vdW50Tm90UmVhY2hlZAABBXBDb252ZXJzaW9uWmVyb0Ftb3VudFJlY2VpdmVkAAEFAhhUQXNzZXRDb252ZXJzaW9uRmFpbGVkAAEFVExpcXVpZGF0aW9uQ2FsbEZhaWxlZAABBTBJbnZhbGlkUm91dGUAAQU0Tm90UHJvZml0YWJsZQABBURGbGFzaE1pbnRlck5vdFNldAABBVhJbnZhbGlkTGlxdWlkYXRpb25EYXRhAAEFAlRAQXNzZXROb3RBcHByb3ZlZAABBVBBc3NldEFscmVhZHlBcHByb3ZlZAABBWBQb29sQWxyZWFkeUhhc0NvbGxhdGVyYWwAAQVASW52YWxpZEFzc2V0UGFpcgABBUxNYXhCdXlQcmljZUV4Y2VlZGVkAAEFSE1heEJ1eUJhY2tFeGNlZWRlZAABBUhNYXhIb2xkaW5nRXhjZWVkZWQAAQVUU2xpcHBhZ2VMaW1pdEV4Y2VlZGVkAAEFVEludmFsaWRFVk1JbnRlcmFjdGlvbgABBVhEZWNpbWFsUmV0cmlldmFsRmFpbGVkAAEFWE5vQXJiaXRyYWdlT3Bwb3J0dW5pdHkAAQU0QXNzZXROb3RGb3VuZAABBUBJbnZhbGlkUG9vbFN0YXRlAAEFSENvbGxhdGVyYWxOb3RFbXB0eQABBThBc3NldE5vdEluUG9vbAABBTxIb2xsYXJOb3RJblBvb2wAAQV0SW5zdWZmaWNpZW50Q29sbGF0ZXJhbEJhbGFuY2UAAQV0SG9sbGFyQ29udHJhY3RBZGRyZXNzTm90Rm91bmQAAQV0TWF4TnVtYmVyT2ZDb2xsYXRlcmFsc1JlYWNoZWQAAQVERmxhc2hNaW50ZXJOb3RTZXQAAQVQSW52YWxpZEFyYml0cmFnZURhdGEAAQUCIDRCYWxhbmNlVG9vTG93AAEFXEFtb3VudEludG9CYWxhbmNlRmFpbGVkAAEFVExpcXVpZGl0eVJlc3RyaWN0aW9ucwABBUBNYXhMb2Nrc0V4Y2VlZGVkAAEFJEtlZXBBbGl2ZQABBUhFeGlzdGVudGlhbERlcG9zaXQAAQUsRGVhZEFjY291bnQAAQU8VG9vTWFueVJlc2VydmVzAAEFAhBcQW1vdW50SW50b0JhbGFuY2VGYWlsZWQAAQU0QmFsYW5jZVRvb0xvdwABBTREZXBvc2l0RmFpbGVkAAEFME5vdFN1cHBvcnRlZAABBQIYRFplcm9WZXN0aW5nUGVyaW9kAAEFWFplcm9WZXN0aW5nUGVyaW9kQ291bnQAAQVkSW5zdWZmaWNpZW50QmFsYW5jZVRvTG9jawABBVxUb29NYW55VmVzdGluZ1NjaGVkdWxlcwABBSRBbW91bnRMb3cAAQVsTWF4VmVzdGluZ1NjaGVkdWxlc0V4Y2VlZGVkAAEFAjQoQmFsYW5jZUxvdwABBSxGZWVPdmVyZmxvdwABBTxQYXltZW50T3ZlcmZsb3cAAQU4V2l0aGRyYXdGYWlsZWQAAQU4R2FzUHJpY2VUb29Mb3cAAQUwSW52YWxpZE5vbmNlAAEFOEdhc0xpbWl0VG9vTG93AAEFPEdhc0xpbWl0VG9vSGlnaAABBThJbnZhbGlkQ2hhaW5JZAABBUBJbnZhbGlkU2lnbmF0dXJlAAEFKFJlZW50cmFuY3kAAQVoVHJhbnNhY3Rpb25NdXN0Q29tZUZyb21FT0EAAQUkVW5kZWZpbmVkAAEFAghASW52YWxpZFNpZ25hdHVyZQABBTBQcmVMb2dFeGlzdHMAAQUCEGxUcnVuY2F0ZWRBY2NvdW50QWxyZWFkeVVzZWQAAQVMQWRkcmVzc0FscmVhZHlCb3VuZAABBWBCb3VuZEFkZHJlc3NDYW5ub3RCZVVzZWQAAQVUQWRkcmVzc05vdFdoaXRlbGlzdGVkAAEFAjRQQ2FudEZpbmREZXBvc2l0T3duZXIAAQVwSW5zdWZmaWNpZW50WHlrU2hhcmVzQmFsYW5jZQABBUhYeWtQb29sRG9lc250RXhpc3QAAQU8Tm90RGVwb3NpdE93bmVyAAEFQENhbnRHZXRYeWtBc3NldHMAAQVMRGVwb3NpdERhdGFOb3RGb3VuZAABBUhaZXJvQ2xhaW1lZFJld2FyZHMAAQVMQXNzZXROb3RJbkFzc2V0UGFpcgABBUBJbnZhbGlkQXNzZXRQYWlyAAEFSEFzc2V0Tm90UmVnaXN0ZXJlZAABBThGYWlsVG9HZXRQb3RJZAABBUBOb0Zhcm1zU3BlY2lmaWVkAAEFTEZhaWxlZFRvVmFsdWVTaGFyZXMAAQUCUEBTY2hlZHVsZU5vdEZvdW5kAAEFYE1pblRyYWRlQW1vdW50Tm90UmVhY2hlZAABBSRGb3JiaWRkZW4AAQVgQmxvY2tOdW1iZXJJc05vdEluRnV0dXJlAAEFNFByaWNlVW5zdGFibGUAAQUYQnVtcGVkAAEFVENhbGN1bGF0aW5nUHJpY2VFcnJvcgABBYRUb3RhbEFtb3VudElzU21hbGxlclRoYW5NaW5CdWRnZXQAAQUwQnVkZ2V0VG9vTG93AAEFQE5vRnJlZUJsb2NrRm91bmQAAQVITWFudWFsbHlUZXJtaW5hdGVkAAEFPE1heFJldHJ5UmVhY2hlZAABBURUcmFkZUxpbWl0UmVhY2hlZAABBVBTbGlwcGFnZUxpbWl0UmVhY2hlZAABBUROb1BhcmVudEhhc2hGb3VuZAABBTBJbnZhbGlkU3RhdGUAAQU4UGVyaW9kVG9vU2hvcnQAAQVkU3RhYmlsaXR5VGhyZXNob2xkVG9vSGlnaAABBUhIYXNBY3RpdmVTY2hlZHVsZXMAAQVATm9SZXNlcnZlc0xvY2tlZAABBQIUQEZhaWxlZFRvU2NoZWR1bGUAAQUgTm90Rm91bmQAAQVcVGFyZ2V0QmxvY2tOdW1iZXJJblBhc3QAAQVIUmVzY2hlZHVsZU5vQ2hhbmdlAAEFFE5hbWVkAAEFAiBMT3ZlcmxhcHBpbmdVcGdyYWRlcwABBVBQcm9oaWJpdGVkQnlQb2xrYWRvdAABBRhUb29CaWcAAQVoVmFsaWRhdGlvbkRhdGFOb3RBdmFpbGFibGUAAQV0SG9zdENvbmZpZ3VyYXRpb25Ob3RBdmFpbGFibGUAAQUwTm90U2NoZWR1bGVkAAEFRE5vdGhpbmdBdXRob3JpemVkAAEFMFVuYXV0aG9yaXplZAABBQJgLFVucmVhY2hhYmxlAAEFLFNlbmRGYWlsdXJlAAEFIEZpbHRlcmVkAAEFSFVud2VpZ2hhYmxlTWVzc2FnZQABBWBEZXN0aW5hdGlvbk5vdEludmVydGlibGUAAQUURW1wdHkAAQU4Q2Fubm90UmVhbmNob3IAAQU0VG9vTWFueUFzc2V0cwABBTRJbnZhbGlkT3JpZ2luAAEFKEJhZFZlcnNpb24AAQUsQmFkTG9jYXRpb24AAQU4Tm9TdWJzY3JpcHRpb24AAQVEQWxyZWFkeVN1YnNjcmliZWQAAQVYQ2Fubm90Q2hlY2tPdXRUZWxlcG9ydAABBShMb3dCYWxhbmNlAAEFMFRvb01hbnlMb2NrcwABBUxBY2NvdW50Tm90U292ZXJlaWduAAEFKEZlZXNOb3RNZXQAAQUwTG9ja05vdEZvdW5kAAEFFEluVXNlAAEFaEludmFsaWRBc3NldFVua25vd25SZXNlcnZlAAEFeEludmFsaWRBc3NldFVuc3VwcG9ydGVkUmVzZXJ2ZQABBTxUb29NYW55UmVzZXJ2ZXMAAQVgTG9jYWxFeGVjdXRpb25JbmNvbXBsZXRlAAEFAhQ4QmFkUXVldWVDb25maWcAAQVAQWxyZWFkeVN1c3BlbmRlZAABBThBbHJlYWR5UmVzdW1lZAABBXRUb29NYW55QWN0aXZlT3V0Ym91bmRDaGFubmVscwABBRhUb29CaWcAAQUCJCxOb3RSZWFwYWJsZQABBRhOb1BhZ2UAAQUkTm9NZXNzYWdlAAEFQEFscmVhZHlQcm9jZXNzZWQAAQUYUXVldWVkAAEFSEluc3VmZmljaWVudFdlaWdodAABBWBUZW1wb3JhcmlseVVucHJvY2Vzc2FibGUAAQUsUXVldWVQYXVzZWQAAQVMUmVjdXJzaXZlRGlzYWxsb3dlZAABBQIMLFVucmVhY2hhYmxlAAEFLFNlbmRGYWlsdXJlAAEFKEJhZFZlcnNpb24AAQUCUERBc3NldEhhc05vUmVzZXJ2ZQABBVROb3RDcm9zc0NoYWluVHJhbnNmZXIAAQUsSW52YWxpZERlc3QAAQWETm90Q3Jvc3NDaGFpblRyYW5zZmVyYWJsZUN1cnJlbmN5AAEFSFVud2VpZ2hhYmxlTWVzc2FnZQABBUhYY21FeGVjdXRpb25GYWlsZWQAAQU4Q2Fubm90UmVhbmNob3IAAQU8SW52YWxpZEFuY2VzdHJ5AAEFMEludmFsaWRBc3NldAABBWBEZXN0aW5hdGlvbk5vdEludmVydGlibGUAAQUoQmFkVmVyc2lvbgABBXREaXN0aW5jdFJlc2VydmVGb3JBc3NldEFuZEZlZQABBRxaZXJvRmVlAAEFKFplcm9BbW91bnQAAQVYVG9vTWFueUFzc2V0c0JlaW5nU2VudAABBVRBc3NldEluZGV4Tm9uRXhpc3RlbnQAAQUwRmVlTm90RW5vdWdoAAEFUE5vdFN1cHBvcnRlZExvY2F0aW9uAAEFTE1pblhjbUZlZU5vdERlZmluZWQAAQUsUmF0ZUxpbWl0ZWQAAQUCDDRCYWxhbmNlVG9vTG93AAEFPEJhbGFuY2VPdmVyZmxvdwABBThVbmhhbmRsZWRBc3NldAABBQJERFRvb01hbnlDYW5kaWRhdGVzAAEFXFRvb0Zld0VsaWdpYmxlQ29sbGF0b3JzAAEFQEFscmVhZHlDYW5kaWRhdGUAAQUwTm90Q2FuZGlkYXRlAAEFUFRvb01hbnlJbnZ1bG5lcmFibGVzAAEFTEFscmVhZHlJbnZ1bG5lcmFibGUAAQU8Tm90SW52dWxuZXJhYmxlAAEFXE5vQXNzb2NpYXRlZFZhbGlkYXRvcklkAAEFWFZhbGlkYXRvck5vdFJlZ2lzdGVyZWQAAQVsSW5zZXJ0VG9DYW5kaWRhdGVMaXN0RmFpbGVkAAEFdFJlbW92ZUZyb21DYW5kaWRhdGVMaXN0RmFpbGVkAAEFNERlcG9zaXRUb29Mb3cAAQVkVXBkYXRlQ2FuZGlkYXRlTGlzdEZhaWxlZAABBUBJbnN1ZmZpY2llbnRCb25kAAEFUFRhcmdldElzTm90Q2FuZGlkYXRlAAEFQElkZW50aWNhbERlcG9zaXQAAQVASW52YWxpZFVucmVzZXJ2ZQABBQIUMEludmFsaWRQcm9vZgABBVxOb0Fzc29jaWF0ZWRWYWxpZGF0b3JJZAABBTREdXBsaWNhdGVkS2V5AAEFGE5vS2V5cwABBSROb0FjY291bnQAAQUCFDhJbnZhbGlkTWVzc2FnZQABBTxNZXNzYWdlTm90Rm91bmQAAQV0Q29uc2Vuc3VzQ2xpZW50Q3JlYXRpb25GYWlsZWQAAQVsVW5ib25kaW5nUGVyaW9kVXBkYXRlRmFpbGVkAAEFbENoYWxsZW5nZVBlcmlvZFVwZGF0ZUZhaWxlZAABBQIIXEludmFsaWRDb25zZW5zdXNTdGF0ZUlkAAEFXENvbnNlbnN1c0FscmVhZHlVcGRhdGVkAAEFAiREVW5yZWdpc3RlcmVkQXNzZXQAAQVIQXNzZXRUZWxlcG9ydEVycm9yAAEFYENvcHJvY2Vzc29yTm90Q29uZmlndXJlZAABBTREaXNwYXRjaEVycm9yAAEFSEFzc2V0Q3JlYXRpb25FcnJvcgABBVRBc3NldERlY2ltYWxzTm90Rm91bmQAAQU4Tm90SW5pdGlhbGl6ZWQAAQUwVW5rbm93bkFzc2V0AAEFNE5vdEFzc2V0T3duZXIAAQUCFFBUb29NYW55VW5pcXVlRW50cmllcwABBUBPblRyYWRlVmFsdWVaZXJvAAEFOE9yYWNsZU5vdEZvdW5kAAEFNEFzc2V0Tm90Rm91bmQAAQVgUHJpY2VPdXRzaWRlQWxsb3dlZFJhbmdlAAEFAghoRXhlY3V0aW9uQ2FsbFN0YWNrT3ZlcmZsb3cAAQVsRXhlY3V0aW9uQ2FsbFN0YWNrVW5kZXJmbG93AAEFAvgYU3lzdGVtAUQgQmFsYW5jZXMBSFxNdWx0aVRyYW5zYWN0aW9uUGF5bWVudAFMIFRyZWFzdXJ5AVAcVXRpbGl0eQFUIFByZWltYWdlAVggSWRlbnRpdHkBXCREZW1vY3JhY3kBYEhUZWNobmljYWxDb21taXR0ZWUBZBRQcm94eQFoIE11bHRpc2lnAWwcVW5pcXVlcwFwSFN0YXRlVHJpZU1pZ3JhdGlvbgF0QENvbnZpY3Rpb25Wb3RpbmcBeCRSZWZlcmVuZGEBfCRXaGl0ZWxpc3QBgChEaXNwYXRjaGVyAYQ0QXNzZXRSZWdpc3RyeQGIGENsYWltcwGMIE9tbmlwb29sAZBAVHJhbnNhY3Rpb25QYXVzZQGUGER1c3RlcgGYTE9tbmlwb29sV2FyZWhvdXNlTE0BoFxPbW5pcG9vbExpcXVpZGl0eU1pbmluZwGoDE9UQwGsOENpcmN1aXRCcmVha2VyAbAYUm91dGVyAbQsRHluYW1pY0ZlZXMBuBxTdGFraW5nAcAoU3RhYmxlc3dhcAHEFEJvbmRzAcg4T3RjU2V0dGxlbWVudHMBzAxMQlAB0AxYWUsB1CRSZWZlcnJhbHMB2CxMaXF1aWRhdGlvbgHcDEhTTQHgGFRva2VucwHkKEN1cnJlbmNpZXMB6BxWZXN0aW5nAewMRVZNAfAgRXRoZXJldW0B9CxFVk1BY2NvdW50cwH4SFhZS0xpcXVpZGl0eU1pbmluZwH8OFhZS1dhcmVob3VzZUxNAaAMRENBAQEBJFNjaGVkdWxlcgEFATxQYXJhY2hhaW5TeXN0ZW0BCQEsUG9sa2Fkb3RYY20BDQEkWGNtcFF1ZXVlAREBME1lc3NhZ2VRdWV1ZQEVARxPcm1sWGNtARkBHFhUb2tlbnMBHQE0VW5rbm93blRva2VucwEhAURDb2xsYXRvclNlbGVjdGlvbgElARxTZXNzaW9uASkBEEF1cmEAAQUQSXNtcAEtATRJc21wUGFyYWNoYWluATEBMFRva2VuR2F0ZXdheQE1ASRFbWFPcmFjbGUBOQEkQnJvYWRjYXN0AT0BAihARnVuZHNVbmF2YWlsYWJsZQABBTBPbmx5UHJvdmlkZXIAAQUwQmVsb3dNaW5pbXVtAAEFMENhbm5vdENyZWF0ZQABBTBVbmtub3duQXNzZXQAAQUYRnJvemVuAAEFLFVuc3VwcG9ydGVkAAEFQENhbm5vdENyZWF0ZUhvbGQAAQU0Tm90RXhwZW5kYWJsZQABBRxCbG9ja2VkAAEFAgwkVW5kZXJmbG93AAEFIE92ZXJmbG93AAEFOERpdmlzaW9uQnlaZXJvAAEFAggwTGltaXRSZWFjaGVkAAEFHE5vTGF5ZXIAAQUCOBRPdGhlcgABBTBDYW5ub3RMb29rdXAAAQUkQmFkT3JpZ2luAAEFGE1vZHVsZQFBAURDb25zdW1lclJlbWFpbmluZwABBSxOb1Byb3ZpZGVycwABBUBUb29NYW55Q29uc3VtZXJzAAEFFFRva2VuAUUBKEFyaXRobWV0aWMBSQE0VHJhbnNhY3Rpb25hbAFNASRFeGhhdXN0ZWQAAQUoQ29ycnVwdGlvbgABBSxVbmF2YWlsYWJsZQABBThSb290Tm90QWxsb3dlZAABBQIcQEV4dHJpbnNpY1N1Y2Nlc3MAAAQ0ZGlzcGF0Y2hfaW5mb0A8RXh0cmluc2ljRmFpbGVkAAAIOGRpc3BhdGNoX2Vycm9yUQE0ZGlzcGF0Y2hfaW5mb0AsQ29kZVVwZGF0ZWQAAQUoTmV3QWNjb3VudAAABBxhY2NvdW50ADRLaWxsZWRBY2NvdW50AAAEHGFjY291bnQAIFJlbWFya2VkAAAIGHNlbmRlcgAQaGFzaCBEVXBncmFkZUF1dGhvcml6ZWQAAAgkY29kZV9oYXNoIDRjaGVja192ZXJzaW9uFAIIEEZyZWUAAQUgUmVzZXJ2ZWQAAQUCWBxFbmRvd2VkAAAIHGFjY291bnQAMGZyZWVfYmFsYW5jZQggRHVzdExvc3QAAAgcYWNjb3VudAAYYW1vdW50CCBUcmFuc2ZlcgAADBBmcm9tAAh0bwAYYW1vdW50CChCYWxhbmNlU2V0AAAIDHdobwAQZnJlZQggUmVzZXJ2ZWQAAAgMd2hvABhhbW91bnQIKFVucmVzZXJ2ZWQAAAgMd2hvABhhbW91bnQISFJlc2VydmVSZXBhdHJpYXRlZAAAEBBmcm9tAAh0bwAYYW1vdW50CEhkZXN0aW5hdGlvbl9zdGF0dXNZARxEZXBvc2l0AAAIDHdobwAYYW1vdW50CCBXaXRoZHJhdwAACAx3aG8AGGFtb3VudAgcU2xhc2hlZAAACAx3aG8AGGFtb3VudAgYTWludGVkAAAIDHdobwAYYW1vdW50CBhCdXJuZWQAAAgMd2hvABhhbW91bnQIJFN1c3BlbmRlZAAACAx3aG8AGGFtb3VudAggUmVzdG9yZWQAAAgMd2hvABhhbW91bnQIIFVwZ3JhZGVkAAAEDHdobwAYSXNzdWVkAAAEGGFtb3VudAgkUmVzY2luZGVkAAAEGGFtb3VudAgYTG9ja2VkAAAIDHdobwAYYW1vdW50CCBVbmxvY2tlZAAACAx3aG8AGGFtb3VudAgYRnJvemVuAAAIDHdobwAYYW1vdW50CBhUaGF3ZWQAAAgMd2hvABhhbW91bnQITFRvdGFsSXNzdWFuY2VGb3JjZWQAAAgMb2xkCAxuZXcIAgRIVHJhbnNhY3Rpb25GZWVQYWlkAAAMDHdobwAoYWN0dWFsX2ZlZQgMdGlwCAIQLEN1cnJlbmN5U2V0AAAIKGFjY291bnRfaWQAIGFzc2V0X2lkBDRDdXJyZW5jeUFkZGVkAAAEIGFzc2V0X2lkBDxDdXJyZW5jeVJlbW92ZWQAAAQgYXNzZXRfaWQEMEZlZVdpdGhkcmF3bgAAFChhY2NvdW50X2lkACBhc3NldF9pZAREbmF0aXZlX2ZlZV9hbW91bnQIVG5vbl9uYXRpdmVfZmVlX2Ftb3VudAhYZGVzdGluYXRpb25fYWNjb3VudF9pZAACMCBTcGVuZGluZwAABEBidWRnZXRfcmVtYWluaW5nCBxBd2FyZGVkAAAMOHByb3Bvc2FsX2luZGV4BBRhd2FyZAgcYWNjb3VudAAUQnVybnQAAAQsYnVybnRfZnVuZHMIIFJvbGxvdmVyAAAEQHJvbGxvdmVyX2JhbGFuY2UIHERlcG9zaXQAAAQUdmFsdWUINFNwZW5kQXBwcm92ZWQAAAw4cHJvcG9zYWxfaW5kZXgEGGFtb3VudAgsYmVuZWZpY2lhcnkAPFVwZGF0ZWRJbmFjdGl2ZQAACCxyZWFjdGl2YXRlZAgsZGVhY3RpdmF0ZWQISEFzc2V0U3BlbmRBcHByb3ZlZAAAFBRpbmRleAQYYW1vdW50CCxiZW5lZmljaWFyeQAodmFsaWRfZnJvbQQkZXhwaXJlX2F0BEBBc3NldFNwZW5kVm9pZGVkAAAEFGluZGV4BBBQYWlkAAAEFGluZGV4BDRQYXltZW50RmFpbGVkAAAEFGluZGV4BDhTcGVuZFByb2Nlc3NlZAAABBRpbmRleAQBBQdtAVEBAhhAQmF0Y2hJbnRlcnJ1cHRlZAAACBRpbmRleAQUZXJyb3JRAThCYXRjaENvbXBsZXRlZAABBWBCYXRjaENvbXBsZXRlZFdpdGhFcnJvcnMAAQU0SXRlbUNvbXBsZXRlZAABBShJdGVtRmFpbGVkAAAEFGVycm9yUQEwRGlzcGF0Y2hlZEFzAAAEGHJlc3VsdHEBAgwUTm90ZWQAAAQQaGFzaCAkUmVxdWVzdGVkAAAEEGhhc2ggHENsZWFyZWQAAAQQaGFzaCACRCxJZGVudGl0eVNldAAABAx3aG8APElkZW50aXR5Q2xlYXJlZAAACAx3aG8AHGRlcG9zaXQIOElkZW50aXR5S2lsbGVkAAAIDHdobwAcZGVwb3NpdAhISnVkZ2VtZW50UmVxdWVzdGVkAAAIDHdobwA8cmVnaXN0cmFyX2luZGV4BFBKdWRnZW1lbnRVbnJlcXVlc3RlZAAACAx3aG8APHJlZ2lzdHJhcl9pbmRleAQ4SnVkZ2VtZW50R2l2ZW4AAAgYdGFyZ2V0ADxyZWdpc3RyYXJfaW5kZXgEOFJlZ2lzdHJhckFkZGVkAAAEPHJlZ2lzdHJhcl9pbmRleARAU3ViSWRlbnRpdHlBZGRlZAAADAxzdWIAEG1haW4AHGRlcG9zaXQISFN1YklkZW50aXR5UmVtb3ZlZAAADAxzdWIAEG1haW4AHGRlcG9zaXQISFN1YklkZW50aXR5UmV2b2tlZAAADAxzdWIAEG1haW4AHGRlcG9zaXQIOEF1dGhvcml0eUFkZGVkAAAEJGF1dGhvcml0eQBAQXV0aG9yaXR5UmVtb3ZlZAAABCRhdXRob3JpdHkALFVzZXJuYW1lU2V0AAAIDHdobwAgdXNlcm5hbWUkOFVzZXJuYW1lUXVldWVkAAAMDHdobwAgdXNlcm5hbWUkKGV4cGlyYXRpb24ESFByZWFwcHJvdmFsRXhwaXJlZAAABBR3aG9zZQBIUHJpbWFyeVVzZXJuYW1lU2V0AAAIDHdobwAgdXNlcm5hbWUkXERhbmdsaW5nVXNlcm5hbWVSZW1vdmVkAAAIDHdobwAgdXNlcm5hbWUkAgxQU3VwZXJNYWpvcml0eUFwcHJvdmUAAQVQU3VwZXJNYWpvcml0eUFnYWluc3QAAQU4U2ltcGxlTWFqb3JpdHkAAQUCCCBTdGFuZGFyZAAACBB2b3RlBBxiYWxhbmNlCBRTcGxpdAAACAxheWUIDG5heQgCDCBFeHRlcm5hbAABBSBQcm9wb3NhbAEEKFJlZmVyZW5kdW0BBAJEIFByb3Bvc2VkAAAIOHByb3Bvc2FsX2luZGV4BBxkZXBvc2l0CBhUYWJsZWQAAAg4cHJvcG9zYWxfaW5kZXgEHGRlcG9zaXQIOEV4dGVybmFsVGFibGVkAAEFHFN0YXJ0ZWQAAAgkcmVmX2luZGV4BCR0aHJlc2hvbGSBARhQYXNzZWQAAAQkcmVmX2luZGV4BCROb3RQYXNzZWQAAAQkcmVmX2luZGV4BCRDYW5jZWxsZWQAAAQkcmVmX2luZGV4BCREZWxlZ2F0ZWQAAAgMd2hvABh0YXJnZXQALFVuZGVsZWdhdGVkAAAEHGFjY291bnQAGFZldG9lZAAADAx3aG8ANHByb3Bvc2FsX2hhc2ggFHVudGlsBCxCbGFja2xpc3RlZAAABDRwcm9wb3NhbF9oYXNoIBRWb3RlZAAADBR2b3RlcgAkcmVmX2luZGV4BBB2b3RlhQEgU2Vjb25kZWQAAAggc2Vjb25kZXIAKHByb3BfaW5kZXgEQFByb3Bvc2FsQ2FuY2VsZWQAAAQocHJvcF9pbmRleAQsTWV0YWRhdGFTZXQAAAgUb3duZXKJARBoYXNoIDxNZXRhZGF0YUNsZWFyZWQAAAgUb3duZXKJARBoYXNoIExNZXRhZGF0YVRyYW5zZmVycmVkAAAMKHByZXZfb3duZXKJARRvd25lcokBEGhhc2ggAhwgUHJvcG9zZWQAABAcYWNjb3VudAA4cHJvcG9zYWxfaW5kZXgENHByb3Bvc2FsX2hhc2ggJHRocmVzaG9sZAQUVm90ZWQAABQcYWNjb3VudAA0cHJvcG9zYWxfaGFzaCAUdm90ZWQUDHllcwQIbm8EIEFwcHJvdmVkAAAENHByb3Bvc2FsX2hhc2ggLERpc2FwcHJvdmVkAAAENHByb3Bvc2FsX2hhc2ggIEV4ZWN1dGVkAAAINHByb3Bvc2FsX2hhc2ggGHJlc3VsdHEBOE1lbWJlckV4ZWN1dGVkAAAINHByb3Bvc2FsX2hhc2ggGHJlc3VsdHEBGENsb3NlZAAADDRwcm9wb3NhbF9oYXNoIAx5ZXMECG5vBAIYDEFueQABBSxDYW5jZWxQcm94eQABBShHb3Zlcm5hbmNlAAEFIFRyYW5zZmVyAAEFJExpcXVpZGl0eQABBTxMaXF1aWRpdHlNaW5pbmcAAQUCFDRQcm94eUV4ZWN1dGVkAAAEGHJlc3VsdHEBLFB1cmVDcmVhdGVkAAAQEHB1cmUADHdobwAocHJveHlfdHlwZZUBUGRpc2FtYmlndWF0aW9uX2luZGV4BCRBbm5vdW5jZWQAAAwQcmVhbAAUcHJveHkAJGNhbGxfaGFzaCAoUHJveHlBZGRlZAAAECRkZWxlZ2F0b3IAJGRlbGVnYXRlZQAocHJveHlfdHlwZZUBFGRlbGF5BDBQcm94eVJlbW92ZWQAABAkZGVsZWdhdG9yACRkZWxlZ2F0ZWUAKHByb3h5X3R5cGWVARRkZWxheQQACBhoZWlnaHQEFGluZGV4BAIQLE5ld011bHRpc2lnAAAMJGFwcHJvdmluZwAgbXVsdGlzaWcAJGNhbGxfaGFzaCBATXVsdGlzaWdBcHByb3ZhbAAAECRhcHByb3ZpbmcAJHRpbWVwb2ludJ0BIG11bHRpc2lnACRjYWxsX2hhc2ggQE11bHRpc2lnRXhlY3V0ZWQAABQkYXBwcm92aW5nACR0aW1lcG9pbnSdASBtdWx0aXNpZwAkY2FsbF9oYXNoIBhyZXN1bHRxAURNdWx0aXNpZ0NhbmNlbGxlZAAAEChjYW5jZWxsaW5nACR0aW1lcG9pbnSdASBtdWx0aXNpZwAkY2FsbF9oYXNoIAQIAAYIBgACbBxDcmVhdGVkAAAMKGNvbGxlY3Rpb24IHGNyZWF0b3IAFG93bmVyADBGb3JjZUNyZWF0ZWQAAAgoY29sbGVjdGlvbggUb3duZXIAJERlc3Ryb3llZAAABChjb2xsZWN0aW9uCBhJc3N1ZWQAAAwoY29sbGVjdGlvbggQaXRlbQgUb3duZXIALFRyYW5zZmVycmVkAAAQKGNvbGxlY3Rpb24IEGl0ZW0IEGZyb20ACHRvABhCdXJuZWQAAAwoY29sbGVjdGlvbggQaXRlbQgUb3duZXIAGEZyb3plbgAACChjb2xsZWN0aW9uCBBpdGVtCBhUaGF3ZWQAAAgoY29sbGVjdGlvbggQaXRlbQhAQ29sbGVjdGlvbkZyb3plbgAABChjb2xsZWN0aW9uCEBDb2xsZWN0aW9uVGhhd2VkAAAEKGNvbGxlY3Rpb24IME93bmVyQ2hhbmdlZAAACChjb2xsZWN0aW9uCCRuZXdfb3duZXIALFRlYW1DaGFuZ2VkAAAQKGNvbGxlY3Rpb24IGGlzc3VlcgAUYWRtaW4AHGZyZWV6ZXIAQEFwcHJvdmVkVHJhbnNmZXIAABAoY29sbGVjdGlvbggQaXRlbQgUb3duZXIAIGRlbGVnYXRlAERBcHByb3ZhbENhbmNlbGxlZAAAEChjb2xsZWN0aW9uCBBpdGVtCBRvd25lcgAgZGVsZWdhdGUAREl0ZW1TdGF0dXNDaGFuZ2VkAAAEKGNvbGxlY3Rpb24IVENvbGxlY3Rpb25NZXRhZGF0YVNldAAADChjb2xsZWN0aW9uCBBkYXRhJCRpc19mcm96ZW4UZENvbGxlY3Rpb25NZXRhZGF0YUNsZWFyZWQAAAQoY29sbGVjdGlvbggsTWV0YWRhdGFTZXQAABAoY29sbGVjdGlvbggQaXRlbQgQZGF0YSQkaXNfZnJvemVuFDxNZXRhZGF0YUNsZWFyZWQAAAgoY29sbGVjdGlvbggQaXRlbQgsUmVkZXBvc2l0ZWQAAAgoY29sbGVjdGlvbghAc3VjY2Vzc2Z1bF9pdGVtc6UBMEF0dHJpYnV0ZVNldAAAEChjb2xsZWN0aW9uCChtYXliZV9pdGVtqQEMa2V5JBR2YWx1ZSRAQXR0cmlidXRlQ2xlYXJlZAAADChjb2xsZWN0aW9uCChtYXliZV9pdGVtqQEMa2V5JGhPd25lcnNoaXBBY2NlcHRhbmNlQ2hhbmdlZAAACAx3aG8AQG1heWJlX2NvbGxlY3Rpb26pAVhDb2xsZWN0aW9uTWF4U3VwcGx5U2V0AAAIKGNvbGxlY3Rpb24IKG1heF9zdXBwbHkEMEl0ZW1QcmljZVNldAAAEChjb2xsZWN0aW9uCBBpdGVtCBRwcmljZQhEd2hpdGVsaXN0ZWRfYnV5ZXKtAUBJdGVtUHJpY2VSZW1vdmVkAAAIKGNvbGxlY3Rpb24IEGl0ZW0IKEl0ZW1Cb3VnaHQAABQoY29sbGVjdGlvbggQaXRlbQgUcHJpY2UIGHNlbGxlcgAUYnV5ZXIAAggYU2lnbmVkAAEFEEF1dG8AAQUCECBNaWdyYXRlZAAADAx0b3AEFGNoaWxkBBxjb21wdXRltQEcU2xhc2hlZAAACAx3aG8AGGFtb3VudAhUQXV0b01pZ3JhdGlvbkZpbmlzaGVkAAEFGEhhbHRlZAAABBRlcnJvcnQCDCBTdGFuZGFyZAAACBB2b3RlBBxiYWxhbmNlCBRTcGxpdAAACAxheWUIDG5heQgwU3BsaXRBYnN0YWluAAAMDGF5ZQgMbmF5CBxhYnN0YWluCAIQJERlbGVnYXRlZAAEAAEILFVuZGVsZWdhdGVkAQAUVm90ZWQAAAgMd2hvABB2b3RlvQEsVm90ZVJlbW92ZWQAAAgMd2hvABB2b3RlvQECDBhMZWdhY3kAAAQQaGFzaCAYSW5saW5lASQYTG9va3VwAAAIEGhhc2ggDGxlbgQADBBheWVzCBBuYXlzCBxzdXBwb3J0CAJAJFN1Ym1pdHRlZAAADBRpbmRleAQUdHJhY2sEIHByb3Bvc2FsxQFURGVjaXNpb25EZXBvc2l0UGxhY2VkAAAMFGluZGV4BAx3aG8AGGFtb3VudAhcRGVjaXNpb25EZXBvc2l0UmVmdW5kZWQAAAwUaW5kZXgEDHdobwAYYW1vdW50CDhEZXBvc2l0U2xhc2hlZAAACAx3aG8AGGFtb3VudAg8RGVjaXNpb25TdGFydGVkAAAQFGluZGV4BBR0cmFjawQgcHJvcG9zYWzFARR0YWxseckBOENvbmZpcm1TdGFydGVkAAAEFGluZGV4BDhDb25maXJtQWJvcnRlZAAABBRpbmRleAQkQ29uZmlybWVkAAAIFGluZGV4BBR0YWxseckBIEFwcHJvdmVkAAAEFGluZGV4BCBSZWplY3RlZAAACBRpbmRleAQUdGFsbHnJASBUaW1lZE91dAAACBRpbmRleAQUdGFsbHnJASRDYW5jZWxsZWQAAAgUaW5kZXgEFHRhbGx5yQEYS2lsbGVkAAAIFGluZGV4BBR0YWxseckBZFN1Ym1pc3Npb25EZXBvc2l0UmVmdW5kZWQAAAwUaW5kZXgEDHdobwAYYW1vdW50CCxNZXRhZGF0YVNldAAACBRpbmRleAQQaGFzaCA8TWV0YWRhdGFDbGVhcmVkAAAIFGluZGV4BBBoYXNoIAYYAAg0YWN0dWFsX3dlaWdodNEBIHBheXNfZmVlPAAIJHBvc3RfaW5mb9UBFGVycm9yUQEH1QHZAQIMPENhbGxXaGl0ZWxpc3RlZAAABCRjYWxsX2hhc2ggWFdoaXRlbGlzdGVkQ2FsbFJlbW92ZWQAAAQkY2FsbF9oYXNoIGRXaGl0ZWxpc3RlZENhbGxEaXNwYXRjaGVkAAAIJGNhbGxfaGFzaCAYcmVzdWx03QECCHRUcmVhc3VyeU1hbmFnZXJDYWxsRGlzcGF0Y2hlZAAACCRjYWxsX2hhc2ggGHJlc3VsdN0BZEFhdmVNYW5hZ2VyQ2FsbERpc3BhdGNoZWQAAAgkY2FsbF9oYXNoIBhyZXN1bHTdAQYkAhgUVG9rZW4AAQUMWFlLAAEFKFN0YWJsZVN3YXAAAQUQQm9uZAABBSBFeHRlcm5hbAABBRRFcmMyMAABBQYEAiwkQnlHZW5lc2lzASAYQnlGb3JrAAAIMGJsb2NrX251bWJlcggoYmxvY2tfaGFzaCAgUG9sa2Fkb3QAAQUYS3VzYW1hAAEFHFdlc3RlbmQAAQUYUm9jb2NvAAEFGFdvY29jbwABBSBFdGhlcmV1bQAABCBjaGFpbl9pZAgsQml0Y29pbkNvcmUAAQUsQml0Y29pbkNhc2gAAQVAUG9sa2Fkb3RCdWxsZXRpbgABBQb1AQUBUAIoEFVuaXQAAQUcTW9uaWtlcgEoFEluZGV4AQQkRXhlY3V0aXZlAAEFJFRlY2huaWNhbAABBSxMZWdpc2xhdGl2ZQABBSBKdWRpY2lhbAABBRxEZWZlbnNlAAEFOEFkbWluaXN0cmF0aW9uAAEFIFRyZWFzdXJ5AAEFAhQUVm9pY2UAAQUcTWVtYmVycwAABBRjb3VudAQgRnJhY3Rpb24AAAgMbm9tBBRkZW5vbQREQXRMZWFzdFByb3BvcnRpb24AAAgMbm9tBBRkZW5vbQRITW9yZVRoYW5Qcm9wb3J0aW9uAAAIDG5vbQQUZGVub20EAigkUGFyYWNoYWluAQQsQWNjb3VudElkMzIAAAgcbmV0d29ya/kBCGlkIDhBY2NvdW50SW5kZXg2NAAACBxuZXR3b3Jr+QEUaW5kZXgIMEFjY291bnRLZXkyMAAACBxuZXR3b3Jr+QEMa2V5/QE4UGFsbGV0SW5zdGFuY2UBBDBHZW5lcmFsSW5kZXgBCChHZW5lcmFsS2V5AAAIGGxlbmd0aAQQZGF0YSAkT25seUNoaWxkAAEFJFBsdXJhbGl0eQAACAhpZAECEHBhcnQFAjxHbG9iYWxDb25zZW5zdXMB9QECJBBIZXJlAAEFCFgxAQkCCFgyAAQJAgEICFgzAAQJAgEMCFg0AAQJAgEQCFg1AAQJAgEUCFg2AAQJAgEYCFg3AAQJAgEcCFg4AAQJAgEgAAgccGFyZW50cwQgaW50ZXJpb3INAgIYWEV4aXN0ZW50aWFsRGVwb3NpdFBhaWQAAAwMd2hvACRmZWVfYXNzZXQEGGFtb3VudAgoUmVnaXN0ZXJlZAAAICBhc3NldF9pZAQoYXNzZXRfbmFtZekBKGFzc2V0X3R5cGXtAUxleGlzdGVudGlhbF9kZXBvc2l0CDh4Y21fcmF0ZV9saW1pdKkBGHN5bWJvbOkBIGRlY2ltYWxz8QE0aXNfc3VmZmljaWVudBQcVXBkYXRlZAAAICBhc3NldF9pZAQoYXNzZXRfbmFtZekBKGFzc2V0X3R5cGXtAUxleGlzdGVudGlhbF9kZXBvc2l0CDh4Y21fcmF0ZV9saW1pdKkBGHN5bWJvbOkBIGRlY2ltYWxz8QE0aXNfc3VmZmljaWVudBQsTG9jYXRpb25TZXQAAAggYXNzZXRfaWQEIGxvY2F0aW9uEQIsQXNzZXRCYW5uZWQAAAQgYXNzZXRfaWQENEFzc2V0VW5iYW5uZWQAAAQgYXNzZXRfaWQEAgQUQ2xhaW0AAwwA/QEIAgRAQ29sbGF0b3JSZXdhcmRlZAAADAx3aG8AGGFtb3VudAggY3VycmVuY3kEAjQoVG9rZW5BZGRlZAAADCBhc3NldF9pZAQ4aW5pdGlhbF9hbW91bnQINGluaXRpYWxfcHJpY2UIMFRva2VuUmVtb3ZlZAAADCBhc3NldF9pZAQYYW1vdW50CDRodWJfd2l0aGRyYXduCDhMaXF1aWRpdHlBZGRlZAAAEAx3aG8AIGFzc2V0X2lkBBhhbW91bnQILHBvc2l0aW9uX2lkCEBMaXF1aWRpdHlSZW1vdmVkAAAUDHdobwAscG9zaXRpb25faWQIIGFzc2V0X2lkBDhzaGFyZXNfcmVtb3ZlZAgMZmVlCGBQcm90b2NvbExpcXVpZGl0eVJlbW92ZWQAABQMd2hvACBhc3NldF9pZAQYYW1vdW50CChodWJfYW1vdW50CDhzaGFyZXNfcmVtb3ZlZAgwU2VsbEV4ZWN1dGVkAAAkDHdobwAgYXNzZXRfaW4EJGFzc2V0X291dAQkYW1vdW50X2luCChhbW91bnRfb3V0CDRodWJfYW1vdW50X2luCDhodWJfYW1vdW50X291dAhAYXNzZXRfZmVlX2Ftb3VudAhMcHJvdG9jb2xfZmVlX2Ftb3VudAgsQnV5RXhlY3V0ZWQAACQMd2hvACBhc3NldF9pbgQkYXNzZXRfb3V0BCRhbW91bnRfaW4IKGFtb3VudF9vdXQINGh1Yl9hbW91bnRfaW4IOGh1Yl9hbW91bnRfb3V0CEBhc3NldF9mZWVfYW1vdW50CExwcm90b2NvbF9mZWVfYW1vdW50CDxQb3NpdGlvbkNyZWF0ZWQAABgscG9zaXRpb25faWQIFG93bmVyABRhc3NldAQYYW1vdW50CBhzaGFyZXMIFHByaWNlCERQb3NpdGlvbkRlc3Ryb3llZAAACCxwb3NpdGlvbl9pZAgUb3duZXIAPFBvc2l0aW9uVXBkYXRlZAAAGCxwb3NpdGlvbl9pZAgUb3duZXIAFGFzc2V0BBhhbW91bnQIGHNoYXJlcwgUcHJpY2UIUFRyYWRhYmxlU3RhdGVVcGRhdGVkAAAIIGFzc2V0X2lkBBRzdGF0ZQQ0QXNzZXRSZWZ1bmRlZAAADCBhc3NldF9pZAQYYW1vdW50CCRyZWNpcGllbnQAVEFzc2V0V2VpZ2h0Q2FwVXBkYXRlZAAACCBhc3NldF9pZAQMY2FwBAIIRFRyYW5zYWN0aW9uUGF1c2VkAAAIRHBhbGxldF9uYW1lX2J5dGVzJExmdW5jdGlvbl9uYW1lX2J5dGVzJExUcmFuc2FjdGlvblVucGF1c2VkAAAIRHBhbGxldF9uYW1lX2J5dGVzJExmdW5jdGlvbl9uYW1lX2J5dGVzJAIMGER1c3RlZAAACAx3aG8AGGFtb3VudAgUQWRkZWQAAAQMd2hvABxSZW1vdmVkAAAEDHdobwACDFxHbG9iYWxGYXJtQWNjUlBaVXBkYXRlZAAADDhnbG9iYWxfZmFybV9pZAQ8YWNjdW11bGF0ZWRfcnB6CDh0b3RhbF9zaGFyZXNfeghcWWllbGRGYXJtQWNjUlBWU1VwZGF0ZWQAABA4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEQGFjY3VtdWxhdGVkX3JwdnMITHRvdGFsX3ZhbHVlZF9zaGFyZXMIVEFsbFJld2FyZHNEaXN0cmlidXRlZAAABDhnbG9iYWxfZmFybV9pZAQACGRpbml0aWFsX3Jld2FyZF9wZXJjZW50YWdlCChzY2FsZV9jb2VmBAYxAgI0REdsb2JhbEZhcm1DcmVhdGVkAAAoCGlkBBRvd25lcgA0dG90YWxfcmV3YXJkcwg8cmV3YXJkX2N1cnJlbmN5BEB5aWVsZF9wZXJfcGVyaW9kCGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMERGJsb2Nrc19wZXJfcGVyaW9kBFRtYXhfcmV3YXJkX3Blcl9wZXJpb2QILG1pbl9kZXBvc2l0CFRscm5hX3ByaWNlX2FkanVzdG1lbnQIREdsb2JhbEZhcm1VcGRhdGVkAAAQCGlkBGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMEQHlpZWxkX3Blcl9wZXJpb2QILG1pbl9kZXBvc2l0CFBHbG9iYWxGYXJtVGVybWluYXRlZAAAEDhnbG9iYWxfZmFybV9pZAQMd2hvADxyZXdhcmRfY3VycmVuY3kEVHVuZGlzdHJpYnV0ZWRfcmV3YXJkcwhAWWllbGRGYXJtQ3JlYXRlZAAAFDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQgYXNzZXRfaWQEKG11bHRpcGxpZXIINGxveWFsdHlfY3VydmU1AkBZaWVsZEZhcm1VcGRhdGVkAAAUOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBCBhc3NldF9pZAQMd2hvAChtdWx0aXBsaWVyCEBZaWVsZEZhcm1TdG9wcGVkAAAQOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBCBhc3NldF9pZAQMd2hvAEBZaWVsZEZhcm1SZXN1bWVkAAAUOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBCBhc3NldF9pZAQMd2hvAChtdWx0aXBsaWVyCExZaWVsZEZhcm1UZXJtaW5hdGVkAAAQOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBCBhc3NldF9pZAQMd2hvADxTaGFyZXNEZXBvc2l0ZWQAABw4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEKGRlcG9zaXRfaWQIIGFzc2V0X2lkBAx3aG8ANHNoYXJlc19hbW91bnQILHBvc2l0aW9uX2lkCERTaGFyZXNSZWRlcG9zaXRlZAAAHDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQoZGVwb3NpdF9pZAggYXNzZXRfaWQEDHdobwA0c2hhcmVzX2Ftb3VudAgscG9zaXRpb25faWQINFJld2FyZENsYWltZWQAABg4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEDHdobwAcY2xhaW1lZAg8cmV3YXJkX2N1cnJlbmN5BChkZXBvc2l0X2lkCDxTaGFyZXNXaXRoZHJhd24AABQ4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEDHdobwAYYW1vdW50CChkZXBvc2l0X2lkCEBEZXBvc2l0RGVzdHJveWVkAAAIDHdobwAoZGVwb3NpdF9pZAgCECRDYW5jZWxsZWQAAAQgb3JkZXJfaWQEGEZpbGxlZAAAFCBvcmRlcl9pZAQMd2hvACRhbW91bnRfaW4IKGFtb3VudF9vdXQIDGZlZQg8UGFydGlhbGx5RmlsbGVkAAAUIG9yZGVyX2lkBAx3aG8AJGFtb3VudF9pbggoYW1vdW50X291dAgMZmVlCBhQbGFjZWQAABggb3JkZXJfaWQEIGFzc2V0X2luBCRhc3NldF9vdXQEJGFtb3VudF9pbggoYW1vdW50X291dAhIcGFydGlhbGx5X2ZpbGxhYmxlFAQEAQgGQQICGFxUcmFkZVZvbHVtZUxpbWl0Q2hhbmdlZAAACCBhc3NldF9pZARIdHJhZGVfdm9sdW1lX2xpbWl0QQJgQWRkTGlxdWlkaXR5TGltaXRDaGFuZ2VkAAAIIGFzc2V0X2lkBDxsaXF1aWRpdHlfbGltaXRFAmxSZW1vdmVMaXF1aWRpdHlMaW1pdENoYW5nZWQAAAggYXNzZXRfaWQEPGxpcXVpZGl0eV9saW1pdEUCNEFzc2V0TG9ja2Rvd24AAAggYXNzZXRfaWQEFHVudGlsBFBBc3NldExvY2tkb3duUmVtb3ZlZAAABCBhc3NldF9pZAQ8RGVwb3NpdFJlbGVhc2VkAAAIDHdobwAgYXNzZXRfaWQEBAQAAgggRXhlY3V0ZWQAABQgYXNzZXRfaW4EJGFzc2V0X291dAQkYW1vdW50X2luCChhbW91bnRfb3V0CCBldmVudF9pZAQwUm91dGVVcGRhdGVkAAAEJGFzc2V0X2lkc00CABAcbWluX2ZlZQQcbWF4X2ZlZQQUZGVjYXkINGFtcGxpZmljYXRpb24IAggURml4ZWQAAAgkYXNzZXRfZmVlBDBwcm90b2NvbF9mZWUEHER5bmFtaWMAAAhAYXNzZXRfZmVlX3BhcmFtc1UCTHByb3RvY29sX2ZlZV9wYXJhbXNVAgIIREFzc2V0RmVlQ29uZmlnU2V0AAAIIGFzc2V0X2lkBBhwYXJhbXNZAlRBc3NldEZlZUNvbmZpZ1JlbW92ZWQAAAQgYXNzZXRfaWQEAhg8UG9zaXRpb25DcmVhdGVkAAAMDHdobwAscG9zaXRpb25faWQIFHN0YWtlCChTdGFrZUFkZGVkAAAcDHdobwAscG9zaXRpb25faWQIFHN0YWtlCCx0b3RhbF9zdGFrZQg4bG9ja2VkX3Jld2FyZHMIOHNsYXNoZWRfcG9pbnRzCEhwYXlhYmxlX3BlcmNlbnRhZ2UIOFJld2FyZHNDbGFpbWVkAAAcDHdobwAscG9zaXRpb25faWQIMHBhaWRfcmV3YXJkcwhAdW5sb2NrZWRfcmV3YXJkcwg4c2xhc2hlZF9wb2ludHMIWHNsYXNoZWRfdW5wYWlkX3Jld2FyZHMISHBheWFibGVfcGVyY2VudGFnZQggVW5zdGFrZWQAAAwMd2hvACxwb3NpdGlvbl9pZAg4dW5sb2NrZWRfc3Rha2UISFN0YWtpbmdJbml0aWFsaXplZAAABFBub25fZHVzdGFibGVfYmFsYW5jZQhUQWNjdW11bGF0ZWRScHNVcGRhdGVkAAAIPGFjY3VtdWxhdGVkX3JwcwgsdG90YWxfc3Rha2UIBAgBCAUBIAIYJExhc3RCbG9jawABBRRTaG9ydAABBShUZW5NaW51dGVzAAEFEEhvdXIAAQUMRGF5AAEFEFdlZWsAAQUDDGkCbQIEAgwUVmFsdWUBZQIYT3JhY2xlAXECIE1NT3JhY2xlAf0BBHUCAARlAgAADBhzb3VyY2V5AjhtYXhfcGVnX3VwZGF0ZQQcY3VycmVudH0CBoECAAggYXNzZXRfaWQEGGFtb3VudAgEiQIAAiwsUG9vbENyZWF0ZWQAABQccG9vbF9pZAQYYXNzZXRzTQI0YW1wbGlmaWNhdGlvbgQMZmVlBAxwZWeFAihGZWVVcGRhdGVkAAAIHHBvb2xfaWQEDGZlZQQ4TGlxdWlkaXR5QWRkZWQAABAccG9vbF9pZAQMd2hvABhzaGFyZXMIGGFzc2V0c40CQExpcXVpZGl0eVJlbW92ZWQAABQccG9vbF9pZAQMd2hvABhzaGFyZXMIHGFtb3VudHONAgxmZWUIMFNlbGxFeGVjdXRlZAAAHAx3aG8AHHBvb2xfaWQEIGFzc2V0X2luBCRhc3NldF9vdXQEJGFtb3VudF9pbggoYW1vdW50X291dAgMZmVlCCxCdXlFeGVjdXRlZAAAHAx3aG8AHHBvb2xfaWQEIGFzc2V0X2luBCRhc3NldF9vdXQEJGFtb3VudF9pbggoYW1vdW50X291dAgMZmVlCFBUcmFkYWJsZVN0YXRlVXBkYXRlZAAADBxwb29sX2lkBCBhc3NldF9pZAQUc3RhdGUEVEFtcGxpZmljYXRpb25DaGFuZ2luZwAAFBxwb29sX2lkBFRjdXJyZW50X2FtcGxpZmljYXRpb24ETGZpbmFsX2FtcGxpZmljYXRpb24ELHN0YXJ0X2Jsb2NrBCRlbmRfYmxvY2sENFBvb2xEZXN0cm95ZWQAAAQccG9vbF9pZARQUG9vbFBlZ1NvdXJjZVVwZGF0ZWQAAAwccG9vbF9pZAQgYXNzZXRfaWQEKHBlZ19zb3VyY2V1AlxQb29sTWF4UGVnVXBkYXRlVXBkYXRlZAAACBxwb29sX2lkBDhtYXhfcGVnX3VwZGF0ZQQCDDBUb2tlbkNyZWF0ZWQAABAYaXNzdWVyACBhc3NldF9pZAQcYm9uZF9pZAQgbWF0dXJpdHkIGElzc3VlZAAAEBhpc3N1ZXIAHGJvbmRfaWQEGGFtb3VudAgMZmVlCCBSZWRlZW1lZAAADAx3aG8AHGJvbmRfaWQEGGFtb3VudAgCBCBFeGVjdXRlZAAACCBhc3NldF9pZAQYcHJvZml0CAIEGExpbmVhcgABBQAoFG93bmVyABRzdGFydPEBDGVuZPEBGGFzc2V0c0ECOGluaXRpYWxfd2VpZ2h0BDBmaW5hbF93ZWlnaHQEMHdlaWdodF9jdXJ2ZZ0CDGZlZUECNGZlZV9jb2xsZWN0b3IAMHJlcGF5X3RhcmdldAgCGCxQb29sQ3JlYXRlZAAACBBwb29sABBkYXRhoQIsUG9vbFVwZGF0ZWQAAAgQcG9vbAAQZGF0YaECOExpcXVpZGl0eUFkZGVkAAAUDHdobwAcYXNzZXRfYQQcYXNzZXRfYgQgYW1vdW50X2EIIGFtb3VudF9iCEBMaXF1aWRpdHlSZW1vdmVkAAAUDHdobwAcYXNzZXRfYQQcYXNzZXRfYgQgYW1vdW50X2EIIGFtb3VudF9iCDBTZWxsRXhlY3V0ZWQAABwMd2hvACBhc3NldF9pbgQkYXNzZXRfb3V0BBhhbW91bnQIKHNhbGVfcHJpY2UIJGZlZV9hc3NldAQoZmVlX2Ftb3VudAgsQnV5RXhlY3V0ZWQAABwMd2hvACRhc3NldF9vdXQEIGFzc2V0X2luBBhhbW91bnQIJGJ1eV9wcmljZQgkZmVlX2Fzc2V0BChmZWVfYW1vdW50CAIYOExpcXVpZGl0eUFkZGVkAAAUDHdobwAcYXNzZXRfYQQcYXNzZXRfYgQgYW1vdW50X2EIIGFtb3VudF9iCEBMaXF1aWRpdHlSZW1vdmVkAAAQDHdobwAcYXNzZXRfYQQcYXNzZXRfYgQYc2hhcmVzCCxQb29sQ3JlYXRlZAAAGAx3aG8AHGFzc2V0X2EEHGFzc2V0X2IEVGluaXRpYWxfc2hhcmVzX2Ftb3VudAgsc2hhcmVfdG9rZW4EEHBvb2wANFBvb2xEZXN0cm95ZWQAABQMd2hvABxhc3NldF9hBBxhc3NldF9iBCxzaGFyZV90b2tlbgQQcG9vbAAwU2VsbEV4ZWN1dGVkAAAgDHdobwAgYXNzZXRfaW4EJGFzc2V0X291dAQYYW1vdW50CChzYWxlX3ByaWNlCCRmZWVfYXNzZXQEKGZlZV9hbW91bnQIEHBvb2wALEJ1eUV4ZWN1dGVkAAAgDHdobwAkYXNzZXRfb3V0BCBhc3NldF9pbgQYYW1vdW50CCRidXlfcHJpY2UIJGZlZV9hc3NldAQoZmVlX2Ftb3VudAgQcG9vbAACGBBOb25lAAEFFFRpZXIwAAEFFFRpZXIxAAEFFFRpZXIyAAEFFFRpZXIzAAEFFFRpZXI0AAEFAAwgcmVmZXJyZXIEGHRyYWRlcgQgZXh0ZXJuYWwEAhg4Q29kZVJlZ2lzdGVyZWQAAAgQY29kZSQcYWNjb3VudAAoQ29kZUxpbmtlZAAADBxhY2NvdW50ABBjb2RlJEByZWZlcnJhbF9hY2NvdW50ACRDb252ZXJ0ZWQAAAgQZnJvbYkCCHRviQIcQ2xhaW1lZAAADAx3aG8AQHJlZmVycmVyX3Jld2FyZHMINHRyYWRlX3Jld2FyZHMITEFzc2V0UmV3YXJkc1VwZGF0ZWQAAAwgYXNzZXRfaWQEFGxldmVsrQIccmV3YXJkc7ECHExldmVsVXAAAAgMd2hvABRsZXZlbK0CAgQoTGlxdWlkYXRlZAAAFBB1c2Vy/QFAY29sbGF0ZXJhbF9hc3NldAQoZGVidF9hc3NldAQ0ZGVidF90b19jb3ZlcggYcHJvZml0CAapAQIUPENvbGxhdGVyYWxBZGRlZAAAGCBhc3NldF9pZAQccG9vbF9pZAQwcHVyY2hhc2VfZmVlBGRtYXhfYnV5X3ByaWNlX2NvZWZmaWNpZW50CDBidXlfYmFja19mZWUEMGJ1eWJhY2tfcmF0ZQREQ29sbGF0ZXJhbFJlbW92ZWQAAAQgYXNzZXRfaWQERENvbGxhdGVyYWxVcGRhdGVkAAAYIGFzc2V0X2lkBDBwdXJjaGFzZV9mZWXxAWRtYXhfYnV5X3ByaWNlX2NvZWZmaWNpZW50qQEwYnV5X2JhY2tfZmVl8QEwYnV5YmFja19yYXRl8QE4bWF4X2luX2hvbGRpbme9AkRBcmJpdHJhZ2VFeGVjdXRlZAAAECRhcmJpdHJhZ2UEIGFzc2V0X2lkBDRob2xsYXJfYW1vdW50CBhwcm9maXQIOEZsYXNoTWludGVyU2V0AAAEMGZsYXNoX21pbnRlcv0BAkQcRW5kb3dlZAAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQIIER1c3RMb3N0AAAMLGN1cnJlbmN5X2lkBAx3aG8AGGFtb3VudAggVHJhbnNmZXIAABAsY3VycmVuY3lfaWQEEGZyb20ACHRvABhhbW91bnQIIFJlc2VydmVkAAAMLGN1cnJlbmN5X2lkBAx3aG8AGGFtb3VudAgoVW5yZXNlcnZlZAAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQISFJlc2VydmVSZXBhdHJpYXRlZAAAFCxjdXJyZW5jeV9pZAQQZnJvbQAIdG8AGGFtb3VudAgYc3RhdHVzWQEoQmFsYW5jZVNldAAAECxjdXJyZW5jeV9pZAQMd2hvABBmcmVlCCByZXNlcnZlZAhAVG90YWxJc3N1YW5jZVNldAAACCxjdXJyZW5jeV9pZAQYYW1vdW50CCRXaXRoZHJhd24AAAwsY3VycmVuY3lfaWQEDHdobwAYYW1vdW50CBxTbGFzaGVkAAAQLGN1cnJlbmN5X2lkBAx3aG8ALGZyZWVfYW1vdW50CDxyZXNlcnZlZF9hbW91bnQIJERlcG9zaXRlZAAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQIHExvY2tTZXQAABAcbG9ja19pZGkCLGN1cnJlbmN5X2lkBAx3aG8AGGFtb3VudAgsTG9ja1JlbW92ZWQAAAwcbG9ja19pZGkCLGN1cnJlbmN5X2lkBAx3aG8AGExvY2tlZAAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQIIFVubG9ja2VkAAAMLGN1cnJlbmN5X2lkBAx3aG8AGGFtb3VudAgYSXNzdWVkAAAILGN1cnJlbmN5X2lkBBhhbW91bnQIJFJlc2NpbmRlZAAACCxjdXJyZW5jeV9pZAQYYW1vdW50CAIQLFRyYW5zZmVycmVkAAAQLGN1cnJlbmN5X2lkBBBmcm9tAAh0bwAYYW1vdW50CDhCYWxhbmNlVXBkYXRlZAAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQIJERlcG9zaXRlZAAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQIJFdpdGhkcmF3bgAADCxjdXJyZW5jeV9pZAQMd2hvABhhbW91bnQIABAUc3RhcnQEGHBlcmlvZAQwcGVyaW9kX2NvdW50BChwZXJfcGVyaW9kCAIMUFZlc3RpbmdTY2hlZHVsZUFkZGVkAAAMEGZyb20ACHRvAEB2ZXN0aW5nX3NjaGVkdWxlzQIcQ2xhaW1lZAAACAx3aG8AGGFtb3VudAhcVmVzdGluZ1NjaGVkdWxlc1VwZGF0ZWQAAAQMd2hvAAQgAAAMHGFkZHJlc3P9ARh0b3BpY3PVAhBkYXRhJAIUDExvZwAABAxsb2fZAhxDcmVhdGVkAAAEHGFkZHJlc3P9ATRDcmVhdGVkRmFpbGVkAAAEHGFkZHJlc3P9ASBFeGVjdXRlZAAABBxhZGRyZXNz/QE4RXhlY3V0ZWRGYWlsZWQAAAQcYWRkcmVzc/0BAgwcU3RvcHBlZAABBSBSZXR1cm5lZAABBSBTdWljaWRlZAABBQEBAkA4U3RhY2tVbmRlcmZsb3cAAQU0U3RhY2tPdmVyZmxvdwABBSxJbnZhbGlkSnVtcAABBTBJbnZhbGlkUmFuZ2UAAQVERGVzaWduYXRlZEludmFsaWQAAQUsQ2FsbFRvb0RlZXAAAQU8Q3JlYXRlQ29sbGlzaW9uAAEFTENyZWF0ZUNvbnRyYWN0TGltaXQAAQUsSW52YWxpZENvZGUBBCxPdXRPZk9mZnNldAABBSBPdXRPZkdhcwABBSRPdXRPZkZ1bmQAAQUsUENVbmRlcmZsb3cAAQUsQ3JlYXRlRW1wdHkAAQUUT3RoZXIB5QIgTWF4Tm9uY2UAAQUCBCBSZXZlcnRlZAABBQIQME5vdFN1cHBvcnRlZAABBUhVbmhhbmRsZWRJbnRlcnJ1cHQAAQVAQ2FsbEVycm9yQXNGYXRhbAHpAhRPdGhlcgHlAgIQHFN1Y2NlZWQB4QIURXJyb3IB6QIYUmV2ZXJ0Ae0CFEZhdGFsAfECAgQgRXhlY3V0ZWQAABQQZnJvbf0BCHRv/QFAdHJhbnNhY3Rpb25faGFzaCAsZXhpdF9yZWFzb271AihleHRyYV9kYXRhJAIUFEJvdW5kAAAIHGFjY291bnQAHGFkZHJlc3P9ATREZXBsb3llckFkZGVkAAAEDHdob/0BPERlcGxveWVyUmVtb3ZlZAAABAx3aG/9AUBDb250cmFjdEFwcHJvdmVkAAAEHGFkZHJlc3P9AUxDb250cmFjdERpc2FwcHJvdmVkAAAEHGFkZHJlc3P9AQAIIGFzc2V0X2luBCRhc3NldF9vdXQEAjRER2xvYmFsRmFybUNyZWF0ZWQAACwIaWQEFG93bmVyADR0b3RhbF9yZXdhcmRzCDxyZXdhcmRfY3VycmVuY3kEQHlpZWxkX3Blcl9wZXJpb2QIYHBsYW5uZWRfeWllbGRpbmdfcGVyaW9kcwREYmxvY2tzX3Blcl9wZXJpb2QESGluY2VudGl2aXplZF9hc3NldARUbWF4X3Jld2FyZF9wZXJfcGVyaW9kCCxtaW5fZGVwb3NpdAhAcHJpY2VfYWRqdXN0bWVudAhER2xvYmFsRmFybVVwZGF0ZWQAAAgIaWQEQHByaWNlX2FkanVzdG1lbnQIQFlpZWxkRmFybUNyZWF0ZWQAABQ4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEKG11bHRpcGxpZXIIKGFzc2V0X3BhaXIBAzRsb3lhbHR5X2N1cnZlNQJQR2xvYmFsRmFybVRlcm1pbmF0ZWQAABA4Z2xvYmFsX2Zhcm1faWQEDHdobwA8cmV3YXJkX2N1cnJlbmN5BFR1bmRpc3RyaWJ1dGVkX3Jld2FyZHMIPFNoYXJlc0RlcG9zaXRlZAAAGDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQMd2hvABhhbW91bnQIIGxwX3Rva2VuBChkZXBvc2l0X2lkCERTaGFyZXNSZWRlcG9zaXRlZAAAGDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQMd2hvABhhbW91bnQIIGxwX3Rva2VuBChkZXBvc2l0X2lkCDRSZXdhcmRDbGFpbWVkAAAYOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBAx3aG8AHGNsYWltZWQIPHJld2FyZF9jdXJyZW5jeQQoZGVwb3NpdF9pZAg8U2hhcmVzV2l0aGRyYXduAAAYOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBAx3aG8AIGxwX3Rva2VuBBhhbW91bnQIKGRlcG9zaXRfaWQIQFlpZWxkRmFybVN0b3BwZWQAABA4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEDHdobwAoYXNzZXRfcGFpcgEDQFlpZWxkRmFybVJlc3VtZWQAABQ4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEDHdobwAoYXNzZXRfcGFpcgEDKG11bHRpcGxpZXIITFlpZWxkRmFybVRlcm1pbmF0ZWQAABA4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEDHdobwAoYXNzZXRfcGFpcgEDQFlpZWxkRmFybVVwZGF0ZWQAABQ4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEDHdobwAoYXNzZXRfcGFpcgEDKG11bHRpcGxpZXIIQERlcG9zaXREZXN0cm95ZWQAAAgMd2hvAChkZXBvc2l0X2lkCAIETEN1cnJlbnRCbG9ja051bWJlcnMAAAhYcGFyYWNoYWluX2Jsb2NrX251bWJlcgRccmVsYXljaGFpbl9ibG9ja19udW1iZXIEAhgMWFlLAAEFDExCUAABBShTdGFibGVzd2FwAQQgT21uaXBvb2wAAQUQQWF2ZQABBQxIU00AAQUADBBwb29sDQMgYXNzZXRfaW4EJGFzc2V0X291dAQEEQMAAggQU2VsbAAAFCBhc3NldF9pbgQkYXNzZXRfb3V0BCRhbW91bnRfaW4IOG1pbl9hbW91bnRfb3V0CBRyb3V0ZRUDDEJ1eQAAFCBhc3NldF9pbgQkYXNzZXRfb3V0BChhbW91bnRfb3V0CDRtYXhfYW1vdW50X2luCBRyb3V0ZRUDAiRARXhlY3V0aW9uU3RhcnRlZAAACAhpZAQUYmxvY2sEJFNjaGVkdWxlZAAAFAhpZAQMd2hvABhwZXJpb2QEMHRvdGFsX2Ftb3VudAgUb3JkZXIZA0BFeGVjdXRpb25QbGFubmVkAAAMCGlkBAx3aG8AFGJsb2NrBDRUcmFkZUV4ZWN1dGVkAAAQCGlkBAx3aG8AJGFtb3VudF9pbggoYW1vdW50X291dAgsVHJhZGVGYWlsZWQAAAwIaWQEDHdobwAUZXJyb3JRAShUZXJtaW5hdGVkAAAMCGlkBAx3aG8AFGVycm9yUQEkQ29tcGxldGVkAAAICGlkBAx3aG8AaFJhbmRvbW5lc3NHZW5lcmF0aW9uRmFpbGVkAAAIFGJsb2NrBBRlcnJvclEBPFJlc2VydmVVbmxvY2tlZAAACAx3aG8AIGFzc2V0X2lkBAYgAiQkU2NoZWR1bGVkAAAIEHdoZW4EFGluZGV4BCBDYW5jZWxlZAAACBB3aGVuBBRpbmRleAQoRGlzcGF0Y2hlZAAADBB0YXNrQQIIaWQhAxhyZXN1bHRxASBSZXRyeVNldAAAEBB0YXNrQQIIaWQhAxhwZXJpb2QEHHJldHJpZXMEOFJldHJ5Q2FuY2VsbGVkAAAIEHRhc2tBAghpZCEDPENhbGxVbmF2YWlsYWJsZQAACBB0YXNrQQIIaWQhAzhQZXJpb2RpY0ZhaWxlZAAACBB0YXNrQQIIaWQhAyxSZXRyeUZhaWxlZAAACBB0YXNrQQIIaWQhA1RQZXJtYW5lbnRseU92ZXJ3ZWlnaHQAAAgQdGFza0ECCGlkIQMCGGBWYWxpZGF0aW9uRnVuY3Rpb25TdG9yZWQAAQVkVmFsaWRhdGlvbkZ1bmN0aW9uQXBwbGllZAAABFRyZWxheV9jaGFpbl9ibG9ja19udW0EbFZhbGlkYXRpb25GdW5jdGlvbkRpc2NhcmRlZAABBWBEb3dud2FyZE1lc3NhZ2VzUmVjZWl2ZWQAAAQUY291bnQEZERvd253YXJkTWVzc2FnZXNQcm9jZXNzZWQAAAgsd2VpZ2h0X3VzZWQYIGRtcV9oZWFkIERVcHdhcmRNZXNzYWdlU2VudAAABDBtZXNzYWdlX2hhc2ghAwKgIE92ZXJmbG93AAEFNFVuaW1wbGVtZW50ZWQAAQVgVW50cnVzdGVkUmVzZXJ2ZUxvY2F0aW9uAAEFZFVudHJ1c3RlZFRlbGVwb3J0TG9jYXRpb24AAQUwTG9jYXRpb25GdWxsAAEFVExvY2F0aW9uTm90SW52ZXJ0aWJsZQABBSRCYWRPcmlnaW4AAQU8SW52YWxpZExvY2F0aW9uAAEFNEFzc2V0Tm90Rm91bmQAAQVURmFpbGVkVG9UcmFuc2FjdEFzc2V0AAEFPE5vdFdpdGhkcmF3YWJsZQABBUhMb2NhdGlvbkNhbm5vdEhvbGQAAQVURXhjZWVkc01heE1lc3NhZ2VTaXplAAEFWERlc3RpbmF0aW9uVW5zdXBwb3J0ZWQAAQUkVHJhbnNwb3J0AAEFKFVucm91dGFibGUAAQUwVW5rbm93bkNsYWltAAEFOEZhaWxlZFRvRGVjb2RlAAEFQE1heFdlaWdodEludmFsaWQAAQU4Tm90SG9sZGluZ0ZlZXMAAQUwVG9vRXhwZW5zaXZlAAEFEFRyYXABCEBFeHBlY3RhdGlvbkZhbHNlAAEFOFBhbGxldE5vdEZvdW5kAAEFME5hbWVNaXNtYXRjaAABBUxWZXJzaW9uSW5jb21wYXRpYmxlAAEFUEhvbGRpbmdXb3VsZE92ZXJmbG93AAEFLEV4cG9ydEVycm9yAAEFOFJlYW5jaG9yRmFpbGVkAAEFGE5vRGVhbAABBShGZWVzTm90TWV0AAEFJExvY2tFcnJvcgABBTBOb1Blcm1pc3Npb24AAQUoVW5hbmNob3JlZAABBThOb3REZXBvc2l0YWJsZQABBUxVbmhhbmRsZWRYY21WZXJzaW9uAAEFSFdlaWdodExpbWl0UmVhY2hlZAEYHEJhcnJpZXIAAQVMV2VpZ2h0Tm90Q29tcHV0YWJsZQABBURFeGNlZWRzU3RhY2tMaW1pdAABBQIMIENvbXBsZXRlAAAEEHVzZWQYKEluY29tcGxldGUAAAgQdXNlZBgUZXJyb3ItAxRFcnJvcgAABBRlcnJvci0DBQFAAhgkVW5kZWZpbmVkAAEFFEluZGV4AQgYQXJyYXk0ASgYQXJyYXk4AWkCHEFycmF5MTYBNQMcQXJyYXkzMgEgAgggRnVuZ2libGUBCCxOb25GdW5naWJsZQE5AwAICGlkEQIMZnVuPQMEQQMAAwgELQMGSQMAGBRpbmRleAQQbmFtZSQsbW9kdWxlX25hbWUkFG1ham9yBBRtaW5vcgQUcGF0Y2gEBFEDAAIMHFN1Y2Nlc3MAAQUURXJyb3IBJDhUcnVuY2F0ZWRFcnJvcgEkAhgQTnVsbAABBRhBc3NldHMBRQM8RXhlY3V0aW9uUmVzdWx0AU0DHFZlcnNpb24BBCxQYWxsZXRzSW5mbwFVAzhEaXNwYXRjaFJlc3VsdAFZAwYRAgIQGE5hdGl2ZQABBUBTb3ZlcmVpZ25BY2NvdW50AAEFJFN1cGVydXNlcgABBQxYY20AAQUADCxkZXN0aW5hdGlvbhECIHF1ZXJ5X2lkCChtYXhfd2VpZ2h0GAIIIEZ1bmdpYmxlAAEFLE5vbkZ1bmdpYmxlAAEFAhAMQWxsAAEFFEFsbE9mAAAICGlkEQIMZnVubQMoQWxsQ291bnRlZAEEMEFsbE9mQ291bnRlZAAADAhpZBECDGZ1bm0DFGNvdW50BAIIIERlZmluaXRlAUUDEFdpbGQBcQMCCCRVbmxpbWl0ZWQAAQUcTGltaXRlZAEYAsA0V2l0aGRyYXdBc3NldAFFA1RSZXNlcnZlQXNzZXREZXBvc2l0ZWQBRQNYUmVjZWl2ZVRlbGVwb3J0ZWRBc3NldAFFAzRRdWVyeVJlc3BvbnNlAAAQIHF1ZXJ5X2lkCCByZXNwb25zZV0DKG1heF93ZWlnaHQYHHF1ZXJpZXJhAzRUcmFuc2ZlckFzc2V0AAAIGGFzc2V0c0UDLGJlbmVmaWNpYXJ5EQJQVHJhbnNmZXJSZXNlcnZlQXNzZXQAAAwYYXNzZXRzRQMQZGVzdBECDHhjbYEDIFRyYW5zYWN0AAAMLG9yaWdpbl9raW5kZQNYcmVxdWlyZV93ZWlnaHRfYXRfbW9zdBgQY2FsbCRkSHJtcE5ld0NoYW5uZWxPcGVuUmVxdWVzdAAADBhzZW5kZXIEQG1heF9tZXNzYWdlX3NpemUEMG1heF9jYXBhY2l0eQRMSHJtcENoYW5uZWxBY2NlcHRlZAAABCRyZWNpcGllbnQESEhybXBDaGFubmVsQ2xvc2luZwAADCRpbml0aWF0b3IEGHNlbmRlcgQkcmVjaXBpZW50BCxDbGVhck9yaWdpbgABBTREZXNjZW5kT3JpZ2luAQ0CLFJlcG9ydEVycm9yAWkDMERlcG9zaXRBc3NldAAACBhhc3NldHN1AyxiZW5lZmljaWFyeRECTERlcG9zaXRSZXNlcnZlQXNzZXQAAAwYYXNzZXRzdQMQZGVzdBECDHhjbYEDNEV4Y2hhbmdlQXNzZXQAAAwQZ2l2ZXUDEHdhbnRFAxxtYXhpbWFsFFxJbml0aWF0ZVJlc2VydmVXaXRoZHJhdwAADBhhc3NldHN1AxxyZXNlcnZlEQIMeGNtgQNASW5pdGlhdGVUZWxlcG9ydAAADBhhc3NldHN1AxBkZXN0EQIMeGNtgQM0UmVwb3J0SG9sZGluZwAACDRyZXNwb25zZV9pbmZvaQMYYXNzZXRzdQMwQnV5RXhlY3V0aW9uAAAIEGZlZXNBAzB3ZWlnaHRfbGltaXR5AzRSZWZ1bmRTdXJwbHVzAAEFPFNldEVycm9ySGFuZGxlcgGBAyxTZXRBcHBlbmRpeAGBAyhDbGVhckVycm9yAAEFKENsYWltQXNzZXQAAAgYYXNzZXRzRQMYdGlja2V0EQIQVHJhcAEIQFN1YnNjcmliZVZlcnNpb24AAAggcXVlcnlfaWQITG1heF9yZXNwb25zZV93ZWlnaHQYSFVuc3Vic2NyaWJlVmVyc2lvbgABBSRCdXJuQXNzZXQBRQMsRXhwZWN0QXNzZXQBRQMwRXhwZWN0T3JpZ2luAWEDLEV4cGVjdEVycm9yAU0DUEV4cGVjdFRyYW5zYWN0U3RhdHVzAVkDLFF1ZXJ5UGFsbGV0AAAILG1vZHVsZV9uYW1lJDRyZXNwb25zZV9pbmZvaQMwRXhwZWN0UGFsbGV0AAAUFGluZGV4BBBuYW1lJCxtb2R1bGVfbmFtZSQsY3JhdGVfbWFqb3IEPG1pbl9jcmF0ZV9taW5vcgRQUmVwb3J0VHJhbnNhY3RTdGF0dXMBaQNMQ2xlYXJUcmFuc2FjdFN0YXR1cwABBTxVbml2ZXJzYWxPcmlnaW4BCQI0RXhwb3J0TWVzc2FnZQAADBxuZXR3b3Jr9QEsZGVzdGluYXRpb24NAgx4Y22BAyRMb2NrQXNzZXQAAAgUYXNzZXRBAyB1bmxvY2tlchECLFVubG9ja0Fzc2V0AAAIFGFzc2V0QQMYdGFyZ2V0EQI4Tm90ZVVubG9ja2FibGUAAAgUYXNzZXRBAxRvd25lchECNFJlcXVlc3RVbmxvY2sAAAgUYXNzZXRBAxhsb2NrZXIRAixTZXRGZWVzTW9kZQAABDBqaXRfd2l0aGRyYXcUIFNldFRvcGljASAoQ2xlYXJUb3BpYwABBSxBbGlhc09yaWdpbgERAjxVbnBhaWRFeGVjdXRpb24AAAgwd2VpZ2h0X2xpbWl0eQMwY2hlY2tfb3JpZ2luYQMEfQMAAhAMQW55AAEFFE5hbWVkASQgUG9sa2Fkb3QAAQUYS3VzYW1hAAEFAigQVW5pdAABBRROYW1lZAEkFEluZGV4AQQkRXhlY3V0aXZlAAEFJFRlY2huaWNhbAABBSxMZWdpc2xhdGl2ZQABBSBKdWRpY2lhbAABBRxEZWZlbnNlAAEFOEFkbWluaXN0cmF0aW9uAAEFIFRyZWFzdXJ5AAEFAiQkUGFyYWNoYWluAQQsQWNjb3VudElkMzIAAAgcbmV0d29ya4UDCGlkIDhBY2NvdW50SW5kZXg2NAAACBxuZXR3b3JrhQMUaW5kZXgIMEFjY291bnRLZXkyMAAACBxuZXR3b3JrhQMMa2V5/QE4UGFsbGV0SW5zdGFuY2UBBDBHZW5lcmFsSW5kZXgBCChHZW5lcmFsS2V5ASQkT25seUNoaWxkAAEFJFBsdXJhbGl0eQAACAhpZIkDEHBhcnQFAgIkEEhlcmUAAQUIWDEBjQMIWDIABI0DAQgIWDMABI0DAQwIWDQABI0DARAIWDUABI0DARQIWDYABI0DARgIWDcABI0DARwIWDgABI0DASAACBxwYXJlbnRzBCBpbnRlcmlvcpEDAgggQ29uY3JldGUBlQMgQWJzdHJhY3QBJAIcJFVuZGVmaW5lZAABBRRJbmRleAEIGEFycmF5NAEoGEFycmF5OAFpAhxBcnJheTE2ATUDHEFycmF5MzIBIBBCbG9iASQCCCBGdW5naWJsZQEILE5vbkZ1bmdpYmxlAZ0DAAgIaWSZAwxmdW6hAwSlAwACCCBDb25jcmV0ZQERAiBBYnN0cmFjdAEgAAgIaWStAwxmdW49AwSxAwACDAhWMgGpAwhWMwG1AwhWNAFFAwIMCFYyAZUDCFYzARECCFY0ARECAmAkQXR0ZW1wdGVkAAAEHG91dGNvbWUxAxBTZW50AAAQGG9yaWdpbhECLGRlc3RpbmF0aW9uEQIcbWVzc2FnZYEDKG1lc3NhZ2VfaWQgSFVuZXhwZWN0ZWRSZXNwb25zZQAACBhvcmlnaW4RAiBxdWVyeV9pZAg0UmVzcG9uc2VSZWFkeQAACCBxdWVyeV9pZAggcmVzcG9uc2VdAyBOb3RpZmllZAAADCBxdWVyeV9pZAgwcGFsbGV0X2luZGV4BChjYWxsX2luZGV4BEBOb3RpZnlPdmVyd2VpZ2h0AAAUIHF1ZXJ5X2lkCDBwYWxsZXRfaW5kZXgEKGNhbGxfaW5kZXgENGFjdHVhbF93ZWlnaHQYTG1heF9idWRnZXRlZF93ZWlnaHQYTE5vdGlmeURpc3BhdGNoRXJyb3IAAAwgcXVlcnlfaWQIMHBhbGxldF9pbmRleAQoY2FsbF9pbmRleARITm90aWZ5RGVjb2RlRmFpbGVkAAAMIHF1ZXJ5X2lkCDBwYWxsZXRfaW5kZXgEKGNhbGxfaW5kZXgEQEludmFsaWRSZXNwb25kZXIAAAwYb3JpZ2luEQIgcXVlcnlfaWQIRGV4cGVjdGVkX2xvY2F0aW9uYQNcSW52YWxpZFJlc3BvbmRlclZlcnNpb24AAAgYb3JpZ2luEQIgcXVlcnlfaWQINFJlc3BvbnNlVGFrZW4AAAQgcXVlcnlfaWQINEFzc2V0c1RyYXBwZWQAAAwQaGFzaCAYb3JpZ2luEQIYYXNzZXRzuQNUVmVyc2lvbkNoYW5nZU5vdGlmaWVkAAAQLGRlc3RpbmF0aW9uEQIYcmVzdWx0BBBjb3N0RQMobWVzc2FnZV9pZCBcU3VwcG9ydGVkVmVyc2lvbkNoYW5nZWQAAAggbG9jYXRpb24RAhx2ZXJzaW9uBFBOb3RpZnlUYXJnZXRTZW5kRmFpbAAADCBsb2NhdGlvbhECIHF1ZXJ5X2lkCBRlcnJvci0DZE5vdGlmeVRhcmdldE1pZ3JhdGlvbkZhaWwAAAggbG9jYXRpb269AyBxdWVyeV9pZAhUSW52YWxpZFF1ZXJpZXJWZXJzaW9uAAAIGG9yaWdpbhECIHF1ZXJ5X2lkCDhJbnZhbGlkUXVlcmllcgAAEBhvcmlnaW4RAiBxdWVyeV9pZAhAZXhwZWN0ZWRfcXVlcmllchECUG1heWJlX2FjdHVhbF9xdWVyaWVyYQNQVmVyc2lvbk5vdGlmeVN0YXJ0ZWQAAAwsZGVzdGluYXRpb24RAhBjb3N0RQMobWVzc2FnZV9pZCBYVmVyc2lvbk5vdGlmeVJlcXVlc3RlZAAADCxkZXN0aW5hdGlvbhECEGNvc3RFAyhtZXNzYWdlX2lkIGBWZXJzaW9uTm90aWZ5VW5yZXF1ZXN0ZWQAAAwsZGVzdGluYXRpb24RAhBjb3N0RQMobWVzc2FnZV9pZCAgRmVlc1BhaWQAAAgYcGF5aW5nEQIQZmVlc0UDNEFzc2V0c0NsYWltZWQAAAwQaGFzaCAYb3JpZ2luEQIYYXNzZXRzuQNgVmVyc2lvbk1pZ3JhdGlvbkZpbmlzaGVkAAAEHHZlcnNpb24EAgw0SW52YWxpZEZvcm1hdAEgSFVuc3VwcG9ydGVkVmVyc2lvbgEgQEV4ZWN1dGVkRG93bndhcmQAAwggMQMCBDxYY21wTWVzc2FnZVNlbnQAAAQwbWVzc2FnZV9oYXNoIAIMEEhlcmUAAQUYUGFyZW50AAEFHFNpYmxpbmcBBAIYJEJhZEZvcm1hdAABBRxDb3JydXB0AAEFLFVuc3VwcG9ydGVkAAEFKE92ZXJ3ZWlnaHQBGBRZaWVsZAABBURTdGFja0xpbWl0UmVhY2hlZAABBQIQQFByb2Nlc3NpbmdGYWlsZWQAAAwIaWQgGG9yaWdpbs0DFGVycm9y0QMkUHJvY2Vzc2VkAAAQCGlkIBhvcmlnaW7NAyx3ZWlnaHRfdXNlZBgcc3VjY2VzcxRIT3ZlcndlaWdodEVucXVldWVkAAAQCGlkIBhvcmlnaW7NAyhwYWdlX2luZGV4BDRtZXNzYWdlX2luZGV4BChQYWdlUmVhcGVkAAAIGG9yaWdpbs0DFGluZGV4BAIEEFNlbnQAAAgIdG8RAhxtZXNzYWdlgQMCBERUcmFuc2ZlcnJlZEFzc2V0cwAAEBhzZW5kZXIAGGFzc2V0c0UDDGZlZUEDEGRlc3QRAgIIJERlcG9zaXRlZAAACBRhc3NldEEDDHdobxECJFdpdGhkcmF3bgAACBRhc3NldEEDDHdobxECBAAAAihATmV3SW52dWxuZXJhYmxlcwAABDRpbnZ1bG5lcmFibGVz5QNESW52dWxuZXJhYmxlQWRkZWQAAAQoYWNjb3VudF9pZABMSW52dWxuZXJhYmxlUmVtb3ZlZAAABChhY2NvdW50X2lkAFBOZXdEZXNpcmVkQ2FuZGlkYXRlcwAABEhkZXNpcmVkX2NhbmRpZGF0ZXMEQE5ld0NhbmRpZGFjeUJvbmQAAAQsYm9uZF9hbW91bnQIOENhbmRpZGF0ZUFkZGVkAAAIKGFjY291bnRfaWQAHGRlcG9zaXQIUENhbmRpZGF0ZUJvbmRVcGRhdGVkAAAIKGFjY291bnRfaWQAHGRlcG9zaXQIQENhbmRpZGF0ZVJlbW92ZWQAAAQoYWNjb3VudF9pZABEQ2FuZGlkYXRlUmVwbGFjZWQAAAwMb2xkAAxuZXcAHGRlcG9zaXQIaEludmFsaWRJbnZ1bG5lcmFibGVTa2lwcGVkAAAEKGFjY291bnRfaWQAAgQoTmV3U2Vzc2lvbgAABDRzZXNzaW9uX2luZGV4BAIUDEV2bQEEIFBvbGthZG90AQQYS3VzYW1hAQQkU3Vic3RyYXRlASgoVGVuZGVybWludAEoAAggc3RhdGVfaWTxA0hjb25zZW5zdXNfc3RhdGVfaWQoAAgIaWT1AxhoZWlnaHQIBCQAAAgoY29tbWl0bWVudCAccmVsYXllciQADChjb21taXRtZW50IBhzb3VyY2XxAxBkZXN08QMCNExTdGF0ZU1hY2hpbmVVcGRhdGVkAAAIQHN0YXRlX21hY2hpbmVfaWT1AzRsYXRlc3RfaGVpZ2h0CFRTdGF0ZUNvbW1pdG1lbnRWZXRvZWQAAAgYaGVpZ2h0+QMkZmlzaGVybWFuJFhDb25zZW5zdXNDbGllbnRDcmVhdGVkAAAETGNvbnNlbnN1c19jbGllbnRfaWQoVENvbnNlbnN1c0NsaWVudEZyb3plbgAABExjb25zZW5zdXNfY2xpZW50X2lkKCBSZXNwb25zZQAAFChkZXN0X2NoYWlu8QMwc291cmNlX2NoYWlu8QM0cmVxdWVzdF9ub25jZQgoY29tbWl0bWVudCA4cmVxX2NvbW1pdG1lbnQgHFJlcXVlc3QAABAoZGVzdF9jaGFpbvEDMHNvdXJjZV9jaGFpbvEDNHJlcXVlc3Rfbm9uY2UIKGNvbW1pdG1lbnQgGEVycm9ycwAABBhlcnJvcnP9A0hQb3N0UmVxdWVzdEhhbmRsZWQBAQRMUG9zdFJlc3BvbnNlSGFuZGxlZAEBBERHZXRSZXF1ZXN0SGFuZGxlZAEBBGRQb3N0UmVxdWVzdFRpbWVvdXRIYW5kbGVkAQUEaFBvc3RSZXNwb25zZVRpbWVvdXRIYW5kbGVkAQUEYEdldFJlcXVlc3RUaW1lb3V0SGFuZGxlZAEFBAAICGlkBDRzbG90X2R1cmF0aW9uCAQNBAACCDxQYXJhY2hhaW5zQWRkZWQAAAQgcGFyYV9pZHMRBERQYXJhY2hhaW5zUmVtb3ZlZAAABCBwYXJhX2lkc00CAwjxAwgEGQQAAAxQZGVmYXVsdF9wZXJfYnl0ZV9mZWUINHBlcl9ieXRlX2ZlZXMdBFhhc3NldF9yZWdpc3RyYXRpb25fZmVlCAIECFYxASEEAgxESG9zdFBhcmFtc1VwZGF0ZWQAAAgMb2xkJQQMbmV3JQRMUmVsYXllckZlZVdpdGhkcmF3bgAACBhhbW91bnQIHGFjY291bnQAYFByb3RvY29sUmV2ZW51ZVdpdGhkcmF3bgAACBhhbW91bnQIHGFjY291bnQAAhA8QXNzZXRUZWxlcG9ydGVkAAAUEGZyb20ACHRvIBhhbW91bnQIEGRlc3TxAyhjb21taXRtZW50IDRBc3NldFJlY2VpdmVkAAAMLGJlbmVmaWNpYXJ5ABhhbW91bnQIGHNvdXJjZfEDNEFzc2V0UmVmdW5kZWQAAAwsYmVuZWZpY2lhcnkAGGFtb3VudAgYc291cmNl8QOIRVJDNjE2MEFzc2V0UmVnaXN0cmF0aW9uRGlzcGF0Y2hlZAAABChjb21taXRtZW50IAIIQEFkZGVkVG9XaGl0ZWxpc3QAAAgYc291cmNlaQIYYXNzZXRzQQJQUmVtb3ZlZEZyb21XaGl0ZWxpc3QAAAgYc291cmNlaQIYYXNzZXRzQQICHCBPbW5pcG9vbAABBShTdGFibGVzd2FwAQQMWFlLAQQMTEJQAAEFDE9UQwEEEEFBVkUAAQUMSFNNAAEFAhQcRXhhY3RJbgABBSBFeGFjdE91dAABBRRMaW1pdAABBTBMaXF1aWRpdHlBZGQAAQU8TGlxdWlkaXR5UmVtb3ZlAAEFAAgUYXNzZXQEGGFtb3VudAgEPQQAAggcQWNjb3VudAEAGEJ1cm5lZAABBQAMFGFzc2V0BBhhbW91bnQILGRlc3RpbmF0aW9uRQQESQQAAhgYUm91dGVyAQQMRENBAAQEAQgUQmF0Y2gBBCBPbW5pcG9vbAEELFhjbUV4Y2hhbmdlAQQMWGNtAAMIIAQEUQQAAgQgU3dhcHBlZDMAACAcc3dhcHBlcgAYZmlsbGVyACxmaWxsZXJfdHlwZTUEJG9wZXJhdGlvbjkEGGlucHV0c0EEHG91dHB1dHNBBBBmZWVzTQQ8b3BlcmF0aW9uX3N0YWNrVQQCCQEYU3lzdGVtAVUBIEJhbGFuY2VzAV0BSFRyYW5zYWN0aW9uUGF5bWVudAFhAVxNdWx0aVRyYW5zYWN0aW9uUGF5bWVudAFlASBUcmVhc3VyeQFpARxVdGlsaXR5AXUBIFByZWltYWdlAXkBIElkZW50aXR5AX0BJERlbW9jcmFjeQGNAUhUZWNobmljYWxDb21taXR0ZWUBkQEUUHJveHkBmQEgTXVsdGlzaWcBoQEcVW5pcXVlcwGxAUhTdGF0ZVRyaWVNaWdyYXRpb24BuQFAQ29udmljdGlvblZvdGluZwHBASRSZWZlcmVuZGEBzQEkV2hpdGVsaXN0AeEBKERpc3BhdGNoZXIB5QE0QXNzZXRSZWdpc3RyeQEVAhhDbGFpbXMBGQI8Q29sbGF0b3JSZXdhcmRzAR0CIE9tbmlwb29sASECQFRyYW5zYWN0aW9uUGF1c2UBJQIYRHVzdGVyASkCTE9tbmlwb29sV2FyZWhvdXNlTE0BLQJcT21uaXBvb2xMaXF1aWRpdHlNaW5pbmcBOQIMT1RDAT0COENpcmN1aXRCcmVha2VyAUkCGFJvdXRlcgFRAixEeW5hbWljRmVlcwFdAhxTdGFraW5nAWECKFN0YWJsZXN3YXABkQIUQm9uZHMBlQI4T3RjU2V0dGxlbWVudHMBmQIMTEJQAaUCDFhZSwGpAiRSZWZlcnJhbHMBtQIsTGlxdWlkYXRpb24BuQIMSFNNAcECGFRva2VucwHFAihDdXJyZW5jaWVzAckCHFZlc3RpbmcB0QIMRVZNAd0CIEV0aGVyZXVtAfkCLEVWTUFjY291bnRzAf0CSFhZS0xpcXVpZGl0eU1pbmluZwEFAzhYWUtXYXJlaG91c2VMTQEtAjhSZWxheUNoYWluSW5mbwEJAwxEQ0EBHQMkU2NoZWR1bGVyASUDPFBhcmFjaGFpblN5c3RlbQEpAyxQb2xrYWRvdFhjbQHBAyhDdW11bHVzWGNtAcUDJFhjbXBRdWV1ZQHJAzBNZXNzYWdlUXVldWUB1QMcT3JtbFhjbQHZAxxYVG9rZW5zAd0DNFVua25vd25Ub2tlbnMB4QNEQ29sbGF0b3JTZWxlY3Rpb24B6QMcU2Vzc2lvbgHtAxBJc21wAQkENElzbXBQYXJhY2hhaW4BFQQsSHlwZXJicmlkZ2UBKQQwVG9rZW5HYXRld2F5AS0EJEVtYU9yYWNsZQExBCRCcm9hZGNhc3QBWQQADBRwaGFzZTQUZXZlbnRdBBh0b3BpY3PVAgRhBAAEQQIAAAgwc3BlY192ZXJzaW9uBCRzcGVjX25hbWXlAgAIJGNvZGVfaGFzaCA0Y2hlY2tfdmVyc2lvbhQAEDhiYXNlX2V4dHJpbnNpYxg0bWF4X2V4dHJpbnNpY9EBJG1heF90b3RhbNEBIHJlc2VydmVk0QEADBhub3JtYWx1BCxvcGVyYXRpb25hbHUEJG1hbmRhdG9yeXUEAAwoYmFzZV9ibG9jaxgkbWF4X2Jsb2NrGCRwZXJfY2xhc3N5BAAMGG5vcm1hbAQsb3BlcmF0aW9uYWwEJG1hbmRhdG9yeQQACBByZWFkCBR3cml0ZQgDCGkCBASJBAAAICRzcGVjX25hbWXlAiRpbXBsX25hbWXlAkRhdXRob3JpbmdfdmVyc2lvbgQwc3BlY192ZXJzaW9uBDBpbXBsX3ZlcnNpb24EEGFwaXONBEx0cmFuc2FjdGlvbl92ZXJzaW9uBDRzdGF0ZV92ZXJzaW9uBAMMAAgIAgwQUm9vdAABBRhTaWduZWQBABBOb25lAAEFAgwcTWVtYmVycwAEBAEIGE1lbWJlcgEAIF9QaGFudG9tAAEFAiREV2hpdGVsaXN0ZWRDYWxsZXIAAQVMUmVmZXJlbmR1bUNhbmNlbGxlcgABBUBSZWZlcmVuZHVtS2lsbGVyAAEFMEdlbmVyYWxBZG1pbgABBTRPbW5pcG9vbEFkbWluAAEFJFRyZWFzdXJlcgABBRxTcGVuZGVyAAEFGFRpcHBlcgABBUhFY29ub21pY1BhcmFtZXRlcnMAAQUCBExFdGhlcmV1bVRyYW5zYWN0aW9uAf0BAggMWGNtARECIFJlc3BvbnNlARECAggUUmVsYXkAAQVAU2libGluZ1BhcmFjaGFpbgEEAhwYc3lzdGVtAZkESFRlY2huaWNhbENvbW1pdHRlZQGdBBxPcmlnaW5zAaEEIEV0aGVyZXVtAaUELFBvbGthZG90WGNtAakEKEN1bXVsdXNYY20BrQQQVm9pZAFtAQIICEF0AQQUQWZ0ZXIBBAAIDHdobwAYYW1vdW50CAa5BAAIFHNpbmNlBChjb25maXJtaW5n8QEGwQQDCARBAgbJBAAsFHRyYWNrBBhvcmlnaW6xBCBwcm9wb3NhbMUBJGVuYWN0bWVudLUEJHN1Ym1pdHRlZARIc3VibWlzc2lvbl9kZXBvc2l0uQRAZGVjaXNpb25fZGVwb3NpdL0EIGRlY2lkaW5nxQQUdGFsbHnJASBpbl9xdWV1ZRQUYWxhcm3NBAIYHE9uZ29pbmcB0QQgQXBwcm92ZWQAAwwEvQS9BCBSZWplY3RlZAADDAS9BL0EJENhbmNlbGxlZAADDAS9BL0EIFRpbWVkT3V0AAMMBL0EvQQYS2lsbGVkAQQDCAQIBNkEAAQkAQgE4QQAAiwYcmVtYXJrAAAEGHJlbWFyayQ4c2V0X2hlYXBfcGFnZXMAAAQUcGFnZXMIIHNldF9jb2RlAAAEEGNvZGUkXHNldF9jb2RlX3dpdGhvdXRfY2hlY2tzAAAEEGNvZGUkLHNldF9zdG9yYWdlAAAEFGl0ZW1z5QQwa2lsbF9zdG9yYWdlAAAEEGtleXP9AyxraWxsX3ByZWZpeAAACBhwcmVmaXgkHHN1YmtleXMERHJlbWFya193aXRoX2V2ZW50AAAEGHJlbWFyayREYXV0aG9yaXplX3VwZ3JhZGUAAAQkY29kZV9oYXNoIIBhdXRob3JpemVfdXBncmFkZV93aXRob3V0X2NoZWNrcwAABCRjb2RlX2hhc2ggYGFwcGx5X2F1dGhvcml6ZWRfdXBncmFkZQAABBBjb2RlJAIEDHNldAAABAxub3cIAgggSW5jcmVhc2UAAQUgRGVjcmVhc2UAAQUCJFB0cmFuc2Zlcl9hbGxvd19kZWF0aAAACBBkZXN0ABR2YWx1ZQg4Zm9yY2VfdHJhbnNmZXIAAAwYc291cmNlABBkZXN0ABR2YWx1ZQhMdHJhbnNmZXJfa2VlcF9hbGl2ZQAACBBkZXN0ABR2YWx1ZQgwdHJhbnNmZXJfYWxsAAAIEGRlc3QAKGtlZXBfYWxpdmUUPGZvcmNlX3VucmVzZXJ2ZQAACAx3aG8AGGFtb3VudAhAdXBncmFkZV9hY2NvdW50cwAABAx3aG/lA0Rmb3JjZV9zZXRfYmFsYW5jZQAACAx3aG8AIG5ld19mcmVlCGxmb3JjZV9hZGp1c3RfdG90YWxfaXNzdWFuY2UAAAgkZGlyZWN0aW9u8QQUZGVsdGEIEGJ1cm4AAAgUdmFsdWUIKGtlZXBfYWxpdmUUBAgBEAIUMHNldF9jdXJyZW5jeQAABCBjdXJyZW5jeQQwYWRkX2N1cnJlbmN5AAAIIGN1cnJlbmN5BBRwcmljZQg8cmVtb3ZlX2N1cnJlbmN5AAAEIGN1cnJlbmN5BFhyZXNldF9wYXltZW50X2N1cnJlbmN5AAAEKGFjY291bnRfaWQAPGRpc3BhdGNoX3Blcm1pdAAAJBBmcm9t/QEIdG/9ARR2YWx1ZfkEEGRhdGEkJGdhc19saW1pdAggZGVhZGxpbmX5BAR2BARyIARzIAIYLHNwZW5kX2xvY2FsAAAIGGFtb3VudAgsYmVuZWZpY2lhcnkAPHJlbW92ZV9hcHByb3ZhbAAABCxwcm9wb3NhbF9pZAQUc3BlbmQAAAwYYW1vdW50CCxiZW5lZmljaWFyeQAodmFsaWRfZnJvbfEBGHBheW91dAAABBRpbmRleAQwY2hlY2tfc3RhdHVzAAAEFGluZGV4BCh2b2lkX3NwZW5kAAAEFGluZGV4BATlBwACGBRiYXRjaAAABBRjYWxscwUFNGFzX2Rlcml2YXRpdmUAAAgUaW5kZXgEEGNhbGzlByRiYXRjaF9hbGwAAAQUY2FsbHMFBSxkaXNwYXRjaF9hcwAACCRhc19vcmlnaW6xBBBjYWxs5QcsZm9yY2VfYmF0Y2gAAAQUY2FsbHMFBSx3aXRoX3dlaWdodAAACBBjYWxs5QcYd2VpZ2h0GAIUNG5vdGVfcHJlaW1hZ2UAAAQUYnl0ZXMkPHVubm90ZV9wcmVpbWFnZQAABBBoYXNoIEByZXF1ZXN0X3ByZWltYWdlAAAEEGhhc2ggSHVucmVxdWVzdF9wcmVpbWFnZQAABBBoYXNoIDhlbnN1cmVfdXBkYXRlZAAABBhoYXNoZXPVAgUBCAUBDAUBFAUBGAUBHAUBJAUBKAUBLAUBMAUBNAUBOAUBPAUBRAUBSAUBTAUBVAUBWAUBXAUBYAUBZAUBaAUBbAUBcAUBdAUBeAUBfAKYEE5vbmUAAQUQUmF3MAFtARBSYXcxAQQQUmF3MgERBRBSYXczARUFEFJhdzQBKBBSYXc1ARkFEFJhdzYBHQUQUmF3NwEhBRBSYXc4AWkCEFJhdzkBJQUUUmF3MTABKQUUUmF3MTEBLQUUUmF3MTIBMQUUUmF3MTMBNQUUUmF3MTQBOQUUUmF3MTUBPQUUUmF3MTYBNQMUUmF3MTcBQQUUUmF3MTgBRQUUUmF3MTkBSQUUUmF3MjAB/QEUUmF3MjEBTQUUUmF3MjIBUQUUUmF3MjMBVQUUUmF3MjQBWQUUUmF3MjUBXQUUUmF3MjYBYQUUUmF3MjcBZQUUUmF3MjgBaQUUUmF3MjkBbQUUUmF3MzABcQUUUmF3MzEBdQUUUmF3MzIBICxCbGFrZVR3bzI1NgEgGFNoYTI1NgEgJEtlY2NhazI1NgEgLFNoYVRocmVlMjU2ASAEeQUBCAR9BQAG/QEAJChhZGRpdGlvbmFsgQUcZGlzcGxheXkFFGxlZ2FseQUMd2VieQUQcmlvdHkFFGVtYWlseQU8cGdwX2ZpbmdlcnByaW50hQUUaW1hZ2V5BRx0d2l0dGVyeQUDCAB5BQSNBQACHBxVbmtub3duAAEFHEZlZVBhaWQBCChSZWFzb25hYmxlAAEFJEtub3duR29vZAABBSRPdXRPZkRhdGUAAQUoTG93UXVhbGl0eQABBSRFcnJvbmVvdXMAAQUFAQEBBQEFAQIMHEVkMjU1MTkBmQUcU3IyNTUxOQGZBRRFY2RzYQGdBQahBQJYNGFkZF9yZWdpc3RyYXIAAAQcYWNjb3VudAAwc2V0X2lkZW50aXR5AAAEEGluZm+JBSBzZXRfc3VicwAABBBzdWJzkQU4Y2xlYXJfaWRlbnRpdHkAAQVEcmVxdWVzdF9qdWRnZW1lbnQAAAgkcmVnX2luZGV4BBxtYXhfZmVlCDhjYW5jZWxfcmVxdWVzdAAABCRyZWdfaW5kZXgEHHNldF9mZWUAAAgUaW5kZXgEDGZlZQg4c2V0X2FjY291bnRfaWQAAAgUaW5kZXgEDG5ldwAoc2V0X2ZpZWxkcwAACBRpbmRleAQYZmllbGRzCERwcm92aWRlX2p1ZGdlbWVudAAAECRyZWdfaW5kZXgEGHRhcmdldAAkanVkZ2VtZW50lQUgaWRlbnRpdHkgNGtpbGxfaWRlbnRpdHkAAAQYdGFyZ2V0ABxhZGRfc3ViAAAIDHN1YgAQZGF0YXkFKHJlbmFtZV9zdWIAAAgMc3ViABBkYXRheQUocmVtb3ZlX3N1YgAABAxzdWIAIHF1aXRfc3ViAAEFWGFkZF91c2VybmFtZV9hdXRob3JpdHkAAAwkYXV0aG9yaXR5ABhzdWZmaXgkKGFsbG9jYXRpb24EZHJlbW92ZV91c2VybmFtZV9hdXRob3JpdHkAAAQkYXV0aG9yaXR5AEBzZXRfdXNlcm5hbWVfZm9yAAAMDHdobwAgdXNlcm5hbWUkJHNpZ25hdHVyZaUFPGFjY2VwdF91c2VybmFtZQAABCB1c2VybmFtZSRccmVtb3ZlX2V4cGlyZWRfYXBwcm92YWwAAAQgdXNlcm5hbWUkUHNldF9wcmltYXJ5X3VzZXJuYW1lAAAEIHVzZXJuYW1lJGByZW1vdmVfZGFuZ2xpbmdfdXNlcm5hbWUAAAQgdXNlcm5hbWUkAhwQTm9uZQABBSBMb2NrZWQxeAABBSBMb2NrZWQyeAABBSBMb2NrZWQzeAABBSBMb2NrZWQ0eAABBSBMb2NrZWQ1eAABBSBMb2NrZWQ2eAABBQJQHHByb3Bvc2UAAAggcHJvcG9zYWzFARR2YWx1ZQgYc2Vjb25kAAAEIHByb3Bvc2FsBBB2b3RlAAAIJHJlZl9pbmRleAQQdm90ZYUBQGVtZXJnZW5jeV9jYW5jZWwAAAQkcmVmX2luZGV4BEBleHRlcm5hbF9wcm9wb3NlAAAEIHByb3Bvc2FsxQFkZXh0ZXJuYWxfcHJvcG9zZV9tYWpvcml0eQAABCBwcm9wb3NhbMUBYGV4dGVybmFsX3Byb3Bvc2VfZGVmYXVsdAAABCBwcm9wb3NhbMUBKGZhc3RfdHJhY2sAAAw0cHJvcG9zYWxfaGFzaCA0dm90aW5nX3BlcmlvZAQUZGVsYXkENHZldG9fZXh0ZXJuYWwAAAQ0cHJvcG9zYWxfaGFzaCBEY2FuY2VsX3JlZmVyZW5kdW0AAAQkcmVmX2luZGV4BCBkZWxlZ2F0ZQAADAh0bwAoY29udmljdGlvbq0FHGJhbGFuY2UIKHVuZGVsZWdhdGUAAQVYY2xlYXJfcHVibGljX3Byb3Bvc2FscwABBRh1bmxvY2sAAAQYdGFyZ2V0ACxyZW1vdmVfdm90ZQAABBRpbmRleAREcmVtb3ZlX290aGVyX3ZvdGUAAAgYdGFyZ2V0ABRpbmRleAQkYmxhY2tsaXN0AAAINHByb3Bvc2FsX2hhc2ggPG1heWJlX3JlZl9pbmRlePEBPGNhbmNlbF9wcm9wb3NhbAAABChwcm9wX2luZGV4BDBzZXRfbWV0YWRhdGEAAAgUb3duZXKJAShtYXliZV9oYXNoIQNEZm9yY2VfcmVtb3ZlX3ZvdGUAAAgYdGFyZ2V0ABRpbmRleAQCGCxzZXRfbWVtYmVycwAADCxuZXdfbWVtYmVyc+UDFHByaW1lrQEkb2xkX2NvdW50BBxleGVjdXRlAAAIIHByb3Bvc2Fs5QcwbGVuZ3RoX2JvdW5kBBxwcm9wb3NlAAAMJHRocmVzaG9sZAQgcHJvcG9zYWzlBzBsZW5ndGhfYm91bmQEEHZvdGUAAAwgcHJvcG9zYWwgFGluZGV4BBxhcHByb3ZlFExkaXNhcHByb3ZlX3Byb3Bvc2FsAAAENHByb3Bvc2FsX2hhc2ggFGNsb3NlAAAQNHByb3Bvc2FsX2hhc2ggFGluZGV4BFRwcm9wb3NhbF93ZWlnaHRfYm91bmQYMGxlbmd0aF9ib3VuZAQGlQECKBRwcm94eQAADBByZWFsAEBmb3JjZV9wcm94eV90eXBluQUQY2FsbOUHJGFkZF9wcm94eQAADCBkZWxlZ2F0ZQAocHJveHlfdHlwZZUBFGRlbGF5BDByZW1vdmVfcHJveHkAAAwgZGVsZWdhdGUAKHByb3h5X3R5cGWVARRkZWxheQQ4cmVtb3ZlX3Byb3hpZXMAAQUsY3JlYXRlX3B1cmUAAAwocHJveHlfdHlwZZUBFGRlbGF5BBRpbmRleAQka2lsbF9wdXJlAAAUHHNwYXduZXIAKHByb3h5X3R5cGWVARRpbmRleAQYaGVpZ2h0BCRleHRfaW5kZXgEIGFubm91bmNlAAAIEHJlYWwAJGNhbGxfaGFzaCBMcmVtb3ZlX2Fubm91bmNlbWVudAAACBByZWFsACRjYWxsX2hhc2ggTHJlamVjdF9hbm5vdW5jZW1lbnQAAAggZGVsZWdhdGUAJGNhbGxfaGFzaCA8cHJveHlfYW5ub3VuY2VkAAAQIGRlbGVnYXRlABByZWFsAEBmb3JjZV9wcm94eV90eXBluQUQY2FsbOUHBp0BAhBQYXNfbXVsdGlfdGhyZXNob2xkXzEAAAhEb3RoZXJfc2lnbmF0b3JpZXPlAxBjYWxs5QcgYXNfbXVsdGkAABQkdGhyZXNob2xkBERvdGhlcl9zaWduYXRvcmllc+UDPG1heWJlX3RpbWVwb2ludMEFEGNhbGzlByhtYXhfd2VpZ2h0GEBhcHByb3ZlX2FzX211bHRpAAAUJHRocmVzaG9sZAREb3RoZXJfc2lnbmF0b3JpZXPlAzxtYXliZV90aW1lcG9pbnTBBSRjYWxsX2hhc2ggKG1heF93ZWlnaHQYPGNhbmNlbF9hc19tdWx0aQAAECR0aHJlc2hvbGQERG90aGVyX3NpZ25hdG9yaWVz5QMkdGltZXBvaW50nQEkY2FsbF9oYXNoIAAMFGl0ZW1zBDhpdGVtX21ldGFkYXRhcwQoYXR0cmlidXRlcwQCaBhjcmVhdGUAAAgoY29sbGVjdGlvbggUYWRtaW4AMGZvcmNlX2NyZWF0ZQAADChjb2xsZWN0aW9uCBRvd25lcgAwZnJlZV9ob2xkaW5nFBxkZXN0cm95AAAIKGNvbGxlY3Rpb24IHHdpdG5lc3PJBRBtaW50AAAMKGNvbGxlY3Rpb24IEGl0ZW0IFG93bmVyABBidXJuAAAMKGNvbGxlY3Rpb24IEGl0ZW0ILGNoZWNrX293bmVyrQEgdHJhbnNmZXIAAAwoY29sbGVjdGlvbggQaXRlbQgQZGVzdAAkcmVkZXBvc2l0AAAIKGNvbGxlY3Rpb24IFGl0ZW1zpQEYZnJlZXplAAAIKGNvbGxlY3Rpb24IEGl0ZW0IEHRoYXcAAAgoY29sbGVjdGlvbggQaXRlbQhEZnJlZXplX2NvbGxlY3Rpb24AAAQoY29sbGVjdGlvbgg8dGhhd19jb2xsZWN0aW9uAAAEKGNvbGxlY3Rpb24ISHRyYW5zZmVyX293bmVyc2hpcAAACChjb2xsZWN0aW9uCCRuZXdfb3duZXIAIHNldF90ZWFtAAAQKGNvbGxlY3Rpb24IGGlzc3VlcgAUYWRtaW4AHGZyZWV6ZXIAQGFwcHJvdmVfdHJhbnNmZXIAAAwoY29sbGVjdGlvbggQaXRlbQggZGVsZWdhdGUAPGNhbmNlbF9hcHByb3ZhbAAADChjb2xsZWN0aW9uCBBpdGVtCFBtYXliZV9jaGVja19kZWxlZ2F0Za0BRGZvcmNlX2l0ZW1fc3RhdHVzAAAcKGNvbGxlY3Rpb24IFG93bmVyABhpc3N1ZXIAFGFkbWluABxmcmVlemVyADBmcmVlX2hvbGRpbmcUJGlzX2Zyb3plbhQ0c2V0X2F0dHJpYnV0ZQAAEChjb2xsZWN0aW9uCChtYXliZV9pdGVtqQEMa2V5JBR2YWx1ZSQ8Y2xlYXJfYXR0cmlidXRlAAAMKGNvbGxlY3Rpb24IKG1heWJlX2l0ZW2pAQxrZXkkMHNldF9tZXRhZGF0YQAAEChjb2xsZWN0aW9uCBBpdGVtCBBkYXRhJCRpc19mcm96ZW4UOGNsZWFyX21ldGFkYXRhAAAIKGNvbGxlY3Rpb24IEGl0ZW0IXHNldF9jb2xsZWN0aW9uX21ldGFkYXRhAAAMKGNvbGxlY3Rpb24IEGRhdGEkJGlzX2Zyb3plbhRkY2xlYXJfY29sbGVjdGlvbl9tZXRhZGF0YQAABChjb2xsZWN0aW9uCFBzZXRfYWNjZXB0X293bmVyc2hpcAAABEBtYXliZV9jb2xsZWN0aW9uqQFkc2V0X2NvbGxlY3Rpb25fbWF4X3N1cHBseQAACChjb2xsZWN0aW9uCChtYXhfc3VwcGx5BCRzZXRfcHJpY2UAABAoY29sbGVjdGlvbggQaXRlbQgUcHJpY2WpAUR3aGl0ZWxpc3RlZF9idXllcq0BIGJ1eV9pdGVtAAAMKGNvbGxlY3Rpb24IEGl0ZW0IJGJpZF9wcmljZQgACBBzaXplBBBpdGVtBAbRBQIMHFRvU3RhcnQAAQUcTGFzdEtleQEkIENvbXBsZXRlAAEFABQwcHJvZ3Jlc3NfdG9w2QU4cHJvZ3Jlc3NfY2hpbGTZBRBzaXplBCR0b3BfaXRlbXMELGNoaWxkX2l0ZW1zBAIYWGNvbnRyb2xfYXV0b19taWdyYXRpb24AAAQwbWF5YmVfY29uZmln1QVAY29udGludWVfbWlncmF0ZQAADBhsaW1pdHPRBTxyZWFsX3NpemVfdXBwZXIEMHdpdG5lc3NfdGFza90FSG1pZ3JhdGVfY3VzdG9tX3RvcAAACBBrZXlz/QMwd2l0bmVzc19zaXplBFBtaWdyYXRlX2N1c3RvbV9jaGlsZAAADBByb290JChjaGlsZF9rZXlz/QModG90YWxfc2l6ZQRUc2V0X3NpZ25lZF9tYXhfbGltaXRzAAAEGGxpbWl0c9EFSGZvcmNlX3NldF9wcm9ncmVzcwAACDBwcm9ncmVzc190b3DZBThwcm9ncmVzc19jaGlsZNkFAhwQdm90ZQAACChwb2xsX2luZGV4BBB2b3RlvQEgZGVsZWdhdGUAABAUY2xhc3MECHRvAChjb252aWN0aW9urQUcYmFsYW5jZQgodW5kZWxlZ2F0ZQAABBRjbGFzcwQYdW5sb2NrAAAIFGNsYXNzBBh0YXJnZXQALHJlbW92ZV92b3RlAAAIFGNsYXNz8QEUaW5kZXgERHJlbW92ZV9vdGhlcl92b3RlAAAMGHRhcmdldAAUY2xhc3MEFGluZGV4BERmb3JjZV9yZW1vdmVfdm90ZQAADBh0YXJnZXQAFGNsYXNzBBRpbmRleAQCJBhzdWJtaXQAAAw8cHJvcG9zYWxfb3JpZ2lusQQgcHJvcG9zYWzFAUBlbmFjdG1lbnRfbW9tZW50tQRYcGxhY2VfZGVjaXNpb25fZGVwb3NpdAAABBRpbmRleARccmVmdW5kX2RlY2lzaW9uX2RlcG9zaXQAAAQUaW5kZXgEGGNhbmNlbAAABBRpbmRleAQQa2lsbAAABBRpbmRleARAbnVkZ2VfcmVmZXJlbmR1bQAABBRpbmRleARIb25lX2Zld2VyX2RlY2lkaW5nAAAEFHRyYWNrBGRyZWZ1bmRfc3VibWlzc2lvbl9kZXBvc2l0AAAEFGluZGV4BDBzZXRfbWV0YWRhdGEAAAgUaW5kZXgEKG1heWJlX2hhc2ghAwIQOHdoaXRlbGlzdF9jYWxsAAAEJGNhbGxfaGFzaCBccmVtb3ZlX3doaXRlbGlzdGVkX2NhbGwAAAQkY2FsbF9oYXNoIGRkaXNwYXRjaF93aGl0ZWxpc3RlZF9jYWxsAAAMJGNhbGxfaGFzaCBAY2FsbF9lbmNvZGVkX2xlbgRMY2FsbF93ZWlnaHRfd2l0bmVzcxicZGlzcGF0Y2hfd2hpdGVsaXN0ZWRfY2FsbF93aXRoX3ByZWltYWdlAAAEEGNhbGzlBwIUUGRpc3BhdGNoX2FzX3RyZWFzdXJ5AAAEEGNhbGzlB2BkaXNwYXRjaF9hc19hYXZlX21hbmFnZXIAAAQQY2FsbOUHRG5vdGVfYWF2ZV9tYW5hZ2VyAAAEHGFjY291bnQAXGRpc3BhdGNoX3dpdGhfZXh0cmFfZ2FzAAAIEGNhbGzlByRleHRyYV9nYXMIRGRpc3BhdGNoX2V2bV9jYWxsAAAEEGNhbGzlBwbtAQYUAhQgcmVnaXN0ZXIAACQgYXNzZXRfaWTxARBuYW1l6QEoYXNzZXRfdHlwZe0BTGV4aXN0ZW50aWFsX2RlcG9zaXSpARhzeW1ib2zpASBkZWNpbWFsc/EBIGxvY2F0aW9uYQM4eGNtX3JhdGVfbGltaXSpATRpc19zdWZmaWNpZW50FBh1cGRhdGUAACQgYXNzZXRfaWQEEG5hbWXpAShhc3NldF90eXBl9QVMZXhpc3RlbnRpYWxfZGVwb3NpdKkBOHhjbV9yYXRlX2xpbWl0qQE0aXNfc3VmZmljaWVudPkFGHN5bWJvbOkBIGRlY2ltYWxz8QEgbG9jYXRpb25hA0RyZWdpc3Rlcl9leHRlcm5hbAAABCBsb2NhdGlvbhECJGJhbl9hc3NldAAABCBhc3NldF9pZAQsdW5iYW5fYXNzZXQAAAQgYXNzZXRfaWQEAgQUY2xhaW0AAARIZXRoZXJldW1fc2lnbmF0dXJlnQUCNCRhZGRfdG9rZW4AABAUYXNzZXQENGluaXRpYWxfcHJpY2UIKHdlaWdodF9jYXAEOHBvc2l0aW9uX293bmVyADRhZGRfbGlxdWlkaXR5AAAIFGFzc2V0BBhhbW91bnQIYGFkZF9saXF1aWRpdHlfd2l0aF9saW1pdAAADBRhc3NldAQYYW1vdW50CEBtaW5fc2hhcmVzX2xpbWl0CEByZW1vdmVfbGlxdWlkaXR5AAAILHBvc2l0aW9uX2lkCBhhbW91bnQIbHJlbW92ZV9saXF1aWRpdHlfd2l0aF9saW1pdAAADCxwb3NpdGlvbl9pZAgYYW1vdW50CCRtaW5fbGltaXQISHNhY3JpZmljZV9wb3NpdGlvbgAABCxwb3NpdGlvbl9pZAgQc2VsbAAAECBhc3NldF9pbgQkYXNzZXRfb3V0BBhhbW91bnQIOG1pbl9idXlfYW1vdW50CAxidXkAABAkYXNzZXRfb3V0BCBhc3NldF9pbgQYYW1vdW50CDxtYXhfc2VsbF9hbW91bnQIYHNldF9hc3NldF90cmFkYWJsZV9zdGF0ZQAACCBhc3NldF9pZAQUc3RhdGUEUHJlZnVuZF9yZWZ1c2VkX2Fzc2V0AAAMIGFzc2V0X2lkBBhhbW91bnQIJHJlY2lwaWVudABQc2V0X2Fzc2V0X3dlaWdodF9jYXAAAAggYXNzZXRfaWQEDGNhcARsd2l0aGRyYXdfcHJvdG9jb2xfbGlxdWlkaXR5AAAQIGFzc2V0X2lkBBhhbW91bnQIFHByaWNlZQIQZGVzdAAwcmVtb3ZlX3Rva2VuAAAIIGFzc2V0X2lkBCxiZW5lZmljaWFyeQACCERwYXVzZV90cmFuc2FjdGlvbgAACCxwYWxsZXRfbmFtZSQ0ZnVuY3Rpb25fbmFtZSRMdW5wYXVzZV90cmFuc2FjdGlvbgAACCxwYWxsZXRfbmFtZSQ0ZnVuY3Rpb25fbmFtZSQCDDBkdXN0X2FjY291bnQAAAgcYWNjb3VudAAsY3VycmVuY3lfaWQERHdoaXRlbGlzdF9hY2NvdW50AAAEHGFjY291bnQAVHJlbW92ZV9mcm9tX3doaXRlbGlzdAAABBxhY2NvdW50AAZpBAJASGNyZWF0ZV9nbG9iYWxfZmFybQAAIDR0b3RhbF9yZXdhcmRzCGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMERGJsb2Nrc19wZXJfcGVyaW9kBDxyZXdhcmRfY3VycmVuY3kEFG93bmVyAEB5aWVsZF9wZXJfcGVyaW9kCCxtaW5fZGVwb3NpdAhUbHJuYV9wcmljZV9hZGp1c3RtZW50CFR0ZXJtaW5hdGVfZ2xvYmFsX2Zhcm0AAAQ4Z2xvYmFsX2Zhcm1faWQERGNyZWF0ZV95aWVsZF9mYXJtAAAQOGdsb2JhbF9mYXJtX2lkBCBhc3NldF9pZAQobXVsdGlwbGllcgg0bG95YWx0eV9jdXJ2ZTUCRHVwZGF0ZV95aWVsZF9mYXJtAAAMOGdsb2JhbF9mYXJtX2lkBCBhc3NldF9pZAQobXVsdGlwbGllcgg8c3RvcF95aWVsZF9mYXJtAAAIOGdsb2JhbF9mYXJtX2lkBCBhc3NldF9pZAREcmVzdW1lX3lpZWxkX2Zhcm0AABA4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEIGFzc2V0X2lkBChtdWx0aXBsaWVyCFB0ZXJtaW5hdGVfeWllbGRfZmFybQAADDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQgYXNzZXRfaWQEOGRlcG9zaXRfc2hhcmVzAAAMOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBCxwb3NpdGlvbl9pZAhAcmVkZXBvc2l0X3NoYXJlcwAADDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQoZGVwb3NpdF9pZAg0Y2xhaW1fcmV3YXJkcwAACChkZXBvc2l0X2lkCDR5aWVsZF9mYXJtX2lkBDx3aXRoZHJhd19zaGFyZXMAAAgoZGVwb3NpdF9pZAg0eWllbGRfZmFybV9pZARIdXBkYXRlX2dsb2JhbF9mYXJtAAAQOGdsb2JhbF9mYXJtX2lkBGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMEQHlpZWxkX3Blcl9wZXJpb2QILG1pbl9kZXBvc2l0CChqb2luX2Zhcm1zAAAIMGZhcm1fZW50cmllc2kELHBvc2l0aW9uX2lkCHBhZGRfbGlxdWlkaXR5X2FuZF9qb2luX2Zhcm1zAAAQMGZhcm1fZW50cmllc2kEFGFzc2V0BBhhbW91bnQIQG1pbl9zaGFyZXNfbGltaXSpAShleGl0X2Zhcm1zAAAIKGRlcG9zaXRfaWQIOHlpZWxkX2Zhcm1faWRzTQLAYWRkX2xpcXVpZGl0eV9zdGFibGVzd2FwX29tbmlwb29sX2FuZF9qb2luX2Zhcm1zAAAMOHN0YWJsZV9wb29sX2lkBFBzdGFibGVfYXNzZXRfYW1vdW50c40CMGZhcm1fZW50cmllcxEGAhAscGxhY2Vfb3JkZXIAABQgYXNzZXRfaW4EJGFzc2V0X291dAQkYW1vdW50X2luCChhbW91bnRfb3V0CEhwYXJ0aWFsbHlfZmlsbGFibGUUSHBhcnRpYWxfZmlsbF9vcmRlcgAACCBvcmRlcl9pZAQkYW1vdW50X2luCChmaWxsX29yZGVyAAAEIG9yZGVyX2lkBDBjYW5jZWxfb3JkZXIAAAQgb3JkZXJfaWQEAhhYc2V0X3RyYWRlX3ZvbHVtZV9saW1pdAAACCBhc3NldF9pZARIdHJhZGVfdm9sdW1lX2xpbWl0QQJcc2V0X2FkZF9saXF1aWRpdHlfbGltaXQAAAggYXNzZXRfaWQEPGxpcXVpZGl0eV9saW1pdEUCaHNldF9yZW1vdmVfbGlxdWlkaXR5X2xpbWl0AAAIIGFzc2V0X2lkBDxsaXF1aWRpdHlfbGltaXRFAjhsb2NrZG93bl9hc3NldAAACCBhc3NldF9pZAQUdW50aWwETGZvcmNlX2xpZnRfbG9ja2Rvd24AAAQgYXNzZXRfaWQEPHJlbGVhc2VfZGVwb3NpdAAACAx3aG8AIGFzc2V0X2lkBAIUEHNlbGwAABQgYXNzZXRfaW4EJGFzc2V0X291dAQkYW1vdW50X2luCDhtaW5fYW1vdW50X291dAgUcm91dGUVAwxidXkAABQgYXNzZXRfaW4EJGFzc2V0X291dAQoYW1vdW50X291dAg0bWF4X2Ftb3VudF9pbggUcm91dGUVAyRzZXRfcm91dGUAAAgoYXNzZXRfcGFpcgEDJG5ld19yb3V0ZRUDSGZvcmNlX2luc2VydF9yb3V0ZQAACChhc3NldF9wYWlyAQMkbmV3X3JvdXRlFQMgc2VsbF9hbGwAABAgYXNzZXRfaW4EJGFzc2V0X291dAQ4bWluX2Ftb3VudF9vdXQIFHJvdXRlFQMCCDRzZXRfYXNzZXRfZmVlAAAIIGFzc2V0X2lkBBhjb25maWdZAkByZW1vdmVfYXNzZXRfZmVlAAAEIGFzc2V0X2lkBAIUSGluaXRpYWxpemVfc3Rha2luZwABBRRzdGFrZQAABBhhbW91bnQIOGluY3JlYXNlX3N0YWtlAAAILHBvc2l0aW9uX2lkCBhhbW91bnQIFGNsYWltAAAELHBvc2l0aW9uX2lkCBx1bnN0YWtlAAAELHBvc2l0aW9uX2lkCAI8LGNyZWF0ZV9wb29sAAAQLHNoYXJlX2Fzc2V0BBhhc3NldHNNAjRhbXBsaWZpY2F0aW9uBAxmZWUEPHVwZGF0ZV9wb29sX2ZlZQAACBxwb29sX2lkBAxmZWUEUHVwZGF0ZV9hbXBsaWZpY2F0aW9uAAAQHHBvb2xfaWQETGZpbmFsX2FtcGxpZmljYXRpb24ELHN0YXJ0X2Jsb2NrBCRlbmRfYmxvY2sENGFkZF9saXF1aWRpdHkAAAgccG9vbF9pZAQYYXNzZXRzjQJQYWRkX2xpcXVpZGl0eV9zaGFyZXMAABAccG9vbF9pZAQYc2hhcmVzCCBhc3NldF9pZARAbWF4X2Fzc2V0X2Ftb3VudAhocmVtb3ZlX2xpcXVpZGl0eV9vbmVfYXNzZXQAABAccG9vbF9pZAQgYXNzZXRfaWQEMHNoYXJlX2Ftb3VudAg4bWluX2Ftb3VudF9vdXQIVHdpdGhkcmF3X2Fzc2V0X2Ftb3VudAAAEBxwb29sX2lkBCBhc3NldF9pZAQYYW1vdW50CEBtYXhfc2hhcmVfYW1vdW50CBBzZWxsAAAUHHBvb2xfaWQEIGFzc2V0X2luBCRhc3NldF9vdXQEJGFtb3VudF9pbgg4bWluX2J1eV9hbW91bnQIDGJ1eQAAFBxwb29sX2lkBCRhc3NldF9vdXQEIGFzc2V0X2luBChhbW91bnRfb3V0CDxtYXhfc2VsbF9hbW91bnQIYHNldF9hc3NldF90cmFkYWJsZV9zdGF0ZQAADBxwb29sX2lkBCBhc3NldF9pZAQUc3RhdGUEQHJlbW92ZV9saXF1aWRpdHkAAAwccG9vbF9pZAQwc2hhcmVfYW1vdW50CDxtaW5fYW1vdW50c19vdXSNAlRjcmVhdGVfcG9vbF93aXRoX3BlZ3MAABgsc2hhcmVfYXNzZXQEGGFzc2V0c00CNGFtcGxpZmljYXRpb24EDGZlZQQocGVnX3NvdXJjZXkCOG1heF9wZWdfdXBkYXRlBFBhZGRfYXNzZXRzX2xpcXVpZGl0eQAADBxwb29sX2lkBBhhc3NldHONAihtaW5fc2hhcmVzCFx1cGRhdGVfYXNzZXRfcGVnX3NvdXJjZQAADBxwb29sX2lkBCBhc3NldF9pZAQocGVnX3NvdXJjZXUCaHVwZGF0ZV9wb29sX21heF9wZWdfdXBkYXRlAAAIHHBvb2xfaWQEOG1heF9wZWdfdXBkYXRlBAIIFGlzc3VlAAAMIGFzc2V0X2lkBBhhbW91bnQIIG1hdHVyaXR5CBhyZWRlZW0AAAgcYm9uZF9pZAQYYW1vdW50CAIEQHNldHRsZV9vdGNfb3JkZXIAAAwYb3RjX2lkBBhhbW91bnQIFHJvdXRlFQMCGCxjcmVhdGVfcG9vbAAALChwb29sX293bmVyABxhc3NldF9hBDhhc3NldF9hX2Ftb3VudAgcYXNzZXRfYgQ4YXNzZXRfYl9hbW91bnQIOGluaXRpYWxfd2VpZ2h0BDBmaW5hbF93ZWlnaHQEMHdlaWdodF9jdXJ2ZZ0CDGZlZUECNGZlZV9jb2xsZWN0b3IAMHJlcGF5X3RhcmdldAhAdXBkYXRlX3Bvb2xfZGF0YQAAJBxwb29sX2lkAChwb29sX293bmVyrQEUc3RhcnTxAQxlbmTxAThpbml0aWFsX3dlaWdodPEBMGZpbmFsX3dlaWdodPEBDGZlZUUCNGZlZV9jb2xsZWN0b3KtATByZXBheV90YXJnZXSpATRhZGRfbGlxdWlkaXR5AAAIIGFtb3VudF9h2QQgYW1vdW50X2LZBEByZW1vdmVfbGlxdWlkaXR5AAAEHHBvb2xfaWQAEHNlbGwAABAgYXNzZXRfaW4EJGFzc2V0X291dAQYYW1vdW50CCRtYXhfbGltaXQIDGJ1eQAAECRhc3NldF9vdXQEIGFzc2V0X2luBBhhbW91bnQIJG1heF9saW1pdAgCHCxjcmVhdGVfcG9vbAAAEBxhc3NldF9hBCBhbW91bnRfYQgcYXNzZXRfYgQgYW1vdW50X2IINGFkZF9saXF1aWRpdHkAABAcYXNzZXRfYQQcYXNzZXRfYgQgYW1vdW50X2EISGFtb3VudF9iX21heF9saW1pdAhkYWRkX2xpcXVpZGl0eV93aXRoX2xpbWl0cwAAFBxhc3NldF9hBBxhc3NldF9iBCBhbW91bnRfYQhIYW1vdW50X2JfbWF4X2xpbWl0CChtaW5fc2hhcmVzCEByZW1vdmVfbGlxdWlkaXR5AAAMHGFzc2V0X2EEHGFzc2V0X2IEMHNoYXJlX2Ftb3VudAhwcmVtb3ZlX2xpcXVpZGl0eV93aXRoX2xpbWl0cwAAFBxhc3NldF9hBBxhc3NldF9iBDBzaGFyZV9hbW91bnQIMG1pbl9hbW91bnRfYQgwbWluX2Ftb3VudF9iCBBzZWxsAAAUIGFzc2V0X2luBCRhc3NldF9vdXQEGGFtb3VudAgkbWF4X2xpbWl0CCBkaXNjb3VudBQMYnV5AAAUJGFzc2V0X291dAQgYXNzZXRfaW4EGGFtb3VudAgkbWF4X2xpbWl0CCBkaXNjb3VudBQCFDRyZWdpc3Rlcl9jb2RlAAAEEGNvZGUkJGxpbmtfY29kZQAABBBjb2RlJBxjb252ZXJ0AAAEIGFzc2V0X2lkBDRjbGFpbV9yZXdhcmRzAAEFVHNldF9yZXdhcmRfcGVyY2VudGFnZQAADCBhc3NldF9pZAQUbGV2ZWytAhxyZXdhcmRzsQICCCRsaXF1aWRhdGUAABRAY29sbGF0ZXJhbF9hc3NldAQoZGVidF9hc3NldAQQdXNlcv0BNGRlYnRfdG9fY292ZXIIFHJvdXRlFQNYc2V0X2JvcnJvd2luZ19jb250cmFjdAAABCBjb250cmFjdP0BAggkSG9sbGFyT3V0AQggSG9sbGFySW4BCAZJBgIcUGFkZF9jb2xsYXRlcmFsX2Fzc2V0AAAcIGFzc2V0X2lkBBxwb29sX2lkBDBwdXJjaGFzZV9mZWUEZG1heF9idXlfcHJpY2VfY29lZmZpY2llbnQIMGJ1eV9iYWNrX2ZlZQQwYnV5YmFja19yYXRlBDhtYXhfaW5faG9sZGluZ6kBXHJlbW92ZV9jb2xsYXRlcmFsX2Fzc2V0AAAEIGFzc2V0X2lkBFx1cGRhdGVfY29sbGF0ZXJhbF9hc3NldAAAGCBhc3NldF9pZAQwcHVyY2hhc2VfZmVl8QFkbWF4X2J1eV9wcmljZV9jb2VmZmljaWVudKkBMGJ1eV9iYWNrX2ZlZfEBMGJ1eWJhY2tfcmF0ZfEBOG1heF9pbl9ob2xkaW5nvQIQc2VsbAAAECBhc3NldF9pbgQkYXNzZXRfb3V0BCRhbW91bnRfaW4IOHNsaXBwYWdlX2xpbWl0CAxidXkAABAgYXNzZXRfaW4EJGFzc2V0X291dAQoYW1vdW50X291dAg4c2xpcHBhZ2VfbGltaXQIRGV4ZWN1dGVfYXJiaXRyYWdlAAAITGNvbGxhdGVyYWxfYXNzZXRfaWQEJGFyYml0cmFnZU0GQHNldF9mbGFzaF9taW50ZXIAAAREZmxhc2hfbWludGVyX2FkZHL9AQIUIHRyYW5zZmVyAAAMEGRlc3QALGN1cnJlbmN5X2lkBBhhbW91bnQIMHRyYW5zZmVyX2FsbAAADBBkZXN0ACxjdXJyZW5jeV9pZAQoa2VlcF9hbGl2ZRRMdHJhbnNmZXJfa2VlcF9hbGl2ZQAADBBkZXN0ACxjdXJyZW5jeV9pZAQYYW1vdW50CDhmb3JjZV90cmFuc2ZlcgAAEBhzb3VyY2UAEGRlc3QALGN1cnJlbmN5X2lkBBhhbW91bnQILHNldF9iYWxhbmNlAAAQDHdobwAsY3VycmVuY3lfaWQEIG5ld19mcmVlCDBuZXdfcmVzZXJ2ZWQIAgwgdHJhbnNmZXIAAAwQZGVzdAAsY3VycmVuY3lfaWQEGGFtb3VudAhgdHJhbnNmZXJfbmF0aXZlX2N1cnJlbmN5AAAIEGRlc3QAGGFtb3VudAg4dXBkYXRlX2JhbGFuY2UAAAwMd2hvACxjdXJyZW5jeV9pZAQYYW1vdW50CATNAgACEBRjbGFpbQABBTx2ZXN0ZWRfdHJhbnNmZXIAAAgQZGVzdAAgc2NoZWR1bGXNAmB1cGRhdGVfdmVzdGluZ19zY2hlZHVsZXMAAAgMd2hvAER2ZXN0aW5nX3NjaGVkdWxlc10GJGNsYWltX2ZvcgAABBBkZXN0AAb5BAMI/QHVAgRpBgACECB3aXRoZHJhdwAACBxhZGRyZXNz/QEUdmFsdWUIEGNhbGwAACQYc291cmNl/QEYdGFyZ2V0/QEUaW5wdXQkFHZhbHVl+QQkZ2FzX2xpbWl0CDxtYXhfZmVlX3Blcl9nYXP5BGBtYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXNlBhRub25jZWUGLGFjY2Vzc19saXN0bQYYY3JlYXRlAAAgGHNvdXJjZf0BEGluaXQkFHZhbHVl+QQkZ2FzX2xpbWl0CDxtYXhfZmVlX3Blcl9nYXP5BGBtYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXNlBhRub25jZWUGLGFjY2Vzc19saXN0bQYcY3JlYXRlMgAAJBhzb3VyY2X9ARBpbml0JBBzYWx0IBR2YWx1ZfkEJGdhc19saW1pdAg8bWF4X2ZlZV9wZXJfZ2Fz+QRgbWF4X3ByaW9yaXR5X2ZlZV9wZXJfZ2FzZQYUbm9uY2VlBixhY2Nlc3NfbGlzdG0GAggQQ2FsbAH9ARhDcmVhdGUAAQUADAR2CARyIARzIAAcFG5vbmNl+QQkZ2FzX3ByaWNl+QQkZ2FzX2xpbWl0+QQYYWN0aW9udQYUdmFsdWX5BBRpbnB1dCQkc2lnbmF0dXJleQYACBxhZGRyZXNz/QEwc3RvcmFnZV9rZXlz1QIEgQYAACwgY2hhaW5faWQIFG5vbmNl+QQkZ2FzX3ByaWNl+QQkZ2FzX2xpbWl0+QQYYWN0aW9udQYUdmFsdWX5BBRpbnB1dCQsYWNjZXNzX2xpc3SFBjBvZGRfeV9wYXJpdHkUBHIgBHMgADAgY2hhaW5faWQIFG5vbmNl+QRgbWF4X3ByaW9yaXR5X2ZlZV9wZXJfZ2Fz+QQ8bWF4X2ZlZV9wZXJfZ2Fz+QQkZ2FzX2xpbWl0+QQYYWN0aW9udQYUdmFsdWX5BBRpbnB1dCQsYWNjZXNzX2xpc3SFBjBvZGRfeV9wYXJpdHkUBHIgBHMgAgwYTGVnYWN5AX0GHEVJUDI5MzABiQYcRUlQMTU1OQGNBgIEIHRyYW5zYWN0AAAELHRyYW5zYWN0aW9ukQYCGEBiaW5kX2V2bV9hZGRyZXNzAAEFVGFkZF9jb250cmFjdF9kZXBsb3llcgAABBxhZGRyZXNz/QFgcmVtb3ZlX2NvbnRyYWN0X2RlcGxveWVyAAAEHGFkZHJlc3P9AWhyZW5vdW5jZV9jb250cmFjdF9kZXBsb3llcgABBUBhcHByb3ZlX2NvbnRyYWN0AAAEHGFkZHJlc3P9AUxkaXNhcHByb3ZlX2NvbnRyYWN0AAAEHGFkZHJlc3P9AQI8SGNyZWF0ZV9nbG9iYWxfZmFybQAAJDR0b3RhbF9yZXdhcmRzCGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMERGJsb2Nrc19wZXJfcGVyaW9kBEhpbmNlbnRpdml6ZWRfYXNzZXQEPHJld2FyZF9jdXJyZW5jeQQUb3duZXIAQHlpZWxkX3Blcl9wZXJpb2QILG1pbl9kZXBvc2l0CEBwcmljZV9hZGp1c3RtZW50CEh1cGRhdGVfZ2xvYmFsX2Zhcm0AAAg4Z2xvYmFsX2Zhcm1faWQEQHByaWNlX2FkanVzdG1lbnQIVHRlcm1pbmF0ZV9nbG9iYWxfZmFybQAABDhnbG9iYWxfZmFybV9pZAREY3JlYXRlX3lpZWxkX2Zhcm0AABA4Z2xvYmFsX2Zhcm1faWQEKGFzc2V0X3BhaXIBAyhtdWx0aXBsaWVyCDRsb3lhbHR5X2N1cnZlNQJEdXBkYXRlX3lpZWxkX2Zhcm0AAAw4Z2xvYmFsX2Zhcm1faWQEKGFzc2V0X3BhaXIBAyhtdWx0aXBsaWVyCDxzdG9wX3lpZWxkX2Zhcm0AAAg4Z2xvYmFsX2Zhcm1faWQEKGFzc2V0X3BhaXIBA0RyZXN1bWVfeWllbGRfZmFybQAAEDhnbG9iYWxfZmFybV9pZAQ0eWllbGRfZmFybV9pZAQoYXNzZXRfcGFpcgEDKG11bHRpcGxpZXIIUHRlcm1pbmF0ZV95aWVsZF9mYXJtAAAMOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBChhc3NldF9wYWlyAQM4ZGVwb3NpdF9zaGFyZXMAABA4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEKGFzc2V0X3BhaXIBAzRzaGFyZXNfYW1vdW50CChqb2luX2Zhcm1zAAAMMGZhcm1fZW50cmllc2kEKGFzc2V0X3BhaXIBAzRzaGFyZXNfYW1vdW50CHBhZGRfbGlxdWlkaXR5X2FuZF9qb2luX2Zhcm1zAAAUHGFzc2V0X2EEHGFzc2V0X2IEIGFtb3VudF9hCEhhbW91bnRfYl9tYXhfbGltaXQIMGZhcm1fZW50cmllc2kEQHJlZGVwb3NpdF9zaGFyZXMAABA4Z2xvYmFsX2Zhcm1faWQENHlpZWxkX2Zhcm1faWQEKGFzc2V0X3BhaXIBAyhkZXBvc2l0X2lkCDRjbGFpbV9yZXdhcmRzAAAIKGRlcG9zaXRfaWQINHlpZWxkX2Zhcm1faWQEPHdpdGhkcmF3X3NoYXJlcwAADChkZXBvc2l0X2lkCDR5aWVsZF9mYXJtX2lkBChhc3NldF9wYWlyAQMoZXhpdF9mYXJtcwAADChkZXBvc2l0X2lkCChhc3NldF9wYWlyAQMwZmFybV9lbnRyaWVzTQIAHBRvd25lcgAYcGVyaW9kBDB0b3RhbF9hbW91bnQILG1heF9yZXRyaWVz8QFMc3RhYmlsaXR5X3RocmVzaG9sZPEBIHNsaXBwYWdl8QEUb3JkZXIZAwIMIHNjaGVkdWxlAAAIIHNjaGVkdWxloQZUc3RhcnRfZXhlY3V0aW9uX2Jsb2Nr8QEkdGVybWluYXRlAAAILHNjaGVkdWxlX2lkBFBuZXh0X2V4ZWN1dGlvbl9ibG9ja/EBPHVubG9ja19yZXNlcnZlcwAACAx3aG8AIGFzc2V0X2lkBAIoIHNjaGVkdWxlAAAQEHdoZW4EOG1heWJlX3BlcmlvZGljRQIgcHJpb3JpdHkEEGNhbGzlBxhjYW5jZWwAAAgQd2hlbgQUaW5kZXgEOHNjaGVkdWxlX25hbWVkAAAUCGlkIBB3aGVuBDhtYXliZV9wZXJpb2RpY0UCIHByaW9yaXR5BBBjYWxs5QcwY2FuY2VsX25hbWVkAAAECGlkIDhzY2hlZHVsZV9hZnRlcgAAEBRhZnRlcgQ4bWF5YmVfcGVyaW9kaWNFAiBwcmlvcml0eQQQY2FsbOUHUHNjaGVkdWxlX25hbWVkX2FmdGVyAAAUCGlkIBRhZnRlcgQ4bWF5YmVfcGVyaW9kaWNFAiBwcmlvcml0eQQQY2FsbOUHJHNldF9yZXRyeQAADBB0YXNrQQIccmV0cmllcwQYcGVyaW9kBDxzZXRfcmV0cnlfbmFtZWQAAAwIaWQgHHJldHJpZXMEGHBlcmlvZAQwY2FuY2VsX3JldHJ5AAAEEHRhc2tBAkhjYW5jZWxfcmV0cnlfbmFtZWQAAAQIaWQgABAscGFyZW50X2hlYWQkTHJlbGF5X3BhcmVudF9udW1iZXIEZHJlbGF5X3BhcmVudF9zdG9yYWdlX3Jvb3QgMG1heF9wb3Zfc2l6ZQQACBxzZW50X2F0BAxtc2ckBLEGAAAIHHNlbnRfYXQEEGRhdGEkBLkGAAMIBL0GBMEGAAAQPHZhbGlkYXRpb25fZGF0Ya0GRHJlbGF5X2NoYWluX3N0YXRl/QNEZG93bndhcmRfbWVzc2FnZXO1Bkxob3Jpem9udGFsX21lc3NhZ2VzxQYCCExzZXRfdmFsaWRhdGlvbl9kYXRhAAAEEGRhdGHJBmBzdWRvX3NlbmRfdXB3YXJkX21lc3NhZ2UAAAQcbWVzc2FnZSQCaCBPdmVyZmxvdwABBTRVbmltcGxlbWVudGVkAAEFYFVudHJ1c3RlZFJlc2VydmVMb2NhdGlvbgABBWRVbnRydXN0ZWRUZWxlcG9ydExvY2F0aW9uAAEFRE11bHRpTG9jYXRpb25GdWxsAAEFaE11bHRpTG9jYXRpb25Ob3RJbnZlcnRpYmxlAAEFJEJhZE9yaWdpbgABBTxJbnZhbGlkTG9jYXRpb24AAQU0QXNzZXROb3RGb3VuZAABBVRGYWlsZWRUb1RyYW5zYWN0QXNzZXQAAQU8Tm90V2l0aGRyYXdhYmxlAAEFSExvY2F0aW9uQ2Fubm90SG9sZAABBVRFeGNlZWRzTWF4TWVzc2FnZVNpemUAAQVYRGVzdGluYXRpb25VbnN1cHBvcnRlZAABBSRUcmFuc3BvcnQAAQUoVW5yb3V0YWJsZQABBTBVbmtub3duQ2xhaW0AAQU4RmFpbGVkVG9EZWNvZGUAAQVATWF4V2VpZ2h0SW52YWxpZAABBThOb3RIb2xkaW5nRmVlcwABBTBUb29FeHBlbnNpdmUAAQUQVHJhcAEITFVuaGFuZGxlZFhjbVZlcnNpb24AAQVIV2VpZ2h0TGltaXRSZWFjaGVkAQgcQmFycmllcgABBUxXZWlnaHROb3RDb21wdXRhYmxlAAEFAwgE0QYG1QYCEBBOdWxsAAEFGEFzc2V0cwGpAzxFeGVjdXRpb25SZXN1bHQB2QYcVmVyc2lvbgEEAggMQWxsAAEFFEFsbE9mAAAICGlkmQMMZnVubQMCCCBEZWZpbml0ZQGpAxBXaWxkAeEGAggkVW5saW1pdGVkAAEFHExpbWl0ZWQBCAJwNFdpdGhkcmF3QXNzZXQBqQNUUmVzZXJ2ZUFzc2V0RGVwb3NpdGVkAakDWFJlY2VpdmVUZWxlcG9ydGVkQXNzZXQBqQM0UXVlcnlSZXNwb25zZQAADCBxdWVyeV9pZAggcmVzcG9uc2XdBihtYXhfd2VpZ2h0CDRUcmFuc2ZlckFzc2V0AAAIGGFzc2V0c6kDLGJlbmVmaWNpYXJ5lQNQVHJhbnNmZXJSZXNlcnZlQXNzZXQAAAwYYXNzZXRzqQMQZGVzdJUDDHhjbfEGIFRyYW5zYWN0AAAMLG9yaWdpbl90eXBlZQNYcmVxdWlyZV93ZWlnaHRfYXRfbW9zdAgQY2FsbCRkSHJtcE5ld0NoYW5uZWxPcGVuUmVxdWVzdAAADBhzZW5kZXIEQG1heF9tZXNzYWdlX3NpemUEMG1heF9jYXBhY2l0eQRMSHJtcENoYW5uZWxBY2NlcHRlZAAABCRyZWNpcGllbnQESEhybXBDaGFubmVsQ2xvc2luZwAADCRpbml0aWF0b3IEGHNlbmRlcgQkcmVjaXBpZW50BCxDbGVhck9yaWdpbgABBTREZXNjZW5kT3JpZ2luAZEDLFJlcG9ydEVycm9yAAAMIHF1ZXJ5X2lkCBBkZXN0lQNMbWF4X3Jlc3BvbnNlX3dlaWdodAgwRGVwb3NpdEFzc2V0AAAMGGFzc2V0c+UGKG1heF9hc3NldHMELGJlbmVmaWNpYXJ5lQNMRGVwb3NpdFJlc2VydmVBc3NldAAAEBhhc3NldHPlBihtYXhfYXNzZXRzBBBkZXN0lQMMeGNt8QY0RXhjaGFuZ2VBc3NldAAACBBnaXZl5QYccmVjZWl2ZakDXEluaXRpYXRlUmVzZXJ2ZVdpdGhkcmF3AAAMGGFzc2V0c+UGHHJlc2VydmWVAwx4Y23xBkBJbml0aWF0ZVRlbGVwb3J0AAAMGGFzc2V0c+UGEGRlc3SVAwx4Y23xBjBRdWVyeUhvbGRpbmcAABAgcXVlcnlfaWQIEGRlc3SVAxhhc3NldHPlBkxtYXhfcmVzcG9uc2Vfd2VpZ2h0CDBCdXlFeGVjdXRpb24AAAgQZmVlc6UDMHdlaWdodF9saW1pdOkGNFJlZnVuZFN1cnBsdXMAAQU8U2V0RXJyb3JIYW5kbGVyAfEGLFNldEFwcGVuZGl4AfEGKENsZWFyRXJyb3IAAQUoQ2xhaW1Bc3NldAAACBhhc3NldHOpAxh0aWNrZXSVAxBUcmFwAQhAU3Vic2NyaWJlVmVyc2lvbgAACCBxdWVyeV9pZAhMbWF4X3Jlc3BvbnNlX3dlaWdodAhIVW5zdWJzY3JpYmVWZXJzaW9uAAEFBO0GAAIYEE51bGwAAQUYQXNzZXRzAbUDPEV4ZWN1dGlvblJlc3VsdAFNAxxWZXJzaW9uAQQsUGFsbGV0c0luZm8BVQM4RGlzcGF0Y2hSZXN1bHQBWQMCEAxBbGwAAQUUQWxsT2YAAAgIaWStAwxmdW5tAyhBbGxDb3VudGVkAQQwQWxsT2ZDb3VudGVkAAAMCGlkrQMMZnVubQMUY291bnQEAgggRGVmaW5pdGUBtQMQV2lsZAH5BgLANFdpdGhkcmF3QXNzZXQBtQNUUmVzZXJ2ZUFzc2V0RGVwb3NpdGVkAbUDWFJlY2VpdmVUZWxlcG9ydGVkQXNzZXQBtQM0UXVlcnlSZXNwb25zZQAAECBxdWVyeV9pZAggcmVzcG9uc2X1BihtYXhfd2VpZ2h0GBxxdWVyaWVyYQM0VHJhbnNmZXJBc3NldAAACBhhc3NldHO1AyxiZW5lZmljaWFyeRECUFRyYW5zZmVyUmVzZXJ2ZUFzc2V0AAAMGGFzc2V0c7UDEGRlc3QRAgx4Y20FByBUcmFuc2FjdAAADCxvcmlnaW5fa2luZGUDWHJlcXVpcmVfd2VpZ2h0X2F0X21vc3QYEGNhbGwkZEhybXBOZXdDaGFubmVsT3BlblJlcXVlc3QAAAwYc2VuZGVyBEBtYXhfbWVzc2FnZV9zaXplBDBtYXhfY2FwYWNpdHkETEhybXBDaGFubmVsQWNjZXB0ZWQAAAQkcmVjaXBpZW50BEhIcm1wQ2hhbm5lbENsb3NpbmcAAAwkaW5pdGlhdG9yBBhzZW5kZXIEJHJlY2lwaWVudAQsQ2xlYXJPcmlnaW4AAQU0RGVzY2VuZE9yaWdpbgENAixSZXBvcnRFcnJvcgFpAzBEZXBvc2l0QXNzZXQAAAgYYXNzZXRz/QYsYmVuZWZpY2lhcnkRAkxEZXBvc2l0UmVzZXJ2ZUFzc2V0AAAMGGFzc2V0c/0GEGRlc3QRAgx4Y20FBzRFeGNoYW5nZUFzc2V0AAAMEGdpdmX9BhB3YW50tQMcbWF4aW1hbBRcSW5pdGlhdGVSZXNlcnZlV2l0aGRyYXcAAAwYYXNzZXRz/QYccmVzZXJ2ZRECDHhjbQUHQEluaXRpYXRlVGVsZXBvcnQAAAwYYXNzZXRz/QYQZGVzdBECDHhjbQUHNFJlcG9ydEhvbGRpbmcAAAg0cmVzcG9uc2VfaW5mb2kDGGFzc2V0c/0GMEJ1eUV4ZWN1dGlvbgAACBBmZWVzsQMwd2VpZ2h0X2xpbWl0eQM0UmVmdW5kU3VycGx1cwABBTxTZXRFcnJvckhhbmRsZXIBBQcsU2V0QXBwZW5kaXgBBQcoQ2xlYXJFcnJvcgABBShDbGFpbUFzc2V0AAAIGGFzc2V0c7UDGHRpY2tldBECEFRyYXABCEBTdWJzY3JpYmVWZXJzaW9uAAAIIHF1ZXJ5X2lkCExtYXhfcmVzcG9uc2Vfd2VpZ2h0GEhVbnN1YnNjcmliZVZlcnNpb24AAQUkQnVybkFzc2V0AbUDLEV4cGVjdEFzc2V0AbUDMEV4cGVjdE9yaWdpbgFhAyxFeHBlY3RFcnJvcgFNA1BFeHBlY3RUcmFuc2FjdFN0YXR1cwFZAyxRdWVyeVBhbGxldAAACCxtb2R1bGVfbmFtZSQ0cmVzcG9uc2VfaW5mb2kDMEV4cGVjdFBhbGxldAAAFBRpbmRleAQQbmFtZSQsbW9kdWxlX25hbWUkLGNyYXRlX21ham9yBDxtaW5fY3JhdGVfbWlub3IEUFJlcG9ydFRyYW5zYWN0U3RhdHVzAWkDTENsZWFyVHJhbnNhY3RTdGF0dXMAAQU8VW5pdmVyc2FsT3JpZ2luAQkCNEV4cG9ydE1lc3NhZ2UAAAwcbmV0d29ya/UBLGRlc3RpbmF0aW9uDQIMeGNtBQckTG9ja0Fzc2V0AAAIFGFzc2V0sQMgdW5sb2NrZXIRAixVbmxvY2tBc3NldAAACBRhc3NldLEDGHRhcmdldBECOE5vdGVVbmxvY2thYmxlAAAIFGFzc2V0sQMUb3duZXIRAjRSZXF1ZXN0VW5sb2NrAAAIFGFzc2V0sQMYbG9ja2VyEQIsU2V0RmVlc01vZGUAAAQwaml0X3dpdGhkcmF3FCBTZXRUb3BpYwEgKENsZWFyVG9waWMAAQUsQWxpYXNPcmlnaW4BEQI8VW5wYWlkRXhlY3V0aW9uAAAIMHdlaWdodF9saW1pdHkDMGNoZWNrX29yaWdpbmEDBAEHAAIMCFYyAfEGCFYzAQUHCFY0AYEDAhAgVGVsZXBvcnQAAQUwTG9jYWxSZXNlcnZlAAEFSERlc3RpbmF0aW9uUmVzZXJ2ZQABBTRSZW1vdGVSZXNlcnZlAb0DAggIVjMBrQMIVjQBEQICOBBzZW5kAAAIEGRlc3S9AxxtZXNzYWdlCQc8dGVsZXBvcnRfYXNzZXRzAAAQEGRlc3S9AyxiZW5lZmljaWFyeb0DGGFzc2V0c7kDOGZlZV9hc3NldF9pdGVtBFxyZXNlcnZlX3RyYW5zZmVyX2Fzc2V0cwAAEBBkZXN0vQMsYmVuZWZpY2lhcnm9Axhhc3NldHO5AzhmZWVfYXNzZXRfaXRlbQQcZXhlY3V0ZQAACBxtZXNzYWdlCQcobWF4X3dlaWdodBhEZm9yY2VfeGNtX3ZlcnNpb24AAAggbG9jYXRpb24RAhx2ZXJzaW9uBGRmb3JjZV9kZWZhdWx0X3hjbV92ZXJzaW9uAAAERG1heWJlX3hjbV92ZXJzaW9u8QF4Zm9yY2Vfc3Vic2NyaWJlX3ZlcnNpb25fbm90aWZ5AAAEIGxvY2F0aW9uvQOAZm9yY2VfdW5zdWJzY3JpYmVfdmVyc2lvbl9ub3RpZnkAAAQgbG9jYXRpb269A3xsaW1pdGVkX3Jlc2VydmVfdHJhbnNmZXJfYXNzZXRzAAAUEGRlc3S9AyxiZW5lZmljaWFyeb0DGGFzc2V0c7kDOGZlZV9hc3NldF9pdGVtBDB3ZWlnaHRfbGltaXR5A1xsaW1pdGVkX3RlbGVwb3J0X2Fzc2V0cwAAFBBkZXN0vQMsYmVuZWZpY2lhcnm9Axhhc3NldHO5AzhmZWVfYXNzZXRfaXRlbQQwd2VpZ2h0X2xpbWl0eQNAZm9yY2Vfc3VzcGVuc2lvbgAABCRzdXNwZW5kZWQUPHRyYW5zZmVyX2Fzc2V0cwAAFBBkZXN0vQMsYmVuZWZpY2lhcnm9Axhhc3NldHO5AzhmZWVfYXNzZXRfaXRlbQQwd2VpZ2h0X2xpbWl0eQMwY2xhaW1fYXNzZXRzAAAIGGFzc2V0c7kDLGJlbmVmaWNpYXJ5vQOMdHJhbnNmZXJfYXNzZXRzX3VzaW5nX3R5cGVfYW5kX3RoZW4AABwQZGVzdL0DGGFzc2V0c7kDUGFzc2V0c190cmFuc2Zlcl90eXBlDQc4cmVtb3RlX2ZlZXNfaWQRB0hmZWVzX3RyYW5zZmVyX3R5cGUNB0hjdXN0b21feGNtX29uX2Rlc3QJBzB3ZWlnaHRfbGltaXR5AwIIJHJlYXBfcGFnZQAACDhtZXNzYWdlX29yaWdpbs0DKHBhZ2VfaW5kZXgESGV4ZWN1dGVfb3ZlcndlaWdodAAAEDhtZXNzYWdlX29yaWdpbs0DEHBhZ2UEFGluZGV4BDB3ZWlnaHRfbGltaXQYAgREc2VuZF9hc19zb3ZlcmVpZ24AAAgQZGVzdL0DHG1lc3NhZ2UJBwIMCFYyAaUDCFYzAbEDCFY0AUEDAhggdHJhbnNmZXIAABAsY3VycmVuY3lfaWQEGGFtb3VudAgQZGVzdL0DRGRlc3Rfd2VpZ2h0X2xpbWl0eQNMdHJhbnNmZXJfbXVsdGlhc3NldAAADBRhc3NldCEHEGRlc3S9A0RkZXN0X3dlaWdodF9saW1pdHkDRHRyYW5zZmVyX3dpdGhfZmVlAAAULGN1cnJlbmN5X2lkBBhhbW91bnQIDGZlZQgQZGVzdL0DRGRlc3Rfd2VpZ2h0X2xpbWl0eQNwdHJhbnNmZXJfbXVsdGlhc3NldF93aXRoX2ZlZQAAEBRhc3NldCEHDGZlZSEHEGRlc3S9A0RkZXN0X3dlaWdodF9saW1pdHkDYHRyYW5zZmVyX211bHRpY3VycmVuY2llcwAAEChjdXJyZW5jaWVz3QQgZmVlX2l0ZW0EEGRlc3S9A0RkZXN0X3dlaWdodF9saW1pdHkDUHRyYW5zZmVyX211bHRpYXNzZXRzAAAQGGFzc2V0c7kDIGZlZV9pdGVtBBBkZXN0vQNEZGVzdF93ZWlnaHRfbGltaXR5AwIkRHNldF9pbnZ1bG5lcmFibGVzAAAEDG5ld+UDWHNldF9kZXNpcmVkX2NhbmRpZGF0ZXMAAAQMbWF4BEhzZXRfY2FuZGlkYWN5X2JvbmQAAAQQYm9uZAhUcmVnaXN0ZXJfYXNfY2FuZGlkYXRlAAEFMGxlYXZlX2ludGVudAABBUBhZGRfaW52dWxuZXJhYmxlAAAEDHdobwBMcmVtb3ZlX2ludnVsbmVyYWJsZQAABAx3aG8ALHVwZGF0ZV9ib25kAAAELG5ld19kZXBvc2l0CEx0YWtlX2NhbmRpZGF0ZV9zbG90AAAIHGRlcG9zaXQIGHRhcmdldAACCCBzZXRfa2V5cwAACBBrZXlzIBRwcm9vZiQocHVyZ2Vfa2V5cwABBQAMPGNvbnNlbnN1c19wcm9vZiRIY29uc2Vuc3VzX3N0YXRlX2lkKBhzaWduZXIkAAwccHJvb2ZfMSQccHJvb2ZfMiRIY29uc2Vuc3VzX3N0YXRlX2lkKAAcGHNvdXJjZfEDEGRlc3TxAxRub25jZQgQZnJvbSQIdG8kRHRpbWVvdXRfdGltZXN0YW1wCBBib2R5JAQ5BwAACBhoZWlnaHT5AxRwcm9vZiQADCByZXF1ZXN0cz0HFHByb29mQQcYc2lnbmVyJAAgGHNvdXJjZfEDEGRlc3TxAxRub25jZQgQZnJvbSQQa2V5c/0DGGhlaWdodAgcY29udGV4dCREdGltZW91dF90aW1lc3RhbXAIAggQUG9zdAE5BwxHZXQBSQcETQcAAAwQcG9zdDkHIHJlc3BvbnNlJER0aW1lb3V0X3RpbWVzdGFtcAgACAxrZXkkFHZhbHVl6QEEWQcAAAgMZ2V0SQcYdmFsdWVzXQcCCBBQb3N0AVUHDEdldAFhBwRlBwACCBxSZXF1ZXN0AVEHIFJlc3BvbnNlAWkHAAwgZGF0YWdyYW1tBxRwcm9vZkEHGHNpZ25lciQEVQcAAgwQUG9zdAAACCByZXF1ZXN0c1EHNHRpbWVvdXRfcHJvb2ZBBzBQb3N0UmVzcG9uc2UAAAgkcmVzcG9uc2VzdQc0dGltZW91dF9wcm9vZkEHDEdldAAABCByZXF1ZXN0c1EHAhQkQ29uc2Vuc3VzATEHKEZyYXVkUHJvb2YBNQccUmVxdWVzdAFFByBSZXNwb25zZQFxBxxUaW1lb3V0AXkHBH0HAAAMJHRpbWVzdGFtcAgwb3ZlcmxheV9yb290IQMoc3RhdGVfcm9vdCAACChjb21taXRtZW50hQcYaGVpZ2h0CAMI9QOJBwSNBwAAGDxjb25zZW5zdXNfc3RhdGUkTGNvbnNlbnN1c19jbGllbnRfaWQoSGNvbnNlbnN1c19zdGF0ZV9pZChAdW5ib25kaW5nX3BlcmlvZAhEY2hhbGxlbmdlX3BlcmlvZHMdBGRzdGF0ZV9tYWNoaW5lX2NvbW1pdG1lbnRzkQcADEhjb25zZW5zdXNfc3RhdGVfaWQoQHVuYm9uZGluZ19wZXJpb2SpAURjaGFsbGVuZ2VfcGVyaW9kcx0EAggcUmVxdWVzdAEgIFJlc3BvbnNlASAACChjb21taXRtZW50nQcYYW1vdW50CAIQPGhhbmRsZV91bnNpZ25lZAAABCBtZXNzYWdlc4EHXGNyZWF0ZV9jb25zZW5zdXNfY2xpZW50AAAEHG1lc3NhZ2WVB1h1cGRhdGVfY29uc2Vuc3VzX3N0YXRlAAAEHG1lc3NhZ2WZBzBmdW5kX21lc3NhZ2UAAAQcbWVzc2FnZaEHAgxodXBkYXRlX3BhcmFjaGFpbl9jb25zZW5zdXMAAAQQZGF0YTEHNGFkZF9wYXJhY2hhaW4AAAQgcGFyYV9pZHMRBEByZW1vdmVfcGFyYWNoYWluAAAEIHBhcmFfaWRzTQIAJCBhc3NldF9pZAQsZGVzdGluYXRpb27xAyRyZWNlcGllbnQgGGFtb3VudAgcdGltZW91dAg0dG9rZW5fZ2F0ZXdheSQscmVsYXllcl9mZWUIJGNhbGxfZGF0YekBGHJlZGVlbRQDCPEDJASxBwAE8QMAABAQbmFtZSQYc3ltYm9sJBhjaGFpbnO5BzxtaW5pbXVtX2JhbGFuY2WpAQMI8QMEBMEHAAAQIGxvY2FsX2lkBAxyZWe9BxhuYXRpdmUUJHByZWNpc2lvbsUHAwjxA/0BBM0HAAAQIGFzc2V0X2lkIChhZGRfY2hhaW5zuQc0cmVtb3ZlX2NoYWluc7kHKG5ld19hZG1pbnPRBwAIIGFzc2V0X2lkBChwcmVjaXNpb25zxQcCFCB0ZWxlcG9ydAAABBhwYXJhbXOtB2xzZXRfdG9rZW5fZ2F0ZXdheV9hZGRyZXNzZXMAAAQkYWRkcmVzc2VztQdQY3JlYXRlX2VyYzYxNjBfYXNzZXQAAAQUYXNzZXTJB1B1cGRhdGVfZXJjNjE2MF9hc3NldAAABBRhc3NldNUHWHVwZGF0ZV9hc3NldF9wcmVjaXNpb24AAAQYdXBkYXRl2QcCDChhZGRfb3JhY2xlAAAIGHNvdXJjZWkCGGFzc2V0c0ECNHJlbW92ZV9vcmFjbGUAAAgYc291cmNlaQIYYXNzZXRzQQJUdXBkYXRlX2JpZnJvc3Rfb3JhY2xlAAAMHGFzc2V0X2G9Axxhc3NldF9ivQMUcHJpY2VlAgIBARhTeXN0ZW0B6QQkVGltZXN0YW1wAe0EIEJhbGFuY2VzAfUEXE11bHRpVHJhbnNhY3Rpb25QYXltZW50Af0EIFRyZWFzdXJ5AQEFHFV0aWxpdHkBCQUgUHJlaW1hZ2UBDQUgSWRlbnRpdHkBqQUkRGVtb2NyYWN5AbEFSFRlY2huaWNhbENvbW1pdHRlZQG1BRRQcm94eQG9BSBNdWx0aXNpZwHFBRxVbmlxdWVzAc0FSFN0YXRlVHJpZU1pZ3JhdGlvbgHhBUBDb252aWN0aW9uVm90aW5nAeUFJFJlZmVyZW5kYQHpBSRXaGl0ZWxpc3QB7QUoRGlzcGF0Y2hlcgHxBTRBc3NldFJlZ2lzdHJ5Af0FGENsYWltcwEBBjhHZW5lc2lzSGlzdG9yeQFtASBPbW5pcG9vbAEFBkBUcmFuc2FjdGlvblBhdXNlAQkGGER1c3RlcgENBkxPbW5pcG9vbFdhcmVob3VzZUxNAW0BXE9tbmlwb29sTGlxdWlkaXR5TWluaW5nARUGDE9UQwEZBjhDaXJjdWl0QnJlYWtlcgEdBhhSb3V0ZXIBIQYsRHluYW1pY0ZlZXMBJQYcU3Rha2luZwEpBihTdGFibGVzd2FwAS0GFEJvbmRzATEGOE90Y1NldHRsZW1lbnRzATUGDExCUAE5BgxYWUsBPQYkUmVmZXJyYWxzAUEGLExpcXVpZGF0aW9uAUUGDEhTTQFRBhhUb2tlbnMBVQYoQ3VycmVuY2llcwFZBhxWZXN0aW5nAWEGDEVWTQFxBiBFdGhlcmV1bQGVBixFVk1BY2NvdW50cwGZBkhYWUtMaXF1aWRpdHlNaW5pbmcBnQY4WFlLV2FyZWhvdXNlTE0BbQE4UmVsYXlDaGFpbkluZm8BbQEMRENBAaUGJFNjaGVkdWxlcgGpBjxQYXJhY2hhaW5TeXN0ZW0BzQY0UGFyYWNoYWluSW5mbwFtASxQb2xrYWRvdFhjbQEVByhDdW11bHVzWGNtAW0BME1lc3NhZ2VRdWV1ZQEZBxxPcm1sWGNtAR0HHFhUb2tlbnMBJQdEQ29sbGF0b3JTZWxlY3Rpb24BKQccU2Vzc2lvbgEtBxBJc21wAaUHNElzbXBQYXJhY2hhaW4BqQcwVG9rZW5HYXRld2F5Ad0HJEVtYU9yYWNsZQHhByRCcm9hZGNhc3QBbQEAHBBuYW1l6QEoYXNzZXRfdHlwZe0BTGV4aXN0ZW50aWFsX2RlcG9zaXQIGHN5bWJvbOkBIGRlY2ltYWxz8QE4eGNtX3JhdGVfbGltaXSpATRpc19zdWZmaWNpZW50FAAULGh1Yl9yZXNlcnZlCBhzaGFyZXMIPHByb3RvY29sX3NoYXJlcwgMY2FwCCB0cmFkYWJsZQQAECBhc3NldF9pZAQYYW1vdW50CBhzaGFyZXMIFHByaWNlZQICDBhBY3RpdmUAAQUcU3RvcHBlZAABBShUZXJtaW5hdGVkAAEFAEgIaWQEFG93bmVyACh1cGRhdGVkX2F0BDh0b3RhbF9zaGFyZXNfegg8YWNjdW11bGF0ZWRfcnB6CDxyZXdhcmRfY3VycmVuY3kEPHBlbmRpbmdfcmV3YXJkcwhgYWNjdW11bGF0ZWRfcGFpZF9yZXdhcmRzCEB5aWVsZF9wZXJfcGVyaW9kCGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMERGJsb2Nrc19wZXJfcGVyaW9kBEhpbmNlbnRpdml6ZWRfYXNzZXQEVG1heF9yZXdhcmRfcGVyX3BlcmlvZAgsbWluX2RlcG9zaXQIWGxpdmVfeWllbGRfZmFybXNfY291bnQEXHRvdGFsX3lpZWxkX2Zhcm1zX2NvdW50BEBwcmljZV9hZGp1c3RtZW50CBRzdGF0ZfUHBAQBDAAwCGlkBCh1cGRhdGVkX2F0BDB0b3RhbF9zaGFyZXMITHRvdGFsX3ZhbHVlZF9zaGFyZXMIQGFjY3VtdWxhdGVkX3JwdnMIPGFjY3VtdWxhdGVkX3Jwegg0bG95YWx0eV9jdXJ2ZTUCKG11bHRpcGxpZXIIFHN0YXRl9Qc0ZW50cmllc19jb3VudAhIbGVmdF90b19kaXN0cmlidXRlCDR0b3RhbF9zdG9wcGVkBAAgOGdsb2JhbF9mYXJtX2lkBDR5aWVsZF9mYXJtX2lkBDR2YWx1ZWRfc2hhcmVzCEBhY2N1bXVsYXRlZF9ycHZzCGxhY2N1bXVsYXRlZF9jbGFpbWVkX3Jld2FyZHMIKGVudGVyZWRfYXQEKHVwZGF0ZWRfYXQETHN0b3BwZWRfYXRfY3JlYXRpb24EBAUIAAAMGHNoYXJlcwgsYW1tX3Bvb2xfaWQESHlpZWxkX2Zhcm1fZW50cmllcwkIAAwkYXNzZXRfZmVlBDBwcm90b2NvbF9mZWUEJHRpbWVzdGFtcAQADCx0b3RhbF9zdGFrZQhwYWNjdW11bGF0ZWRfcmV3YXJkX3Blcl9zdGFrZQhQcG90X3Jlc2VydmVkX2JhbGFuY2UIABwUc3Rha2UINGFjdGlvbl9wb2ludHMIQHJld2FyZF9wZXJfc3Rha2UIKGNyZWF0ZWRfYXQEYGFjY3VtdWxhdGVkX3NsYXNoX3BvaW50cwhoYWNjdW11bGF0ZWRfdW5wYWlkX3Jld2FyZHMIaGFjY3VtdWxhdGVkX2xvY2tlZF9yZXdhcmRzCAAIGGFtb3VudAgoY29udmljdGlvbq0FAwgEHQgEIQgAAwgABAAYGGFzc2V0c00CVGluaXRpYWxfYW1wbGlmaWNhdGlvbgRMZmluYWxfYW1wbGlmaWNhdGlvbgQ0aW5pdGlhbF9ibG9jawQsZmluYWxfYmxvY2sEDGZlZQQACBhhbW91bnQIIGRlY2ltYWxzBAQxCAAAGBhhc3NldHNNAiByZXNlcnZlczUINGFtcGxpZmljYXRpb24IDGZlZQQQcGVnc30COHNoYXJlX2lzc3VhbmNlCAAIFHN0YXJ0BAxlbmQEABgccG9vbF9pZAQwcHVyY2hhc2VfZmVlBGRtYXhfYnV5X3ByaWNlX2NvZWZmaWNpZW50CDBidXliYWNrX3JhdGUEMGJ1eV9iYWNrX2ZlZQQ4bWF4X2luX2hvbGRpbmepAQAICGlkaQIYYW1vdW50CARFCAAADBBmcmVlCCByZXNlcnZlZAgYZnJvemVuCATZAgAFAQEEABxAdHJhbnNhY3Rpb25faGFzaCBEdHJhbnNhY3Rpb25faW5kZXgEEGZyb239AQh0b4UFQGNvbnRyYWN0X2FkZHJlc3OFBRBsb2dzUQgobG9nc19ibG9vbVUIABAsc3RhdHVzX2NvZGUEIHVzZWRfZ2Fz+QQobG9nc19ibG9vbVUIEGxvZ3NRCAIMGExlZ2FjeQFdCBxFSVAyOTMwAV0IHEVJUDE1NTkBXQgDDJEGWQhhCAA8LHBhcmVudF9oYXNoICxvbW1lcnNfaGFzaCAsYmVuZWZpY2lhcnn9AShzdGF0ZV9yb290IER0cmFuc2FjdGlvbnNfcm9vdCA0cmVjZWlwdHNfcm9vdCAobG9nc19ibG9vbVUIKGRpZmZpY3VsdHn5BBhudW1iZXL5BCRnYXNfbGltaXT5BCBnYXNfdXNlZPkEJHRpbWVzdGFtcAgoZXh0cmFfZGF0YSQgbWl4X2hhc2ggFG5vbmNlaQIEkQYABGkIAAAMGGhlYWRlcmkIMHRyYW5zYWN0aW9uc20IGG9tbWVyc3EIBGEIAARZCAADDAAEBAAMGHNoYXJlcwgsYW1tX3Bvb2xfaWQASHlpZWxkX2Zhcm1fZW50cmllcwkIAwhpAkECAAgEbggEZAgAEBBhX2luCBRiX291dAgUYV9vdXQIEGJfaW4IAAgEYQgEYggAFBRwcmljZY0IGHZvbHVtZZEIJGxpcXVpZGl0eZUIPHNoYXJlc19pc3N1YW5jZakBKHVwZGF0ZWRfYXQEAwiJCJkIBJ0IAAMMaQJBAm0CAwiZCAQEiQgAAwgETQgEsQgAAAgcYmFsYW5jZfkEFG5vbmNl+QQGbQYACCBzdGFuZGFyZPkEJGVmZmVjdGl2ZfkEABA4cmVmX3RpbWVfbGltaXSpAUBwcm9vZl9zaXplX2xpbWl0qQE4cmVmX3RpbWVfdXNhZ2WpAUBwcm9vZl9zaXplX3VzYWdlqQEGxQgAFCxleGl0X3JlYXNvbvUCFHZhbHVlJCB1c2VkX2dhc8EILHdlaWdodF9pbmZvyQgQbG9nc1EIB80IUQEAFCxleGl0X3JlYXNvbvUCFHZhbHVl/QEgdXNlZF9nYXPBCCx3ZWlnaHRfaW5mb8kIEGxvZ3NRCAfVCFEBBnUIBnkIBn0IAwzdCOEI5QgDCN0I5QgAFCxwYXJlbnRfaGFzaCAYbnVtYmVyBChzdGF0ZV9yb290IDxleHRyaW5zaWNzX3Jvb3QgGGRpZ2VzdDAEEQcAAhg0VW5pbXBsZW1lbnRlZAABBWRWZXJzaW9uZWRDb252ZXJzaW9uRmFpbGVkAAEFTFdlaWdodE5vdENvbXB1dGFibGUAAQVMVW5oYW5kbGVkWGNtVmVyc2lvbgABBTRBc3NldE5vdEZvdW5kAAEFKFVucm91dGFibGUAAQUH9Qj5CAcY+QgHCPkIB7kD+QgEXQQABgkHBAkHAAMIvQMVCQQZCQAAEEBleGVjdXRpb25fcmVzdWx03QE4ZW1pdHRlZF9ldmVudHMNCSRsb2NhbF94Y20RCThmb3J3YXJkZWRfeGNtcx0JAgg0VW5pbXBsZW1lbnRlZAABBWRWZXJzaW9uZWRDb252ZXJzaW9uRmFpbGVkAAEFByEJJQkADEBleGVjdXRpb25fcmVzdWx0MQM4ZW1pdHRlZF9ldmVudHMNCThmb3J3YXJkZWRfeGNtcx0JBy0JJQkAEBxyZXNlcnZlBBhhdG9rZW4ELGxpcXVkaXR5X2luCDBsaXF1ZGl0eV9vdXQIBDUJAAIsPEludmFsaWRTcGVjTmFtZQABBWhTcGVjVmVyc2lvbk5lZWRzVG9JbmNyZWFzZQABBXRGYWlsZWRUb0V4dHJhY3RSdW50aW1lVmVyc2lvbgABBUxOb25EZWZhdWx0Q29tcG9zaXRlAAEFPE5vblplcm9SZWZDb3VudAABBTBDYWxsRmlsdGVyZWQAAQVsTXVsdGlCbG9ja01pZ3JhdGlvbnNPbmdvaW5nAAEFLEludmFsaWRUYXNrAAEFKEZhaWxlZFRhc2sAAQVETm90aGluZ0F1dGhvcml6ZWQAAQUwVW5hdXRob3JpemVkAAEFAhhMT3ZlcmxhcHBpbmdVcGdyYWRlcwABBVBQcm9oaWJpdGVkQnlQb2xrYWRvdAABBRhUb29CaWcAAQVoVmFsaWRhdGlvbkRhdGFOb3RBdmFpbGFibGUAAQV0SG9zdENvbmZpZ3VyYXRpb25Ob3RBdmFpbGFibGUAAQUwTm90U2NoZWR1bGVkAAEFAhQoTm90VmVzdGluZwABBVRBdE1heFZlc3RpbmdTY2hlZHVsZXMAAQUkQW1vdW50TG93AAEFYFNjaGVkdWxlSW5kZXhPdXRPZkJvdW5kcwABBVRJbnZhbGlkU2NoZWR1bGVQYXJhbXMAAQUCGGBJbnZhbGlkRXRoZXJldW1TaWduYXR1cmUAAQVAU2lnbmVySGFzTm9DbGFpbQABBUBTZW5kZXJIYXNOb0NsYWltAAEFMFBvdFVuZGVyZmxvdwABBUBJbnZhbGlkU3RhdGVtZW50AAEFTFZlc3RlZEJhbGFuY2VFeGlzdHMAAQUCpCBPdmVyZmxvdwABBTRVbmltcGxlbWVudGVkAAEFYFVudHJ1c3RlZFJlc2VydmVMb2NhdGlvbgABBWRVbnRydXN0ZWRUZWxlcG9ydExvY2F0aW9uAAEFMExvY2F0aW9uRnVsbAABBVRMb2NhdGlvbk5vdEludmVydGlibGUAAQUkQmFkT3JpZ2luAAEFPEludmFsaWRMb2NhdGlvbgABBTRBc3NldE5vdEZvdW5kAAEFVEZhaWxlZFRvVHJhbnNhY3RBc3NldAABBTxOb3RXaXRoZHJhd2FibGUAAQVITG9jYXRpb25DYW5ub3RIb2xkAAEFVEV4Y2VlZHNNYXhNZXNzYWdlU2l6ZQABBVhEZXN0aW5hdGlvblVuc3VwcG9ydGVkAAEFJFRyYW5zcG9ydAABBShVbnJvdXRhYmxlAAEFMFVua25vd25DbGFpbQABBThGYWlsZWRUb0RlY29kZQABBUBNYXhXZWlnaHRJbnZhbGlkAAEFOE5vdEhvbGRpbmdGZWVzAAEFMFRvb0V4cGVuc2l2ZQABBRBUcmFwAAEFQEV4cGVjdGF0aW9uRmFsc2UAAQU4UGFsbGV0Tm90Rm91bmQAAQUwTmFtZU1pc21hdGNoAAEFTFZlcnNpb25JbmNvbXBhdGlibGUAAQVQSG9sZGluZ1dvdWxkT3ZlcmZsb3cAAQUsRXhwb3J0RXJyb3IAAQU4UmVhbmNob3JGYWlsZWQAAQUYTm9EZWFsAAEFKEZlZXNOb3RNZXQAAQUkTG9ja0Vycm9yAAEFME5vUGVybWlzc2lvbgABBShVbmFuY2hvcmVkAAEFOE5vdERlcG9zaXRhYmxlAAEFNFRvb01hbnlBc3NldHMAAQVMVW5oYW5kbGVkWGNtVmVyc2lvbgABBUhXZWlnaHRMaW1pdFJlYWNoZWQAAQUcQmFycmllcgABBUxXZWlnaHROb3RDb21wdXRhYmxlAAEFREV4Y2VlZHNTdGFja0xpbWl0AAEFAnAsVW5yZWFjaGFibGUAAQUsU2VuZEZhaWx1cmUAAQUgRmlsdGVyZWQAAQVIVW53ZWlnaGFibGVNZXNzYWdlAAEFYERlc3RpbmF0aW9uTm90SW52ZXJ0aWJsZQABBRRFbXB0eQABBThDYW5ub3RSZWFuY2hvcgABBTRUb29NYW55QXNzZXRzAAEFNEludmFsaWRPcmlnaW4AAQUoQmFkVmVyc2lvbgABBSxCYWRMb2NhdGlvbgABBThOb1N1YnNjcmlwdGlvbgABBURBbHJlYWR5U3Vic2NyaWJlZAABBVhDYW5ub3RDaGVja091dFRlbGVwb3J0AAEFKExvd0JhbGFuY2UAAQUwVG9vTWFueUxvY2tzAAEFTEFjY291bnROb3RTb3ZlcmVpZ24AAQUoRmVlc05vdE1ldAABBTBMb2NrTm90Rm91bmQAAQUUSW5Vc2UAAQVoSW52YWxpZEFzc2V0VW5rbm93blJlc2VydmUAAQV4SW52YWxpZEFzc2V0VW5zdXBwb3J0ZWRSZXNlcnZlAAEFPFRvb01hbnlSZXNlcnZlcwABBWBMb2NhbEV4ZWN1dGlvbkluY29tcGxldGUAAQVgVG9vTWFueUF1dGhvcml6ZWRBbGlhc2VzAAEFNEV4cGlyZXNJblBhc3QAAQU0QWxpYXNOb3RGb3VuZAABBYRMb2NhbEV4ZWN1dGlvbkluY29tcGxldGVXaXRoRXJyb3IAAAgUaW5kZXgEFGVycm9yTQkCNGhVbnN1cHBvcnRlZExvY2F0aW9uVmVyc2lvbgABBURJbnZhbGlkQXNzZXRPd25lcgABBSxTZW5kRmFpbHVyZQABBShGZWVzTm90TWV0AAEFYExvY2F0aW9uQ29udmVyc2lvbkZhaWxlZAABBRhIYWx0ZWQAAQUsVW5yZWFjaGFibGUAAQVAVW5zdXBwb3J0ZWRBc3NldAABBTRXaXRoZHJhd0Vycm9yAAEFOEludmFsaWRBY2NvdW50AAEFJFN3YXBFcnJvcgABBSRCdXJuRXJyb3IAAQU0VGlwQW1vdW50WmVybwABBQIULE5vdEFzc2lnbmVkAAEFIE5vdE93bmVyAAEFFEluVXNlAAEFLE5vdFRyYW5zZmVyAAEFJFBlcm1hbmVudAABBQJcKEJhbGFuY2VMb3cAAQUkTm9BY2NvdW50AAEFME5vUGVybWlzc2lvbgABBRxVbmtub3duAAEFGEZyb3plbgABBRRJblVzZQABBShCYWRXaXRuZXNzAAEFOE1pbkJhbGFuY2VaZXJvAAEFTFVuYXZhaWxhYmxlQ29uc3VtZXIAAQUsQmFkTWV0YWRhdGEAAQUoVW5hcHByb3ZlZAABBSBXb3VsZERpZQABBTRBbHJlYWR5RXhpc3RzAAEFJE5vRGVwb3NpdAABBSRXb3VsZEJ1cm4AAQUkTGl2ZUFzc2V0AAEFMEFzc2V0Tm90TGl2ZQABBTxJbmNvcnJlY3RTdGF0dXMAAQUkTm90RnJvemVuAAEFOENhbGxiYWNrRmFpbGVkAAEFKEJhZEFzc2V0SWQAAQU8Q29udGFpbnNGcmVlemVzAAEFNENvbnRhaW5zSG9sZHMAAQUCWDBOb1Blcm1pc3Npb24AAQVEVW5rbm93bkNvbGxlY3Rpb24AAQU0QWxyZWFkeUV4aXN0cwABBShXcm9uZ093bmVyAAEFKEJhZFdpdG5lc3MAAQUUSW5Vc2UAAQUYRnJvemVuAAEFNFdyb25nRGVsZWdhdGUAAQUoTm9EZWxlZ2F0ZQABBShVbmFwcHJvdmVkAAEFKFVuYWNjZXB0ZWQAAQUYTG9ja2VkAAEFQE1heFN1cHBseVJlYWNoZWQAAQVMTWF4U3VwcGx5QWxyZWFkeVNldAABBURNYXhTdXBwbHlUb29TbWFsbAABBSxVbmtub3duSXRlbQABBShOb3RGb3JTYWxlAAEFJEJpZFRvb0xvdwABBShOb01ldGFkYXRhAAEFNFdyb25nTWV0YWRhdGEAAQVEQXR0cmlidXRlTm90Rm91bmQAAQU4V3JvbmdBdHRyaWJ1dGUAAQUCtDBOb1Blcm1pc3Npb24AAQVEVW5rbm93bkNvbGxlY3Rpb24AAQU0QWxyZWFkeUV4aXN0cwABBTxBcHByb3ZhbEV4cGlyZWQAAQUoV3JvbmdPd25lcgABBShCYWRXaXRuZXNzAAEFRENvbGxlY3Rpb25JZEluVXNlAAEFUEl0ZW1zTm9uVHJhbnNmZXJhYmxlAAEFLE5vdERlbGVnYXRlAAEFNFdyb25nRGVsZWdhdGUAAQUoVW5hcHByb3ZlZAABBShVbmFjY2VwdGVkAAEFKEl0ZW1Mb2NrZWQAAQVQTG9ja2VkSXRlbUF0dHJpYnV0ZXMAAQVoTG9ja2VkQ29sbGVjdGlvbkF0dHJpYnV0ZXMAAQVITG9ja2VkSXRlbU1ldGFkYXRhAAEFYExvY2tlZENvbGxlY3Rpb25NZXRhZGF0YQABBUBNYXhTdXBwbHlSZWFjaGVkAAEFPE1heFN1cHBseUxvY2tlZAABBURNYXhTdXBwbHlUb29TbWFsbAABBSxVbmtub3duSXRlbQABBSxVbmtub3duU3dhcAABBUBNZXRhZGF0YU5vdEZvdW5kAAEFREF0dHJpYnV0ZU5vdEZvdW5kAAEFKE5vdEZvclNhbGUAAQUkQmlkVG9vTG93AAEFUFJlYWNoZWRBcHByb3ZhbExpbWl0AAEFPERlYWRsaW5lRXhwaXJlZAABBTRXcm9uZ0R1cmF0aW9uAAEFOE1ldGhvZERpc2FibGVkAAEFMFdyb25nU2V0dGluZwABBVhJbmNvbnNpc3RlbnRJdGVtQ29uZmlnAAEFIE5vQ29uZmlnAAEFPFJvbGVzTm90Q2xlYXJlZAABBThNaW50Tm90U3RhcnRlZAABBSRNaW50RW5kZWQAAQU4QWxyZWFkeUNsYWltZWQAAQU0SW5jb3JyZWN0RGF0YQABBSxXcm9uZ09yaWdpbgABBThXcm9uZ1NpZ25hdHVyZQABBURJbmNvcnJlY3RNZXRhZGF0YQABBWRNYXhBdHRyaWJ1dGVzTGltaXRSZWFjaGVkAAEFOFdyb25nTmFtZXNwYWNlAAEFSENvbGxlY3Rpb25Ob3RFbXB0eQABBTxXaXRuZXNzUmVxdWlyZWQAAQUCXEBJbnZhbGlkQXNzZXRQYWlyAAEFKFBvb2xFeGlzdHMAAQVIV3JvbmdEZXNpcmVkQW1vdW50AAEFYEFtb3VudE9uZUxlc3NUaGFuTWluaW1hbAABBWBBbW91bnRUd29MZXNzVGhhbk1pbmltYWwAAQVoUmVzZXJ2ZUxlZnRMZXNzVGhhbk1pbmltYWwAAQVAQW1vdW50T3V0VG9vSGlnaAABBTBQb29sTm90Rm91bmQAAQUgT3ZlcmZsb3cAAQWAQXNzZXRPbmVEZXBvc2l0RGlkTm90TWVldE1pbmltdW0AAQWAQXNzZXRUd29EZXBvc2l0RGlkTm90TWVldE1pbmltdW0AAQWMQXNzZXRPbmVXaXRoZHJhd2FsRGlkTm90TWVldE1pbmltdW0AAQWMQXNzZXRUd29XaXRoZHJhd2FsRGlkTm90TWVldE1pbmltdW0AAQVwT3B0aW1hbEFtb3VudExlc3NUaGFuRGVzaXJlZAABBWxJbnN1ZmZpY2llbnRMaXF1aWRpdHlNaW50ZWQAAQU0WmVyb0xpcXVpZGl0eQABBShaZXJvQW1vdW50AAEFjFByb3ZpZGVkTWluaW11bU5vdFN1ZmZpY2llbnRGb3JTd2FwAAEFjFByb3ZpZGVkTWF4aW11bU5vdFN1ZmZpY2llbnRGb3JTd2FwAAEFLEludmFsaWRQYXRoAAEFNE5vblVuaXF1ZVBhdGgAAQVQSW5jb3JyZWN0UG9vbEFzc2V0SWQAAQUwQmVsb3dNaW5pbXVtAAEFAjBwSW5zdWZmaWNpZW50UHJvcG9zZXJzQmFsYW5jZQABBTBJbnZhbGlkSW5kZXgAAQUwUmVhc29uVG9vQmlnAAEFQFVuZXhwZWN0ZWRTdGF0dXMAAQU4UmVxdWlyZUN1cmF0b3IAAQUwSW52YWxpZFZhbHVlAAEFKEludmFsaWRGZWUAAQU0UGVuZGluZ1BheW91dAABBSRQcmVtYXR1cmUAAQVQSGFzQWN0aXZlQ2hpbGRCb3VudHkAAQU0VG9vTWFueVF1ZXVlZAABBSxOb3RQcm9wb3NlcgABBQIMVFBhcmVudEJvdW50eU5vdEFjdGl2ZQABBWRJbnN1ZmZpY2llbnRCb3VudHlCYWxhbmNlAAEFUFRvb01hbnlDaGlsZEJvdW50aWVzAAEFAgxAVW5rbm93bkFzc2V0S2luZAABBTRBbHJlYWR5RXhpc3RzAAEFIE92ZXJmbG93AAEFAhxoTm90RW5vdWdoU3BhY2VJblVuYm9uZFBvb2wAAQUwUG9vbE5vdEZvdW5kAAEFSFJld2FyZFBvb2xOb3RGb3VuZAABBUBTdWJQb29sc05vdEZvdW5kAAEFcEJvbmRlZFN0YXNoS2lsbGVkUHJlbWF0dXJlbHkAAQVURGVsZWdhdGlvblVuc3VwcG9ydGVkAAEFPFNsYXNoTm90QXBwbGllZAABBQKYMFBvb2xOb3RGb3VuZAABBUhQb29sTWVtYmVyTm90Rm91bmQAAQVIUmV3YXJkUG9vbE5vdEZvdW5kAAEFQFN1YlBvb2xzTm90Rm91bmQAAQVkQWNjb3VudEJlbG9uZ3NUb090aGVyUG9vbAABBThGdWxseVVuYm9uZGluZwABBURNYXhVbmJvbmRpbmdMaW1pdAABBURDYW5ub3RXaXRoZHJhd0FueQABBURNaW5pbXVtQm9uZE5vdE1ldAABBTBPdmVyZmxvd1Jpc2sAAQU0Tm90RGVzdHJveWluZwABBTBOb3ROb21pbmF0b3IAAQVUTm90S2lja2VyT3JEZXN0cm95aW5nAAEFHE5vdE9wZW4AAQUgTWF4UG9vbHMAAQU4TWF4UG9vbE1lbWJlcnMAAQVEQ2FuTm90Q2hhbmdlU3RhdGUAAQVURG9lc05vdEhhdmVQZXJtaXNzaW9uAAEFVE1ldGFkYXRhRXhjZWVkc01heExlbgABBSREZWZlbnNpdmUBeQmcUGFydGlhbFVuYm9uZE5vdEFsbG93ZWRQZXJtaXNzaW9ubGVzc2x5AAEFXE1heENvbW1pc3Npb25SZXN0cmljdGVkAAEFYENvbW1pc3Npb25FeGNlZWRzTWF4aW11bQABBXhDb21taXNzaW9uRXhjZWVkc0dsb2JhbE1heGltdW0AAQVkQ29tbWlzc2lvbkNoYW5nZVRocm90dGxlZAABBXhDb21taXNzaW9uQ2hhbmdlUmF0ZU5vdEFsbG93ZWQAAQVMTm9QZW5kaW5nQ29tbWlzc2lvbgABBVhOb0NvbW1pc3Npb25DdXJyZW50U2V0AAEFLFBvb2xJZEluVXNlAAEFNEludmFsaWRQb29sSWQAAQVMQm9uZEV4dHJhUmVzdHJpY3RlZAABBTxOb3RoaW5nVG9BZGp1c3QAAQU4Tm90aGluZ1RvU2xhc2gAAQUsU2xhc2hUb29Mb3cAAQU8QWxyZWFkeU1pZ3JhdGVkAAEFLE5vdE1pZ3JhdGVkAAEFME5vdFN1cHBvcnRlZAABBShSZXN0cmljdGVkAAEFAhQkRHVwbGljYXRlAAEFKE5vdEhlYXZpZXIAAQUwTm90SW5TYW1lQmFnAAEFME5vZGVOb3RGb3VuZAABBRhMb2NrZWQAAQUCCBBMaXN0AYEJGExvY2tlZAABBQIwKE5vdEFsbG93ZWQAAQU4QWxyZWFkeVN0YWtpbmcAAQVgSW52YWxpZFJld2FyZERlc3RpbmF0aW9uAAEFREludmFsaWREZWxlZ2F0aW9uAAEFOE5vdEVub3VnaEZ1bmRzAAEFIE5vdEFnZW50AAEFME5vdERlbGVnYXRvcgABBSBCYWRTdGF0ZQABBThVbmFwcGxpZWRTbGFzaAABBThOb3RoaW5nVG9TbGFzaAABBThXaXRoZHJhd0ZhaWxlZAABBTBOb3RTdXBwb3J0ZWQAAQUCDCBGYWxsYmFjawABBTxVbmV4cGVjdGVkUGhhc2UAAQUgU25hcHNob3QAAQUCJDhQaGFzZU5vdFNpZ25lZAABBSREdXBsaWNhdGUAAQUkUXVldWVGdWxsAAEFMEJhZFBhZ2VJbmRleAABBTROb3RSZWdpc3RlcmVkAAEFME5vU3VibWlzc2lvbgABBTBSb3VuZE5vdE92ZXIAAQU4QmFkV2l0bmVzc0RhdGEAAQVQVG9vTWFueUludnVsbmVyYWJsZXMAAQUCkDROb3RDb250cm9sbGVyAAEFIE5vdFN0YXNoAAEFNEFscmVhZHlCb25kZWQAAQU0QWxyZWFkeVBhaXJlZAABBTBFbXB0eVRhcmdldHMAAQU4RHVwbGljYXRlSW5kZXgAAQVISW52YWxpZFNsYXNoUmVjb3JkAAEFQEluc3VmZmljaWVudEJvbmQAAQUwTm9Nb3JlQ2h1bmtzAAEFNE5vVW5sb2NrQ2h1bmsAAQUwRnVuZGVkVGFyZ2V0AAEFSEludmFsaWRFcmFUb1Jld2FyZAABBWhJbnZhbGlkTnVtYmVyT2ZOb21pbmF0aW9ucwABBThBbHJlYWR5Q2xhaW1lZAABBSxJbnZhbGlkUGFnZQABBVRJbmNvcnJlY3RIaXN0b3J5RGVwdGgAAQUgQmFkU3RhdGUAAQU4VG9vTWFueVRhcmdldHMAAQUkQmFkVGFyZ2V0AAEFQENhbm5vdENoaWxsT3RoZXIAAQVEVG9vTWFueU5vbWluYXRvcnMAAQVEVG9vTWFueVZhbGlkYXRvcnMAAQVAQ29tbWlzc2lvblRvb0xvdwABBSxCb3VuZE5vdE1ldAABBVBDb250cm9sbGVyRGVwcmVjYXRlZAABBUxDYW5ub3RSZXN0b3JlTGVkZ2VyAAEFbFJld2FyZERlc3RpbmF0aW9uUmVzdHJpY3RlZAABBThOb3RFbm91Z2hGdW5kcwABBVxWaXJ0dWFsU3Rha2VyTm90QWxsb3dlZAABBTxDYW5ub3RSZWFwU3Rhc2gAAQU8QWxyZWFkeU1pZ3JhdGVkAAEFNEVyYU5vdFN0YXJ0ZWQAAQUoUmVzdHJpY3RlZAABBXRVbmFwcGxpZWRTbGFzaGVzSW5QcmV2aW91c0VyYQABBThFcmFOb3RQcnVuYWJsZQABBThDYW5jZWxsZWRTbGFzaAABBQIsOE5vTGVhc2VSZXNlcnZlAAEFXE5vQ3Jvd2Rsb2FuQ29udHJpYnV0aW9uAAEFSE5vQ3Jvd2Rsb2FuUmVzZXJ2ZQABBZRGYWlsZWRUb1dpdGhkcmF3Q3Jvd2Rsb2FuQ29udHJpYnV0aW9uAAEFGE5vdFlldAABBVhDb250cmlidXRpb25zUmVtYWluaW5nAAEFXFdyb25nRGVyaXZlZFRyYW5zbGF0aW9uAAEFME5vdFNvdmVyZWlnbgABBTRJbnRlcm5hbEVycm9yAAEFVE1pZ3JhdGlvbk5vdENvbXBsZXRlZAABBSxaZXJvQmFsYW5jZQABBQJMYEZhaWxlZFRvVW5yZXNlcnZlRGVwb3NpdAABBVhGYWlsZWRUb1Byb2Nlc3NBY2NvdW50AAEFOEluc2VydENvbmZsaWN0AAEFTEZhaWxlZFRvQ29udmVydFR5cGUAAQVAUHJlaW1hZ2VOb3RGb3VuZAABBUxGYWlsZWRUb0NvbnZlcnRDYWxsAAEFREZhaWxlZFRvQm91bmRDYWxsAAEFIFhjbUVycm9yAAEFgEZhaWxlZFRvSW50ZWdyYXRlVmVzdGluZ1NjaGVkdWxlAAEFgEZhaWxlZFRvQ2FsY3VsYXRlQ2hlY2tpbmdBY2NvdW50AAEFTEZhaWxlZFRvQm91bmRWZWN0b3IAAQVoRG1wUXVldWVQcmlvcml0eUFscmVhZHlTZXQAAQVASW52YWxpZFBhcmFtZXRlcgABBTxQcmVpbWFnZU1pc3NpbmcAAQU4UHJlaW1hZ2VUb29CaWcAAQVQUHJlaW1hZ2VDaHVua01pc3NpbmcAAQVUUHJlaW1hZ2VTdGF0dXNJbnZhbGlkAAEFNEJhZFhjbVZlcnNpb24AAQU0SW52YWxpZE9yaWdpbgABBQKcGFN5c3RlbQE9CTxQYXJhY2hhaW5TeXN0ZW0BQQkgUHJlaW1hZ2UBWCRTY2hlZHVsZXIBBQEgQmFsYW5jZXMBSBxWZXN0aW5nAUUJGENsYWltcwFJCURDb2xsYXRvclNlbGVjdGlvbgElARxTZXNzaW9uASkBJFhjbXBRdWV1ZQERASxQb2xrYWRvdFhjbQFRCTBNZXNzYWdlUXVldWUBFQFgU25vd2JyaWRnZVN5c3RlbUZyb250ZW5kAVUJHFV0aWxpdHkBVCBNdWx0aXNpZwFsFFByb3h5AWgcSW5kaWNlcwFZCRhBc3NldHMBXQkcVW5pcXVlcwFhCRBOZnRzAWUJNEZvcmVpZ25Bc3NldHMBXQkoUG9vbEFzc2V0cwFdCTxBc3NldENvbnZlcnNpb24BaQkgVHJlYXN1cnkBUEBDb252aWN0aW9uVm90aW5nAXgkUmVmZXJlbmRhAXwkV2hpdGVsaXN0AYAgQm91bnRpZXMBbQk0Q2hpbGRCb3VudGllcwFxCSRBc3NldFJhdGUBdQlIU3RhdGVUcmllTWlncmF0aW9uAXQ8Tm9taW5hdGlvblBvb2xzAX0JJFZvdGVyTGlzdAGFCUBEZWxlZ2F0ZWRTdGFraW5nAYkJSE11bHRpQmxvY2tFbGVjdGlvbgGNCWBNdWx0aUJsb2NrRWxlY3Rpb25TaWduZWQBkQkcU3Rha2luZwGVCRRBaE9wcwGZCShBaE1pZ3JhdG9yAZ0JAjhASW52YWxpZFN0YXRlUm9vdAABBUhJbmNvbXBsZXRlRGF0YWJhc2UAAQVQVmFsdWVBdEluY29tcGxldGVLZXkAAQUwRGVjb2RlckVycm9yAAEFLEludmFsaWRIYXNoAAEFMER1cGxpY2F0ZUtleQABBThFeHRyYW5lb3VzTm9kZQABBTxFeHRyYW5lb3VzVmFsdWUAAQVcRXh0cmFuZW91c0hhc2hSZWZlcmVuY2UAAQVUSW52YWxpZENoaWxkUmVmZXJlbmNlAAEFNFZhbHVlTWlzbWF0Y2gAAQU8SW5jb21wbGV0ZVByb29mAAEFMFJvb3RNaXNtYXRjaAABBSxEZWNvZGVFcnJvcgABBQI8FE90aGVyAAEFMENhbm5vdExvb2t1cAABBSRCYWRPcmlnaW4AAQUYTW9kdWxlAaEJRENvbnN1bWVyUmVtYWluaW5nAAEFLE5vUHJvdmlkZXJzAAEFQFRvb01hbnlDb25zdW1lcnMAAQUUVG9rZW4BRQEoQXJpdGhtZXRpYwFJATRUcmFuc2FjdGlvbmFsAU0BJEV4aGF1c3RlZAABBShDb3JydXB0aW9uAAEFLFVuYXZhaWxhYmxlAAEFOFJvb3ROb3RBbGxvd2VkAAEFEFRyaWUBpQkCLEBFeHRyaW5zaWNTdWNjZXNzAAAENGRpc3BhdGNoX2luZm9APEV4dHJpbnNpY0ZhaWxlZAAACDhkaXNwYXRjaF9lcnJvcqkJNGRpc3BhdGNoX2luZm9ALENvZGVVcGRhdGVkAAEFKE5ld0FjY291bnQAAAQcYWNjb3VudAA0S2lsbGVkQWNjb3VudAAABBxhY2NvdW50ACBSZW1hcmtlZAAACBhzZW5kZXIAEGhhc2ggLFRhc2tTdGFydGVkAAAANFRhc2tDb21wbGV0ZWQAAAAoVGFza0ZhaWxlZAAABAxlcnKpCURVcGdyYWRlQXV0aG9yaXplZAAACCRjb2RlX2hhc2ggNGNoZWNrX3ZlcnNpb24UgFJlamVjdGVkSW52YWxpZEF1dGhvcml6ZWRVcGdyYWRlAAAIJGNvZGVfaGFzaCAUZXJyb3KpCQdtAakJAigkU2NoZWR1bGVkAAAIEHdoZW4EFGluZGV4BCBDYW5jZWxlZAAACBB3aGVuBBRpbmRleAQoRGlzcGF0Y2hlZAAADBB0YXNrQQIIaWQhAxhyZXN1bHSxCSBSZXRyeVNldAAAEBB0YXNrQQIIaWQhAxhwZXJpb2QEHHJldHJpZXMEOFJldHJ5Q2FuY2VsbGVkAAAIEHRhc2tBAghpZCEDPENhbGxVbmF2YWlsYWJsZQAACBB0YXNrQQIIaWQhAzhQZXJpb2RpY0ZhaWxlZAAACBB0YXNrQQIIaWQhAyxSZXRyeUZhaWxlZAAACBB0YXNrQQIIaWQhA1RQZXJtYW5lbnRseU92ZXJ3ZWlnaHQAAAgQdGFza0ECCGlkIQNAQWdlbmRhSW5jb21wbGV0ZQAABBB3aGVuBAIcLFNpZ25lZFBoYXNlAW0BUE1heFNpZ25lZFN1Ym1pc3Npb25zAW0BNFVuc2lnbmVkUGhhc2UBbQEoTWluZXJQYWdlcwFtAURNYXhFbGVjdGluZ1ZvdGVycwFtAVhUYXJnZXRTbmFwc2hvdFBlckJsb2NrAW0BOE1heEVyYUR1cmF0aW9uAW0BAghQTWF4U2NoZWR1bGVkUGVyQmxvY2sBbQE0TWF4aW11bVdlaWdodAFtAQIIPE1heE9uSW5pdFdlaWdodAFtATxNYXhPbklkbGVXZWlnaHQBbQECDDxTdGFraW5nRWxlY3Rpb24BuQkkU2NoZWR1bGVyAb0JME1lc3NhZ2VRdWV1ZQHBCQIcLFNpZ25lZFBoYXNlAQRQTWF4U2lnbmVkU3VibWlzc2lvbnMBBDRVbnNpZ25lZFBoYXNlAQQoTWluZXJQYWdlcwEERE1heEVsZWN0aW5nVm90ZXJzAQRYVGFyZ2V0U25hcHNob3RQZXJCbG9jawEEOE1heEVyYUR1cmF0aW9uAQgCCFBNYXhTY2hlZHVsZWRQZXJCbG9jawEENE1heGltdW1XZWlnaHQBGAIIPE1heE9uSW5pdFdlaWdodAHRATxNYXhPbklkbGVXZWlnaHQB0QECDDxTdGFraW5nRWxlY3Rpb24ByQkkU2NoZWR1bGVyAc0JME1lc3NhZ2VRdWV1ZQHRCQbVCQIEHFVwZGF0ZWQAAAwMa2V5xQkkb2xkX3ZhbHVl2QkkbmV3X3ZhbHVl2QkCCDhCYWxhbmNlVXBkYXRlZAABBVRGYWlsZWRUb011dGF0ZUFjY291bnQAAQUCXBxFbmRvd2VkAAAIHGFjY291bnQAMGZyZWVfYmFsYW5jZQggRHVzdExvc3QAAAgcYWNjb3VudAAYYW1vdW50CCBUcmFuc2ZlcgAADBBmcm9tAAh0bwAYYW1vdW50CChCYWxhbmNlU2V0AAAIDHdobwAQZnJlZQggUmVzZXJ2ZWQAAAgMd2hvABhhbW91bnQIKFVucmVzZXJ2ZWQAAAgMd2hvABhhbW91bnQISFJlc2VydmVSZXBhdHJpYXRlZAAAEBBmcm9tAAh0bwAYYW1vdW50CEhkZXN0aW5hdGlvbl9zdGF0dXNZARxEZXBvc2l0AAAIDHdobwAYYW1vdW50CCBXaXRoZHJhdwAACAx3aG8AGGFtb3VudAgcU2xhc2hlZAAACAx3aG8AGGFtb3VudAgYTWludGVkAAAIDHdobwAYYW1vdW50CBhCdXJuZWQAAAgMd2hvABhhbW91bnQIJFN1c3BlbmRlZAAACAx3aG8AGGFtb3VudAggUmVzdG9yZWQAAAgMd2hvABhhbW91bnQIIFVwZ3JhZGVkAAAEDHdobwAYSXNzdWVkAAAEGGFtb3VudAgkUmVzY2luZGVkAAAEGGFtb3VudAgYTG9ja2VkAAAIDHdobwAYYW1vdW50CCBVbmxvY2tlZAAACAx3aG8AGGFtb3VudAgYRnJvemVuAAAIDHdobwAYYW1vdW50CBhUaGF3ZWQAAAgMd2hvABhhbW91bnQITFRvdGFsSXNzdWFuY2VGb3JjZWQAAAgMb2xkCAxuZXcIKFVuZXhwZWN0ZWQB4QkCICRCeUdlbmVzaXMBIBhCeUZvcmsAAAgwYmxvY2tfbnVtYmVyCChibG9ja19oYXNoICBQb2xrYWRvdAABBRhLdXNhbWEAAQUgRXRoZXJldW0AAAQgY2hhaW5faWQILEJpdGNvaW5Db3JlAAEFLEJpdGNvaW5DYXNoAAEFQFBvbGthZG90QnVsbGV0aW4AAQUG6QkCKCRQYXJhY2hhaW4BBCxBY2NvdW50SWQzMgAACBxuZXR3b3Jr7QkIaWQgOEFjY291bnRJbmRleDY0AAAIHG5ldHdvcmvtCRRpbmRleAgwQWNjb3VudEtleTIwAAAIHG5ldHdvcmvtCQxrZXn9AThQYWxsZXRJbnN0YW5jZQEEMEdlbmVyYWxJbmRleAEIKEdlbmVyYWxLZXkAAAgYbGVuZ3RoBBBkYXRhICRPbmx5Q2hpbGQAAQUkUGx1cmFsaXR5AAAICGlkAQIQcGFydAUCPEdsb2JhbENvbnNlbnN1cwHpCQTxCQEIBPEJAQwE8QkBEATxCQEUBPEJARgE8QkBHATxCQEgAiQQSGVyZQABBQhYMQHxCQhYMgH1CQhYMwH5CQhYNAH9CQhYNQEBCghYNgEFCghYNwEJCghYOAENCgAIHHBhcmVudHMEIGludGVyaW9yEQoCCDhBc3NldFR4RmVlUGFpZAAAEAx3aG8AKGFjdHVhbF9mZWUIDHRpcAggYXNzZXRfaWQVCkRBc3NldFJlZnVuZEZhaWxlZAAABEhuYXRpdmVfYW1vdW50X2tlcHQIAgw4VmVzdGluZ0NyZWF0ZWQAAAgcYWNjb3VudAA4c2NoZWR1bGVfaW5kZXgEOFZlc3RpbmdVcGRhdGVkAAAIHGFjY291bnQAIHVudmVzdGVkCEBWZXN0aW5nQ29tcGxldGVkAAAEHGFjY291bnQAAgQcQ2xhaW1lZAAADAx3aG8AQGV0aGVyZXVtX2FkZHJlc3P9ARhhbW91bnQIAhAoTmV3U2Vzc2lvbgAABDRzZXNzaW9uX2luZGV4BCROZXdRdWV1ZWQAAQVEVmFsaWRhdG9yRGlzYWJsZWQAAAQkdmFsaWRhdG9yAEhWYWxpZGF0b3JSZWVuYWJsZWQAAAQkdmFsaWRhdG9yAAKkIE92ZXJmbG93AAEFNFVuaW1wbGVtZW50ZWQAAQVgVW50cnVzdGVkUmVzZXJ2ZUxvY2F0aW9uAAEFZFVudHJ1c3RlZFRlbGVwb3J0TG9jYXRpb24AAQUwTG9jYXRpb25GdWxsAAEFVExvY2F0aW9uTm90SW52ZXJ0aWJsZQABBSRCYWRPcmlnaW4AAQU8SW52YWxpZExvY2F0aW9uAAEFNEFzc2V0Tm90Rm91bmQAAQVURmFpbGVkVG9UcmFuc2FjdEFzc2V0AAEFPE5vdFdpdGhkcmF3YWJsZQABBUhMb2NhdGlvbkNhbm5vdEhvbGQAAQVURXhjZWVkc01heE1lc3NhZ2VTaXplAAEFWERlc3RpbmF0aW9uVW5zdXBwb3J0ZWQAAQUkVHJhbnNwb3J0AAEFKFVucm91dGFibGUAAQUwVW5rbm93bkNsYWltAAEFOEZhaWxlZFRvRGVjb2RlAAEFQE1heFdlaWdodEludmFsaWQAAQU4Tm90SG9sZGluZ0ZlZXMAAQUwVG9vRXhwZW5zaXZlAAEFEFRyYXABCEBFeHBlY3RhdGlvbkZhbHNlAAEFOFBhbGxldE5vdEZvdW5kAAEFME5hbWVNaXNtYXRjaAABBUxWZXJzaW9uSW5jb21wYXRpYmxlAAEFUEhvbGRpbmdXb3VsZE92ZXJmbG93AAEFLEV4cG9ydEVycm9yAAEFOFJlYW5jaG9yRmFpbGVkAAEFGE5vRGVhbAABBShGZWVzTm90TWV0AAEFJExvY2tFcnJvcgABBTBOb1Blcm1pc3Npb24AAQUoVW5hbmNob3JlZAABBThOb3REZXBvc2l0YWJsZQABBTRUb29NYW55QXNzZXRzAAEFTFVuaGFuZGxlZFhjbVZlcnNpb24AAQVIV2VpZ2h0TGltaXRSZWFjaGVkARgcQmFycmllcgABBUxXZWlnaHROb3RDb21wdXRhYmxlAAEFREV4Y2VlZHNTdGFja0xpbWl0AAEFAAgUaW5kZXgEFGVycm9yKQoCDCBDb21wbGV0ZQAABBB1c2VkGChJbmNvbXBsZXRlAAAIEHVzZWQYFGVycm9yLQoURXJyb3IBLQoACAhpZBUKDGZ1bj0DBDUKAAMIBCkKBj0KAhgQTnVsbAABBRhBc3NldHMBOQo8RXhlY3V0aW9uUmVzdWx0AUEKHFZlcnNpb24BBCxQYWxsZXRzSW5mbwFVAzhEaXNwYXRjaFJlc3VsdAFZAwYVCgAMLGRlc3RpbmF0aW9uFQogcXVlcnlfaWQIKG1heF93ZWlnaHQYAhAMQWxsAAEFFEFsbE9mAAAICGlkFQoMZnVubQMoQWxsQ291bnRlZAEEMEFsbE9mQ291bnRlZAAADAhpZBUKDGZ1bm0DFGNvdW50BAIIIERlZmluaXRlATkKEFdpbGQBUQoCDCBUZWxlcG9ydAFVCjhSZXNlcnZlRGVwb3NpdAFVCjxSZXNlcnZlV2l0aGRyYXcBVQoGWQoEWQoABhEKAgQwQXNzZXRDbGFpbWVyAAAEIGxvY2F0aW9uFQoEaQoAAtA0V2l0aGRyYXdBc3NldAE5ClRSZXNlcnZlQXNzZXREZXBvc2l0ZWQBOQpYUmVjZWl2ZVRlbGVwb3J0ZWRBc3NldAE5CjRRdWVyeVJlc3BvbnNlAAAQIHF1ZXJ5X2lkCCByZXNwb25zZUUKKG1heF93ZWlnaHQYHHF1ZXJpZXJJCjRUcmFuc2ZlckFzc2V0AAAIGGFzc2V0czkKLGJlbmVmaWNpYXJ5FQpQVHJhbnNmZXJSZXNlcnZlQXNzZXQAAAwYYXNzZXRzOQoQZGVzdBUKDHhjbXUKIFRyYW5zYWN0AAAMLG9yaWdpbl9raW5kZQNMZmFsbGJhY2tfbWF4X3dlaWdodNEBEGNhbGwkZEhybXBOZXdDaGFubmVsT3BlblJlcXVlc3QAAAwYc2VuZGVyBEBtYXhfbWVzc2FnZV9zaXplBDBtYXhfY2FwYWNpdHkETEhybXBDaGFubmVsQWNjZXB0ZWQAAAQkcmVjaXBpZW50BEhIcm1wQ2hhbm5lbENsb3NpbmcAAAwkaW5pdGlhdG9yBBhzZW5kZXIEJHJlY2lwaWVudAQsQ2xlYXJPcmlnaW4AAQU0RGVzY2VuZE9yaWdpbgERCixSZXBvcnRFcnJvcgFNCjBEZXBvc2l0QXNzZXQAAAgYYXNzZXRzVQosYmVuZWZpY2lhcnkVCkxEZXBvc2l0UmVzZXJ2ZUFzc2V0AAAMGGFzc2V0c1UKEGRlc3QVCgx4Y211CjRFeGNoYW5nZUFzc2V0AAAMEGdpdmVVChB3YW50OQocbWF4aW1hbBRcSW5pdGlhdGVSZXNlcnZlV2l0aGRyYXcAAAwYYXNzZXRzVQoccmVzZXJ2ZRUKDHhjbXUKQEluaXRpYXRlVGVsZXBvcnQAAAwYYXNzZXRzVQoQZGVzdBUKDHhjbXUKNFJlcG9ydEhvbGRpbmcAAAg0cmVzcG9uc2VfaW5mb00KGGFzc2V0c1UKMEJ1eUV4ZWN1dGlvbgAACBBmZWVzNQowd2VpZ2h0X2xpbWl0eQM0UmVmdW5kU3VycGx1cwABBTxTZXRFcnJvckhhbmRsZXIBdQosU2V0QXBwZW5kaXgBdQooQ2xlYXJFcnJvcgABBShDbGFpbUFzc2V0AAAIGGFzc2V0czkKGHRpY2tldBUKEFRyYXABCEBTdWJzY3JpYmVWZXJzaW9uAAAIIHF1ZXJ5X2lkCExtYXhfcmVzcG9uc2Vfd2VpZ2h0GEhVbnN1YnNjcmliZVZlcnNpb24AAQUkQnVybkFzc2V0ATkKLEV4cGVjdEFzc2V0ATkKMEV4cGVjdE9yaWdpbgFJCixFeHBlY3RFcnJvcgFBClBFeHBlY3RUcmFuc2FjdFN0YXR1cwFZAyxRdWVyeVBhbGxldAAACCxtb2R1bGVfbmFtZSQ0cmVzcG9uc2VfaW5mb00KMEV4cGVjdFBhbGxldAAAFBRpbmRleAQQbmFtZSQsbW9kdWxlX25hbWUkLGNyYXRlX21ham9yBDxtaW5fY3JhdGVfbWlub3IEUFJlcG9ydFRyYW5zYWN0U3RhdHVzAU0KTENsZWFyVHJhbnNhY3RTdGF0dXMAAQU8VW5pdmVyc2FsT3JpZ2luAfEJNEV4cG9ydE1lc3NhZ2UAAAwcbmV0d29ya+kJLGRlc3RpbmF0aW9uEQoMeGNtdQokTG9ja0Fzc2V0AAAIFGFzc2V0NQogdW5sb2NrZXIVCixVbmxvY2tBc3NldAAACBRhc3NldDUKGHRhcmdldBUKOE5vdGVVbmxvY2thYmxlAAAIFGFzc2V0NQoUb3duZXIVCjRSZXF1ZXN0VW5sb2NrAAAIFGFzc2V0NQoYbG9ja2VyFQosU2V0RmVlc01vZGUAAAQwaml0X3dpdGhkcmF3FCBTZXRUb3BpYwEgKENsZWFyVG9waWMAAQUsQWxpYXNPcmlnaW4BFQo8VW5wYWlkRXhlY3V0aW9uAAAIMHdlaWdodF9saW1pdHkDMGNoZWNrX29yaWdpbkkKHFBheUZlZXMAAAQUYXNzZXQ1CkBJbml0aWF0ZVRyYW5zZmVyAAAULGRlc3RpbmF0aW9uFQoscmVtb3RlX2ZlZXNdCjxwcmVzZXJ2ZV9vcmlnaW4UGGFzc2V0c2EKKHJlbW90ZV94Y211CkRFeGVjdXRlV2l0aE9yaWdpbgAACERkZXNjZW5kYW50X29yaWdpbmUKDHhjbXUKIFNldEhpbnRzAAAEFGhpbnRzbQoEcQoAAhw0Tm90QXBwbGljYWJsZQABBSRUcmFuc3BvcnQAAQUoVW5yb3V0YWJsZQABBVhEZXN0aW5hdGlvblVuc3VwcG9ydGVkAAEFVEV4Y2VlZHNNYXhNZXNzYWdlU2l6ZQABBTxNaXNzaW5nQXJndW1lbnQAAQUQRmVlcwABBQIMCFYzAbUDCFY0AUUDCFY1ATkKAgwIVjMBEQIIVjQBEQIIVjUBFQoCdCRBdHRlbXB0ZWQAAAQcb3V0Y29tZTEKEFNlbnQAABAYb3JpZ2luFQosZGVzdGluYXRpb24VChxtZXNzYWdldQoobWVzc2FnZV9pZCAoU2VuZEZhaWxlZAAAEBhvcmlnaW4VCixkZXN0aW5hdGlvbhUKFGVycm9yeQoobWVzc2FnZV9pZCA8UHJvY2Vzc1hjbUVycm9yAAAMGG9yaWdpbhUKFGVycm9yKQoobWVzc2FnZV9pZCBIVW5leHBlY3RlZFJlc3BvbnNlAAAIGG9yaWdpbhUKIHF1ZXJ5X2lkCDRSZXNwb25zZVJlYWR5AAAIIHF1ZXJ5X2lkCCByZXNwb25zZUUKIE5vdGlmaWVkAAAMIHF1ZXJ5X2lkCDBwYWxsZXRfaW5kZXgEKGNhbGxfaW5kZXgEQE5vdGlmeU92ZXJ3ZWlnaHQAABQgcXVlcnlfaWQIMHBhbGxldF9pbmRleAQoY2FsbF9pbmRleAQ0YWN0dWFsX3dlaWdodBhMbWF4X2J1ZGdldGVkX3dlaWdodBhMTm90aWZ5RGlzcGF0Y2hFcnJvcgAADCBxdWVyeV9pZAgwcGFsbGV0X2luZGV4BChjYWxsX2luZGV4BEhOb3RpZnlEZWNvZGVGYWlsZWQAAAwgcXVlcnlfaWQIMHBhbGxldF9pbmRleAQoY2FsbF9pbmRleARASW52YWxpZFJlc3BvbmRlcgAADBhvcmlnaW4VCiBxdWVyeV9pZAhEZXhwZWN0ZWRfbG9jYXRpb25JClxJbnZhbGlkUmVzcG9uZGVyVmVyc2lvbgAACBhvcmlnaW4VCiBxdWVyeV9pZAg0UmVzcG9uc2VUYWtlbgAABCBxdWVyeV9pZAg0QXNzZXRzVHJhcHBlZAAADBBoYXNoIBhvcmlnaW4VChhhc3NldHN9ClRWZXJzaW9uQ2hhbmdlTm90aWZpZWQAABAsZGVzdGluYXRpb24VChhyZXN1bHQEEGNvc3Q5CihtZXNzYWdlX2lkIFxTdXBwb3J0ZWRWZXJzaW9uQ2hhbmdlZAAACCBsb2NhdGlvbhUKHHZlcnNpb24EUE5vdGlmeVRhcmdldFNlbmRGYWlsAAAMIGxvY2F0aW9uFQogcXVlcnlfaWQIFGVycm9yKQpkTm90aWZ5VGFyZ2V0TWlncmF0aW9uRmFpbAAACCBsb2NhdGlvboEKIHF1ZXJ5X2lkCFRJbnZhbGlkUXVlcmllclZlcnNpb24AAAgYb3JpZ2luFQogcXVlcnlfaWQIOEludmFsaWRRdWVyaWVyAAAQGG9yaWdpbhUKIHF1ZXJ5X2lkCEBleHBlY3RlZF9xdWVyaWVyFQpQbWF5YmVfYWN0dWFsX3F1ZXJpZXJJClBWZXJzaW9uTm90aWZ5U3RhcnRlZAAADCxkZXN0aW5hdGlvbhUKEGNvc3Q5CihtZXNzYWdlX2lkIFhWZXJzaW9uTm90aWZ5UmVxdWVzdGVkAAAMLGRlc3RpbmF0aW9uFQoQY29zdDkKKG1lc3NhZ2VfaWQgYFZlcnNpb25Ob3RpZnlVbnJlcXVlc3RlZAAADCxkZXN0aW5hdGlvbhUKEGNvc3Q5CihtZXNzYWdlX2lkICBGZWVzUGFpZAAACBhwYXlpbmcVChBmZWVzOQo0QXNzZXRzQ2xhaW1lZAAADBBoYXNoIBhvcmlnaW4VChhhc3NldHN9CmBWZXJzaW9uTWlncmF0aW9uRmluaXNoZWQAAAQcdmVyc2lvbgQ8QWxpYXNBdXRob3JpemVkAAAMHGFsaWFzZXIVChh0YXJnZXQVChhleHBpcnmpAWRBbGlhc0F1dGhvcml6YXRpb25SZW1vdmVkAAAIHGFsaWFzZXIVChh0YXJnZXQVCnBBbGlhc2VzQXV0aG9yaXphdGlvbnNSZW1vdmVkAAAEGHRhcmdldBUKAgw0SW52YWxpZEZvcm1hdAEgSFVuc3VwcG9ydGVkVmVyc2lvbgEgQEV4ZWN1dGVkRG93bndhcmQAAwggMQoCCGhEZWxpdmVyeUZlZUZhY3RvckRlY3JlYXNlZAAABCRuZXdfdmFsdWUIaERlbGl2ZXJ5RmVlRmFjdG9ySW5jcmVhc2VkAAAEJG5ld192YWx1ZQgCCBhOb3JtYWwAAQUYSGFsdGVkAAEFAggsTWVzc2FnZVNlbnQAABAYb3JpZ2luFQosZGVzdGluYXRpb24VChxtZXNzYWdldQoobWVzc2FnZV9pZCBoRXhwb3J0T3BlcmF0aW5nTW9kZUNoYW5nZWQAAAQQbW9kZZEKAiBAQmF0Y2hJbnRlcnJ1cHRlZAAACBRpbmRleAQUZXJyb3KpCThCYXRjaENvbXBsZXRlZAABBWBCYXRjaENvbXBsZXRlZFdpdGhFcnJvcnMAAQU0SXRlbUNvbXBsZXRlZAABBShJdGVtRmFpbGVkAAAEFGVycm9yqQkwRGlzcGF0Y2hlZEFzAAAEGHJlc3VsdLEJRElmRWxzZU1haW5TdWNjZXNzAAEFUElmRWxzZUZhbGxiYWNrQ2FsbGVkAAAEKG1haW5fZXJyb3KpCQIULE5ld011bHRpc2lnAAAMJGFwcHJvdmluZwAgbXVsdGlzaWcAJGNhbGxfaGFzaCBATXVsdGlzaWdBcHByb3ZhbAAAECRhcHByb3ZpbmcAJHRpbWVwb2ludJ0BIG11bHRpc2lnACRjYWxsX2hhc2ggQE11bHRpc2lnRXhlY3V0ZWQAABQkYXBwcm92aW5nACR0aW1lcG9pbnSdASBtdWx0aXNpZwAkY2FsbF9oYXNoIBhyZXN1bHSxCURNdWx0aXNpZ0NhbmNlbGxlZAAAEChjYW5jZWxsaW5nACR0aW1lcG9pbnSdASBtdWx0aXNpZwAkY2FsbF9oYXNoIDBEZXBvc2l0UG9rZWQAABAMd2hvACRjYWxsX2hhc2ggLG9sZF9kZXBvc2l0CCxuZXdfZGVwb3NpdAgCMAxBbnkAAQUsTm9uVHJhbnNmZXIAAQUsQ2FuY2VsUHJveHkAAQUYQXNzZXRzAAEFKEFzc2V0T3duZXIAAQUwQXNzZXRNYW5hZ2VyAAEFIENvbGxhdG9yAAEFKEdvdmVybmFuY2UAAQUcU3Rha2luZwABBTxOb21pbmF0aW9uUG9vbHMAAQUcQXVjdGlvbgABBUBQYXJhUmVnaXN0cmF0aW9uAAEFAggcUHJveGllcwABBTRBbm5vdW5jZW1lbnRzAAEFAhw0UHJveHlFeGVjdXRlZAAABBhyZXN1bHSxCSxQdXJlQ3JlYXRlZAAAEBBwdXJlAAx3aG8AKHByb3h5X3R5cGWhClBkaXNhbWJpZ3VhdGlvbl9pbmRleAQoUHVyZUtpbGxlZAAAEBBwdXJlABxzcGF3bmVyAChwcm94eV90eXBloQpQZGlzYW1iaWd1YXRpb25faW5kZXgEJEFubm91bmNlZAAADBByZWFsABRwcm94eQAkY2FsbF9oYXNoIChQcm94eUFkZGVkAAAQJGRlbGVnYXRvcgAkZGVsZWdhdGVlAChwcm94eV90eXBloQoUZGVsYXkEMFByb3h5UmVtb3ZlZAAAECRkZWxlZ2F0b3IAJGRlbGVnYXRlZQAocHJveHlfdHlwZaEKFGRlbGF5BDBEZXBvc2l0UG9rZWQAABAMd2hvABBraW5kpQosb2xkX2RlcG9zaXQILG5ld19kZXBvc2l0CAIQNEluZGV4QXNzaWduZWQAAAgMd2hvABRpbmRleAQoSW5kZXhGcmVlZAAABBRpbmRleAQsSW5kZXhGcm96ZW4AAAgUaW5kZXgEDHdobwAwRGVwb3NpdFBva2VkAAAQDHdobwAUaW5kZXgELG9sZF9kZXBvc2l0CCxuZXdfZGVwb3NpdAgCaBxDcmVhdGVkAAAMIGFzc2V0X2lkBBxjcmVhdG9yABRvd25lcgAYSXNzdWVkAAAMIGFzc2V0X2lkBBRvd25lcgAYYW1vdW50CCxUcmFuc2ZlcnJlZAAAECBhc3NldF9pZAQQZnJvbQAIdG8AGGFtb3VudAgYQnVybmVkAAAMIGFzc2V0X2lkBBRvd25lcgAcYmFsYW5jZQgsVGVhbUNoYW5nZWQAABAgYXNzZXRfaWQEGGlzc3VlcgAUYWRtaW4AHGZyZWV6ZXIAME93bmVyQ2hhbmdlZAAACCBhc3NldF9pZAQUb3duZXIAGEZyb3plbgAACCBhc3NldF9pZAQMd2hvABhUaGF3ZWQAAAggYXNzZXRfaWQEDHdobwAsQXNzZXRGcm96ZW4AAAQgYXNzZXRfaWQELEFzc2V0VGhhd2VkAAAEIGFzc2V0X2lkBERBY2NvdW50c0Rlc3Ryb3llZAAADCBhc3NldF9pZARIYWNjb3VudHNfZGVzdHJveWVkBEhhY2NvdW50c19yZW1haW5pbmcESEFwcHJvdmFsc0Rlc3Ryb3llZAAADCBhc3NldF9pZARMYXBwcm92YWxzX2Rlc3Ryb3llZARMYXBwcm92YWxzX3JlbWFpbmluZwRIRGVzdHJ1Y3Rpb25TdGFydGVkAAAEIGFzc2V0X2lkBCREZXN0cm95ZWQAAAQgYXNzZXRfaWQEMEZvcmNlQ3JlYXRlZAAACCBhc3NldF9pZAQUb3duZXIALE1ldGFkYXRhU2V0AAAUIGFzc2V0X2lkBBBuYW1lJBhzeW1ib2wkIGRlY2ltYWxzBCRpc19mcm96ZW4UPE1ldGFkYXRhQ2xlYXJlZAAABCBhc3NldF9pZARAQXBwcm92ZWRUcmFuc2ZlcgAAECBhc3NldF9pZAQYc291cmNlACBkZWxlZ2F0ZQAYYW1vdW50CERBcHByb3ZhbENhbmNlbGxlZAAADCBhc3NldF9pZAQUb3duZXIAIGRlbGVnYXRlAExUcmFuc2ZlcnJlZEFwcHJvdmVkAAAUIGFzc2V0X2lkBBRvd25lcgAgZGVsZWdhdGUALGRlc3RpbmF0aW9uABhhbW91bnQISEFzc2V0U3RhdHVzQ2hhbmdlZAAABCBhc3NldF9pZARYQXNzZXRNaW5CYWxhbmNlQ2hhbmdlZAAACCBhc3NldF9pZAQ8bmV3X21pbl9iYWxhbmNlCBxUb3VjaGVkAAAMIGFzc2V0X2lkBAx3aG8AJGRlcG9zaXRvcgAcQmxvY2tlZAAACCBhc3NldF9pZAQMd2hvACREZXBvc2l0ZWQAAAwgYXNzZXRfaWQEDHdobwAYYW1vdW50CCRXaXRoZHJhd24AAAwgYXNzZXRfaWQEDHdobwAYYW1vdW50CAJsHENyZWF0ZWQAAAwoY29sbGVjdGlvbgQcY3JlYXRvcgAUb3duZXIAMEZvcmNlQ3JlYXRlZAAACChjb2xsZWN0aW9uBBRvd25lcgAkRGVzdHJveWVkAAAEKGNvbGxlY3Rpb24EGElzc3VlZAAADChjb2xsZWN0aW9uBBBpdGVtBBRvd25lcgAsVHJhbnNmZXJyZWQAABAoY29sbGVjdGlvbgQQaXRlbQQQZnJvbQAIdG8AGEJ1cm5lZAAADChjb2xsZWN0aW9uBBBpdGVtBBRvd25lcgAYRnJvemVuAAAIKGNvbGxlY3Rpb24EEGl0ZW0EGFRoYXdlZAAACChjb2xsZWN0aW9uBBBpdGVtBEBDb2xsZWN0aW9uRnJvemVuAAAEKGNvbGxlY3Rpb24EQENvbGxlY3Rpb25UaGF3ZWQAAAQoY29sbGVjdGlvbgQwT3duZXJDaGFuZ2VkAAAIKGNvbGxlY3Rpb24EJG5ld19vd25lcgAsVGVhbUNoYW5nZWQAABAoY29sbGVjdGlvbgQYaXNzdWVyABRhZG1pbgAcZnJlZXplcgBAQXBwcm92ZWRUcmFuc2ZlcgAAEChjb2xsZWN0aW9uBBBpdGVtBBRvd25lcgAgZGVsZWdhdGUAREFwcHJvdmFsQ2FuY2VsbGVkAAAQKGNvbGxlY3Rpb24EEGl0ZW0EFG93bmVyACBkZWxlZ2F0ZQBESXRlbVN0YXR1c0NoYW5nZWQAAAQoY29sbGVjdGlvbgRUQ29sbGVjdGlvbk1ldGFkYXRhU2V0AAAMKGNvbGxlY3Rpb24EEGRhdGEkJGlzX2Zyb3plbhRkQ29sbGVjdGlvbk1ldGFkYXRhQ2xlYXJlZAAABChjb2xsZWN0aW9uBCxNZXRhZGF0YVNldAAAEChjb2xsZWN0aW9uBBBpdGVtBBBkYXRhJCRpc19mcm96ZW4UPE1ldGFkYXRhQ2xlYXJlZAAACChjb2xsZWN0aW9uBBBpdGVtBCxSZWRlcG9zaXRlZAAACChjb2xsZWN0aW9uBEBzdWNjZXNzZnVsX2l0ZW1zTQIwQXR0cmlidXRlU2V0AAAQKGNvbGxlY3Rpb24EKG1heWJlX2l0ZW3xAQxrZXkkFHZhbHVlJEBBdHRyaWJ1dGVDbGVhcmVkAAAMKGNvbGxlY3Rpb24EKG1heWJlX2l0ZW3xAQxrZXkkaE93bmVyc2hpcEFjY2VwdGFuY2VDaGFuZ2VkAAAIDHdobwBAbWF5YmVfY29sbGVjdGlvbvEBWENvbGxlY3Rpb25NYXhTdXBwbHlTZXQAAAgoY29sbGVjdGlvbgQobWF4X3N1cHBseQQwSXRlbVByaWNlU2V0AAAQKGNvbGxlY3Rpb24EEGl0ZW0EFHByaWNlCER3aGl0ZWxpc3RlZF9idXllcq0BQEl0ZW1QcmljZVJlbW92ZWQAAAgoY29sbGVjdGlvbgQQaXRlbQQoSXRlbUJvdWdodAAAFChjb2xsZWN0aW9uBBBpdGVtBBRwcmljZQgYc2VsbGVyABRidXllcgACEBhQYWxsZXQAAQU8Q29sbGVjdGlvbk93bmVyAAEFJEl0ZW1Pd25lcgABBRxBY2NvdW50AQACCBBTZW5kAAEFHFJlY2VpdmUAAQUACBhhbW91bnQIJGRpcmVjdGlvbr0KBsEKAggsVXNlZFRvQ2xhaW0BBEBUcmFuc2ZlckRpc2FibGVkAAEFApgcQ3JlYXRlZAAADChjb2xsZWN0aW9uBBxjcmVhdG9yABRvd25lcgAwRm9yY2VDcmVhdGVkAAAIKGNvbGxlY3Rpb24EFG93bmVyACREZXN0cm95ZWQAAAQoY29sbGVjdGlvbgQYSXNzdWVkAAAMKGNvbGxlY3Rpb24EEGl0ZW0EFG93bmVyACxUcmFuc2ZlcnJlZAAAEChjb2xsZWN0aW9uBBBpdGVtBBBmcm9tAAh0bwAYQnVybmVkAAAMKGNvbGxlY3Rpb24EEGl0ZW0EFG93bmVyAEhJdGVtVHJhbnNmZXJMb2NrZWQAAAgoY29sbGVjdGlvbgQQaXRlbQRQSXRlbVRyYW5zZmVyVW5sb2NrZWQAAAgoY29sbGVjdGlvbgQQaXRlbQRQSXRlbVByb3BlcnRpZXNMb2NrZWQAABAoY29sbGVjdGlvbgQQaXRlbQQ0bG9ja19tZXRhZGF0YRQ8bG9ja19hdHRyaWJ1dGVzFEBDb2xsZWN0aW9uTG9ja2VkAAAEKGNvbGxlY3Rpb24EME93bmVyQ2hhbmdlZAAACChjb2xsZWN0aW9uBCRuZXdfb3duZXIALFRlYW1DaGFuZ2VkAAAQKGNvbGxlY3Rpb24EGGlzc3Vlcq0BFGFkbWlurQEcZnJlZXplcq0BQFRyYW5zZmVyQXBwcm92ZWQAABQoY29sbGVjdGlvbgQQaXRlbQQUb3duZXIAIGRlbGVnYXRlACBkZWFkbGluZfEBREFwcHJvdmFsQ2FuY2VsbGVkAAAQKGNvbGxlY3Rpb24EEGl0ZW0EFG93bmVyACBkZWxlZ2F0ZQBUQWxsQXBwcm92YWxzQ2FuY2VsbGVkAAAMKGNvbGxlY3Rpb24EEGl0ZW0EFG93bmVyAFxDb2xsZWN0aW9uQ29uZmlnQ2hhbmdlZAAABChjb2xsZWN0aW9uBFRDb2xsZWN0aW9uTWV0YWRhdGFTZXQAAAgoY29sbGVjdGlvbgQQZGF0YSRkQ29sbGVjdGlvbk1ldGFkYXRhQ2xlYXJlZAAABChjb2xsZWN0aW9uBDxJdGVtTWV0YWRhdGFTZXQAAAwoY29sbGVjdGlvbgQQaXRlbQQQZGF0YSRMSXRlbU1ldGFkYXRhQ2xlYXJlZAAACChjb2xsZWN0aW9uBBBpdGVtBCxSZWRlcG9zaXRlZAAACChjb2xsZWN0aW9uBEBzdWNjZXNzZnVsX2l0ZW1zTQIwQXR0cmlidXRlU2V0AAAUKGNvbGxlY3Rpb24EKG1heWJlX2l0ZW3xAQxrZXkkFHZhbHVlJCRuYW1lc3BhY2W5CkBBdHRyaWJ1dGVDbGVhcmVkAAAQKGNvbGxlY3Rpb24EKG1heWJlX2l0ZW3xAQxrZXkkJG5hbWVzcGFjZbkKbEl0ZW1BdHRyaWJ1dGVzQXBwcm92YWxBZGRlZAAADChjb2xsZWN0aW9uBBBpdGVtBCBkZWxlZ2F0ZQB0SXRlbUF0dHJpYnV0ZXNBcHByb3ZhbFJlbW92ZWQAAAwoY29sbGVjdGlvbgQQaXRlbQQgZGVsZWdhdGUAaE93bmVyc2hpcEFjY2VwdGFuY2VDaGFuZ2VkAAAIDHdobwBAbWF5YmVfY29sbGVjdGlvbvEBWENvbGxlY3Rpb25NYXhTdXBwbHlTZXQAAAgoY29sbGVjdGlvbgQobWF4X3N1cHBseQR0Q29sbGVjdGlvbk1pbnRTZXR0aW5nc1VwZGF0ZWQAAAQoY29sbGVjdGlvbgRsTmV4dENvbGxlY3Rpb25JZEluY3JlbWVudGVkAAAEHG5leHRfaWTxATBJdGVtUHJpY2VTZXQAABAoY29sbGVjdGlvbgQQaXRlbQQUcHJpY2UIRHdoaXRlbGlzdGVkX2J1eWVyrQFASXRlbVByaWNlUmVtb3ZlZAAACChjb2xsZWN0aW9uBBBpdGVtBChJdGVtQm91Z2h0AAAUKGNvbGxlY3Rpb24EEGl0ZW0EFHByaWNlCBhzZWxsZXIAFGJ1eWVyABxUaXBTZW50AAAUKGNvbGxlY3Rpb24EEGl0ZW0EGHNlbmRlcgAgcmVjZWl2ZXIAGGFtb3VudAgsU3dhcENyZWF0ZWQAABhIb2ZmZXJlZF9jb2xsZWN0aW9uBDBvZmZlcmVkX2l0ZW0ESGRlc2lyZWRfY29sbGVjdGlvbgQwZGVzaXJlZF9pdGVt8QEUcHJpY2XFCiBkZWFkbGluZQQ0U3dhcENhbmNlbGxlZAAAGEhvZmZlcmVkX2NvbGxlY3Rpb24EMG9mZmVyZWRfaXRlbQRIZGVzaXJlZF9jb2xsZWN0aW9uBDBkZXNpcmVkX2l0ZW3xARRwcmljZcUKIGRlYWRsaW5lBCxTd2FwQ2xhaW1lZAAAIDxzZW50X2NvbGxlY3Rpb24EJHNlbnRfaXRlbQQ8c2VudF9pdGVtX293bmVyAExyZWNlaXZlZF9jb2xsZWN0aW9uBDRyZWNlaXZlZF9pdGVtBExyZWNlaXZlZF9pdGVtX293bmVyABRwcmljZcUKIGRlYWRsaW5lBFhQcmVTaWduZWRBdHRyaWJ1dGVzU2V0AAAMKGNvbGxlY3Rpb24EEGl0ZW0EJG5hbWVzcGFjZbkKSFBhbGxldEF0dHJpYnV0ZVNldAAAEChjb2xsZWN0aW9uBBBpdGVt8QEkYXR0cmlidXRlyQoUdmFsdWUkAmgcQ3JlYXRlZAAADCBhc3NldF9pZBUKHGNyZWF0b3IAFG93bmVyABhJc3N1ZWQAAAwgYXNzZXRfaWQVChRvd25lcgAYYW1vdW50CCxUcmFuc2ZlcnJlZAAAECBhc3NldF9pZBUKEGZyb20ACHRvABhhbW91bnQIGEJ1cm5lZAAADCBhc3NldF9pZBUKFG93bmVyABxiYWxhbmNlCCxUZWFtQ2hhbmdlZAAAECBhc3NldF9pZBUKGGlzc3VlcgAUYWRtaW4AHGZyZWV6ZXIAME93bmVyQ2hhbmdlZAAACCBhc3NldF9pZBUKFG93bmVyABhGcm96ZW4AAAggYXNzZXRfaWQVCgx3aG8AGFRoYXdlZAAACCBhc3NldF9pZBUKDHdobwAsQXNzZXRGcm96ZW4AAAQgYXNzZXRfaWQVCixBc3NldFRoYXdlZAAABCBhc3NldF9pZBUKREFjY291bnRzRGVzdHJveWVkAAAMIGFzc2V0X2lkFQpIYWNjb3VudHNfZGVzdHJveWVkBEhhY2NvdW50c19yZW1haW5pbmcESEFwcHJvdmFsc0Rlc3Ryb3llZAAADCBhc3NldF9pZBUKTGFwcHJvdmFsc19kZXN0cm95ZWQETGFwcHJvdmFsc19yZW1haW5pbmcESERlc3RydWN0aW9uU3RhcnRlZAAABCBhc3NldF9pZBUKJERlc3Ryb3llZAAABCBhc3NldF9pZBUKMEZvcmNlQ3JlYXRlZAAACCBhc3NldF9pZBUKFG93bmVyACxNZXRhZGF0YVNldAAAFCBhc3NldF9pZBUKEG5hbWUkGHN5bWJvbCQgZGVjaW1hbHMEJGlzX2Zyb3plbhQ8TWV0YWRhdGFDbGVhcmVkAAAEIGFzc2V0X2lkFQpAQXBwcm92ZWRUcmFuc2ZlcgAAECBhc3NldF9pZBUKGHNvdXJjZQAgZGVsZWdhdGUAGGFtb3VudAhEQXBwcm92YWxDYW5jZWxsZWQAAAwgYXNzZXRfaWQVChRvd25lcgAgZGVsZWdhdGUATFRyYW5zZmVycmVkQXBwcm92ZWQAABQgYXNzZXRfaWQVChRvd25lcgAgZGVsZWdhdGUALGRlc3RpbmF0aW9uABhhbW91bnQISEFzc2V0U3RhdHVzQ2hhbmdlZAAABCBhc3NldF9pZBUKWEFzc2V0TWluQmFsYW5jZUNoYW5nZWQAAAggYXNzZXRfaWQVCjxuZXdfbWluX2JhbGFuY2UIHFRvdWNoZWQAAAwgYXNzZXRfaWQVCgx3aG8AJGRlcG9zaXRvcgAcQmxvY2tlZAAACCBhc3NldF9pZBUKDHdobwAkRGVwb3NpdGVkAAAMIGFzc2V0X2lkFQoMd2hvABhhbW91bnQIJFdpdGhkcmF3bgAADCBhc3NldF9pZBUKDHdobwAYYW1vdW50CAQVCgEIAwgVCggE2QoAAhgsUG9vbENyZWF0ZWQAABAcY3JlYXRvcgAccG9vbF9pZNUKMHBvb2xfYWNjb3VudAAgbHBfdG9rZW4EOExpcXVpZGl0eUFkZGVkAAAcDHdobwAcbWludF90bwAccG9vbF9pZNUKQGFtb3VudDFfcHJvdmlkZWQIQGFtb3VudDJfcHJvdmlkZWQIIGxwX3Rva2VuBDxscF90b2tlbl9taW50ZWQIQExpcXVpZGl0eVJlbW92ZWQAACAMd2hvACx3aXRoZHJhd190bwAccG9vbF9pZNUKHGFtb3VudDEIHGFtb3VudDIIIGxwX3Rva2VuBDxscF90b2tlbl9idXJuZWQIOHdpdGhkcmF3YWxfZmVlBDBTd2FwRXhlY3V0ZWQAABQMd2hvABxzZW5kX3RvACRhbW91bnRfaW4IKGFtb3VudF9vdXQIEHBhdGjdCkhTd2FwQ3JlZGl0RXhlY3V0ZWQAAAwkYW1vdW50X2luCChhbW91bnRfb3V0CBBwYXRo3QocVG91Y2hlZAAACBxwb29sX2lk1QoMd2hvAAIMCFYzAAAIIGxvY2F0aW9uEQIgYXNzZXRfaWStAwhWNAAACCBsb2NhdGlvbhECIGFzc2V0X2lkEQIIVjUAAAggbG9jYXRpb24VCiBhc3NldF9pZBUKAggIVjQAAAggbG9jYXRpb24RAihhY2NvdW50X2lkEQIIVjUAAAggbG9jYXRpb24VCihhY2NvdW50X2lkFQoCMCBTcGVuZGluZwAABEBidWRnZXRfcmVtYWluaW5nCBxBd2FyZGVkAAAMOHByb3Bvc2FsX2luZGV4BBRhd2FyZAgcYWNjb3VudAAUQnVybnQAAAQsYnVybnRfZnVuZHMIIFJvbGxvdmVyAAAEQHJvbGxvdmVyX2JhbGFuY2UIHERlcG9zaXQAAAQUdmFsdWUINFNwZW5kQXBwcm92ZWQAAAw4cHJvcG9zYWxfaW5kZXgEGGFtb3VudAgsYmVuZWZpY2lhcnkAPFVwZGF0ZWRJbmFjdGl2ZQAACCxyZWFjdGl2YXRlZAgsZGVhY3RpdmF0ZWQISEFzc2V0U3BlbmRBcHByb3ZlZAAAGBRpbmRleAQoYXNzZXRfa2luZOUKGGFtb3VudAgsYmVuZWZpY2lhcnnpCih2YWxpZF9mcm9tBCRleHBpcmVfYXQEQEFzc2V0U3BlbmRWb2lkZWQAAAQUaW5kZXgEEFBhaWQAAAgUaW5kZXgEKHBheW1lbnRfaWQINFBheW1lbnRGYWlsZWQAAAgUaW5kZXgEKHBheW1lbnRfaWQIOFNwZW5kUHJvY2Vzc2VkAAAEFGluZGV4BAIUJERlbGVnYXRlZAAEAAEILFVuZGVsZWdhdGVkAQAUVm90ZWQAAAgMd2hvABB2b3RlvQEsVm90ZVJlbW92ZWQAAAgMd2hvABB2b3RlvQEwVm90ZVVubG9ja2VkAAAIDHdobwAUY2xhc3MEAAgkcG9zdF9pbmZv1QEUZXJyb3KpCQfVAfUKAgw8Q2FsbFdoaXRlbGlzdGVkAAAEJGNhbGxfaGFzaCBYV2hpdGVsaXN0ZWRDYWxsUmVtb3ZlZAAABCRjYWxsX2hhc2ggZFdoaXRlbGlzdGVkQ2FsbERpc3BhdGNoZWQAAAgkY2FsbF9oYXNoIBhyZXN1bHT5CgIwOEJvdW50eVByb3Bvc2VkAAAEFGluZGV4BDhCb3VudHlSZWplY3RlZAAACBRpbmRleAQQYm9uZAhIQm91bnR5QmVjYW1lQWN0aXZlAAAEFGluZGV4BDRCb3VudHlBd2FyZGVkAAAIFGluZGV4BCxiZW5lZmljaWFyeQA0Qm91bnR5Q2xhaW1lZAAADBRpbmRleAQYcGF5b3V0CCxiZW5lZmljaWFyeQA4Qm91bnR5Q2FuY2VsZWQAAAQUaW5kZXgEOEJvdW50eUV4dGVuZGVkAAAEFGluZGV4BDhCb3VudHlBcHByb3ZlZAAABBRpbmRleAQ8Q3VyYXRvclByb3Bvc2VkAAAIJGJvdW50eV9pZAQcY3VyYXRvcgBEQ3VyYXRvclVuYXNzaWduZWQAAAQkYm91bnR5X2lkBDxDdXJhdG9yQWNjZXB0ZWQAAAgkYm91bnR5X2lkBBxjdXJhdG9yADBEZXBvc2l0UG9rZWQAABAkYm91bnR5X2lkBCBwcm9wb3NlcgAsb2xkX2RlcG9zaXQILG5ld19kZXBvc2l0CAIQFEFkZGVkAAAIFGluZGV4BCxjaGlsZF9pbmRleAQcQXdhcmRlZAAADBRpbmRleAQsY2hpbGRfaW5kZXgELGJlbmVmaWNpYXJ5ABxDbGFpbWVkAAAQFGluZGV4BCxjaGlsZF9pbmRleAQYcGF5b3V0CCxiZW5lZmljaWFyeQAgQ2FuY2VsZWQAAAgUaW5kZXgELGNoaWxkX2luZGV4BAIMQEFzc2V0UmF0ZUNyZWF0ZWQAAAgoYXNzZXRfa2luZOUKEHJhdGUIQEFzc2V0UmF0ZVJlbW92ZWQAAAQoYXNzZXRfa2luZOUKQEFzc2V0UmF0ZVVwZGF0ZWQAAAwoYXNzZXRfa2luZOUKDG9sZAgMbmV3CAIMEE9wZW4AAQUcQmxvY2tlZAABBShEZXN0cm95aW5nAAEFAwgEAAYRCwAIMG1heF9pbmNyZWFzZQQkbWluX2RlbGF5BAIIOFBlcm1pc3Npb25sZXNzAAEFHEFjY291bnQBAAYdCwIQMFBlcm1pc3Npb25lZAABBVhQZXJtaXNzaW9ubGVzc0NvbXBvdW5kAAEFWFBlcm1pc3Npb25sZXNzV2l0aGRyYXcAAQVEUGVybWlzc2lvbmxlc3NBbGwAAQUCXBxDcmVhdGVkAAAIJGRlcG9zaXRvcgAccG9vbF9pZAQYQm9uZGVkAAAQGG1lbWJlcgAccG9vbF9pZAQYYm9uZGVkCBhqb2luZWQUHFBhaWRPdXQAAAwYbWVtYmVyABxwb29sX2lkBBhwYXlvdXQIIFVuYm9uZGVkAAAUGG1lbWJlcgAccG9vbF9pZAQcYmFsYW5jZQgYcG9pbnRzCAxlcmEEJFdpdGhkcmF3bgAAEBhtZW1iZXIAHHBvb2xfaWQEHGJhbGFuY2UIGHBvaW50cwgkRGVzdHJveWVkAAAEHHBvb2xfaWQEMFN0YXRlQ2hhbmdlZAAACBxwb29sX2lkBCRuZXdfc3RhdGUNCzRNZW1iZXJSZW1vdmVkAAAMHHBvb2xfaWQEGG1lbWJlcgBAcmVsZWFzZWRfYmFsYW5jZQgwUm9sZXNVcGRhdGVkAAAMEHJvb3StARxib3VuY2VyrQEkbm9taW5hdG9yrQEsUG9vbFNsYXNoZWQAAAgccG9vbF9pZAQcYmFsYW5jZQhQVW5ib25kaW5nUG9vbFNsYXNoZWQAAAwccG9vbF9pZAQMZXJhBBxiYWxhbmNlCFRQb29sQ29tbWlzc2lvblVwZGF0ZWQAAAgccG9vbF9pZAQcY3VycmVudBULYFBvb2xNYXhDb21taXNzaW9uVXBkYXRlZAAACBxwb29sX2lkBDhtYXhfY29tbWlzc2lvbgR8UG9vbENvbW1pc3Npb25DaGFuZ2VSYXRlVXBkYXRlZAAACBxwb29sX2lkBCxjaGFuZ2VfcmF0ZRkLkFBvb2xDb21taXNzaW9uQ2xhaW1QZXJtaXNzaW9uVXBkYXRlZAAACBxwb29sX2lkBChwZXJtaXNzaW9uIQtUUG9vbENvbW1pc3Npb25DbGFpbWVkAAAIHHBvb2xfaWQEKGNvbW1pc3Npb24IZE1pbkJhbGFuY2VEZWZpY2l0QWRqdXN0ZWQAAAgccG9vbF9pZAQYYW1vdW50CGBNaW5CYWxhbmNlRXhjZXNzQWRqdXN0ZWQAAAgccG9vbF9pZAQYYW1vdW50CHBNZW1iZXJDbGFpbVBlcm1pc3Npb25VcGRhdGVkAAAIGG1lbWJlcgAocGVybWlzc2lvbiULPE1ldGFkYXRhVXBkYXRlZAAACBxwb29sX2lkBBhjYWxsZXIASFBvb2xOb21pbmF0aW9uTWFkZQAACBxwb29sX2lkBBhjYWxsZXIAUFBvb2xOb21pbmF0b3JDaGlsbGVkAAAIHHBvb2xfaWQEGGNhbGxlcgBMR2xvYmFsUGFyYW1zVXBkYXRlZAAAGDRtaW5fam9pbl9ib25kCDxtaW5fY3JlYXRlX2JvbmQIJG1heF9wb29sc/EBLG1heF9tZW1iZXJz8QFQbWF4X21lbWJlcnNfcGVyX3Bvb2zxAVRnbG9iYWxfbWF4X2NvbW1pc3Npb27xAQIIIFJlYmFnZ2VkAAAMDHdobwAQZnJvbQgIdG8IMFNjb3JlVXBkYXRlZAAACAx3aG8AJG5ld19zY29yZQgCECREZWxlZ2F0ZWQAAAwUYWdlbnQAJGRlbGVnYXRvcgAYYW1vdW50CCBSZWxlYXNlZAAADBRhZ2VudAAkZGVsZWdhdG9yABhhbW91bnQIHFNsYXNoZWQAAAwUYWdlbnQAJGRlbGVnYXRvcgAYYW1vdW50CEhNaWdyYXRlZERlbGVnYXRpb24AAAwUYWdlbnQAJGRlbGVnYXRvcgAYYW1vdW50CAMICAQGNQsCGHBTZXNzaW9uUmVwb3J0SW50ZWdyaXR5RmFpbGVkAAEFbFZhbGlkYXRvclNldEludGVncml0eUZhaWxlZAABBThTZXNzaW9uU2tpcHBlZAABBVxTZXNzaW9uQWxyZWFkeVByb2Nlc3NlZAABBVhWYWxpZGF0b3JTZXRTZW5kRmFpbGVkAAEFTFZhbGlkYXRvclNldERyb3BwZWQAAQUCDFRTZXNzaW9uUmVwb3J0UmVjZWl2ZWQAABAkZW5kX2luZGV4BFBhY3RpdmF0aW9uX3RpbWVzdGFtcDkLXHZhbGlkYXRvcl9wb2ludHNfY291bnRzBCBsZWZ0b3ZlchQ8T2ZmZW5jZVJlY2VpdmVkAAAINHNsYXNoX3Nlc3Npb24EOG9mZmVuY2VzX2NvdW50BChVbmV4cGVjdGVkAT0LAiAMT2ZmAAEFGFNpZ25lZAEEQFNpZ25lZFZhbGlkYXRpb24BBCBVbnNpZ25lZAEEIFNuYXBzaG90AQQQRG9uZQABBRhFeHBvcnQBBCRFbWVyZ2VuY3kAAQUCDERQaGFzZVRyYW5zaXRpb25lZAAACBBmcm9tRQsIdG9FC3hVbmV4cGVjdGVkVGFyZ2V0U25hcHNob3RGYWlsZWQAAQV0VW5leHBlY3RlZFZvdGVyU25hcHNob3RGYWlsZWQAAQUCKFhTb2x1dGlvbldlaWdodE92ZXJmbG93AAEFWFNvbHV0aW9uVGFyZ2V0T3ZlcmZsb3cAAQVQU29sdXRpb25JbnZhbGlkSW5kZXgAAQVgU29sdXRpb25JbnZhbGlkUGFnZUluZGV4AAEFPEFyaXRobWV0aWNFcnJvcgABBUhJbnZhbGlkU3VwcG9ydEVkZ2UAAQU0VG9vTWFueVZvdGVycwABBThCb3VuZHNFeGNlZWRlZAABBThEdXBsaWNhdGVWb3RlcgABBTxEdXBsaWNhdGVUYXJnZXQAAQUCLEBXcm9uZ1dpbm5lckNvdW50AAEFTFNuYXBzaG90VW5hdmFpbGFibGUAAQUsSW52YWxpZFZvdGUAAQUwSW52YWxpZFZvdGVyAAEFNEludmFsaWRXaW5uZXIAAQUwSW52YWxpZFNjb3JlAAEFMEludmFsaWRSb3VuZAABBSxTY29yZVRvb0xvdwABBVBGYWlsZWRUb0JvdW5kU3VwcG9ydAABBTBOcG9zRWxlY3Rpb24BTQsoSW5jb21wbGV0ZQABBQAMNG1pbmltYWxfc3Rha2UIJHN1bV9zdGFrZQhEc3VtX3N0YWtlX3NxdWFyZWQIBlULAgxIVmVyaWZpY2F0aW9uRmFpbGVkAAMIBFELIFZlcmlmaWVkAAQEAQgYUXVldWVkAAMIVQtZCwIcKFJlZ2lzdGVyZWQAAwwEAFULGFN0b3JlZAADDAQABCBSZXdhcmRlZAADDAQACBxTbGFzaGVkAAMMBAAIHEVqZWN0ZWQAAwgEACREaXNjYXJkZWQAAwgEABhCYWlsZWQAAwgEAAIUGFN0YWtlZAABBRRTdGFzaAABBShDb250cm9sbGVyAAEFHEFjY291bnQBABBOb25lAAEFAAgoY29tbWlzc2lvbgQcYmxvY2tlZBQCEChOb3RGb3JjaW5nAAEFIEZvcmNlTmV3AAEFJEZvcmNlTm9uZQABBSxGb3JjZUFsd2F5cwABBQcEBAIIYEVyYUR1cmF0aW9uQm91bmRFeGNlZWRlZAABBWhVbmtub3duVmFsaWRhdG9yQWN0aXZhdGlvbgABBQJkHEVyYVBhaWQAAAwkZXJhX2luZGV4BEB2YWxpZGF0b3JfcGF5b3V0CCRyZW1haW5kZXIIIFJld2FyZGVkAAAMFHN0YXNoABBkZXN0ZQsYYW1vdW50CBxTbGFzaGVkAAAIGHN0YWtlcgAYYW1vdW50CGhPbGRTbGFzaGluZ1JlcG9ydERpc2NhcmRlZAAABDRzZXNzaW9uX2luZGV4BBhCb25kZWQAAAgUc3Rhc2gAGGFtb3VudAggVW5ib25kZWQAAAgUc3Rhc2gAGGFtb3VudAgkV2l0aGRyYXduAAAIFHN0YXNoABhhbW91bnQINFN0YWtlclJlbW92ZWQAAAQUc3Rhc2gAGEtpY2tlZAAACCRub21pbmF0b3IAFHN0YXNoABxDaGlsbGVkAAAEFHN0YXNoADRQYXlvdXRTdGFydGVkAAAQJGVyYV9pbmRleAQ8dmFsaWRhdG9yX3N0YXNoABBwYWdlBBBuZXh08QFEVmFsaWRhdG9yUHJlZnNTZXQAAAgUc3Rhc2gAFHByZWZzaQtoU25hcHNob3RWb3RlcnNTaXplRXhjZWVkZWQAAAQQc2l6ZQRsU25hcHNob3RUYXJnZXRzU2l6ZUV4Y2VlZGVkAAAEEHNpemUEIEZvcmNlRXJhAAAEEG1vZGVtC2RDb250cm9sbGVyQmF0Y2hEZXByZWNhdGVkAAAEIGZhaWx1cmVzBEBDdXJyZW5jeU1pZ3JhdGVkAAAIFHN0YXNoADhmb3JjZV93aXRoZHJhdwhYUGFnZWRFbGVjdGlvblByb2NlZWRlZAAACBBwYWdlBBhyZXN1bHRxCzxPZmZlbmNlUmVwb3J0ZWQAAAwsb2ZmZW5jZV9lcmEEJHZhbGlkYXRvcgAgZnJhY3Rpb24ENFNsYXNoQ29tcHV0ZWQAABAsb2ZmZW5jZV9lcmEEJHNsYXNoX2VyYQQgb2ZmZW5kZXIAEHBhZ2UEOFNsYXNoQ2FuY2VsbGVkAAAIJHNsYXNoX2VyYQQkdmFsaWRhdG9yADhTZXNzaW9uUm90YXRlZAAADEBzdGFydGluZ19zZXNzaW9uBChhY3RpdmVfZXJhBCxwbGFubmVkX2VyYQQoVW5leHBlY3RlZAF1CzRPZmZlbmNlVG9vT2xkAAAMLG9mZmVuY2VfZXJhBCR2YWxpZGF0b3IAIGZyYWN0aW9uBCRFcmFQcnVuZWQAAAQUaW5kZXgEAgxcTGVhc2VVbnJlc2VydmVSZW1haW5pbmcAAAwkZGVwb3NpdG9yABxwYXJhX2lkBCRyZW1haW5pbmcIbENyb3dkbG9hblVucmVzZXJ2ZVJlbWFpbmluZwAADCRkZXBvc2l0b3IAHHBhcmFfaWQEJHJlbWFpbmluZwhEU292ZXJlaWduTWlncmF0ZWQAABAccGFyYV9pZAQQZnJvbQAIdG8AQGRlcml2YXRpb25faW5kZXjxAQIQHFBlbmRpbmcAAQVQRGF0YU1pZ3JhdGlvbk9uZ29pbmcAAQU0TWlncmF0aW9uRG9uZQABBRxDb29sT2ZmAAAEGGVuZF9hdAQCbChBc3NldFJhdGVzAAEFIEJhZ3NMaXN0AAEFIEJhbGFuY2VzAAEFIEJvdW50aWVzAAEFNENoaWxkQm91bnRpZXMAAQUYQ2xhaW1zAAEFQENvbnZpY3Rpb25Wb3RpbmcAAQUkQ3Jvd2Rsb2FuAAEFQERlbGVnYXRlZFN0YWtpbmcAAQUcSW5kaWNlcwABBSBNdWx0aXNpZwABBSBOb21Qb29scwABBTRQcmVpbWFnZUNodW5rAAEFUFByZWltYWdlTGVnYWN5U3RhdHVzAAEFVFByZWltYWdlUmVxdWVzdFN0YXR1cwABBUhQcm94eUFubm91bmNlbWVudHMAAQUwUHJveHlQcm94aWVzAAEFIFJlY292ZXJ5AAEFRFJlZmVyZW5kYU1ldGFkYXRhAAEFUFJlZmVyZW5kYVJlZmVyZW5kdW1zAAEFPFJlZmVyZW5kYVZhbHVlcwABBSRTY2hlZHVsZXIAAQU8U2NoZWR1bGVyQWdlbmRhAAEFHFN0YWtpbmcAAQUgVHJlYXN1cnkAAQUcVmVzdGluZwABBRxTb2NpZXR5AAEFAgwYQ29uZmlnAAEFOE92ZXJyaWRlQ29uZmlnAAQEAQggRGlzYWJsZWQAAQUCQDxTdGFnZVRyYW5zaXRpb24AAAgMb2xkgQsMbmV3gQs0QmF0Y2hSZWNlaXZlZAAACBhwYWxsZXSFCxRjb3VudAQ4QmF0Y2hQcm9jZXNzZWQAAAwYcGFsbGV0hQsoY291bnRfZ29vZAQkY291bnRfYmFkBGBBc3NldEh1Yk1pZ3JhdGlvblN0YXJ0ZWQAAQVkQXNzZXRIdWJNaWdyYXRpb25GaW5pc2hlZAABBUxEbXBRdWV1ZVByaW9yaXR5U2V0AAAMLHByaW9yaXRpemVkFCxjeWNsZV9ibG9jawQwY3ljbGVfcGVyaW9kBGREbXBRdWV1ZVByaW9yaXR5Q29uZmlnU2V0AAAIDG9sZIkLDG5ld4kLXEJhbGFuY2VzQmVmb3JlUmVjb3JkU2V0AAAIQGNoZWNraW5nX2FjY291bnQIOHRvdGFsX2lzc3VhbmNlCHBCYWxhbmNlc0JlZm9yZVJlY29yZENvbnN1bWVkAAAIQGNoZWNraW5nX2FjY291bnQIOHRvdGFsX2lzc3VhbmNlCEhSZWZlcmVuZHVtQ2FuY2VsZWQAAAQIaWQEKE1hbmFnZXJTZXQAAAgMb2xkrQEMbmV3rQGMQWNjb3VudFRyYW5zbGF0ZWRQYXJhY2hhaW5Tb3ZlcmVpZ24AAAgQZnJvbQAIdG8AqEFjY291bnRUcmFuc2xhdGVkUGFyYWNoYWluU292ZXJlaWduRGVyaXZlZAAADBBmcm9tAAh0bwBAZGVyaXZhdGlvbl9pbmRleAQcWGNtU2VudAAAEBhvcmlnaW4VCixkZXN0aW5hdGlvbhUKHG1lc3NhZ2V1CihtZXNzYWdlX2lkIIBGYWlsZWRUb1VucmVzZXJ2ZU11bHRpc2lnRGVwb3NpdAAADDxleHBlY3RlZF9hbW91bnQIOG1pc3NpbmdfYW1vdW50CBxhY2NvdW50AIBGYWlsZWRUb1VucmVzZXJ2ZVByZWltYWdlRGVwb3NpdAAADDxleHBlY3RlZF9hbW91bnQIOG1pc3NpbmdfYW1vdW50CBxhY2NvdW50AAK4GFN5c3RlbQGtCTxQYXJhY2hhaW5TeXN0ZW0BKQMgUHJlaW1hZ2UBeQEkU2NoZWR1bGVyAbUJKFBhcmFtZXRlcnMB3QkgQmFsYW5jZXMB5QlIVHJhbnNhY3Rpb25QYXltZW50AWEBOEFzc2V0VHhQYXltZW50ARkKHFZlc3RpbmcBHQoYQ2xhaW1zASEKRENvbGxhdG9yU2VsZWN0aW9uAekDHFNlc3Npb24BJQokWGNtcFF1ZXVlAckDLFBvbGthZG90WGNtAYUKKEN1bXVsdXNYY20BiQpEVG9LdXNhbWFYY21Sb3V0ZXIBjQowTWVzc2FnZVF1ZXVlAdUDYFNub3dicmlkZ2VTeXN0ZW1Gcm9udGVuZAGVChxVdGlsaXR5AZkKIE11bHRpc2lnAZ0KFFByb3h5AakKHEluZGljZXMBrQoYQXNzZXRzAbEKHFVuaXF1ZXMBtQoQTmZ0cwHNCjRGb3JlaWduQXNzZXRzAdEKKFBvb2xBc3NldHMBsQo8QXNzZXRDb252ZXJzaW9uAeEKIFRyZWFzdXJ5Ae0KQENvbnZpY3Rpb25Wb3RpbmcB8QokUmVmZXJlbmRhAc0BJFdoaXRlbGlzdAH9CiBCb3VudGllcwEBCzRDaGlsZEJvdW50aWVzAQULJEFzc2V0UmF0ZQEJC0hTdGF0ZVRyaWVNaWdyYXRpb24BuQE8Tm9taW5hdGlvblBvb2xzASkLJFZvdGVyTGlzdAEtC0BEZWxlZ2F0ZWRTdGFraW5nATELPFN0YWtpbmdSY0NsaWVudAFBC0hNdWx0aUJsb2NrRWxlY3Rpb24BSQtoTXVsdGlCbG9ja0VsZWN0aW9uVmVyaWZpZXIBXQtgTXVsdGlCbG9ja0VsZWN0aW9uU2lnbmVkAWELHFN0YWtpbmcBeQsUQWhPcHMBfQsoQWhNaWdyYXRvcgGNCwAMFHBoYXNlNBRldmVudJELGHRvcGljc9UCBJULAAAgJHNwZWNfbmFtZeUCJGltcGxfbmFtZeUCRGF1dGhvcmluZ192ZXJzaW9uBDBzcGVjX3ZlcnNpb24EMGltcGxfdmVyc2lvbgQQYXBpc40ETHRyYW5zYWN0aW9uX3ZlcnNpb24EOHN5c3RlbV92ZXJzaW9uBAIMCFYzAQUHCFY0AYEDCFY1AXUKAhAgVGVsZXBvcnQAAQUwTG9jYWxSZXNlcnZlAAEFSERlc3RpbmF0aW9uUmVzZXJ2ZQABBTRSZW1vdGVSZXNlcnZlAYEKAgwIVjMBrQMIVjQBEQIIVjUBFQoCDBBMaXZlAAEFGEZyb3plbgABBShEZXN0cm95aW5nAAEFADAUb3duZXIAGGlzc3VlcgAUYWRtaW4AHGZyZWV6ZXIAGHN1cHBseQgcZGVwb3NpdAgsbWluX2JhbGFuY2UINGlzX3N1ZmZpY2llbnQUIGFjY291bnRzBCxzdWZmaWNpZW50cwQkYXBwcm92YWxzBBhzdGF0dXOtCwIMGExpcXVpZAABBRhGcm96ZW4AAQUcQmxvY2tlZAABBQIUIENvbnN1bWVyAAEFKFN1ZmZpY2llbnQAAQUsRGVwb3NpdEhlbGQBCDxEZXBvc2l0UmVmdW5kZWQAAQUsRGVwb3NpdEZyb20AAwgACAAMHGJhbGFuY2UIGHN0YXR1c7ULGHJlYXNvbrkLAwwEAAAACBhhbW91bnQIHGRlcG9zaXQIABQcZGVwb3NpdAgQbmFtZSQYc3ltYm9sJCBkZWNpbWFscwQkaXNfZnJvemVuFAIUCElkAQAUSW5kZXgBbQEMUmF3ASQkQWRkcmVzczMyASAkQWRkcmVzczIwAf0BAwgVCgADDBUKAAAEqQsAB9kL+QgHfQr5CAIQEFJvb3QAAQUYU2lnbmVkAQAQTm9uZQABBShBdXRob3JpemVkAAEFAggMWGNtARUKIFJlc3BvbnNlARUKAjwwU3Rha2luZ0FkbWluAAEFJFRyZWFzdXJlcgABBTxGZWxsb3dzaGlwQWRtaW4AAQUwR2VuZXJhbEFkbWluAAEFMEF1Y3Rpb25BZG1pbgABBShMZWFzZUFkbWluAAEFTFJlZmVyZW5kdW1DYW5jZWxsZXIAAQVAUmVmZXJlbmR1bUtpbGxlcgABBSxTbWFsbFRpcHBlcgABBSRCaWdUaXBwZXIAAQUwU21hbGxTcGVuZGVyAAEFNE1lZGl1bVNwZW5kZXIAAQUoQmlnU3BlbmRlcgABBURXaGl0ZWxpc3RlZENhbGxlcgABBTRXaXNoRm9yQ2hhbmdlAAEFAhAYc3lzdGVtAeULLFBvbGthZG90WGNtAekLKEN1bXVsdXNYY20BrQQcT3JpZ2lucwHtCwIwGHJlbWFyawAABBhyZW1hcmskOHNldF9oZWFwX3BhZ2VzAAAEFHBhZ2VzCCBzZXRfY29kZQAABBBjb2RlJFxzZXRfY29kZV93aXRob3V0X2NoZWNrcwAABBBjb2RlJCxzZXRfc3RvcmFnZQAABBRpdGVtc+UEMGtpbGxfc3RvcmFnZQAABBBrZXlz/QMsa2lsbF9wcmVmaXgAAAgYcHJlZml4JBxzdWJrZXlzBERyZW1hcmtfd2l0aF9ldmVudAAABBhyZW1hcmskHGRvX3Rhc2sAAABEYXV0aG9yaXplX3VwZ3JhZGUAAAQkY29kZV9oYXNoIIBhdXRob3JpemVfdXBncmFkZV93aXRob3V0X2NoZWNrcwAABCRjb2RlX2hhc2ggYGFwcGx5X2F1dGhvcml6ZWRfdXBncmFkZQAABBBjb2RlJATxCAAAEDx2YWxpZGF0aW9uX2RhdGGtBkRyZWxheV9jaGFpbl9zdGF0Zf0DYHJlbGF5X3BhcmVudF9kZXNjZW5kYW50c/kLQGNvbGxhdG9yX3BlZXJfaWTpAQAIHHNlbnRfYXQEIG1zZ19oYXNoIAQBDAAACDRmdWxsX21lc3NhZ2VztQY8aGFzaGVkX21lc3NhZ2VzBQwDCAS5BgQNDAADCAQBDAQVDAAACDRmdWxsX21lc3NhZ2VzEQw8aGFzaGVkX21lc3NhZ2VzGQwACERkb3dud2FyZF9tZXNzYWdlcwkMTGhvcml6b250YWxfbWVzc2FnZXMdDAIITHNldF92YWxpZGF0aW9uX2RhdGEAAAgQZGF0Yf0LVGluYm91bmRfbWVzc2FnZXNfZGF0YSEMYHN1ZG9fc2VuZF91cHdhcmRfbWVzc2FnZQAABBxtZXNzYWdlJAIoIHNjaGVkdWxlAAAQEHdoZW4EOG1heWJlX3BlcmlvZGljRQIgcHJpb3JpdHkEEGNhbGxBEBhjYW5jZWwAAAgQd2hlbgQUaW5kZXgEOHNjaGVkdWxlX25hbWVkAAAUCGlkIBB3aGVuBDhtYXliZV9wZXJpb2RpY0UCIHByaW9yaXR5BBBjYWxsQRAwY2FuY2VsX25hbWVkAAAECGlkIDhzY2hlZHVsZV9hZnRlcgAAEBRhZnRlcgQ4bWF5YmVfcGVyaW9kaWNFAiBwcmlvcml0eQQQY2FsbEEQUHNjaGVkdWxlX25hbWVkX2FmdGVyAAAUCGlkIBRhZnRlcgQ4bWF5YmVfcGVyaW9kaWNFAiBwcmlvcml0eQQQY2FsbEEQJHNldF9yZXRyeQAADBB0YXNrQQIccmV0cmllcwQYcGVyaW9kBDxzZXRfcmV0cnlfbmFtZWQAAAwIaWQgHHJldHJpZXMEGHBlcmlvZAQwY2FuY2VsX3JldHJ5AAAEEHRhc2tBAkhjYW5jZWxfcmV0cnlfbmFtZWQAAAQIaWQgAhwsU2lnbmVkUGhhc2UABPEBAQRQTWF4U2lnbmVkU3VibWlzc2lvbnMABPEBAQQ0VW5zaWduZWRQaGFzZQAE8QEBBChNaW5lclBhZ2VzAATxAQEERE1heEVsZWN0aW5nVm90ZXJzAATxAQEEWFRhcmdldFNuYXBzaG90UGVyQmxvY2sABPEBAQQ4TWF4RXJhRHVyYXRpb24ABKkBAQQCCFBNYXhTY2hlZHVsZWRQZXJCbG9jawAE8QEBBDRNYXhpbXVtV2VpZ2h0AATRAQEEBtEBAgg8TWF4T25Jbml0V2VpZ2h0AAQ1DAEEPE1heE9uSWRsZVdlaWdodAAENQwBBAIMPFN0YWtpbmdFbGVjdGlvbgEtDCRTY2hlZHVsZXIBMQwwTWVzc2FnZVF1ZXVlATkMAgQ0c2V0X3BhcmFtZXRlcgAABCRrZXlfdmFsdWU9DAIkUHRyYW5zZmVyX2FsbG93X2RlYXRoAAAIEGRlc3TNCxR2YWx1ZQg4Zm9yY2VfdHJhbnNmZXIAAAwYc291cmNlzQsQZGVzdM0LFHZhbHVlCEx0cmFuc2Zlcl9rZWVwX2FsaXZlAAAIEGRlc3TNCxR2YWx1ZQgwdHJhbnNmZXJfYWxsAAAIEGRlc3TNCyhrZWVwX2FsaXZlFDxmb3JjZV91bnJlc2VydmUAAAgMd2hvzQsYYW1vdW50CEB1cGdyYWRlX2FjY291bnRzAAAEDHdob+UDRGZvcmNlX3NldF9iYWxhbmNlAAAIDHdob80LIG5ld19mcmVlCGxmb3JjZV9hZGp1c3RfdG90YWxfaXNzdWFuY2UAAAgkZGlyZWN0aW9u8QQUZGVsdGEIEGJ1cm4AAAgUdmFsdWUIKGtlZXBfYWxpdmUUAAwYbG9ja2VkCCRwZXJfYmxvY2sIOHN0YXJ0aW5nX2Jsb2NrBAIYEHZlc3QAAQUodmVzdF9vdGhlcgAABBh0YXJnZXTNCzx2ZXN0ZWRfdHJhbnNmZXIAAAgYdGFyZ2V0zQsgc2NoZWR1bGVJDFRmb3JjZV92ZXN0ZWRfdHJhbnNmZXIAAAwYc291cmNlzQsYdGFyZ2V0zQsgc2NoZWR1bGVJDDxtZXJnZV9zY2hlZHVsZXMAAAg8c2NoZWR1bGUxX2luZGV4BDxzY2hlZHVsZTJfaW5kZXgEdGZvcmNlX3JlbW92ZV92ZXN0aW5nX3NjaGVkdWxlAAAIGHRhcmdldM0LOHNjaGVkdWxlX2luZGV4BAMMCAgEBlEMAggcUmVndWxhcgABBRBTYWZ0AAEFBlkMAhQUY2xhaW0AAAgQZGVzdABIZXRoZXJldW1fc2lnbmF0dXJlnQUobWludF9jbGFpbQAAEAx3aG/9ARR2YWx1ZQhAdmVzdGluZ19zY2hlZHVsZVUMJHN0YXRlbWVudF0MMGNsYWltX2F0dGVzdAAADBBkZXN0AEhldGhlcmV1bV9zaWduYXR1cmWdBSRzdGF0ZW1lbnQkGGF0dGVzdAAABCRzdGF0ZW1lbnQkKG1vdmVfY2xhaW0AAAwMb2xk/QEMbmV3/QE4bWF5YmVfcHJlY2xhaW2tAQIUVHN1c3BlbmRfeGNtX2V4ZWN1dGlvbgABBVByZXN1bWVfeGNtX2V4ZWN1dGlvbgABBWB1cGRhdGVfc3VzcGVuZF90aHJlc2hvbGQAAAQMbmV3BFR1cGRhdGVfZHJvcF90aHJlc2hvbGQAAAQMbmV3BFx1cGRhdGVfcmVzdW1lX3RocmVzaG9sZAAABAxuZXcEAkQQc2VuZAAACBBkZXN0gQocbWVzc2FnZaELPHRlbGVwb3J0X2Fzc2V0cwAAEBBkZXN0gQosYmVuZWZpY2lhcnmBChhhc3NldHN9CjhmZWVfYXNzZXRfaXRlbQRccmVzZXJ2ZV90cmFuc2Zlcl9hc3NldHMAABAQZGVzdIEKLGJlbmVmaWNpYXJ5gQoYYXNzZXRzfQo4ZmVlX2Fzc2V0X2l0ZW0EHGV4ZWN1dGUAAAgcbWVzc2FnZaELKG1heF93ZWlnaHQYRGZvcmNlX3hjbV92ZXJzaW9uAAAIIGxvY2F0aW9uFQocdmVyc2lvbgRkZm9yY2VfZGVmYXVsdF94Y21fdmVyc2lvbgAABERtYXliZV94Y21fdmVyc2lvbvEBeGZvcmNlX3N1YnNjcmliZV92ZXJzaW9uX25vdGlmeQAABCBsb2NhdGlvboEKgGZvcmNlX3Vuc3Vic2NyaWJlX3ZlcnNpb25fbm90aWZ5AAAEIGxvY2F0aW9ugQp8bGltaXRlZF9yZXNlcnZlX3RyYW5zZmVyX2Fzc2V0cwAAFBBkZXN0gQosYmVuZWZpY2lhcnmBChhhc3NldHN9CjhmZWVfYXNzZXRfaXRlbQQwd2VpZ2h0X2xpbWl0eQNcbGltaXRlZF90ZWxlcG9ydF9hc3NldHMAABQQZGVzdIEKLGJlbmVmaWNpYXJ5gQoYYXNzZXRzfQo4ZmVlX2Fzc2V0X2l0ZW0EMHdlaWdodF9saW1pdHkDQGZvcmNlX3N1c3BlbnNpb24AAAQkc3VzcGVuZGVkFDx0cmFuc2Zlcl9hc3NldHMAABQQZGVzdIEKLGJlbmVmaWNpYXJ5gQoYYXNzZXRzfQo4ZmVlX2Fzc2V0X2l0ZW0EMHdlaWdodF9saW1pdHkDMGNsYWltX2Fzc2V0cwAACBhhc3NldHN9CixiZW5lZmljaWFyeYEKjHRyYW5zZmVyX2Fzc2V0c191c2luZ190eXBlX2FuZF90aGVuAAAcEGRlc3SBChhhc3NldHN9ClBhc3NldHNfdHJhbnNmZXJfdHlwZaULOHJlbW90ZV9mZWVzX2lkqQtIZmVlc190cmFuc2Zlcl90eXBlpQtIY3VzdG9tX3hjbV9vbl9kZXN0oQswd2VpZ2h0X2xpbWl0eQNQYWRkX2F1dGhvcml6ZWRfYWxpYXMAAAgcYWxpYXNlcoEKHGV4cGlyZXOpAVxyZW1vdmVfYXV0aG9yaXplZF9hbGlhcwAABBxhbGlhc2VygQp0cmVtb3ZlX2FsbF9hdXRob3JpemVkX2FsaWFzZXMAAQUCBFByZXBvcnRfYnJpZGdlX3N0YXR1cwAACCRicmlkZ2VfaWQgMGlzX2Nvbmdlc3RlZBQADBBuYW1lJBhzeW1ib2wkIGRlY2ltYWxzBAIIHEluYm91bmQBCCBPdXRib3VuZAEIAgxIc2V0X29wZXJhdGluZ19tb2RlAAAEEG1vZGWRCjhyZWdpc3Rlcl90b2tlbgAADCBhc3NldF9pZIEKIG1ldGFkYXRhcQwkZmVlX2Fzc2V0NQocYWRkX3RpcAAACChtZXNzYWdlX2lkdQwUYXNzZXQ1CgRBEAACIBRiYXRjaAAABBRjYWxsc30MNGFzX2Rlcml2YXRpdmUAAAgUaW5kZXgEEGNhbGxBECRiYXRjaF9hbGwAAAQUY2FsbHN9DCxkaXNwYXRjaF9hcwAACCRhc19vcmlnaW7xCxBjYWxsQRAsZm9yY2VfYmF0Y2gAAAQUY2FsbHN9DCx3aXRoX3dlaWdodAAACBBjYWxsQRAYd2VpZ2h0GBxpZl9lbHNlAAAIEG1haW5BECBmYWxsYmFja0EQUGRpc3BhdGNoX2FzX2ZhbGxpYmxlAAAIJGFzX29yaWdpbvELEGNhbGxBEAIUUGFzX211bHRpX3RocmVzaG9sZF8xAAAIRG90aGVyX3NpZ25hdG9yaWVz5QMQY2FsbEEQIGFzX211bHRpAAAUJHRocmVzaG9sZAREb3RoZXJfc2lnbmF0b3JpZXPlAzxtYXliZV90aW1lcG9pbnTBBRBjYWxsQRAobWF4X3dlaWdodBhAYXBwcm92ZV9hc19tdWx0aQAAFCR0aHJlc2hvbGQERG90aGVyX3NpZ25hdG9yaWVz5QM8bWF5YmVfdGltZXBvaW50wQUkY2FsbF9oYXNoIChtYXhfd2VpZ2h0GDxjYW5jZWxfYXNfbXVsdGkAABAkdGhyZXNob2xkBERvdGhlcl9zaWduYXRvcmllc+UDJHRpbWVwb2ludJ0BJGNhbGxfaGFzaCAwcG9rZV9kZXBvc2l0AAAMJHRocmVzaG9sZAREb3RoZXJfc2lnbmF0b3JpZXPlAyRjYWxsX2hhc2ggBqEKAiwUcHJveHkAAAwQcmVhbM0LQGZvcmNlX3Byb3h5X3R5cGWJDBBjYWxsQRAkYWRkX3Byb3h5AAAMIGRlbGVnYXRlzQsocHJveHlfdHlwZaEKFGRlbGF5BDByZW1vdmVfcHJveHkAAAwgZGVsZWdhdGXNCyhwcm94eV90eXBloQoUZGVsYXkEOHJlbW92ZV9wcm94aWVzAAEFLGNyZWF0ZV9wdXJlAAAMKHByb3h5X3R5cGWhChRkZWxheQQUaW5kZXgEJGtpbGxfcHVyZQAAFBxzcGF3bmVyzQsocHJveHlfdHlwZaEKFGluZGV4BBhoZWlnaHQEJGV4dF9pbmRleAQgYW5ub3VuY2UAAAgQcmVhbM0LJGNhbGxfaGFzaCBMcmVtb3ZlX2Fubm91bmNlbWVudAAACBByZWFszQskY2FsbF9oYXNoIExyZWplY3RfYW5ub3VuY2VtZW50AAAIIGRlbGVnYXRlzQskY2FsbF9oYXNoIDxwcm94eV9hbm5vdW5jZWQAABAgZGVsZWdhdGXNCxByZWFszQtAZm9yY2VfcHJveHlfdHlwZYkMEGNhbGxBEDBwb2tlX2RlcG9zaXQAAQUCGBRjbGFpbQAABBRpbmRleAQgdHJhbnNmZXIAAAgMbmV3zQsUaW5kZXgEEGZyZWUAAAQUaW5kZXgEOGZvcmNlX3RyYW5zZmVyAAAMDG5ld80LFGluZGV4BBhmcmVlemUUGGZyZWV6ZQAABBRpbmRleAQwcG9rZV9kZXBvc2l0AAAEFGluZGV4BAKEGGNyZWF0ZQAADAhpZAQUYWRtaW7NCyxtaW5fYmFsYW5jZQgwZm9yY2VfY3JlYXRlAAAQCGlkBBRvd25lcs0LNGlzX3N1ZmZpY2llbnQULG1pbl9iYWxhbmNlCDRzdGFydF9kZXN0cm95AAAECGlkBEBkZXN0cm95X2FjY291bnRzAAAECGlkBERkZXN0cm95X2FwcHJvdmFscwAABAhpZAQ4ZmluaXNoX2Rlc3Ryb3kAAAQIaWQEEG1pbnQAAAwIaWQELGJlbmVmaWNpYXJ5zQsYYW1vdW50CBBidXJuAAAMCGlkBAx3aG/NCxhhbW91bnQIIHRyYW5zZmVyAAAMCGlkBBh0YXJnZXTNCxhhbW91bnQITHRyYW5zZmVyX2tlZXBfYWxpdmUAAAwIaWQEGHRhcmdldM0LGGFtb3VudAg4Zm9yY2VfdHJhbnNmZXIAABAIaWQEGHNvdXJjZc0LEGRlc3TNCxhhbW91bnQIGGZyZWV6ZQAACAhpZAQMd2hvzQsQdGhhdwAACAhpZAQMd2hvzQswZnJlZXplX2Fzc2V0AAAECGlkBCh0aGF3X2Fzc2V0AAAECGlkBEh0cmFuc2Zlcl9vd25lcnNoaXAAAAgIaWQEFG93bmVyzQsgc2V0X3RlYW0AABAIaWQEGGlzc3Vlcs0LFGFkbWluzQscZnJlZXplcs0LMHNldF9tZXRhZGF0YQAAEAhpZAQQbmFtZSQYc3ltYm9sJCBkZWNpbWFscwQ4Y2xlYXJfbWV0YWRhdGEAAAQIaWQESGZvcmNlX3NldF9tZXRhZGF0YQAAFAhpZAQQbmFtZSQYc3ltYm9sJCBkZWNpbWFscwQkaXNfZnJvemVuFFBmb3JjZV9jbGVhcl9tZXRhZGF0YQAABAhpZARIZm9yY2VfYXNzZXRfc3RhdHVzAAAgCGlkBBRvd25lcs0LGGlzc3Vlcs0LFGFkbWluzQscZnJlZXplcs0LLG1pbl9iYWxhbmNlCDRpc19zdWZmaWNpZW50FCRpc19mcm96ZW4UQGFwcHJvdmVfdHJhbnNmZXIAAAwIaWQEIGRlbGVnYXRlzQsYYW1vdW50CDxjYW5jZWxfYXBwcm92YWwAAAgIaWQEIGRlbGVnYXRlzQtUZm9yY2VfY2FuY2VsX2FwcHJvdmFsAAAMCGlkBBRvd25lcs0LIGRlbGVnYXRlzQtEdHJhbnNmZXJfYXBwcm92ZWQAABAIaWQEFG93bmVyzQssZGVzdGluYXRpb27NCxhhbW91bnQIFHRvdWNoAAAECGlkBBhyZWZ1bmQAAAgIaWQEKGFsbG93X2J1cm4UPHNldF9taW5fYmFsYW5jZQAACAhpZAQsbWluX2JhbGFuY2UILHRvdWNoX290aGVyAAAICGlkBAx3aG/NCzByZWZ1bmRfb3RoZXIAAAgIaWQEDHdob80LFGJsb2NrAAAICGlkBAx3aG/NCzB0cmFuc2Zlcl9hbGwAAAwIaWQEEGRlc3TNCyhrZWVwX2FsaXZlFAbNCwJoGGNyZWF0ZQAACChjb2xsZWN0aW9uBBRhZG1pbs0LMGZvcmNlX2NyZWF0ZQAADChjb2xsZWN0aW9uBBRvd25lcs0LMGZyZWVfaG9sZGluZxQcZGVzdHJveQAACChjb2xsZWN0aW9uBBx3aXRuZXNzyQUQbWludAAADChjb2xsZWN0aW9uBBBpdGVtBBRvd25lcs0LEGJ1cm4AAAwoY29sbGVjdGlvbgQQaXRlbQQsY2hlY2tfb3duZXKZDCB0cmFuc2ZlcgAADChjb2xsZWN0aW9uBBBpdGVtBBBkZXN0zQskcmVkZXBvc2l0AAAIKGNvbGxlY3Rpb24EFGl0ZW1zTQIYZnJlZXplAAAIKGNvbGxlY3Rpb24EEGl0ZW0EEHRoYXcAAAgoY29sbGVjdGlvbgQQaXRlbQREZnJlZXplX2NvbGxlY3Rpb24AAAQoY29sbGVjdGlvbgQ8dGhhd19jb2xsZWN0aW9uAAAEKGNvbGxlY3Rpb24ESHRyYW5zZmVyX293bmVyc2hpcAAACChjb2xsZWN0aW9uBCRuZXdfb3duZXLNCyBzZXRfdGVhbQAAEChjb2xsZWN0aW9uBBhpc3N1ZXLNCxRhZG1pbs0LHGZyZWV6ZXLNC0BhcHByb3ZlX3RyYW5zZmVyAAAMKGNvbGxlY3Rpb24EEGl0ZW0EIGRlbGVnYXRlzQs8Y2FuY2VsX2FwcHJvdmFsAAAMKGNvbGxlY3Rpb24EEGl0ZW0EUG1heWJlX2NoZWNrX2RlbGVnYXRlmQxEZm9yY2VfaXRlbV9zdGF0dXMAABwoY29sbGVjdGlvbgQUb3duZXLNCxhpc3N1ZXLNCxRhZG1pbs0LHGZyZWV6ZXLNCzBmcmVlX2hvbGRpbmcUJGlzX2Zyb3plbhQ0c2V0X2F0dHJpYnV0ZQAAEChjb2xsZWN0aW9uBChtYXliZV9pdGVt8QEMa2V5JBR2YWx1ZSQ8Y2xlYXJfYXR0cmlidXRlAAAMKGNvbGxlY3Rpb24EKG1heWJlX2l0ZW3xAQxrZXkkMHNldF9tZXRhZGF0YQAAEChjb2xsZWN0aW9uBBBpdGVtBBBkYXRhJCRpc19mcm96ZW4UOGNsZWFyX21ldGFkYXRhAAAIKGNvbGxlY3Rpb24EEGl0ZW0EXHNldF9jb2xsZWN0aW9uX21ldGFkYXRhAAAMKGNvbGxlY3Rpb24EEGRhdGEkJGlzX2Zyb3plbhRkY2xlYXJfY29sbGVjdGlvbl9tZXRhZGF0YQAABChjb2xsZWN0aW9uBFBzZXRfYWNjZXB0X293bmVyc2hpcAAABEBtYXliZV9jb2xsZWN0aW9u8QFkc2V0X2NvbGxlY3Rpb25fbWF4X3N1cHBseQAACChjb2xsZWN0aW9uBChtYXhfc3VwcGx5BCRzZXRfcHJpY2UAABAoY29sbGVjdGlvbgQQaXRlbQQUcHJpY2WpAUR3aGl0ZWxpc3RlZF9idXllcpkMIGJ1eV9pdGVtAAAMKGNvbGxlY3Rpb24EEGl0ZW0EJGJpZF9wcmljZQgCDBhJc3N1ZXIAAQUYUHVibGljAAEFIEhvbGRlck9mAQQAFCRtaW50X3R5cGWhDBRwcmljZakBLHN0YXJ0X2Jsb2Nr8QEkZW5kX2Jsb2Nr8QFUZGVmYXVsdF9pdGVtX3NldHRpbmdzCAAMIHNldHRpbmdzCChtYXhfc3VwcGx58QE0bWludF9zZXR0aW5nc6UMAAw4aXRlbV9tZXRhZGF0YXMEMGl0ZW1fY29uZmlncwQoYXR0cmlidXRlcwQACChvd25lZF9pdGVt8QEobWludF9wcmljZakBBrEMABAoY29sbGVjdGlvbgQQaXRlbQQgcmVjZWl2ZXIAGGFtb3VudAgEuQwAABwoY29sbGVjdGlvbgQQaXRlbQQoYXR0cmlidXRlc+UEIG1ldGFkYXRhJDBvbmx5X2FjY291bnStASBkZWFkbGluZQQobWludF9wcmljZakBABQoY29sbGVjdGlvbgQQaXRlbQQoYXR0cmlidXRlc+UEJG5hbWVzcGFjZbkKIGRlYWRsaW5lBAKcGGNyZWF0ZQAACBRhZG1pbs0LGGNvbmZpZ6kMMGZvcmNlX2NyZWF0ZQAACBRvd25lcs0LGGNvbmZpZ6kMHGRlc3Ryb3kAAAgoY29sbGVjdGlvbgQcd2l0bmVzc60MEG1pbnQAABAoY29sbGVjdGlvbgQQaXRlbQQcbWludF90b80LMHdpdG5lc3NfZGF0YbUMKGZvcmNlX21pbnQAABAoY29sbGVjdGlvbgQQaXRlbQQcbWludF90b80LLGl0ZW1fY29uZmlnCBBidXJuAAAIKGNvbGxlY3Rpb24EEGl0ZW0EIHRyYW5zZmVyAAAMKGNvbGxlY3Rpb24EEGl0ZW0EEGRlc3TNCyRyZWRlcG9zaXQAAAgoY29sbGVjdGlvbgQUaXRlbXNNAkhsb2NrX2l0ZW1fdHJhbnNmZXIAAAgoY29sbGVjdGlvbgQQaXRlbQRQdW5sb2NrX2l0ZW1fdHJhbnNmZXIAAAgoY29sbGVjdGlvbgQQaXRlbQQ8bG9ja19jb2xsZWN0aW9uAAAIKGNvbGxlY3Rpb24ENGxvY2tfc2V0dGluZ3MISHRyYW5zZmVyX293bmVyc2hpcAAACChjb2xsZWN0aW9uBCRuZXdfb3duZXLNCyBzZXRfdGVhbQAAEChjb2xsZWN0aW9uBBhpc3N1ZXKZDBRhZG1pbpkMHGZyZWV6ZXKZDFhmb3JjZV9jb2xsZWN0aW9uX293bmVyAAAIKGNvbGxlY3Rpb24EFG93bmVyzQtcZm9yY2VfY29sbGVjdGlvbl9jb25maWcAAAgoY29sbGVjdGlvbgQYY29uZmlnqQxAYXBwcm92ZV90cmFuc2ZlcgAAEChjb2xsZWN0aW9uBBBpdGVtBCBkZWxlZ2F0Zc0LOG1heWJlX2RlYWRsaW5l8QE8Y2FuY2VsX2FwcHJvdmFsAAAMKGNvbGxlY3Rpb24EEGl0ZW0EIGRlbGVnYXRlzQtwY2xlYXJfYWxsX3RyYW5zZmVyX2FwcHJvdmFscwAACChjb2xsZWN0aW9uBBBpdGVtBFBsb2NrX2l0ZW1fcHJvcGVydGllcwAAEChjb2xsZWN0aW9uBBBpdGVtBDRsb2NrX21ldGFkYXRhFDxsb2NrX2F0dHJpYnV0ZXMUNHNldF9hdHRyaWJ1dGUAABQoY29sbGVjdGlvbgQobWF5YmVfaXRlbfEBJG5hbWVzcGFjZbkKDGtleSQUdmFsdWUkTGZvcmNlX3NldF9hdHRyaWJ1dGUAABgYc2V0X2FzrQEoY29sbGVjdGlvbgQobWF5YmVfaXRlbfEBJG5hbWVzcGFjZbkKDGtleSQUdmFsdWUkPGNsZWFyX2F0dHJpYnV0ZQAAEChjb2xsZWN0aW9uBChtYXliZV9pdGVt8QEkbmFtZXNwYWNluQoMa2V5JFxhcHByb3ZlX2l0ZW1fYXR0cmlidXRlcwAADChjb2xsZWN0aW9uBBBpdGVtBCBkZWxlZ2F0Zc0LfGNhbmNlbF9pdGVtX2F0dHJpYnV0ZXNfYXBwcm92YWwAABAoY29sbGVjdGlvbgQQaXRlbQQgZGVsZWdhdGXNCxx3aXRuZXNzBDBzZXRfbWV0YWRhdGEAAAwoY29sbGVjdGlvbgQQaXRlbQQQZGF0YSQ4Y2xlYXJfbWV0YWRhdGEAAAgoY29sbGVjdGlvbgQQaXRlbQRcc2V0X2NvbGxlY3Rpb25fbWV0YWRhdGEAAAgoY29sbGVjdGlvbgQQZGF0YSRkY2xlYXJfY29sbGVjdGlvbl9tZXRhZGF0YQAABChjb2xsZWN0aW9uBFBzZXRfYWNjZXB0X293bmVyc2hpcAAABEBtYXliZV9jb2xsZWN0aW9u8QFkc2V0X2NvbGxlY3Rpb25fbWF4X3N1cHBseQAACChjb2xsZWN0aW9uBChtYXhfc3VwcGx5BFB1cGRhdGVfbWludF9zZXR0aW5ncwAACChjb2xsZWN0aW9uBDRtaW50X3NldHRpbmdzpQwkc2V0X3ByaWNlAAAQKGNvbGxlY3Rpb24EEGl0ZW0EFHByaWNlqQFEd2hpdGVsaXN0ZWRfYnV5ZXKZDCBidXlfaXRlbQAADChjb2xsZWN0aW9uBBBpdGVtBCRiaWRfcHJpY2UIIHBheV90aXBzAAAEEHRpcHO9DCxjcmVhdGVfc3dhcAAAGEhvZmZlcmVkX2NvbGxlY3Rpb24EMG9mZmVyZWRfaXRlbQRIZGVzaXJlZF9jb2xsZWN0aW9uBEhtYXliZV9kZXNpcmVkX2l0ZW3xASxtYXliZV9wcmljZcUKIGR1cmF0aW9uBCxjYW5jZWxfc3dhcAAACEhvZmZlcmVkX2NvbGxlY3Rpb24EMG9mZmVyZWRfaXRlbQQoY2xhaW1fc3dhcAAAFDxzZW5kX2NvbGxlY3Rpb24EJHNlbmRfaXRlbQRIcmVjZWl2ZV9jb2xsZWN0aW9uBDByZWNlaXZlX2l0ZW0ENHdpdG5lc3NfcHJpY2XFCjxtaW50X3ByZV9zaWduZWQAAAwkbWludF9kYXRhwQwkc2lnbmF0dXJloQUYc2lnbmVyAGRzZXRfYXR0cmlidXRlc19wcmVfc2lnbmVkAAAMEGRhdGHFDCRzaWduYXR1cmWhBRhzaWduZXIAAoQYY3JlYXRlAAAMCGlkFQoUYWRtaW7NCyxtaW5fYmFsYW5jZQgwZm9yY2VfY3JlYXRlAAAQCGlkFQoUb3duZXLNCzRpc19zdWZmaWNpZW50FCxtaW5fYmFsYW5jZQg0c3RhcnRfZGVzdHJveQAABAhpZBUKQGRlc3Ryb3lfYWNjb3VudHMAAAQIaWQVCkRkZXN0cm95X2FwcHJvdmFscwAABAhpZBUKOGZpbmlzaF9kZXN0cm95AAAECGlkFQoQbWludAAADAhpZBUKLGJlbmVmaWNpYXJ5zQsYYW1vdW50CBBidXJuAAAMCGlkFQoMd2hvzQsYYW1vdW50CCB0cmFuc2ZlcgAADAhpZBUKGHRhcmdldM0LGGFtb3VudAhMdHJhbnNmZXJfa2VlcF9hbGl2ZQAADAhpZBUKGHRhcmdldM0LGGFtb3VudAg4Zm9yY2VfdHJhbnNmZXIAABAIaWQVChhzb3VyY2XNCxBkZXN0zQsYYW1vdW50CBhmcmVlemUAAAgIaWQVCgx3aG/NCxB0aGF3AAAICGlkFQoMd2hvzQswZnJlZXplX2Fzc2V0AAAECGlkFQoodGhhd19hc3NldAAABAhpZBUKSHRyYW5zZmVyX293bmVyc2hpcAAACAhpZBUKFG93bmVyzQsgc2V0X3RlYW0AABAIaWQVChhpc3N1ZXLNCxRhZG1pbs0LHGZyZWV6ZXLNCzBzZXRfbWV0YWRhdGEAABAIaWQVChBuYW1lJBhzeW1ib2wkIGRlY2ltYWxzBDhjbGVhcl9tZXRhZGF0YQAABAhpZBUKSGZvcmNlX3NldF9tZXRhZGF0YQAAFAhpZBUKEG5hbWUkGHN5bWJvbCQgZGVjaW1hbHMEJGlzX2Zyb3plbhRQZm9yY2VfY2xlYXJfbWV0YWRhdGEAAAQIaWQVCkhmb3JjZV9hc3NldF9zdGF0dXMAACAIaWQVChRvd25lcs0LGGlzc3Vlcs0LFGFkbWluzQscZnJlZXplcs0LLG1pbl9iYWxhbmNlCDRpc19zdWZmaWNpZW50FCRpc19mcm96ZW4UQGFwcHJvdmVfdHJhbnNmZXIAAAwIaWQVCiBkZWxlZ2F0Zc0LGGFtb3VudAg8Y2FuY2VsX2FwcHJvdmFsAAAICGlkFQogZGVsZWdhdGXNC1Rmb3JjZV9jYW5jZWxfYXBwcm92YWwAAAwIaWQVChRvd25lcs0LIGRlbGVnYXRlzQtEdHJhbnNmZXJfYXBwcm92ZWQAABAIaWQVChRvd25lcs0LLGRlc3RpbmF0aW9uzQsYYW1vdW50CBR0b3VjaAAABAhpZBUKGHJlZnVuZAAACAhpZBUKKGFsbG93X2J1cm4UPHNldF9taW5fYmFsYW5jZQAACAhpZBUKLG1pbl9iYWxhbmNlCCx0b3VjaF9vdGhlcgAACAhpZBUKDHdob80LMHJlZnVuZF9vdGhlcgAACAhpZBUKDHdob80LFGJsb2NrAAAICGlkFQoMd2hvzQswdHJhbnNmZXJfYWxsAAAMCGlkFQoQZGVzdM0LKGtlZXBfYWxpdmUUBBUKAAIYLGNyZWF0ZV9wb29sAAAIGGFzc2V0MRUKGGFzc2V0MhUKNGFkZF9saXF1aWRpdHkAABwYYXNzZXQxFQoYYXNzZXQyFQo8YW1vdW50MV9kZXNpcmVkCDxhbW91bnQyX2Rlc2lyZWQILGFtb3VudDFfbWluCCxhbW91bnQyX21pbggcbWludF90bwBAcmVtb3ZlX2xpcXVpZGl0eQAAGBhhc3NldDEVChhhc3NldDIVCjRscF90b2tlbl9idXJuCExhbW91bnQxX21pbl9yZWNlaXZlCExhbW91bnQyX21pbl9yZWNlaXZlCCx3aXRoZHJhd190bwBwc3dhcF9leGFjdF90b2tlbnNfZm9yX3Rva2VucwAAFBBwYXRo0QwkYW1vdW50X2luCDhhbW91bnRfb3V0X21pbggcc2VuZF90bwAoa2VlcF9hbGl2ZRRwc3dhcF90b2tlbnNfZm9yX2V4YWN0X3Rva2VucwAAFBBwYXRo0QwoYW1vdW50X291dAg0YW1vdW50X2luX21heAgcc2VuZF90bwAoa2VlcF9hbGl2ZRQUdG91Y2gAAAgYYXNzZXQxFQoYYXNzZXQyFQoCGCxzcGVuZF9sb2NhbAAACBhhbW91bnQILGJlbmVmaWNpYXJ5zQs8cmVtb3ZlX2FwcHJvdmFsAAAELHByb3Bvc2FsX2lkBBRzcGVuZAAAEChhc3NldF9raW5k5QoYYW1vdW50CCxiZW5lZmljaWFyeekKKHZhbGlkX2Zyb23xARhwYXlvdXQAAAQUaW5kZXgEMGNoZWNrX3N0YXR1cwAABBRpbmRleAQodm9pZF9zcGVuZAAABBRpbmRleAQCGBB2b3RlAAAIKHBvbGxfaW5kZXgEEHZvdGW9ASBkZWxlZ2F0ZQAAEBRjbGFzcwQIdG/NCyhjb252aWN0aW9urQUcYmFsYW5jZQgodW5kZWxlZ2F0ZQAABBRjbGFzcwQYdW5sb2NrAAAIFGNsYXNzBBh0YXJnZXTNCyxyZW1vdmVfdm90ZQAACBRjbGFzc/EBFGluZGV4BERyZW1vdmVfb3RoZXJfdm90ZQAADBh0YXJnZXTNCxRjbGFzcwQUaW5kZXgEAiQYc3VibWl0AAAMPHByb3Bvc2FsX29yaWdpbvELIHByb3Bvc2FsxQFAZW5hY3RtZW50X21vbWVudLUEWHBsYWNlX2RlY2lzaW9uX2RlcG9zaXQAAAQUaW5kZXgEXHJlZnVuZF9kZWNpc2lvbl9kZXBvc2l0AAAEFGluZGV4BBhjYW5jZWwAAAQUaW5kZXgEEGtpbGwAAAQUaW5kZXgEQG51ZGdlX3JlZmVyZW5kdW0AAAQUaW5kZXgESG9uZV9mZXdlcl9kZWNpZGluZwAABBR0cmFjawRkcmVmdW5kX3N1Ym1pc3Npb25fZGVwb3NpdAAABBRpbmRleAQwc2V0X21ldGFkYXRhAAAIFGluZGV4BChtYXliZV9oYXNoIQMCEDh3aGl0ZWxpc3RfY2FsbAAABCRjYWxsX2hhc2ggXHJlbW92ZV93aGl0ZWxpc3RlZF9jYWxsAAAEJGNhbGxfaGFzaCBkZGlzcGF0Y2hfd2hpdGVsaXN0ZWRfY2FsbAAADCRjYWxsX2hhc2ggQGNhbGxfZW5jb2RlZF9sZW4ETGNhbGxfd2VpZ2h0X3dpdG5lc3MYnGRpc3BhdGNoX3doaXRlbGlzdGVkX2NhbGxfd2l0aF9wcmVpbWFnZQAABBBjYWxsQRACLDhwcm9wb3NlX2JvdW50eQAACBR2YWx1ZQgsZGVzY3JpcHRpb24kOGFwcHJvdmVfYm91bnR5AAAEJGJvdW50eV9pZAQ8cHJvcG9zZV9jdXJhdG9yAAAMJGJvdW50eV9pZAQcY3VyYXRvcs0LDGZlZQhAdW5hc3NpZ25fY3VyYXRvcgAABCRib3VudHlfaWQEOGFjY2VwdF9jdXJhdG9yAAAEJGJvdW50eV9pZAQwYXdhcmRfYm91bnR5AAAIJGJvdW50eV9pZAQsYmVuZWZpY2lhcnnNCzBjbGFpbV9ib3VudHkAAAQkYm91bnR5X2lkBDBjbG9zZV9ib3VudHkAAAQkYm91bnR5X2lkBFBleHRlbmRfYm91bnR5X2V4cGlyeQAACCRib3VudHlfaWQEGHJlbWFyayRsYXBwcm92ZV9ib3VudHlfd2l0aF9jdXJhdG9yAAAMJGJvdW50eV9pZAQcY3VyYXRvcs0LDGZlZQgwcG9rZV9kZXBvc2l0AAAEJGJvdW50eV9pZAQCHEBhZGRfY2hpbGRfYm91bnR5AAAMQHBhcmVudF9ib3VudHlfaWQEFHZhbHVlCCxkZXNjcmlwdGlvbiQ8cHJvcG9zZV9jdXJhdG9yAAAQQHBhcmVudF9ib3VudHlfaWQEPGNoaWxkX2JvdW50eV9pZAQcY3VyYXRvcs0LDGZlZQg4YWNjZXB0X2N1cmF0b3IAAAhAcGFyZW50X2JvdW50eV9pZAQ8Y2hpbGRfYm91bnR5X2lkBEB1bmFzc2lnbl9jdXJhdG9yAAAIQHBhcmVudF9ib3VudHlfaWQEPGNoaWxkX2JvdW50eV9pZARIYXdhcmRfY2hpbGRfYm91bnR5AAAMQHBhcmVudF9ib3VudHlfaWQEPGNoaWxkX2JvdW50eV9pZAQsYmVuZWZpY2lhcnnNC0hjbGFpbV9jaGlsZF9ib3VudHkAAAhAcGFyZW50X2JvdW50eV9pZAQ8Y2hpbGRfYm91bnR5X2lkBEhjbG9zZV9jaGlsZF9ib3VudHkAAAhAcGFyZW50X2JvdW50eV9pZAQ8Y2hpbGRfYm91bnR5X2lkBAIMGGNyZWF0ZQAACChhc3NldF9raW5k5QoQcmF0ZQgYdXBkYXRlAAAIKGFzc2V0X2tpbmTlChByYXRlCBhyZW1vdmUAAAQoYXNzZXRfa2luZOUKAggsRnJlZUJhbGFuY2UBCBxSZXdhcmRzAAEFAgwQTm9vcAABBQxTZXQBCBhSZW1vdmUAAQUCDBBOb29wAAEFDFNldAEEGFJlbW92ZQABBQIMEE5vb3AAAQUMU2V0AQAYUmVtb3ZlAAEFAmgQam9pbgAACBhhbW91bnQIHHBvb2xfaWQEKGJvbmRfZXh0cmEAAAQUZXh0cmH1DDBjbGFpbV9wYXlvdXQAAQUYdW5ib25kAAAIOG1lbWJlcl9hY2NvdW50zQtAdW5ib25kaW5nX3BvaW50cwhYcG9vbF93aXRoZHJhd191bmJvbmRlZAAACBxwb29sX2lkBEhudW1fc2xhc2hpbmdfc3BhbnMERHdpdGhkcmF3X3VuYm9uZGVkAAAIOG1lbWJlcl9hY2NvdW50zQtIbnVtX3NsYXNoaW5nX3NwYW5zBBhjcmVhdGUAABAYYW1vdW50CBByb290zQskbm9taW5hdG9yzQscYm91bmNlcs0LTGNyZWF0ZV93aXRoX3Bvb2xfaWQAABQYYW1vdW50CBByb290zQskbm9taW5hdG9yzQscYm91bmNlcs0LHHBvb2xfaWQEIG5vbWluYXRlAAAIHHBvb2xfaWQEKHZhbGlkYXRvcnPlAyRzZXRfc3RhdGUAAAgccG9vbF9pZAQUc3RhdGUNCzBzZXRfbWV0YWRhdGEAAAgccG9vbF9pZAQgbWV0YWRhdGEkLHNldF9jb25maWdzAAAYNG1pbl9qb2luX2JvbmT5DDxtaW5fY3JlYXRlX2JvbmT5DCRtYXhfcG9vbHP9DCxtYXhfbWVtYmVyc/0MUG1heF9tZW1iZXJzX3Blcl9wb29s/QxUZ2xvYmFsX21heF9jb21taXNzaW9u/QwwdXBkYXRlX3JvbGVzAAAQHHBvb2xfaWQEIG5ld19yb290AQ00bmV3X25vbWluYXRvcgENLG5ld19ib3VuY2VyAQ0UY2hpbGwAAAQccG9vbF9pZARAYm9uZF9leHRyYV9vdGhlcgAACBhtZW1iZXLNCxRleHRyYfUMUHNldF9jbGFpbV9wZXJtaXNzaW9uAAAEKHBlcm1pc3Npb24lC0hjbGFpbV9wYXlvdXRfb3RoZXIAAAQUb3RoZXIAOHNldF9jb21taXNzaW9uAAAIHHBvb2xfaWQEOG5ld19jb21taXNzaW9uFQtIc2V0X2NvbW1pc3Npb25fbWF4AAAIHHBvb2xfaWQEOG1heF9jb21taXNzaW9uBGhzZXRfY29tbWlzc2lvbl9jaGFuZ2VfcmF0ZQAACBxwb29sX2lkBCxjaGFuZ2VfcmF0ZRkLQGNsYWltX2NvbW1pc3Npb24AAAQccG9vbF9pZARMYWRqdXN0X3Bvb2xfZGVwb3NpdAAABBxwb29sX2lkBHxzZXRfY29tbWlzc2lvbl9jbGFpbV9wZXJtaXNzaW9uAAAIHHBvb2xfaWQEKHBlcm1pc3Npb24hCyxhcHBseV9zbGFzaAAABDhtZW1iZXJfYWNjb3VudM0LSG1pZ3JhdGVfZGVsZWdhdGlvbgAABDhtZW1iZXJfYWNjb3VudM0LeG1pZ3JhdGVfcG9vbF90b19kZWxlZ2F0ZV9zdGFrZQAABBxwb29sX2lkBAIMFHJlYmFnAAAEKGRpc2xvY2F0ZWTNCzxwdXRfaW5fZnJvbnRfb2YAAAQcbGlnaHRlcs0LVHB1dF9pbl9mcm9udF9vZl9vdGhlcgAACBxoZWF2aWVyzQscbGlnaHRlcs0LBCkIAAAQJGVuZF9pbmRleARAdmFsaWRhdG9yX3BvaW50cw0NUGFjdGl2YXRpb25fdGltZXN0YW1wOQsgbGVmdG92ZXIUAAwgb2ZmZW5kZXIAJHJlcG9ydGVyc+UDOHNsYXNoX2ZyYWN0aW9uBAMIBBUNBBkNAAIIUHJlbGF5X3Nlc3Npb25fcmVwb3J0AAAEGHJlcG9ydBENXHJlbGF5X25ld19vZmZlbmNlX3BhZ2VkAAAEIG9mZmVuY2VzHQ0DCAAIBCUNAAAIFHRvdGFsCBh2b3RlcnMpDQMIAC0NBDENAAIUQEZvcmNlUm90YXRlUm91bmQAAQU0Rm9yY2VTZXRQaGFzZQFFC1BFbWVyZ2VuY3lTZXRTb2x1dGlvbgADCDUNVQtERW1lcmdlbmN5RmFsbGJhY2sAAQVQU2V0TWluVW50cnVzdGVkU2NvcmUBVQsCBBhtYW5hZ2UAAAQIb3A5DQMIBAQEQQ0AAwwEQQ0EBEkNAARBDQEIAwwEUQ0EBFUNAARBDQEMAwwEXQ0EBGENAARBDQEQAwwEaQ0EBG0NAARBDQEUAwwEdQ0EBHkNAARBDQEYAwwEgQ0EBIUNAARBDQEcAwwEjQ0EBJENAARBDQEgAwwEmQ0EBJ0NAARBDQEkAwwEpQ0EBKkNAARBDQEoAwwEsQ0EBLUNAARBDQEsAwwEvQ0EBMENAARBDQEwAwwEyQ0EBM0NAARBDQE0AwwE1Q0EBNkNAARBDQE4AwwE4Q0EBOUNAARBDQE8AwwE7Q0EBPENAABAGHZvdGVzMUUNGHZvdGVzMk0NGHZvdGVzM1kNGHZvdGVzNGUNGHZvdGVzNXENGHZvdGVzNn0NGHZvdGVzN4kNGHZvdGVzOJUNGHZvdGVzOaENHHZvdGVzMTCtDRx2b3RlczExuQ0cdm90ZXMxMsUNHHZvdGVzMTPRDRx2b3RlczE03Q0cdm90ZXMxNekNHHZvdGVzMTb1DQT5DQAADDhzb2x1dGlvbl9wYWdlc/0NFHNjb3JlVQsUcm91bmQEAgQ8c3VibWl0X3Vuc2lnbmVkAAAEOHBhZ2VkX3NvbHV0aW9uAQ4G+Q0CFCByZWdpc3RlcgAABDRjbGFpbWVkX3Njb3JlVQssc3VibWl0X3BhZ2UAAAgQcGFnZQQ4bWF5YmVfc29sdXRpb24JDhBiYWlsAAEFUGNsZWFyX29sZF9yb3VuZF9kYXRhAAAIFHJvdW5kBDR3aXRuZXNzX3BhZ2VzBERzZXRfaW52dWxuZXJhYmxlcwAABAxpbnblAwTNCwAACBR2YWx1ZQgMZXJhBAQVDgAGGQ4ChBBib25kAAAIFHZhbHVlCBRwYXllZWULKGJvbmRfZXh0cmEAAAQ4bWF4X2FkZGl0aW9uYWwIGHVuYm9uZAAABBR2YWx1ZQhEd2l0aGRyYXdfdW5ib25kZWQAAARIbnVtX3NsYXNoaW5nX3NwYW5zBCB2YWxpZGF0ZQAABBRwcmVmc2kLIG5vbWluYXRlAAAEHHRhcmdldHMRDhRjaGlsbAABBSRzZXRfcGF5ZWUAAAQUcGF5ZWVlCzhzZXRfY29udHJvbGxlcgABBUxzZXRfdmFsaWRhdG9yX2NvdW50AAAEDG5ldwRgaW5jcmVhc2VfdmFsaWRhdG9yX2NvdW50AAAEKGFkZGl0aW9uYWwEVHNjYWxlX3ZhbGlkYXRvcl9jb3VudAAABBhmYWN0b3IENGZvcmNlX25vX2VyYXMAAQU0Zm9yY2VfbmV3X2VyYQABBURzZXRfaW52dWxuZXJhYmxlcwAABDRpbnZ1bG5lcmFibGVz5QM0Zm9yY2VfdW5zdGFrZQAACBRzdGFzaABIbnVtX3NsYXNoaW5nX3NwYW5zBFBmb3JjZV9uZXdfZXJhX2Fsd2F5cwABBVRjYW5jZWxfZGVmZXJyZWRfc2xhc2gAAAgMZXJhBER2YWxpZGF0b3Jfc2xhc2hlcw0NOHBheW91dF9zdGFrZXJzAAAIPHZhbGlkYXRvcl9zdGFzaAAMZXJhBBhyZWJvbmQAAAQUdmFsdWUIKHJlYXBfc3Rhc2gAAAgUc3Rhc2gASG51bV9zbGFzaGluZ19zcGFucwQQa2ljawAABAx3aG8RDkxzZXRfc3Rha2luZ19jb25maWdzAAAcSG1pbl9ub21pbmF0b3JfYm9uZPkMSG1pbl92YWxpZGF0b3JfYm9uZPkMTG1heF9ub21pbmF0b3JfY291bnT9DExtYXhfdmFsaWRhdG9yX2NvdW50/Qw8Y2hpbGxfdGhyZXNob2xk/Qw4bWluX2NvbW1pc3Npb279DEhtYXhfc3Rha2VkX3Jld2FyZHP9DCxjaGlsbF9vdGhlcgAABBRzdGFzaABoZm9yY2VfYXBwbHlfbWluX2NvbW1pc3Npb24AAAQ8dmFsaWRhdG9yX3N0YXNoAEhzZXRfbWluX2NvbW1pc3Npb24AAAQMbmV3BFhwYXlvdXRfc3Rha2Vyc19ieV9wYWdlAAAMPHZhbGlkYXRvcl9zdGFzaAAMZXJhBBBwYWdlBDB1cGRhdGVfcGF5ZWUAAAQoY29udHJvbGxlcgBoZGVwcmVjYXRlX2NvbnRyb2xsZXJfYmF0Y2gAAAQsY29udHJvbGxlcnPlAzhyZXN0b3JlX2xlZGdlcgAAEBRzdGFzaABAbWF5YmVfY29udHJvbGxlcq0BLG1heWJlX3RvdGFsqQE8bWF5YmVfdW5sb2NraW5nHQ5AbWlncmF0ZV9jdXJyZW5jeQAABBRzdGFzaAAsYXBwbHlfc2xhc2gAAAgkc2xhc2hfZXJhBCRzbGFzaF9rZXmBCDhwcnVuZV9lcmFfc3RlcAAABAxlcmEEAhBcdW5yZXNlcnZlX2xlYXNlX2RlcG9zaXQAAAwUYmxvY2sEJGRlcG9zaXRvcq0BHHBhcmFfaWQEfHdpdGhkcmF3X2Nyb3dkbG9hbl9jb250cmlidXRpb24AAAwUYmxvY2sEJGRlcG9zaXRvcq0BHHBhcmFfaWQEbHVucmVzZXJ2ZV9jcm93ZGxvYW5fcmVzZXJ2ZQAADBRibG9jawQkZGVwb3NpdG9yrQEccGFyYV9pZASMdHJhbnNmZXJfdG9fcG9zdF9taWdyYXRpb25fdHJlYXN1cnkAAAQgYXNzZXRfaWQVCgIEIFByZWltYWdlAAEFAgQcU3Rha2luZwABBQIEPFNsYXNoRm9yTWlncmF0ZQABBQIERFN0YWtpbmdEZWxlZ2F0aW9uAAEFAgQQS2V5cwABBQIEOEF1dGhvcml6ZUFsaWFzAAEFAhggUHJlaW1hZ2UBKQ4cU3Rha2luZwEtDkhTdGF0ZVRyaWVNaWdyYXRpb24BMQ5ARGVsZWdhdGVkU3Rha2luZwE1DhxTZXNzaW9uATkOJFhjbVBhbGxldAE9DgAICGlkQQ4YYW1vdW50CARFDgACBDhQb29sTWluQmFsYW5jZQABBQIEPE5vbWluYXRpb25Qb29scwFNDgAICGlkUQ4YYW1vdW50CARVDgACDAxGZWUAAQUQTWlzYwABBQxBbGwAAQUADAhpZGkCGGFtb3VudAgccmVhc29uc10OBGEOAAAoDHdobwAQZnJlZQggcmVzZXJ2ZWQIGGZyb3plbggUaG9sZHNJDhxmcmVlemVzWQ4UbG9ja3NlDjx1bm5hbWVkX3Jlc2VydmUIJGNvbnN1bWVycwQkcHJvdmlkZXJzBARpDgAACBxjcmVhdG9yABxkZXBvc2l0CARxDgACIAxBbnkAAQUsTm9uVHJhbnNmZXIAAQUoR292ZXJuYW5jZQABBRxTdGFraW5nAAEFLENhbmNlbFByb3h5AAEFHEF1Y3Rpb24AAQU8Tm9taW5hdGlvblBvb2xzAAEFQFBhcmFSZWdpc3RyYXRpb24AAQUADCBkZWxlZ2F0ZQAocHJveHlfdHlwZXkOFGRlbGF5BAR9DgAADCRkZWxlZ2F0b3IAHGRlcG9zaXQIHHByb3hpZXOBDgSFDgAACCRkZXBvc2l0b3IAHGRlcG9zaXQIBI0OAAAQNHByZWltYWdlX2hhc2ggMHByZWltYWdlX2xlbgREY2h1bmtfYnl0ZV9vZmZzZXQELGNodW5rX2J5dGVzJASVDgADCAAkBp0OAggsVW5yZXF1ZXN0ZWQAAAgYdGlja2V0nQ4MbGVuBCRSZXF1ZXN0ZWQAAAwwbWF5YmVfdGlja2V0oQ4UY291bnQEJG1heWJlX2xlbvEBAAgQaGFzaCA4cmVxdWVzdF9zdGF0dXOlDgSpDgAADBBoYXNoICRkZXBvc2l0b3IAHGRlcG9zaXQIBLEOAAAgSHRvdGFsX3ZhbHVlX2xvY2tlZKkBNG1pbl9qb2luX2JvbmSpATxtaW5fY3JlYXRlX2JvbmSpASRtYXhfcG9vbHPxAUBtYXhfcG9vbF9tZW1iZXJz8QFkbWF4X3Bvb2xfbWVtYmVyc19wZXJfcG9vbPEBVGdsb2JhbF9tYXhfY29tbWlzc2lvbvEBMGxhc3RfcG9vbF9pZPEBABAccG9vbF9pZAQYcG9pbnRzCHBsYXN0X3JlY29yZGVkX3Jld2FyZF9jb3VudGVyCDh1bmJvbmRpbmdfZXJhc90EAwgAvQ4GGQsAFBxjdXJyZW50FQsMbWF48QEsY2hhbmdlX3JhdGXFDjR0aHJvdHRsZV9mcm9t8QFAY2xhaW1fcGVybWlzc2lvbiELABAkZGVwb3NpdG9yABByb290rQEkbm9taW5hdG9yrQEcYm91bmNlcq0BABQoY29tbWlzc2lvbskOOG1lbWJlcl9jb3VudGVyBBhwb2ludHMIFHJvbGVzzQ4Uc3RhdGUNCwMIBNEOABRwbGFzdF9yZWNvcmRlZF9yZXdhcmRfY291bnRlcghsbGFzdF9yZWNvcmRlZF90b3RhbF9wYXlvdXRzCFR0b3RhbF9yZXdhcmRzX2NsYWltZWQIYHRvdGFsX2NvbW1pc3Npb25fcGVuZGluZwhgdG90YWxfY29tbWlzc2lvbl9jbGFpbWVkCAMIBNkOAAgYcG9pbnRzCBxiYWxhbmNlCAMIBOEOBOUOAAAIGG5vX2VyYeEOIHdpdGhfZXJh6Q4DCATtDgMIBCQDCAAlCwIgNFN0b3JhZ2VWYWx1ZXMAAAQYdmFsdWVzuQ4sUG9vbE1lbWJlcnMAAAQYbWVtYmVywQ4sQm9uZGVkUG9vbHMAAAQQcG9vbNUOLFJld2FyZFBvb2xzAAAEHHJld2FyZHPdDjxTdWJQb29sc1N0b3JhZ2UAAAQkc3ViX3Bvb2xz8Q4gTWV0YWRhdGEAAAQQbWV0YfUOTFJldmVyc2VQb29sSWRMb29rdXAAAAQcbG9va3VwcykIQENsYWltUGVybWlzc2lvbnMAAAQUcGVybXP5DgT9DgAESQwAAAgMd2hvACRzY2hlZHVsZXMFDwQJDwADCATdBAQRDwAADEByZWZlcmVuZHVtX2NvdW508QE4ZGVjaWRpbmdfY291bnRFDSx0cmFja19xdWV1ZRUPBBkPAAIIGHN5c3RlbQHlCxxPcmlnaW5zAe0LACwUdHJhY2sEGG9yaWdpbiEPIHByb3Bvc2FsxQEkZW5hY3RtZW50tQQkc3VibWl0dGVkBEhzdWJtaXNzaW9uX2RlcG9zaXS5BEBkZWNpc2lvbl9kZXBvc2l0vQQgZGVjaWRpbmfFBBR0YWxseckBIGluX3F1ZXVlFBRhbGFybc0EAhgcT25nb2luZwElDyBBcHByb3ZlZAADDAS9BL0EIFJlamVjdGVkAAMMBL0EvQQkQ2FuY2VsbGVkAAMMBL0EvQQgVGltZWRPdXQAAwwEvQS9BBhLaWxsZWQBBAMIBCkPBC0PAAMI/QEIAwj9AVkMAwgA/QECFDRTdG9yYWdlVmFsdWVzAAAEFHRvdGFsCBhDbGFpbXMBNQ8cVmVzdGluZwAACAx3aG/9ASBzY2hlZHVsZVEMHFNpZ25pbmcBOQ8kUHJlY2xhaW1zAT0PBEEPAAAUCGlkABBwcmV2rQEQbmV4dK0BJGJhZ191cHBlcggUc2NvcmUIAAwQaGVhZK0BEHRhaWytASRiYWdfdXBwZXIIAggQTm9kZQAACAhpZAAQbm9kZUkPDEJhZwAACBRzY29yZQgMYmFnTQ8EUQ8AAAw0dG90YWxfcmV0cmllcwQkcmVtYWluaW5nBBhwZXJpb2QEAwhBAlkPAwggQQICDDxJbmNvbXBsZXRlU2luY2UBBBxSZXRyaWVzAV0PGExvb2t1cAFhDwRlDwAAEBRpbmRleAQMd2hvABxkZXBvc2l0CBhmcm96ZW4UBG0PAAMIBL0BBHUPAAAIFHZvdGVzCBxjYXBpdGFsCAAMFHZvdGVzeQ8sZGVsZWdhdGlvbnN9DxRwcmlvctkEABQcYmFsYW5jZQgYdGFyZ2V0AChjb252aWN0aW9urQUsZGVsZWdhdGlvbnN9DxRwcmlvctkEAggcQ2FzdGluZwGBDyhEZWxlZ2F0aW5nAYUPAggkVm90aW5nRm9yAAMMAASJDzRDbGFzc0xvY2tzRm9yAAMIAN0EBI0PAAIcIFByb3Bvc2VkAAEFIEFwcHJvdmVkAAEFGEZ1bmRlZAABBTxDdXJhdG9yUHJvcG9zZWQAAAQcY3VyYXRvcgAYQWN0aXZlAAAIHGN1cmF0b3IAKHVwZGF0ZV9kdWUENFBlbmRpbmdQYXlvdXQAAAwcY3VyYXRvcgAsYmVuZWZpY2lhcnkAJHVubG9ja19hdARMQXBwcm92ZWRXaXRoQ3VyYXRvcgAABBxjdXJhdG9yAAAYIHByb3Bvc2VyABR2YWx1ZQgMZmVlCDxjdXJhdG9yX2RlcG9zaXQIEGJvbmQIGHN0YXR1c5UPAwgEmQ8CECxCb3VudHlDb3VudAEEPEJvdW50eUFwcHJvdmFscwFNAkhCb3VudHlEZXNjcmlwdGlvbnMB9Q4gQm91bnRpZXMBnQ8EoQ8AAwjlCggEqQ8AAgwwTGVhc2VSZXNlcnZlAAAQPHVucmVzZXJ2ZV9ibG9jawQcYWNjb3VudAAccGFyYV9pZAQYYW1vdW50CFRDcm93ZGxvYW5Db250cmlidXRpb24AABQ4d2l0aGRyYXdfYmxvY2sELGNvbnRyaWJ1dG9yABxwYXJhX2lkBBhhbW91bnQIRGNyb3dkbG9hbl9hY2NvdW50AEBDcm93ZGxvYW5SZXNlcnZlAAAQPHVucmVzZXJ2ZV9ibG9jawQkZGVwb3NpdG9yABxwYXJhX2lkBBhhbW91bnQIBLEPAAMIBCAEuQ8AABAgcHJvcG9zZXIAFHZhbHVlCCxiZW5lZmljaWFyeQAQYm9uZAgDCATBDwIMHFBlbmRpbmcAAQUkQXR0ZW1wdGVkAAAECGlkCBhGYWlsZWQAAQUAGChhc3NldF9raW5k5QoYYW1vdW50CCxiZW5lZmljaWFyeYEKKHZhbGlkX2Zyb20EJGV4cGlyZV9hdAQYc3RhdHVzyQ8CHDRQcm9wb3NhbENvdW50AQQkUHJvcG9zYWxzAcUPJEFwcHJvdmFscwFNAihTcGVuZENvdW50AQQYU3BlbmRzAAAICGlkBBhzdGF0dXPNDzxMYXN0U3BlbmRQZXJpb2QB8QEURnVuZHMAAQUE0Q8AABQgbWF5YmVfaWQhAyBwcmlvcml0eQQQY2FsbMUBOG1heWJlX3BlcmlvZGljRQIYb3JpZ2luIQ8G2Q8E3Q8AAAgUYmxvY2sEGGFnZW5kYeEPBOUPAAIIKERlbGVnYXRvcnMAAAwkZGVsZWdhdG9yABRhZ2VudAAYYW1vdW50CBhBZ2VudHMAABQUYWdlbnQAFHBheWVlADx0b3RhbF9kZWxlZ2F0ZWQIVHVuY2xhaW1lZF93aXRoZHJhd2Fscwg0cGVuZGluZ19zbGFzaAgE7Q8AAhAUQWRkZWQAAQU8Q3VyYXRvclByb3Bvc2VkAAAEHGN1cmF0b3IAGEFjdGl2ZQAABBxjdXJhdG9yADRQZW5kaW5nUGF5b3V0AAAMHGN1cmF0b3IALGJlbmVmaWNpYXJ5ACR1bmxvY2tfYXQEABQ0cGFyZW50X2JvdW50eQQUdmFsdWUIDGZlZQg8Y3VyYXRvcl9kZXBvc2l0CBhzdGF0dXP1DwIcQENoaWxkQm91bnR5Q291bnQBBExQYXJlbnRDaGlsZEJvdW50aWVzAAQEAQhgUGFyZW50VG90YWxDaGlsZEJvdW50aWVzAAQEAQgsQ2hpbGRCb3VudHkAAAwkcGFyZW50X2lkBCBjaGlsZF9pZAQwY2hpbGRfYm91bnR5+Q9kQ2hpbGRCb3VudHlEZXNjcmlwdGlvbnNWMQAADCRwYXJlbnRfaWQEIGNoaWxkX2lkBCxkZXNjcmlwdGlvbiRQVjBUb1YxQ2hpbGRCb3VudHlJZHMAAAwsdjBfY2hpbGRfaWQEJHBhcmVudF9pZAQsdjFfY2hpbGRfaWQETENoaWxkcmVuQ3VyYXRvckZlZXMAAAggY2hpbGRfaWQEGGFtb3VudAgE/Q8AAAgUaW5kZXgEFHN0YXJ0qQEGBRAGbQsAQDx2YWxpZGF0b3JfY291bnTxAUxtaW5fdmFsaWRhdG9yX2NvdW508QFIbWluX25vbWluYXRvcl9ib25kqQFIbWluX3ZhbGlkYXRvcl9ib25kqQFAbWluX2FjdGl2ZV9zdGFrZakBOG1pbl9jb21taXNzaW9u8QFQbWF4X3ZhbGlkYXRvcnNfY291bnTxAVBtYXhfbm9taW5hdG9yc19jb3VudPEBLGN1cnJlbnRfZXJh8QEoYWN0aXZlX2VyYQkQJGZvcmNlX2VyYQ0QSG1heF9zdGFrZWRfcmV3YXJkc/EBVHNsYXNoX3Jld2FyZF9mcmFjdGlvbvEBVGNhbmNlbGVkX3NsYXNoX3BheW91dKkBXGN1cnJlbnRfcGxhbm5lZF9zZXNzaW9u8QE8Y2hpbGxfdGhyZXNob2xk8QEAEBRzdGFzaAAUdG90YWwIGGFjdGl2ZQgkdW5sb2NraW5nGQ4ADBx0YXJnZXRz5QMwc3VibWl0dGVkX2luBChzdXBwcmVzc2VkFAAQFHRvdGFsCAxvd24IPG5vbWluYXRvcl9jb3VudAQocGFnZV9jb3VudAQACAx3aG8AFHZhbHVlCAQhEAAACChwYWdlX3RvdGFsCBhvdGhlcnMlEAAIFHRvdGFsBChpbmRpdmlkdWFsDQ0AFCR2YWxpZGF0b3IADG93bggYb3RoZXJzKQ0kcmVwb3J0ZXJz5QMYcGF5b3V0CAJIGFZhbHVlcwEREDRJbnZ1bG5lcmFibGVzAeUDGEJvbmRlZAAACBRzdGFzaAAoY29udHJvbGxlcgAYTGVkZ2VyAAAIKGNvbnRyb2xsZXIAGGxlZGdlchUQFFBheWVlAAAIFHN0YXNoABxwYXltZW50ZQsoVmFsaWRhdG9ycwAACBRzdGFzaAAodmFsaWRhdG9yc2kLKE5vbWluYXRvcnMAAAgUc3Rhc2gALG5vbWluYXRpb25zGRA4VmlydHVhbFN0YWtlcnMBAExFcmFzU3Rha2Vyc092ZXJ2aWV3AAAMDGVyYQQkdmFsaWRhdG9yACBleHBvc3VyZR0QQEVyYXNTdGFrZXJzUGFnZWQAABAMZXJhBCR2YWxpZGF0b3IAEHBhZ2UEIGV4cG9zdXJlKRA4Q2xhaW1lZFJld2FyZHMAAAwMZXJhBCR2YWxpZGF0b3IAHHJld2FyZHNNAkhFcmFzVmFsaWRhdG9yUHJlZnMAAAwMZXJhBCR2YWxpZGF0b3IAFHByZWZzaQtMRXJhc1ZhbGlkYXRvclJld2FyZAAACAxlcmEEGHJld2FyZAhARXJhc1Jld2FyZFBvaW50cwAACAxlcmEEGHBvaW50cy0QOEVyYXNUb3RhbFN0YWtlAAAIDGVyYQQsdG90YWxfc3Rha2UIQFVuYXBwbGllZFNsYXNoZXMAAAgMZXJhBBRzbGFzaDEQKEJvbmRlZEVyYXMBaQRMVmFsaWRhdG9yU2xhc2hJbkVyYQAADAxlcmEEJHZhbGlkYXRvcgAUc2xhc2jZBAQ1EAACfEByZWNlaXZlX2FjY291bnRzAAAEIGFjY291bnRzbQ5EcmVjZWl2ZV9tdWx0aXNpZ3MAAAQgYWNjb3VudHN1DlRyZWNlaXZlX3Byb3h5X3Byb3hpZXMAAAQccHJveGllc4kObHJlY2VpdmVfcHJveHlfYW5ub3VuY2VtZW50cwAABDRhbm5vdW5jZW1lbnRzkQ5ccmVjZWl2ZV9wcmVpbWFnZV9jaHVua3MAAAQYY2h1bmtzmQ58cmVjZWl2ZV9wcmVpbWFnZV9yZXF1ZXN0X3N0YXR1cwAABDhyZXF1ZXN0X3N0YXR1c60OeHJlY2VpdmVfcHJlaW1hZ2VfbGVnYWN5X3N0YXR1cwAABDRsZWdhY3lfc3RhdHVztQ5ocmVjZWl2ZV9ub21fcG9vbHNfbWVzc2FnZXMAAAQgbWVzc2FnZXMBD2RyZWNlaXZlX3Zlc3Rpbmdfc2NoZWR1bGVzAAAEJHNjaGVkdWxlcw0PYHJlY2VpdmVfcmVmZXJlbmRhX3ZhbHVlcwAABBh2YWx1ZXMdD0xyZWNlaXZlX3JlZmVyZW5kdW1zAAAELHJlZmVyZW5kdW1zMQ84cmVjZWl2ZV9jbGFpbXMAAAQgbWVzc2FnZXNFD2hyZWNlaXZlX2JhZ3NfbGlzdF9tZXNzYWdlcwAABCBtZXNzYWdlc1UPaHJlY2VpdmVfc2NoZWR1bGVyX21lc3NhZ2VzAAAEIG1lc3NhZ2VzaQ88cmVjZWl2ZV9pbmRpY2VzAAAEHGluZGljZXNxD4hyZWNlaXZlX2NvbnZpY3Rpb25fdm90aW5nX21lc3NhZ2VzAAAEIG1lc3NhZ2VzkQ9kcmVjZWl2ZV9ib3VudGllc19tZXNzYWdlcwAABCBtZXNzYWdlc6UPTHJlY2VpdmVfYXNzZXRfcmF0ZXMAAAQUcmF0ZXOtD2hyZWNlaXZlX2Nyb3dkbG9hbl9tZXNzYWdlcwAABCBtZXNzYWdlc7UPaHJlY2VpdmVfcmVmZXJlbmRhX21ldGFkYXRhAAAEIG1ldGFkYXRhvQ9kcmVjZWl2ZV90cmVhc3VyeV9tZXNzYWdlcwAABCBtZXNzYWdlc9UPhHJlY2VpdmVfc2NoZWR1bGVyX2FnZW5kYV9tZXNzYWdlcwAABCBtZXNzYWdlc+kPiHJlY2VpdmVfZGVsZWdhdGVkX3N0YWtpbmdfbWVzc2FnZXMAAAQgbWVzc2FnZXPxD3xyZWNlaXZlX2NoaWxkX2JvdW50aWVzX21lc3NhZ2VzAAAEIG1lc3NhZ2VzARBgcmVjZWl2ZV9zdGFraW5nX21lc3NhZ2VzAAAEIG1lc3NhZ2VzORA8Zm9yY2Vfc2V0X3N0YWdlAAAEFHN0YWdlgQs8c3RhcnRfbWlncmF0aW9uAAEFWHNldF9kbXBfcXVldWVfcHJpb3JpdHkAAAQMbmV3iQssc2V0X21hbmFnZXIAAAQMbmV3rQFAZmluaXNoX21pZ3JhdGlvbgAACBBkYXRhqQE8Y29vbF9vZmZfZW5kX2F0BEBzZW5kX3hjbV9tZXNzYWdlAAAIEGRlc3SBChxtZXNzYWdloQsCuBhTeXN0ZW0B9Qs8UGFyYWNoYWluU3lzdGVtASUMJFRpbWVzdGFtcAHtBDRQYXJhY2hhaW5JbmZvAW0BIFByZWltYWdlAQ0FJFNjaGVkdWxlcgEpDChQYXJhbWV0ZXJzAUEMIEJhbGFuY2VzAUUMHFZlc3RpbmcBTQwYQ2xhaW1zAWEMRENvbGxhdG9yU2VsZWN0aW9uASkHHFNlc3Npb24BLQckWGNtcFF1ZXVlAWUMLFBvbGthZG90WGNtAWkMKEN1bXVsdXNYY20BbQFEVG9LdXNhbWFYY21Sb3V0ZXIBbQwwTWVzc2FnZVF1ZXVlARkHYFNub3dicmlkZ2VTeXN0ZW1Gcm9udGVuZAF5DBxVdGlsaXR5AYEMIE11bHRpc2lnAYUMFFByb3h5AY0MHEluZGljZXMBkQwYQXNzZXRzAZUMHFVuaXF1ZXMBnQwQTmZ0cwHJDDRGb3JlaWduQXNzZXRzAc0MKFBvb2xBc3NldHMBlQw8QXNzZXRDb252ZXJzaW9uAdUMIFRyZWFzdXJ5AdkMQENvbnZpY3Rpb25Wb3RpbmcB3QwkUmVmZXJlbmRhAeEMJFdoaXRlbGlzdAHlDCBCb3VudGllcwHpDDRDaGlsZEJvdW50aWVzAe0MJEFzc2V0UmF0ZQHxDEhTdGF0ZVRyaWVNaWdyYXRpb24B4QU8Tm9taW5hdGlvblBvb2xzAQUNJFZvdGVyTGlzdAEJDTxTdGFraW5nUmNDbGllbnQBIQ1ITXVsdGlCbG9ja0VsZWN0aW9uAT0NaE11bHRpQmxvY2tFbGVjdGlvblZlcmlmaWVyAW0BaE11bHRpQmxvY2tFbGVjdGlvblVuc2lnbmVkAQUOYE11bHRpQmxvY2tFbGVjdGlvblNpZ25lZAENDhxTdGFraW5nASEOFEFoT3BzASUOKEFoTWlncmF0b3IBPRAEkQsABqELBKELAAMIgQpNEARREAAAEEBleGVjdXRpb25fcmVzdWx0+Qo4ZW1pdHRlZF9ldmVudHNFECRsb2NhbF94Y21JEDhmb3J3YXJkZWRfeGNtc1UQB1kQJQkADEBleGVjdXRpb25fcmVzdWx0MQo4ZW1pdHRlZF9ldmVudHNFEDhmb3J3YXJkZWRfeGNtc1UQB2EQJQkGZQI=";
    metadataTypes_default = content;
  }
});

// node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/hydration_metadata-KGTJ7Y2K.mjs
var hydration_metadata_KGTJ7Y2K_exports = {};
__export(hydration_metadata_KGTJ7Y2K_exports, {
  default: () => hydration_metadata_default
});
var binMeta, hydration_metadata_default;
var init_hydration_metadata_KGTJ7Y2K = __esm({
  "node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/hydration_metadata-KGTJ7Y2K.mjs"() {
    binMeta = "bWV0YQ/ZDwAMHHNwX2NvcmUYY3J5cHRvLEFjY291bnRJZDMyAAAEAAQBIFt1ODsgMzJdAAAEAAADIAAAAAgACAAABQMADAgwZnJhbWVfc3lzdGVtLEFjY291bnRJbmZvCBROb25jZQEQLEFjY291bnREYXRhARQAFAEUbm9uY2UQARROb25jZQABJGNvbnN1bWVycxABIFJlZkNvdW50AAEkcHJvdmlkZXJzEAEgUmVmQ291bnQAASxzdWZmaWNpZW50cxABIFJlZkNvdW50AAEQZGF0YRQBLEFjY291bnREYXRhAAAQAAAFBQAUDDxwYWxsZXRfYmFsYW5jZXMUdHlwZXMsQWNjb3VudERhdGEEHEJhbGFuY2UBGAAQARBmcmVlGAEcQmFsYW5jZQABIHJlc2VydmVkGAEcQmFsYW5jZQABGGZyb3plbhgBHEJhbGFuY2UAARRmbGFncxwBKEV4dHJhRmxhZ3MAABgAAAUHABwMPHBhbGxldF9iYWxhbmNlcxR0eXBlcyhFeHRyYUZsYWdzAAAEABgBEHUxMjgAACAAAAUAACQMNGZyYW1lX3N1cHBvcnQgZGlzcGF0Y2hAUGVyRGlzcGF0Y2hDbGFzcwQEVAEoAAwBGG5vcm1hbCgBBFQAASxvcGVyYXRpb25hbCgBBFQAASRtYW5kYXRvcnkoAQRUAAAoDChzcF93ZWlnaHRzJHdlaWdodF92MhhXZWlnaHQAAAgBIHJlZl90aW1lLAEMdTY0AAEocHJvb2Zfc2l6ZSwBDHU2NAAALAAABjAAMAAABQYANAg8cHJpbWl0aXZlX3R5cGVzEEgyNTYAAAQABAEgW3U4OyAzMl0AADgAAAIIADwQKHNwX3J1bnRpbWUcZ2VuZXJpYxhkaWdlc3QYRGlnZXN0AAAEARBsb2dzQAE8VmVjPERpZ2VzdEl0ZW0+AABAAAACRABEEChzcF9ydW50aW1lHGdlbmVyaWMYZGlnZXN0KERpZ2VzdEl0ZW0AARQoUHJlUnVudGltZQgASAFEQ29uc2Vuc3VzRW5naW5lSWQAADgBHFZlYzx1OD4ABgAkQ29uc2Vuc3VzCABIAURDb25zZW5zdXNFbmdpbmVJZAAAOAEcVmVjPHU4PgAEABBTZWFsCABIAURDb25zZW5zdXNFbmdpbmVJZAAAOAEcVmVjPHU4PgAFABRPdGhlcgQAOAEcVmVjPHU4PgAAAGRSdW50aW1lRW52aXJvbm1lbnRVcGRhdGVkAAgAAEgAAAMEAAAACABMAAACUABQCDBmcmFtZV9zeXN0ZW0sRXZlbnRSZWNvcmQIBEUBVARUATQADAEUcGhhc2XJCAEUUGhhc2UAARRldmVudFQBBEUAARh0b3BpY3PJAQEYVmVjPFQ+AABUCDxoeWRyYWR4X3J1bnRpbWUwUnVudGltZUV2ZW50AAEJARhTeXN0ZW0EAFgBcGZyYW1lX3N5c3RlbTo6RXZlbnQ8UnVudGltZT4AAQAgQmFsYW5jZXMEAHwBfHBhbGxldF9iYWxhbmNlczo6RXZlbnQ8UnVudGltZT4ABwBIVHJhbnNhY3Rpb25QYXltZW50BACEAahwYWxsZXRfdHJhbnNhY3Rpb25fcGF5bWVudDo6RXZlbnQ8UnVudGltZT4ACQBcTXVsdGlUcmFuc2FjdGlvblBheW1lbnQEAIgBwHBhbGxldF90cmFuc2FjdGlvbl9tdWx0aV9wYXltZW50OjpFdmVudDxSdW50aW1lPgDLACBUcmVhc3VyeQQAjAF8cGFsbGV0X3RyZWFzdXJ5OjpFdmVudDxSdW50aW1lPgALABxVdGlsaXR5BACUAVRwYWxsZXRfdXRpbGl0eTo6RXZlbnQADQAgUHJlaW1hZ2UEAJwBfHBhbGxldF9wcmVpbWFnZTo6RXZlbnQ8UnVudGltZT4ADwAgSWRlbnRpdHkEAKABfHBhbGxldF9pZGVudGl0eTo6RXZlbnQ8UnVudGltZT4AEQAkRGVtb2NyYWN5BACoAYBwYWxsZXRfZGVtb2NyYWN5OjpFdmVudDxSdW50aW1lPgATAEhUZWNobmljYWxDb21taXR0ZWUEALwB/HBhbGxldF9jb2xsZWN0aXZlOjpFdmVudDxSdW50aW1lLCBwYWxsZXRfY29sbGVjdGl2ZTo6SW5zdGFuY2UyPgAZABRQcm94eQQAwAFwcGFsbGV0X3Byb3h5OjpFdmVudDxSdW50aW1lPgAdACBNdWx0aXNpZwQAzAF8cGFsbGV0X211bHRpc2lnOjpFdmVudDxSdW50aW1lPgAfABxVbmlxdWVzBADUAXhwYWxsZXRfdW5pcXVlczo6RXZlbnQ8UnVudGltZT4AIABIU3RhdGVUcmllTWlncmF0aW9uBADwAaxwYWxsZXRfc3RhdGVfdHJpZV9taWdyYXRpb246OkV2ZW50PFJ1bnRpbWU+ACMAQENvbnZpY3Rpb25Wb3RpbmcEAPwBoHBhbGxldF9jb252aWN0aW9uX3ZvdGluZzo6RXZlbnQ8UnVudGltZT4AJAAkUmVmZXJlbmRhBAAJAQGAcGFsbGV0X3JlZmVyZW5kYTo6RXZlbnQ8UnVudGltZT4AJQAkV2hpdGVsaXN0BABRBwGAcGFsbGV0X3doaXRlbGlzdDo6RXZlbnQ8UnVudGltZT4AJwAoRGlzcGF0Y2hlcgQAZQcBhHBhbGxldF9kaXNwYXRjaGVyOjpFdmVudDxSdW50aW1lPgAoADRBc3NldFJlZ2lzdHJ5BABpBwGUcGFsbGV0X2Fzc2V0X3JlZ2lzdHJ5OjpFdmVudDxSdW50aW1lPgAzABhDbGFpbXMEAG0HAXRwYWxsZXRfY2xhaW1zOjpFdmVudDxSdW50aW1lPgA1ADxDb2xsYXRvclJld2FyZHMEAHUHAZxwYWxsZXRfY29sbGF0b3JfcmV3YXJkczo6RXZlbnQ8UnVudGltZT4AOQAgT21uaXBvb2wEAHkHAXxwYWxsZXRfb21uaXBvb2w6OkV2ZW50PFJ1bnRpbWU+ADsAQFRyYW5zYWN0aW9uUGF1c2UEAH0HAaBwYWxsZXRfdHJhbnNhY3Rpb25fcGF1c2U6OkV2ZW50PFJ1bnRpbWU+ADwAGER1c3RlcgQAgQcBdHBhbGxldF9kdXN0ZXI6OkV2ZW50PFJ1bnRpbWU+AD0ATE9tbmlwb29sV2FyZWhvdXNlTE0EAIUHAUkBd2FyZWhvdXNlX2xpcXVpZGl0eV9taW5pbmc6OkV2ZW50PFJ1bnRpbWUsIHdhcmVob3VzZV9saXF1aWRpdHlfbWluaW5nOjoKSW5zdGFuY2UxPgA+AFxPbW5pcG9vbExpcXVpZGl0eU1pbmluZwQAiQcBwHBhbGxldF9vbW5pcG9vbF9saXF1aWRpdHlfbWluaW5nOjpFdmVudDxSdW50aW1lPgA/AAxPVEMEAI0HAWhwYWxsZXRfb3RjOjpFdmVudDxSdW50aW1lPgBAADhDaXJjdWl0QnJlYWtlcgQAkQcBmHBhbGxldF9jaXJjdWl0X2JyZWFrZXI6OkV2ZW50PFJ1bnRpbWU+AEEAGFJvdXRlcgQAlQcBlHBhbGxldF9yb3V0ZV9leGVjdXRvcjo6RXZlbnQ8UnVudGltZT4AQwAsRHluYW1pY0ZlZXMEAJkHAYxwYWxsZXRfZHluYW1pY19mZWVzOjpFdmVudDxSdW50aW1lPgBEABxTdGFraW5nBACdBwF4cGFsbGV0X3N0YWtpbmc6OkV2ZW50PFJ1bnRpbWU+AEUAKFN0YWJsZXN3YXAEAKEHAYRwYWxsZXRfc3RhYmxlc3dhcDo6RXZlbnQ8UnVudGltZT4ARgAUQm9uZHMEALkHAXBwYWxsZXRfYm9uZHM6OkV2ZW50PFJ1bnRpbWU+AEcAOE90Y1NldHRsZW1lbnRzBAC9BwGYcGFsbGV0X290Y19zZXR0bGVtZW50czo6RXZlbnQ8UnVudGltZT4ASAAMTEJQBADBBwFocGFsbGV0X2xicDo6RXZlbnQ8UnVudGltZT4ASQAMWFlLBADJBwFocGFsbGV0X3h5azo6RXZlbnQ8UnVudGltZT4ASgAkUmVmZXJyYWxzBADNBwGAcGFsbGV0X3JlZmVycmFsczo6RXZlbnQ8UnVudGltZT4ASwAsTGlxdWlkYXRpb24EANUHAYhwYWxsZXRfbGlxdWlkYXRpb246OkV2ZW50PFJ1bnRpbWU+AEwADEhTTQQA2QcBaHBhbGxldF9oc206OkV2ZW50PFJ1bnRpbWU+AFIAGFRva2VucwQA3QcBbG9ybWxfdG9rZW5zOjpFdmVudDxSdW50aW1lPgBNAChDdXJyZW5jaWVzBADhBwGEcGFsbGV0X2N1cnJlbmNpZXM6OkV2ZW50PFJ1bnRpbWU+AE8AHFZlc3RpbmcEAOUHAXBvcm1sX3Zlc3Rpbmc6OkV2ZW50PFJ1bnRpbWU+AFEADEVWTQQA6QcBaHBhbGxldF9ldm06OkV2ZW50PFJ1bnRpbWU+AFoAIEV0aGVyZXVtBADxBwFYcGFsbGV0X2V0aGVyZXVtOjpFdmVudABcACxFVk1BY2NvdW50cwQAFQgBjHBhbGxldF9ldm1fYWNjb3VudHM6OkV2ZW50PFJ1bnRpbWU+AF0ASFhZS0xpcXVpZGl0eU1pbmluZwQAGQgBrHBhbGxldF94eWtfbGlxdWlkaXR5X21pbmluZzo6RXZlbnQ8UnVudGltZT4AXwA4WFlLV2FyZWhvdXNlTE0EAB0IAUkBd2FyZWhvdXNlX2xpcXVpZGl0eV9taW5pbmc6OkV2ZW50PFJ1bnRpbWUsIHdhcmVob3VzZV9saXF1aWRpdHlfbWluaW5nOjoKSW5zdGFuY2UyPgBgADhSZWxheUNoYWluSW5mbwQAIQgBmHBhbGxldF9yZWxheWNoYWluX2luZm86OkV2ZW50PFJ1bnRpbWU+AMkADERDQQQAJQgBaHBhbGxldF9kY2E6OkV2ZW50PFJ1bnRpbWU+AEIAJFNjaGVkdWxlcgQAKQgBgHBhbGxldF9zY2hlZHVsZXI6OkV2ZW50PFJ1bnRpbWU+AAUAPFBhcmFjaGFpblN5c3RlbQQAMQgBvGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW06OkV2ZW50PFJ1bnRpbWU+AGcALFBvbGthZG90WGNtBAA1CAFocGFsbGV0X3hjbTo6RXZlbnQ8UnVudGltZT4AawAoQ3VtdWx1c1hjbQQAPQgBiGN1bXVsdXNfcGFsbGV0X3hjbTo6RXZlbnQ8UnVudGltZT4AbQAkWGNtcFF1ZXVlBABBCAGkY3VtdWx1c19wYWxsZXRfeGNtcF9xdWV1ZTo6RXZlbnQ8UnVudGltZT4AbwAwTWVzc2FnZVF1ZXVlBABFCAGQcGFsbGV0X21lc3NhZ2VfcXVldWU6OkV2ZW50PFJ1bnRpbWU+AHIAHE9ybWxYY20EAE0IAWBvcm1sX3hjbTo6RXZlbnQ8UnVudGltZT4AhwAcWFRva2VucwQAUQgBcG9ybWxfeHRva2Vuczo6RXZlbnQ8UnVudGltZT4AiQA0VW5rbm93blRva2VucwQAVQgBaG9ybWxfdW5rbm93bl90b2tlbnM6OkV2ZW50AIsARENvbGxhdG9yU2VsZWN0aW9uBABZCAGkcGFsbGV0X2NvbGxhdG9yX3NlbGVjdGlvbjo6RXZlbnQ8UnVudGltZT4AowAcU2Vzc2lvbgQAXQgBVHBhbGxldF9zZXNzaW9uOjpFdmVudAClABBJc21wBABhCAFscGFsbGV0X2lzbXA6OkV2ZW50PFJ1bnRpbWU+ALQANElzbXBQYXJhY2hhaW4EAH0IAXhpc21wX3BhcmFjaGFpbjo6RXZlbnQ8UnVudGltZT4AtQAsSHlwZXJicmlkZ2UEAIEIAYhwYWxsZXRfaHlwZXJicmlkZ2U6OkV2ZW50PFJ1bnRpbWU+ALYAMFRva2VuR2F0ZXdheQQAmQgBkHBhbGxldF90b2tlbl9nYXRld2F5OjpFdmVudDxSdW50aW1lPgC3ACRFbWFPcmFjbGUEAJ0IAYRwYWxsZXRfZW1hX29yYWNsZTo6RXZlbnQ8UnVudGltZT4AygAkQnJvYWRjYXN0BAChCAGAcGFsbGV0X2Jyb2FkY2FzdDo6RXZlbnQ8UnVudGltZT4AzAAAWAwwZnJhbWVfc3lzdGVtGHBhbGxldBRFdmVudAQEVAABHEBFeHRyaW5zaWNTdWNjZXNzBAE0ZGlzcGF0Y2hfaW5mb1wBMERpc3BhdGNoSW5mbwAABJBBbiBleHRyaW5zaWMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS48RXh0cmluc2ljRmFpbGVkCAE4ZGlzcGF0Y2hfZXJyb3JoATREaXNwYXRjaEVycm9yAAE0ZGlzcGF0Y2hfaW5mb1wBMERpc3BhdGNoSW5mbwABBFBBbiBleHRyaW5zaWMgZmFpbGVkLixDb2RlVXBkYXRlZAACBFBgOmNvZGVgIHdhcyB1cGRhdGVkLihOZXdBY2NvdW50BAEcYWNjb3VudAABMFQ6OkFjY291bnRJZAADBGhBIG5ldyBhY2NvdW50IHdhcyBjcmVhdGVkLjRLaWxsZWRBY2NvdW50BAEcYWNjb3VudAABMFQ6OkFjY291bnRJZAAEBFhBbiBhY2NvdW50IHdhcyByZWFwZWQuIFJlbWFya2VkCAEYc2VuZGVyAAEwVDo6QWNjb3VudElkAAEQaGFzaDQBHFQ6Okhhc2gABQRwT24gb24tY2hhaW4gcmVtYXJrIGhhcHBlbmVkLkRVcGdyYWRlQXV0aG9yaXplZAgBJGNvZGVfaGFzaDQBHFQ6Okhhc2gAATRjaGVja192ZXJzaW9uIAEQYm9vbAAGBGhBbiB1cGdyYWRlIHdhcyBhdXRob3JpemVkLgRwRXZlbnQgZm9yIHRoZSBTeXN0ZW0gcGFsbGV0LlwMNGZyYW1lX3N1cHBvcnQgZGlzcGF0Y2gwRGlzcGF0Y2hJbmZvAAAMARh3ZWlnaHQoARhXZWlnaHQAARRjbGFzc2ABNERpc3BhdGNoQ2xhc3MAASBwYXlzX2ZlZWQBEFBheXMAAGAMNGZyYW1lX3N1cHBvcnQgZGlzcGF0Y2g0RGlzcGF0Y2hDbGFzcwABDBhOb3JtYWwAAAAsT3BlcmF0aW9uYWwAAQAkTWFuZGF0b3J5AAIAAGQMNGZyYW1lX3N1cHBvcnQgZGlzcGF0Y2gQUGF5cwABCAxZZXMAAAAITm8AAQAAaAgoc3BfcnVudGltZTREaXNwYXRjaEVycm9yAAE4FE90aGVyAAAAMENhbm5vdExvb2t1cAABACRCYWRPcmlnaW4AAgAYTW9kdWxlBABsASxNb2R1bGVFcnJvcgADAERDb25zdW1lclJlbWFpbmluZwAEACxOb1Byb3ZpZGVycwAFAEBUb29NYW55Q29uc3VtZXJzAAYAFFRva2VuBABwAShUb2tlbkVycm9yAAcAKEFyaXRobWV0aWMEAHQBPEFyaXRobWV0aWNFcnJvcgAIADRUcmFuc2FjdGlvbmFsBAB4AUhUcmFuc2FjdGlvbmFsRXJyb3IACQAkRXhoYXVzdGVkAAoAKENvcnJ1cHRpb24ACwAsVW5hdmFpbGFibGUADAA4Um9vdE5vdEFsbG93ZWQADQAAbAgoc3BfcnVudGltZSxNb2R1bGVFcnJvcgAACAEUaW5kZXgIAQh1OAABFGVycm9ySAGMW3U4OyBNQVhfTU9EVUxFX0VSUk9SX0VOQ09ERURfU0laRV0AAHAIKHNwX3J1bnRpbWUoVG9rZW5FcnJvcgABKEBGdW5kc1VuYXZhaWxhYmxlAAAAME9ubHlQcm92aWRlcgABADBCZWxvd01pbmltdW0AAgAwQ2Fubm90Q3JlYXRlAAMAMFVua25vd25Bc3NldAAEABhGcm96ZW4ABQAsVW5zdXBwb3J0ZWQABgBAQ2Fubm90Q3JlYXRlSG9sZAAHADROb3RFeHBlbmRhYmxlAAgAHEJsb2NrZWQACQAAdAg0c3BfYXJpdGhtZXRpYzxBcml0aG1ldGljRXJyb3IAAQwkVW5kZXJmbG93AAAAIE92ZXJmbG93AAEAOERpdmlzaW9uQnlaZXJvAAIAAHgIKHNwX3J1bnRpbWVIVHJhbnNhY3Rpb25hbEVycm9yAAEIMExpbWl0UmVhY2hlZAAAABxOb0xheWVyAAEAAHwMPHBhbGxldF9iYWxhbmNlcxhwYWxsZXQURXZlbnQIBFQABEkAAVgcRW5kb3dlZAgBHGFjY291bnQAATBUOjpBY2NvdW50SWQAATBmcmVlX2JhbGFuY2UYAShUOjpCYWxhbmNlAAAEuEFuIGFjY291bnQgd2FzIGNyZWF0ZWQgd2l0aCBzb21lIGZyZWUgYmFsYW5jZS4gRHVzdExvc3QIARxhY2NvdW50AAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQABCD0BQW4gYWNjb3VudCB3YXMgcmVtb3ZlZCB3aG9zZSBiYWxhbmNlIHdhcyBub24temVybyBidXQgYmVsb3cgRXhpc3RlbnRpYWxEZXBvc2l0LHhyZXN1bHRpbmcgaW4gYW4gb3V0cmlnaHQgbG9zcy4gVHJhbnNmZXIMARBmcm9tAAEwVDo6QWNjb3VudElkAAEIdG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAIETFRyYW5zZmVyIHN1Y2NlZWRlZC4oQmFsYW5jZVNldAgBDHdobwABMFQ6OkFjY291bnRJZAABEGZyZWUYAShUOjpCYWxhbmNlAAMEaEEgYmFsYW5jZSB3YXMgc2V0IGJ5IHJvb3QuIFJlc2VydmVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAEBOBTb21lIGJhbGFuY2Ugd2FzIHJlc2VydmVkIChtb3ZlZCBmcm9tIGZyZWUgdG8gcmVzZXJ2ZWQpLihVbnJlc2VydmVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAFBOhTb21lIGJhbGFuY2Ugd2FzIHVucmVzZXJ2ZWQgKG1vdmVkIGZyb20gcmVzZXJ2ZWQgdG8gZnJlZSkuSFJlc2VydmVSZXBhdHJpYXRlZBABEGZyb20AATBUOjpBY2NvdW50SWQAAQh0bwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UAAUhkZXN0aW5hdGlvbl9zdGF0dXOAARhTdGF0dXMABghNAVNvbWUgYmFsYW5jZSB3YXMgbW92ZWQgZnJvbSB0aGUgcmVzZXJ2ZSBvZiB0aGUgZmlyc3QgYWNjb3VudCB0byB0aGUgc2Vjb25kIGFjY291bnQu2EZpbmFsIGFyZ3VtZW50IGluZGljYXRlcyB0aGUgZGVzdGluYXRpb24gYmFsYW5jZSB0eXBlLhxEZXBvc2l0CAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAHBNhTb21lIGFtb3VudCB3YXMgZGVwb3NpdGVkIChlLmcuIGZvciB0cmFuc2FjdGlvbiBmZWVzKS4gV2l0aGRyYXcIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAgEHQFTb21lIGFtb3VudCB3YXMgd2l0aGRyYXduIGZyb20gdGhlIGFjY291bnQgKGUuZy4gZm9yIHRyYW5zYWN0aW9uIGZlZXMpLhxTbGFzaGVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAJBAEBU29tZSBhbW91bnQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgYWNjb3VudCAoZS5nLiBmb3IgbWlzYmVoYXZpb3IpLhhNaW50ZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAoEnFNvbWUgYW1vdW50IHdhcyBtaW50ZWQgaW50byBhbiBhY2NvdW50LhhCdXJuZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAsEnFNvbWUgYW1vdW50IHdhcyBidXJuZWQgZnJvbSBhbiBhY2NvdW50LiRTdXNwZW5kZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAwEFQFTb21lIGFtb3VudCB3YXMgc3VzcGVuZGVkIGZyb20gYW4gYWNjb3VudCAoaXQgY2FuIGJlIHJlc3RvcmVkIGxhdGVyKS4gUmVzdG9yZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAA0EpFNvbWUgYW1vdW50IHdhcyByZXN0b3JlZCBpbnRvIGFuIGFjY291bnQuIFVwZ3JhZGVkBAEMd2hvAAEwVDo6QWNjb3VudElkAA4EYEFuIGFjY291bnQgd2FzIHVwZ3JhZGVkLhhJc3N1ZWQEARhhbW91bnQYAShUOjpCYWxhbmNlAA8ELQFUb3RhbCBpc3N1YW5jZSB3YXMgaW5jcmVhc2VkIGJ5IGBhbW91bnRgLCBjcmVhdGluZyBhIGNyZWRpdCB0byBiZSBiYWxhbmNlZC4kUmVzY2luZGVkBAEYYW1vdW50GAEoVDo6QmFsYW5jZQAQBCUBVG90YWwgaXNzdWFuY2Ugd2FzIGRlY3JlYXNlZCBieSBgYW1vdW50YCwgY3JlYXRpbmcgYSBkZWJ0IHRvIGJlIGJhbGFuY2VkLhhMb2NrZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlABEEYFNvbWUgYmFsYW5jZSB3YXMgbG9ja2VkLiBVbmxvY2tlZAgBDHdobwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UAEgRoU29tZSBiYWxhbmNlIHdhcyB1bmxvY2tlZC4YRnJvemVuCAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQATBGBTb21lIGJhbGFuY2Ugd2FzIGZyb3plbi4YVGhhd2VkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAUBGBTb21lIGJhbGFuY2Ugd2FzIHRoYXdlZC5MVG90YWxJc3N1YW5jZUZvcmNlZAgBDG9sZBgBKFQ6OkJhbGFuY2UAAQxuZXcYAShUOjpCYWxhbmNlABUErFRoZSBgVG90YWxJc3N1YW5jZWAgd2FzIGZvcmNlZnVsbHkgY2hhbmdlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSAFDRmcmFtZV9zdXBwb3J0GHRyYWl0cxh0b2tlbnMQbWlzYzRCYWxhbmNlU3RhdHVzAAEIEEZyZWUAAAAgUmVzZXJ2ZWQAAQAAhAxocGFsbGV0X3RyYW5zYWN0aW9uX3BheW1lbnQYcGFsbGV0FEV2ZW50BARUAAEESFRyYW5zYWN0aW9uRmVlUGFpZAwBDHdobwABMFQ6OkFjY291bnRJZAABKGFjdHVhbF9mZWUYATBCYWxhbmNlT2Y8VD4AAQx0aXAYATBCYWxhbmNlT2Y8VD4AAAhZAUEgdHJhbnNhY3Rpb24gZmVlIGBhY3R1YWxfZmVlYCwgb2Ygd2hpY2ggYHRpcGAgd2FzIGFkZGVkIHRvIHRoZSBtaW5pbXVtIGluY2x1c2lvbiBmZWUsXGhhcyBiZWVuIHBhaWQgYnkgYHdob2AuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0iAyAcGFsbGV0X3RyYW5zYWN0aW9uX211bHRpX3BheW1lbnQYcGFsbGV0FEV2ZW50BARUAAEQLEN1cnJlbmN5U2V0CAEoYWNjb3VudF9pZAABMFQ6OkFjY291bnRJZAABIGFzc2V0X2lkEAEwQXNzZXRJZE9mPFQ+AAAILEN1cnJlbmN5U2V0PFt3aG8sIGN1cnJlbmN5XTRDdXJyZW5jeUFkZGVkBAEgYXNzZXRfaWQQATBBc3NldElkT2Y8VD4AAQhsTmV3IGFjY2VwdGVkIGN1cnJlbmN5IGFkZGVkKFtjdXJyZW5jeV08Q3VycmVuY3lSZW1vdmVkBAEgYXNzZXRfaWQQATBBc3NldElkT2Y8VD4AAghkQWNjZXB0ZWQgY3VycmVuY3kgcmVtb3ZlZChbY3VycmVuY3ldMEZlZVdpdGhkcmF3bhQBKGFjY291bnRfaWQAATBUOjpBY2NvdW50SWQAASBhc3NldF9pZBABMEFzc2V0SWRPZjxUPgABRG5hdGl2ZV9mZWVfYW1vdW50GAEwQmFsYW5jZU9mPFQ+AAFUbm9uX25hdGl2ZV9mZWVfYW1vdW50GAEwQmFsYW5jZU9mPFQ+AAFYZGVzdGluYXRpb25fYWNjb3VudF9pZAABMFQ6OkFjY291bnRJZAADCKxUcmFuc2FjdGlvbiBmZWUgcGFpZCBpbiBub24tbmF0aXZlIGN1cnJlbmN5SQFbQWNjb3VudCwgQ3VycmVuY3ksIE5hdGl2ZSBmZWUgYW1vdW50LCBOb24tbmF0aXZlIGZlZSBhbW91bnQsIERlc3RpbmF0aW9uIGFjY291bnRdBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0jAw8cGFsbGV0X3RyZWFzdXJ5GHBhbGxldBRFdmVudAgEVAAESQABMCBTcGVuZGluZwQBQGJ1ZGdldF9yZW1haW5pbmcYATxCYWxhbmNlT2Y8VCwgST4AAATkV2UgaGF2ZSBlbmRlZCBhIHNwZW5kIHBlcmlvZCBhbmQgd2lsbCBub3cgYWxsb2NhdGUgZnVuZHMuHEF3YXJkZWQMAThwcm9wb3NhbF9pbmRleBABNFByb3Bvc2FsSW5kZXgAARRhd2FyZBgBPEJhbGFuY2VPZjxULCBJPgABHGFjY291bnQAATBUOjpBY2NvdW50SWQAAQR8U29tZSBmdW5kcyBoYXZlIGJlZW4gYWxsb2NhdGVkLhRCdXJudAQBLGJ1cm50X2Z1bmRzGAE8QmFsYW5jZU9mPFQsIEk+AAIEiFNvbWUgb2Ygb3VyIGZ1bmRzIGhhdmUgYmVlbiBidXJudC4gUm9sbG92ZXIEAUByb2xsb3Zlcl9iYWxhbmNlGAE8QmFsYW5jZU9mPFQsIEk+AAMELQFTcGVuZGluZyBoYXMgZmluaXNoZWQ7IHRoaXMgaXMgdGhlIGFtb3VudCB0aGF0IHJvbGxzIG92ZXIgdW50aWwgbmV4dCBzcGVuZC4cRGVwb3NpdAQBFHZhbHVlGAE8QmFsYW5jZU9mPFQsIEk+AAQEfFNvbWUgZnVuZHMgaGF2ZSBiZWVuIGRlcG9zaXRlZC40U3BlbmRBcHByb3ZlZAwBOHByb3Bvc2FsX2luZGV4EAE0UHJvcG9zYWxJbmRleAABGGFtb3VudBgBPEJhbGFuY2VPZjxULCBJPgABLGJlbmVmaWNpYXJ5AAEwVDo6QWNjb3VudElkAAUEnEEgbmV3IHNwZW5kIHByb3Bvc2FsIGhhcyBiZWVuIGFwcHJvdmVkLjxVcGRhdGVkSW5hY3RpdmUIASxyZWFjdGl2YXRlZBgBPEJhbGFuY2VPZjxULCBJPgABLGRlYWN0aXZhdGVkGAE8QmFsYW5jZU9mPFQsIEk+AAYEzFRoZSBpbmFjdGl2ZSBmdW5kcyBvZiB0aGUgcGFsbGV0IGhhdmUgYmVlbiB1cGRhdGVkLkhBc3NldFNwZW5kQXBwcm92ZWQYARRpbmRleBABKFNwZW5kSW5kZXgAAShhc3NldF9raW5kkAEwVDo6QXNzZXRLaW5kAAEYYW1vdW50GAFQQXNzZXRCYWxhbmNlT2Y8VCwgST4AASxiZW5lZmljaWFyeQABOFQ6OkJlbmVmaWNpYXJ5AAEodmFsaWRfZnJvbRABREJsb2NrTnVtYmVyRm9yPFQ+AAEkZXhwaXJlX2F0EAFEQmxvY2tOdW1iZXJGb3I8VD4ABwS0QSBuZXcgYXNzZXQgc3BlbmQgcHJvcG9zYWwgaGFzIGJlZW4gYXBwcm92ZWQuQEFzc2V0U3BlbmRWb2lkZWQEARRpbmRleBABKFNwZW5kSW5kZXgACAR0QW4gYXBwcm92ZWQgc3BlbmQgd2FzIHZvaWRlZC4QUGFpZAgBFGluZGV4EAEoU3BlbmRJbmRleAABKHBheW1lbnRfaWSQAWQ8VDo6UGF5bWFzdGVyIGFzIFBheT46OklkAAkETEEgcGF5bWVudCBoYXBwZW5lZC40UGF5bWVudEZhaWxlZAgBFGluZGV4EAEoU3BlbmRJbmRleAABKHBheW1lbnRfaWSQAWQ8VDo6UGF5bWFzdGVyIGFzIFBheT46OklkAAoEkEEgcGF5bWVudCBmYWlsZWQgYW5kIGNhbiBiZSByZXRyaWVkLjhTcGVuZFByb2Nlc3NlZAQBFGluZGV4EAEoU3BlbmRJbmRleAALCE0BQSBzcGVuZCB3YXMgcHJvY2Vzc2VkIGFuZCByZW1vdmVkIGZyb20gdGhlIHN0b3JhZ2UuIEl0IG1pZ2h0IGhhdmUgYmVlbiBzdWNjZXNzZnVsbHlwcGFpZCBvciBpdCBtYXkgaGF2ZSBleHBpcmVkLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldJAAAAQAAJQMOHBhbGxldF91dGlsaXR5GHBhbGxldBRFdmVudAABGEBCYXRjaEludGVycnVwdGVkCAEUaW5kZXgQAQx1MzIAARRlcnJvcmgBNERpc3BhdGNoRXJyb3IAAAhVAUJhdGNoIG9mIGRpc3BhdGNoZXMgZGlkIG5vdCBjb21wbGV0ZSBmdWxseS4gSW5kZXggb2YgZmlyc3QgZmFpbGluZyBkaXNwYXRjaCBnaXZlbiwgYXNId2VsbCBhcyB0aGUgZXJyb3IuOEJhdGNoQ29tcGxldGVkAAEEyEJhdGNoIG9mIGRpc3BhdGNoZXMgY29tcGxldGVkIGZ1bGx5IHdpdGggbm8gZXJyb3IuYEJhdGNoQ29tcGxldGVkV2l0aEVycm9ycwACBLRCYXRjaCBvZiBkaXNwYXRjaGVzIGNvbXBsZXRlZCBidXQgaGFzIGVycm9ycy40SXRlbUNvbXBsZXRlZAADBB0BQSBzaW5nbGUgaXRlbSB3aXRoaW4gYSBCYXRjaCBvZiBkaXNwYXRjaGVzIGhhcyBjb21wbGV0ZWQgd2l0aCBubyBlcnJvci4oSXRlbUZhaWxlZAQBFGVycm9yaAE0RGlzcGF0Y2hFcnJvcgAEBBEBQSBzaW5nbGUgaXRlbSB3aXRoaW4gYSBCYXRjaCBvZiBkaXNwYXRjaGVzIGhhcyBjb21wbGV0ZWQgd2l0aCBlcnJvci4wRGlzcGF0Y2hlZEFzBAEYcmVzdWx0mAE4RGlzcGF0Y2hSZXN1bHQABQRYQSBjYWxsIHdhcyBkaXNwYXRjaGVkLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldJgEGFJlc3VsdAgEVAGQBEUBaAEICE9rBACQAAAAAAxFcnIEAGgAAAEAAJwMPHBhbGxldF9wcmVpbWFnZRhwYWxsZXQURXZlbnQEBFQAAQwUTm90ZWQEARBoYXNoNAEcVDo6SGFzaAAABGhBIHByZWltYWdlIGhhcyBiZWVuIG5vdGVkLiRSZXF1ZXN0ZWQEARBoYXNoNAEcVDo6SGFzaAABBHhBIHByZWltYWdlIGhhcyBiZWVuIHJlcXVlc3RlZC4cQ2xlYXJlZAQBEGhhc2g0ARxUOjpIYXNoAAIEbEEgcHJlaW1hZ2UgaGFzIGJlbiBjbGVhcmVkLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldKAMPHBhbGxldF9pZGVudGl0eRhwYWxsZXQURXZlbnQEBFQAAUQsSWRlbnRpdHlTZXQEAQx3aG8AATBUOjpBY2NvdW50SWQAAATsQSBuYW1lIHdhcyBzZXQgb3IgcmVzZXQgKHdoaWNoIHdpbGwgcmVtb3ZlIGFsbCBqdWRnZW1lbnRzKS48SWRlbnRpdHlDbGVhcmVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEcZGVwb3NpdBgBMEJhbGFuY2VPZjxUPgABBMxBIG5hbWUgd2FzIGNsZWFyZWQsIGFuZCB0aGUgZ2l2ZW4gYmFsYW5jZSByZXR1cm5lZC44SWRlbnRpdHlLaWxsZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARxkZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAIExEEgbmFtZSB3YXMgcmVtb3ZlZCBhbmQgdGhlIGdpdmVuIGJhbGFuY2Ugc2xhc2hlZC5ISnVkZ2VtZW50UmVxdWVzdGVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAE8cmVnaXN0cmFyX2luZGV4EAE4UmVnaXN0cmFySW5kZXgAAwScQSBqdWRnZW1lbnQgd2FzIGFza2VkIGZyb20gYSByZWdpc3RyYXIuUEp1ZGdlbWVudFVucmVxdWVzdGVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAE8cmVnaXN0cmFyX2luZGV4EAE4UmVnaXN0cmFySW5kZXgABASIQSBqdWRnZW1lbnQgcmVxdWVzdCB3YXMgcmV0cmFjdGVkLjhKdWRnZW1lbnRHaXZlbggBGHRhcmdldAABMFQ6OkFjY291bnRJZAABPHJlZ2lzdHJhcl9pbmRleBABOFJlZ2lzdHJhckluZGV4AAUElEEganVkZ2VtZW50IHdhcyBnaXZlbiBieSBhIHJlZ2lzdHJhci44UmVnaXN0cmFyQWRkZWQEATxyZWdpc3RyYXJfaW5kZXgQAThSZWdpc3RyYXJJbmRleAAGBFhBIHJlZ2lzdHJhciB3YXMgYWRkZWQuQFN1YklkZW50aXR5QWRkZWQMAQxzdWIAATBUOjpBY2NvdW50SWQAARBtYWluAAEwVDo6QWNjb3VudElkAAEcZGVwb3NpdBgBMEJhbGFuY2VPZjxUPgAHBPRBIHN1Yi1pZGVudGl0eSB3YXMgYWRkZWQgdG8gYW4gaWRlbnRpdHkgYW5kIHRoZSBkZXBvc2l0IHBhaWQuSFN1YklkZW50aXR5UmVtb3ZlZAwBDHN1YgABMFQ6OkFjY291bnRJZAABEG1haW4AATBUOjpBY2NvdW50SWQAARxkZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAgECQFBIHN1Yi1pZGVudGl0eSB3YXMgcmVtb3ZlZCBmcm9tIGFuIGlkZW50aXR5IGFuZCB0aGUgZGVwb3NpdCBmcmVlZC5IU3ViSWRlbnRpdHlSZXZva2VkDAEMc3ViAAEwVDo6QWNjb3VudElkAAEQbWFpbgABMFQ6OkFjY291bnRJZAABHGRlcG9zaXQYATBCYWxhbmNlT2Y8VD4ACQgZAUEgc3ViLWlkZW50aXR5IHdhcyBjbGVhcmVkLCBhbmQgdGhlIGdpdmVuIGRlcG9zaXQgcmVwYXRyaWF0ZWQgZnJvbSB0aGXIbWFpbiBpZGVudGl0eSBhY2NvdW50IHRvIHRoZSBzdWItaWRlbnRpdHkgYWNjb3VudC44QXV0aG9yaXR5QWRkZWQEASRhdXRob3JpdHkAATBUOjpBY2NvdW50SWQACgR8QSB1c2VybmFtZSBhdXRob3JpdHkgd2FzIGFkZGVkLkBBdXRob3JpdHlSZW1vdmVkBAEkYXV0aG9yaXR5AAEwVDo6QWNjb3VudElkAAsEhEEgdXNlcm5hbWUgYXV0aG9yaXR5IHdhcyByZW1vdmVkLixVc2VybmFtZVNldAgBDHdobwABMFQ6OkFjY291bnRJZAABIHVzZXJuYW1lpAEsVXNlcm5hbWU8VD4ADAR0QSB1c2VybmFtZSB3YXMgc2V0IGZvciBgd2hvYC44VXNlcm5hbWVRdWV1ZWQMAQx3aG8AATBUOjpBY2NvdW50SWQAASB1c2VybmFtZaQBLFVzZXJuYW1lPFQ+AAEoZXhwaXJhdGlvbhABREJsb2NrTnVtYmVyRm9yPFQ+AA0EGQFBIHVzZXJuYW1lIHdhcyBxdWV1ZWQsIGJ1dCBgd2hvYCBtdXN0IGFjY2VwdCBpdCBwcmlvciB0byBgZXhwaXJhdGlvbmAuSFByZWFwcHJvdmFsRXhwaXJlZAQBFHdob3NlAAEwVDo6QWNjb3VudElkAA4EOQFBIHF1ZXVlZCB1c2VybmFtZSBwYXNzZWQgaXRzIGV4cGlyYXRpb24gd2l0aG91dCBiZWluZyBjbGFpbWVkIGFuZCB3YXMgcmVtb3ZlZC5IUHJpbWFyeVVzZXJuYW1lU2V0CAEMd2hvAAEwVDo6QWNjb3VudElkAAEgdXNlcm5hbWWkASxVc2VybmFtZTxUPgAPBAEBQSB1c2VybmFtZSB3YXMgc2V0IGFzIGEgcHJpbWFyeSBhbmQgY2FuIGJlIGxvb2tlZCB1cCBmcm9tIGB3aG9gLlxEYW5nbGluZ1VzZXJuYW1lUmVtb3ZlZAgBDHdobwABMFQ6OkFjY291bnRJZAABIHVzZXJuYW1lpAEsVXNlcm5hbWU8VD4AEAhdAUEgZGFuZ2xpbmcgdXNlcm5hbWUgKGFzIGluLCBhIHVzZXJuYW1lIGNvcnJlc3BvbmRpbmcgdG8gYW4gYWNjb3VudCB0aGF0IGhhcyByZW1vdmVkIGl0c2xpZGVudGl0eSkgaGFzIGJlZW4gcmVtb3ZlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSkDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAAqAxAcGFsbGV0X2RlbW9jcmFjeRhwYWxsZXQURXZlbnQEBFQAAUQgUHJvcG9zZWQIAThwcm9wb3NhbF9pbmRleBABJFByb3BJbmRleAABHGRlcG9zaXQYATBCYWxhbmNlT2Y8VD4AAAS8QSBtb3Rpb24gaGFzIGJlZW4gcHJvcG9zZWQgYnkgYSBwdWJsaWMgYWNjb3VudC4YVGFibGVkCAE4cHJvcG9zYWxfaW5kZXgQASRQcm9wSW5kZXgAARxkZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAEE2EEgcHVibGljIHByb3Bvc2FsIGhhcyBiZWVuIHRhYmxlZCBmb3IgcmVmZXJlbmR1bSB2b3RlLjhFeHRlcm5hbFRhYmxlZAACBJRBbiBleHRlcm5hbCBwcm9wb3NhbCBoYXMgYmVlbiB0YWJsZWQuHFN0YXJ0ZWQIASRyZWZfaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgAASR0aHJlc2hvbGSsATRWb3RlVGhyZXNob2xkAAMEXEEgcmVmZXJlbmR1bSBoYXMgYmVndW4uGFBhc3NlZAQBJHJlZl9pbmRleBABPFJlZmVyZW5kdW1JbmRleAAEBKxBIHByb3Bvc2FsIGhhcyBiZWVuIGFwcHJvdmVkIGJ5IHJlZmVyZW5kdW0uJE5vdFBhc3NlZAQBJHJlZl9pbmRleBABPFJlZmVyZW5kdW1JbmRleAAFBKxBIHByb3Bvc2FsIGhhcyBiZWVuIHJlamVjdGVkIGJ5IHJlZmVyZW5kdW0uJENhbmNlbGxlZAQBJHJlZl9pbmRleBABPFJlZmVyZW5kdW1JbmRleAAGBIBBIHJlZmVyZW5kdW0gaGFzIGJlZW4gY2FuY2VsbGVkLiREZWxlZ2F0ZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARh0YXJnZXQAATBUOjpBY2NvdW50SWQABwTcQW4gYWNjb3VudCBoYXMgZGVsZWdhdGVkIHRoZWlyIHZvdGUgdG8gYW5vdGhlciBhY2NvdW50LixVbmRlbGVnYXRlZAQBHGFjY291bnQAATBUOjpBY2NvdW50SWQACATkQW4gYWNjb3VudCBoYXMgY2FuY2VsbGVkIGEgcHJldmlvdXMgZGVsZWdhdGlvbiBvcGVyYXRpb24uGFZldG9lZAwBDHdobwABMFQ6OkFjY291bnRJZAABNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAEUdW50aWwQAURCbG9ja051bWJlckZvcjxUPgAJBJRBbiBleHRlcm5hbCBwcm9wb3NhbCBoYXMgYmVlbiB2ZXRvZWQuLEJsYWNrbGlzdGVkBAE0cHJvcG9zYWxfaGFzaDQBHFQ6Okhhc2gACgTEQSBwcm9wb3NhbF9oYXNoIGhhcyBiZWVuIGJsYWNrbGlzdGVkIHBlcm1hbmVudGx5LhRWb3RlZAwBFHZvdGVyAAEwVDo6QWNjb3VudElkAAEkcmVmX2luZGV4EAE8UmVmZXJlbmR1bUluZGV4AAEQdm90ZbABZEFjY291bnRWb3RlPEJhbGFuY2VPZjxUPj4ACwSQQW4gYWNjb3VudCBoYXMgdm90ZWQgaW4gYSByZWZlcmVuZHVtIFNlY29uZGVkCAEgc2Vjb25kZXIAATBUOjpBY2NvdW50SWQAAShwcm9wX2luZGV4EAEkUHJvcEluZGV4AAwEjEFuIGFjY291bnQgaGFzIHNlY2NvbmRlZCBhIHByb3Bvc2FsQFByb3Bvc2FsQ2FuY2VsZWQEAShwcm9wX2luZGV4EAEkUHJvcEluZGV4AA0EYEEgcHJvcG9zYWwgZ290IGNhbmNlbGVkLixNZXRhZGF0YVNldAgBFG93bmVyuAE0TWV0YWRhdGFPd25lcgQ8TWV0YWRhdGEgb3duZXIuARBoYXNoNAEcVDo6SGFzaAQ4UHJlaW1hZ2UgaGFzaC4OBNRNZXRhZGF0YSBmb3IgYSBwcm9wb3NhbCBvciBhIHJlZmVyZW5kdW0gaGFzIGJlZW4gc2V0LjxNZXRhZGF0YUNsZWFyZWQIARRvd25lcrgBNE1ldGFkYXRhT3duZXIEPE1ldGFkYXRhIG93bmVyLgEQaGFzaDQBHFQ6Okhhc2gEOFByZWltYWdlIGhhc2guDwTkTWV0YWRhdGEgZm9yIGEgcHJvcG9zYWwgb3IgYSByZWZlcmVuZHVtIGhhcyBiZWVuIGNsZWFyZWQuTE1ldGFkYXRhVHJhbnNmZXJyZWQMAShwcmV2X293bmVyuAE0TWV0YWRhdGFPd25lcgRgUHJldmlvdXMgbWV0YWRhdGEgb3duZXIuARRvd25lcrgBNE1ldGFkYXRhT3duZXIETE5ldyBtZXRhZGF0YSBvd25lci4BEGhhc2g0ARxUOjpIYXNoBDhQcmVpbWFnZSBoYXNoLhAErE1ldGFkYXRhIGhhcyBiZWVuIHRyYW5zZmVycmVkIHRvIG5ldyBvd25lci4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSsDEBwYWxsZXRfZGVtb2NyYWN5OHZvdGVfdGhyZXNob2xkNFZvdGVUaHJlc2hvbGQAAQxQU3VwZXJNYWpvcml0eUFwcHJvdmUAAABQU3VwZXJNYWpvcml0eUFnYWluc3QAAQA4U2ltcGxlTWFqb3JpdHkAAgAAsAxAcGFsbGV0X2RlbW9jcmFjeRB2b3RlLEFjY291bnRWb3RlBBxCYWxhbmNlARgBCCBTdGFuZGFyZAgBEHZvdGW0ARBWb3RlAAEcYmFsYW5jZRgBHEJhbGFuY2UAAAAUU3BsaXQIAQxheWUYARxCYWxhbmNlAAEMbmF5GAEcQmFsYW5jZQABAAC0DEBwYWxsZXRfZGVtb2NyYWN5EHZvdGUQVm90ZQAABAAIAAAAuAxAcGFsbGV0X2RlbW9jcmFjeRR0eXBlczRNZXRhZGF0YU93bmVyAAEMIEV4dGVybmFsAAAAIFByb3Bvc2FsBAAQASRQcm9wSW5kZXgAAQAoUmVmZXJlbmR1bQQAEAE8UmVmZXJlbmR1bUluZGV4AAIAALwMRHBhbGxldF9jb2xsZWN0aXZlGHBhbGxldBRFdmVudAgEVAAESQABHCBQcm9wb3NlZBABHGFjY291bnQAATBUOjpBY2NvdW50SWQAAThwcm9wb3NhbF9pbmRleBABNFByb3Bvc2FsSW5kZXgAATRwcm9wb3NhbF9oYXNoNAEcVDo6SGFzaAABJHRocmVzaG9sZBABLE1lbWJlckNvdW50AAAISQFBIG1vdGlvbiAoZ2l2ZW4gaGFzaCkgaGFzIGJlZW4gcHJvcG9zZWQgKGJ5IGdpdmVuIGFjY291bnQpIHdpdGggYSB0aHJlc2hvbGQgKGdpdmVuPGBNZW1iZXJDb3VudGApLhRWb3RlZBQBHGFjY291bnQAATBUOjpBY2NvdW50SWQAATRwcm9wb3NhbF9oYXNoNAEcVDo6SGFzaAABFHZvdGVkIAEQYm9vbAABDHllcxABLE1lbWJlckNvdW50AAEIbm8QASxNZW1iZXJDb3VudAABCAUBQSBtb3Rpb24gKGdpdmVuIGhhc2gpIGhhcyBiZWVuIHZvdGVkIG9uIGJ5IGdpdmVuIGFjY291bnQsIGxlYXZpbmcVAWEgdGFsbHkgKHllcyB2b3RlcyBhbmQgbm8gdm90ZXMgZ2l2ZW4gcmVzcGVjdGl2ZWx5IGFzIGBNZW1iZXJDb3VudGApLiBBcHByb3ZlZAQBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAIEwEEgbW90aW9uIHdhcyBhcHByb3ZlZCBieSB0aGUgcmVxdWlyZWQgdGhyZXNob2xkLixEaXNhcHByb3ZlZAQBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAME0EEgbW90aW9uIHdhcyBub3QgYXBwcm92ZWQgYnkgdGhlIHJlcXVpcmVkIHRocmVzaG9sZC4gRXhlY3V0ZWQIATRwcm9wb3NhbF9oYXNoNAEcVDo6SGFzaAABGHJlc3VsdJgBOERpc3BhdGNoUmVzdWx0AAQEIQFBIG1vdGlvbiB3YXMgZXhlY3V0ZWQ7IHJlc3VsdCB3aWxsIGJlIGBPa2AgaWYgaXQgcmV0dXJuZWQgd2l0aG91dCBlcnJvci44TWVtYmVyRXhlY3V0ZWQIATRwcm9wb3NhbF9oYXNoNAEcVDo6SGFzaAABGHJlc3VsdJgBOERpc3BhdGNoUmVzdWx0AAUESQFBIHNpbmdsZSBtZW1iZXIgZGlkIHNvbWUgYWN0aW9uOyByZXN1bHQgd2lsbCBiZSBgT2tgIGlmIGl0IHJldHVybmVkIHdpdGhvdXQgZXJyb3IuGENsb3NlZAwBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAEMeWVzEAEsTWVtYmVyQ291bnQAAQhubxABLE1lbWJlckNvdW50AAYEVQFBIHByb3Bvc2FsIHdhcyBjbG9zZWQgYmVjYXVzZSBpdHMgdGhyZXNob2xkIHdhcyByZWFjaGVkIG9yIGFmdGVyIGl0cyBkdXJhdGlvbiB3YXMgdXAuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0wAwwcGFsbGV0X3Byb3h5GHBhbGxldBRFdmVudAQEVAABFDRQcm94eUV4ZWN1dGVkBAEYcmVzdWx0mAE4RGlzcGF0Y2hSZXN1bHQAAAS8QSBwcm94eSB3YXMgZXhlY3V0ZWQgY29ycmVjdGx5LCB3aXRoIHRoZSBnaXZlbi4sUHVyZUNyZWF0ZWQQARBwdXJlAAEwVDo6QWNjb3VudElkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEocHJveHlfdHlwZcQBMFQ6OlByb3h5VHlwZQABUGRpc2FtYmlndWF0aW9uX2luZGV4yAEMdTE2AAEI3EEgcHVyZSBhY2NvdW50IGhhcyBiZWVuIGNyZWF0ZWQgYnkgbmV3IHByb3h5IHdpdGggZ2l2ZW6QZGlzYW1iaWd1YXRpb24gaW5kZXggYW5kIHByb3h5IHR5cGUuJEFubm91bmNlZAwBEHJlYWwAATBUOjpBY2NvdW50SWQAARRwcm94eQABMFQ6OkFjY291bnRJZAABJGNhbGxfaGFzaDQBNENhbGxIYXNoT2Y8VD4AAgTgQW4gYW5ub3VuY2VtZW50IHdhcyBwbGFjZWQgdG8gbWFrZSBhIGNhbGwgaW4gdGhlIGZ1dHVyZS4oUHJveHlBZGRlZBABJGRlbGVnYXRvcgABMFQ6OkFjY291bnRJZAABJGRlbGVnYXRlZQABMFQ6OkFjY291bnRJZAABKHByb3h5X3R5cGXEATBUOjpQcm94eVR5cGUAARRkZWxheRABREJsb2NrTnVtYmVyRm9yPFQ+AAMESEEgcHJveHkgd2FzIGFkZGVkLjBQcm94eVJlbW92ZWQQASRkZWxlZ2F0b3IAATBUOjpBY2NvdW50SWQAASRkZWxlZ2F0ZWUAATBUOjpBY2NvdW50SWQAAShwcm94eV90eXBlxAEwVDo6UHJveHlUeXBlAAEUZGVsYXkQAURCbG9ja051bWJlckZvcjxUPgAEBFBBIHByb3h5IHdhcyByZW1vdmVkLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldMQMPGh5ZHJhZHhfcnVudGltZRhzeXN0ZW0kUHJveHlUeXBlAAEYDEFueQAAACxDYW5jZWxQcm94eQABAChHb3Zlcm5hbmNlAAIAIFRyYW5zZmVyAAMAJExpcXVpZGl0eQAEADxMaXF1aWRpdHlNaW5pbmcABQAAyAAABQQAzAw8cGFsbGV0X211bHRpc2lnGHBhbGxldBRFdmVudAQEVAABECxOZXdNdWx0aXNpZwwBJGFwcHJvdmluZwABMFQ6OkFjY291bnRJZAABIG11bHRpc2lnAAEwVDo6QWNjb3VudElkAAEkY2FsbF9oYXNoBAEgQ2FsbEhhc2gAAASMQSBuZXcgbXVsdGlzaWcgb3BlcmF0aW9uIGhhcyBiZWd1bi5ATXVsdGlzaWdBcHByb3ZhbBABJGFwcHJvdmluZwABMFQ6OkFjY291bnRJZAABJHRpbWVwb2ludNABcFRpbWVwb2ludDxCbG9ja051bWJlckZvcjxUPj4AASBtdWx0aXNpZwABMFQ6OkFjY291bnRJZAABJGNhbGxfaGFzaAQBIENhbGxIYXNoAAEEyEEgbXVsdGlzaWcgb3BlcmF0aW9uIGhhcyBiZWVuIGFwcHJvdmVkIGJ5IHNvbWVvbmUuQE11bHRpc2lnRXhlY3V0ZWQUASRhcHByb3ZpbmcAATBUOjpBY2NvdW50SWQAASR0aW1lcG9pbnTQAXBUaW1lcG9pbnQ8QmxvY2tOdW1iZXJGb3I8VD4+AAEgbXVsdGlzaWcAATBUOjpBY2NvdW50SWQAASRjYWxsX2hhc2gEASBDYWxsSGFzaAABGHJlc3VsdJgBOERpc3BhdGNoUmVzdWx0AAIEnEEgbXVsdGlzaWcgb3BlcmF0aW9uIGhhcyBiZWVuIGV4ZWN1dGVkLkRNdWx0aXNpZ0NhbmNlbGxlZBABKGNhbmNlbGxpbmcAATBUOjpBY2NvdW50SWQAASR0aW1lcG9pbnTQAXBUaW1lcG9pbnQ8QmxvY2tOdW1iZXJGb3I8VD4+AAEgbXVsdGlzaWcAATBUOjpBY2NvdW50SWQAASRjYWxsX2hhc2gEASBDYWxsSGFzaAADBKBBIG11bHRpc2lnIG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV00Ag8cGFsbGV0X211bHRpc2lnJFRpbWVwb2ludAQsQmxvY2tOdW1iZXIBEAAIARhoZWlnaHQQASxCbG9ja051bWJlcgABFGluZGV4EAEMdTMyAADUDDhwYWxsZXRfdW5pcXVlcxhwYWxsZXQURXZlbnQIBFQABEkAAWwcQ3JlYXRlZAwBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARxjcmVhdG9yAAEwVDo6QWNjb3VudElkAAEUb3duZXIAATBUOjpBY2NvdW50SWQAAARsQSBgY29sbGVjdGlvbmAgd2FzIGNyZWF0ZWQuMEZvcmNlQ3JlYXRlZAgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARRvd25lcgABMFQ6OkFjY291bnRJZAABBIRBIGBjb2xsZWN0aW9uYCB3YXMgZm9yY2UtY3JlYXRlZC4kRGVzdHJveWVkBAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAACBHRBIGBjb2xsZWN0aW9uYCB3YXMgZGVzdHJveWVkLhhJc3N1ZWQMAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQaXRlbRgBJFQ6Okl0ZW1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAMEVEFuIGBpdGVtYCB3YXMgaXNzdWVkLixUcmFuc2ZlcnJlZBABKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEQZnJvbQABMFQ6OkFjY291bnRJZAABCHRvAAEwVDo6QWNjb3VudElkAAQEaEFuIGBpdGVtYCB3YXMgdHJhbnNmZXJyZWQuGEJ1cm5lZAwBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEUb3duZXIAATBUOjpBY2NvdW50SWQABQRgQW4gYGl0ZW1gIHdhcyBkZXN0cm95ZWQuGEZyb3plbggBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAYEXFNvbWUgYGl0ZW1gIHdhcyBmcm96ZW4uGFRoYXdlZAgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAcEXFNvbWUgYGl0ZW1gIHdhcyB0aGF3ZWQuQENvbGxlY3Rpb25Gcm96ZW4EAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAgEdFNvbWUgYGNvbGxlY3Rpb25gIHdhcyBmcm96ZW4uQENvbGxlY3Rpb25UaGF3ZWQEAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAkEdFNvbWUgYGNvbGxlY3Rpb25gIHdhcyB0aGF3ZWQuME93bmVyQ2hhbmdlZAgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAASRuZXdfb3duZXIAATBUOjpBY2NvdW50SWQACgRIVGhlIG93bmVyIGNoYW5nZWQuLFRlYW1DaGFuZ2VkEAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABGGlzc3VlcgABMFQ6OkFjY291bnRJZAABFGFkbWluAAEwVDo6QWNjb3VudElkAAEcZnJlZXplcgABMFQ6OkFjY291bnRJZAALBHBUaGUgbWFuYWdlbWVudCB0ZWFtIGNoYW5nZWQuQEFwcHJvdmVkVHJhbnNmZXIQAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQaXRlbRgBJFQ6Okl0ZW1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAEgZGVsZWdhdGUAATBUOjpBY2NvdW50SWQADAgxAUFuIGBpdGVtYCBvZiBhIGBjb2xsZWN0aW9uYCBoYXMgYmVlbiBhcHByb3ZlZCBieSB0aGUgYG93bmVyYCBmb3IgdHJhbnNmZXIgYnk0YSBgZGVsZWdhdGVgLkRBcHByb3ZhbENhbmNlbGxlZBABKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEUb3duZXIAATBUOjpBY2NvdW50SWQAASBkZWxlZ2F0ZQABMFQ6OkFjY291bnRJZAANCBkBQW4gYXBwcm92YWwgZm9yIGEgYGRlbGVnYXRlYCBhY2NvdW50IHRvIHRyYW5zZmVyIHRoZSBgaXRlbWAgb2YgYW4gaXRlbahgY29sbGVjdGlvbmAgd2FzIGNhbmNlbGxlZCBieSBpdHMgYG93bmVyYC5ESXRlbVN0YXR1c0NoYW5nZWQEAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAA4EEQFBIGBjb2xsZWN0aW9uYCBoYXMgaGFkIGl0cyBhdHRyaWJ1dGVzIGNoYW5nZWQgYnkgdGhlIGBGb3JjZWAgb3JpZ2luLlRDb2xsZWN0aW9uTWV0YWRhdGFTZXQMAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQZGF0YdgBeEJvdW5kZWRWZWM8dTgsIFQ6OlN0cmluZ0xpbWl0PgABJGlzX2Zyb3plbiABEGJvb2wADwS0TmV3IG1ldGFkYXRhIGhhcyBiZWVuIHNldCBmb3IgYSBgY29sbGVjdGlvbmAuZENvbGxlY3Rpb25NZXRhZGF0YUNsZWFyZWQEAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkABAEtE1ldGFkYXRhIGhhcyBiZWVuIGNsZWFyZWQgZm9yIGEgYGNvbGxlY3Rpb25gLixNZXRhZGF0YVNldBABKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEQZGF0YdgBeEJvdW5kZWRWZWM8dTgsIFQ6OlN0cmluZ0xpbWl0PgABJGlzX2Zyb3plbiABEGJvb2wAEQSYTmV3IG1ldGFkYXRhIGhhcyBiZWVuIHNldCBmb3IgYW4gaXRlbS48TWV0YWRhdGFDbGVhcmVkCAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGl0ZW0YASRUOjpJdGVtSWQAEgSYTWV0YWRhdGEgaGFzIGJlZW4gY2xlYXJlZCBmb3IgYW4gaXRlbS4sUmVkZXBvc2l0ZWQIAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAFAc3VjY2Vzc2Z1bF9pdGVtc9wBOFZlYzxUOjpJdGVtSWQ+ABMEmE1ldGFkYXRhIGhhcyBiZWVuIGNsZWFyZWQgZm9yIGFuIGl0ZW0uMEF0dHJpYnV0ZVNldBABKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAAShtYXliZV9pdGVt4AFET3B0aW9uPFQ6Okl0ZW1JZD4AAQxrZXnkAWxCb3VuZGVkVmVjPHU4LCBUOjpLZXlMaW1pdD4AARR2YWx1ZegBdEJvdW5kZWRWZWM8dTgsIFQ6OlZhbHVlTGltaXQ+ABQEBQFOZXcgYXR0cmlidXRlIG1ldGFkYXRhIGhhcyBiZWVuIHNldCBmb3IgYSBgY29sbGVjdGlvbmAgb3IgYGl0ZW1gLkBBdHRyaWJ1dGVDbGVhcmVkDAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABKG1heWJlX2l0ZW3gAURPcHRpb248VDo6SXRlbUlkPgABDGtleeQBbEJvdW5kZWRWZWM8dTgsIFQ6OktleUxpbWl0PgAVBAUBQXR0cmlidXRlIG1ldGFkYXRhIGhhcyBiZWVuIGNsZWFyZWQgZm9yIGEgYGNvbGxlY3Rpb25gIG9yIGBpdGVtYC5oT3duZXJzaGlwQWNjZXB0YW5jZUNoYW5nZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAAUBtYXliZV9jb2xsZWN0aW9u4AFcT3B0aW9uPFQ6OkNvbGxlY3Rpb25JZD4AFgTAT3duZXJzaGlwIGFjY2VwdGFuY2UgaGFzIGNoYW5nZWQgZm9yIGFuIGFjY291bnQuWENvbGxlY3Rpb25NYXhTdXBwbHlTZXQIAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEobWF4X3N1cHBseRABDHUzMgAXBKRNYXggc3VwcGx5IGhhcyBiZWVuIHNldCBmb3IgYSBjb2xsZWN0aW9uLjBJdGVtUHJpY2VTZXQQAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQaXRlbRgBJFQ6Okl0ZW1JZAABFHByaWNlGAE8SXRlbVByaWNlPFQsIEk+AAFEd2hpdGVsaXN0ZWRfYnV5ZXLsAVBPcHRpb248VDo6QWNjb3VudElkPgAYBIxUaGUgcHJpY2Ugd2FzIHNldCBmb3IgdGhlIGluc3RhbmNlLkBJdGVtUHJpY2VSZW1vdmVkCAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGl0ZW0YASRUOjpJdGVtSWQAGQScVGhlIHByaWNlIGZvciB0aGUgaW5zdGFuY2Ugd2FzIHJlbW92ZWQuKEl0ZW1Cb3VnaHQUAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQaXRlbRgBJFQ6Okl0ZW1JZAABFHByaWNlGAE8SXRlbVByaWNlPFQsIEk+AAEYc2VsbGVyAAEwVDo6QWNjb3VudElkAAEUYnV5ZXIAATBUOjpBY2NvdW50SWQAGgRMQW4gaXRlbSB3YXMgYm91Z2h0LgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldNgMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AADcAAACGADgBBhPcHRpb24EBFQBGAEIEE5vbmUAAAAQU29tZQQAGAAAAQAA5AxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQgEUwAABAA4ARhWZWM8VD4AAOgMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AADsBBhPcHRpb24EBFQBAAEIEE5vbmUAAAAQU29tZQQAAAAAAQAA8AxscGFsbGV0X3N0YXRlX3RyaWVfbWlncmF0aW9uGHBhbGxldBRFdmVudAQEVAABECBNaWdyYXRlZAwBDHRvcBABDHUzMgABFGNoaWxkEAEMdTMyAAEcY29tcHV0ZfQBQE1pZ3JhdGlvbkNvbXB1dGUAAAg5AUdpdmVuIG51bWJlciBvZiBgKHRvcCwgY2hpbGQpYCBrZXlzIHdlcmUgbWlncmF0ZWQgcmVzcGVjdGl2ZWx5LCB3aXRoIHRoZSBnaXZlbihgY29tcHV0ZWAuHFNsYXNoZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYATBCYWxhbmNlT2Y8VD4AAQS0U29tZSBhY2NvdW50IGdvdCBzbGFzaGVkIGJ5IHRoZSBnaXZlbiBhbW91bnQuVEF1dG9NaWdyYXRpb25GaW5pc2hlZAACBIRUaGUgYXV0byBtaWdyYXRpb24gdGFzayBmaW5pc2hlZC4YSGFsdGVkBAEUZXJyb3L4ASBFcnJvcjxUPgADBOxNaWdyYXRpb24gZ290IGhhbHRlZCBkdWUgdG8gYW4gZXJyb3Igb3IgbWlzcy1jb25maWd1cmF0aW9uLgRwSW5uZXIgZXZlbnRzIG9mIHRoaXMgcGFsbGV0LvQMbHBhbGxldF9zdGF0ZV90cmllX21pZ3JhdGlvbhhwYWxsZXRATWlncmF0aW9uQ29tcHV0ZQABCBhTaWduZWQAAAAQQXV0bwABAAD4DGxwYWxsZXRfc3RhdGVfdHJpZV9taWdyYXRpb24YcGFsbGV0FEVycm9yBARUAAEYPE1heFNpZ25lZExpbWl0cwAABIBNYXggc2lnbmVkIGxpbWl0cyBub3QgcmVzcGVjdGVkLihLZXlUb29Mb25nAAEctEEga2V5IHdhcyBsb25nZXIgdGhhbiB0aGUgY29uZmlndXJlZCBtYXhpbXVtLgARAVRoaXMgbWVhbnMgdGhhdCB0aGUgbWlncmF0aW9uIGhhbHRlZCBhdCB0aGUgY3VycmVudCBbYFByb2dyZXNzYF0gYW5kAQFjYW4gYmUgcmVzdW1lZCB3aXRoIGEgbGFyZ2VyIFtgY3JhdGU6OkNvbmZpZzo6TWF4S2V5TGVuYF0gdmFsdWUuIQFSZXRyeWluZyB3aXRoIHRoZSBzYW1lIFtgY3JhdGU6OkNvbmZpZzo6TWF4S2V5TGVuYF0gdmFsdWUgd2lsbCBub3Qgd29yay5FAVRoZSB2YWx1ZSBzaG91bGQgb25seSBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgYSBzdG9yYWdlIG1pZ3JhdGlvbiBmb3IgdGhlIGN1cnJlbnRseZBzdG9yZWQgW2BjcmF0ZTo6UHJvZ3Jlc3M6Okxhc3RLZXlgXS44Tm90RW5vdWdoRnVuZHMAAgSUc3VibWl0dGVyIGRvZXMgbm90IGhhdmUgZW5vdWdoIGZ1bmRzLihCYWRXaXRuZXNzAAMEaEJhZCB3aXRuZXNzIGRhdGEgcHJvdmlkZWQuZFNpZ25lZE1pZ3JhdGlvbk5vdEFsbG93ZWQABAQlAVNpZ25lZCBtaWdyYXRpb24gaXMgbm90IGFsbG93ZWQgYmVjYXVzZSB0aGUgbWF4aW11bSBsaW1pdCBpcyBub3Qgc2V0IHlldC4wQmFkQ2hpbGRSb290AAUEYEJhZCBjaGlsZCByb290IHByb3ZpZGVkLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC78DGBwYWxsZXRfY29udmljdGlvbl92b3RpbmcYcGFsbGV0FEV2ZW50CARUAARJAAEQJERlbGVnYXRlZAgAAAEwVDo6QWNjb3VudElkAAAAATBUOjpBY2NvdW50SWQAAAQdAUFuIGFjY291bnQgaGFzIGRlbGVnYXRlZCB0aGVpciB2b3RlIHRvIGFub3RoZXIgYWNjb3VudC4gXFt3aG8sIHRhcmdldFxdLFVuZGVsZWdhdGVkBAAAATBUOjpBY2NvdW50SWQAAQT0QW4gXFthY2NvdW50XF0gaGFzIGNhbmNlbGxlZCBhIHByZXZpb3VzIGRlbGVnYXRpb24gb3BlcmF0aW9uLhRWb3RlZAgBDHdobwABMFQ6OkFjY291bnRJZAABEHZvdGUBAQFwQWNjb3VudFZvdGU8QmFsYW5jZU9mPFQsIEk+PgACBGRBbiBhY2NvdW50IHRoYXQgaGFzIHZvdGVkLFZvdGVSZW1vdmVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEQdm90ZQEBAXBBY2NvdW50Vm90ZTxCYWxhbmNlT2Y8VCwgST4+AAMEYEEgdm90ZSB0aGF0IGJlZW4gcmVtb3ZlZAR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldAEBDGBwYWxsZXRfY29udmljdGlvbl92b3RpbmcQdm90ZSxBY2NvdW50Vm90ZQQcQmFsYW5jZQEYAQwgU3RhbmRhcmQIARB2b3RlBQEBEFZvdGUAARxiYWxhbmNlGAEcQmFsYW5jZQAAABRTcGxpdAgBDGF5ZRgBHEJhbGFuY2UAAQxuYXkYARxCYWxhbmNlAAEAMFNwbGl0QWJzdGFpbgwBDGF5ZRgBHEJhbGFuY2UAAQxuYXkYARxCYWxhbmNlAAEcYWJzdGFpbhgBHEJhbGFuY2UAAgAABQEMYHBhbGxldF9jb252aWN0aW9uX3ZvdGluZxB2b3RlEFZvdGUAAAQACAAAAAkBDEBwYWxsZXRfcmVmZXJlbmRhGHBhbGxldBRFdmVudAgEVAAESQABQCRTdWJtaXR0ZWQMARRpbmRleBABPFJlZmVyZW5kdW1JbmRleARgSW5kZXggb2YgdGhlIHJlZmVyZW5kdW0uARR0cmFja8gBPFRyYWNrSWRPZjxULCBJPgQlAVRoZSB0cmFjayAoYW5kIGJ5IGV4dGVuc2lvbiBwcm9wb3NhbCBkaXNwYXRjaCBvcmlnaW4pIG9mIHRoaXMgcmVmZXJlbmR1bS4BIHByb3Bvc2FsDQEBTEJvdW5kZWRDYWxsT2Y8VCwgST4EgFRoZSBwcm9wb3NhbCBmb3IgdGhlIHJlZmVyZW5kdW0uAASAQSByZWZlcmVuZHVtIGhhcyBiZWVuIHN1Ym1pdHRlZC5URGVjaXNpb25EZXBvc2l0UGxhY2VkDAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgEYEluZGV4IG9mIHRoZSByZWZlcmVuZHVtLgEMd2hvAAEwVDo6QWNjb3VudElkBIxUaGUgYWNjb3VudCB3aG8gcGxhY2VkIHRoZSBkZXBvc2l0LgEYYW1vdW50GAE8QmFsYW5jZU9mPFQsIEk+BIRUaGUgYW1vdW50IHBsYWNlZCBieSB0aGUgYWNjb3VudC4BBJRUaGUgZGVjaXNpb24gZGVwb3NpdCBoYXMgYmVlbiBwbGFjZWQuXERlY2lzaW9uRGVwb3NpdFJlZnVuZGVkDAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgEYEluZGV4IG9mIHRoZSByZWZlcmVuZHVtLgEMd2hvAAEwVDo6QWNjb3VudElkBIxUaGUgYWNjb3VudCB3aG8gcGxhY2VkIHRoZSBkZXBvc2l0LgEYYW1vdW50GAE8QmFsYW5jZU9mPFQsIEk+BIRUaGUgYW1vdW50IHBsYWNlZCBieSB0aGUgYWNjb3VudC4CBJxUaGUgZGVjaXNpb24gZGVwb3NpdCBoYXMgYmVlbiByZWZ1bmRlZC44RGVwb3NpdFNsYXNoZWQIAQx3aG8AATBUOjpBY2NvdW50SWQEjFRoZSBhY2NvdW50IHdobyBwbGFjZWQgdGhlIGRlcG9zaXQuARhhbW91bnQYATxCYWxhbmNlT2Y8VCwgST4EhFRoZSBhbW91bnQgcGxhY2VkIGJ5IHRoZSBhY2NvdW50LgMEbEEgZGVwb3NpdCBoYXMgYmVlbiBzbGFzaGVkLjxEZWNpc2lvblN0YXJ0ZWQQARRpbmRleBABPFJlZmVyZW5kdW1JbmRleARgSW5kZXggb2YgdGhlIHJlZmVyZW5kdW0uARR0cmFja8gBPFRyYWNrSWRPZjxULCBJPgQlAVRoZSB0cmFjayAoYW5kIGJ5IGV4dGVuc2lvbiBwcm9wb3NhbCBkaXNwYXRjaCBvcmlnaW4pIG9mIHRoaXMgcmVmZXJlbmR1bS4BIHByb3Bvc2FsDQEBTEJvdW5kZWRDYWxsT2Y8VCwgST4EgFRoZSBwcm9wb3NhbCBmb3IgdGhlIHJlZmVyZW5kdW0uARR0YWxseU0HASBUOjpUYWxseQS4VGhlIGN1cnJlbnQgdGFsbHkgb2Ygdm90ZXMgaW4gdGhpcyByZWZlcmVuZHVtLgQEvEEgcmVmZXJlbmR1bSBoYXMgbW92ZWQgaW50byB0aGUgZGVjaWRpbmcgcGhhc2UuOENvbmZpcm1TdGFydGVkBAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgEYEluZGV4IG9mIHRoZSByZWZlcmVuZHVtLgUAOENvbmZpcm1BYm9ydGVkBAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgEYEluZGV4IG9mIHRoZSByZWZlcmVuZHVtLgYAJENvbmZpcm1lZAgBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4BGBJbmRleCBvZiB0aGUgcmVmZXJlbmR1bS4BFHRhbGx5TQcBIFQ6OlRhbGx5BLBUaGUgZmluYWwgdGFsbHkgb2Ygdm90ZXMgaW4gdGhpcyByZWZlcmVuZHVtLgcEIQFBIHJlZmVyZW5kdW0gaGFzIGVuZGVkIGl0cyBjb25maXJtYXRpb24gcGhhc2UgYW5kIGlzIHJlYWR5IGZvciBhcHByb3ZhbC4gQXBwcm92ZWQEARRpbmRleBABPFJlZmVyZW5kdW1JbmRleARgSW5kZXggb2YgdGhlIHJlZmVyZW5kdW0uCAQNAUEgcmVmZXJlbmR1bSBoYXMgYmVlbiBhcHByb3ZlZCBhbmQgaXRzIHByb3Bvc2FsIGhhcyBiZWVuIHNjaGVkdWxlZC4gUmVqZWN0ZWQIARRpbmRleBABPFJlZmVyZW5kdW1JbmRleARgSW5kZXggb2YgdGhlIHJlZmVyZW5kdW0uARR0YWxseU0HASBUOjpUYWxseQSwVGhlIGZpbmFsIHRhbGx5IG9mIHZvdGVzIGluIHRoaXMgcmVmZXJlbmR1bS4JBKxBIHByb3Bvc2FsIGhhcyBiZWVuIHJlamVjdGVkIGJ5IHJlZmVyZW5kdW0uIFRpbWVkT3V0CAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgEYEluZGV4IG9mIHRoZSByZWZlcmVuZHVtLgEUdGFsbHlNBwEgVDo6VGFsbHkEsFRoZSBmaW5hbCB0YWxseSBvZiB2b3RlcyBpbiB0aGlzIHJlZmVyZW5kdW0uCgTYQSByZWZlcmVuZHVtIGhhcyBiZWVuIHRpbWVkIG91dCB3aXRob3V0IGJlaW5nIGRlY2lkZWQuJENhbmNlbGxlZAgBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4BGBJbmRleCBvZiB0aGUgcmVmZXJlbmR1bS4BFHRhbGx5TQcBIFQ6OlRhbGx5BLBUaGUgZmluYWwgdGFsbHkgb2Ygdm90ZXMgaW4gdGhpcyByZWZlcmVuZHVtLgsEgEEgcmVmZXJlbmR1bSBoYXMgYmVlbiBjYW5jZWxsZWQuGEtpbGxlZAgBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4BGBJbmRleCBvZiB0aGUgcmVmZXJlbmR1bS4BFHRhbGx5TQcBIFQ6OlRhbGx5BLBUaGUgZmluYWwgdGFsbHkgb2Ygdm90ZXMgaW4gdGhpcyByZWZlcmVuZHVtLgwEdEEgcmVmZXJlbmR1bSBoYXMgYmVlbiBraWxsZWQuZFN1Ym1pc3Npb25EZXBvc2l0UmVmdW5kZWQMARRpbmRleBABPFJlZmVyZW5kdW1JbmRleARgSW5kZXggb2YgdGhlIHJlZmVyZW5kdW0uAQx3aG8AATBUOjpBY2NvdW50SWQEjFRoZSBhY2NvdW50IHdobyBwbGFjZWQgdGhlIGRlcG9zaXQuARhhbW91bnQYATxCYWxhbmNlT2Y8VCwgST4EhFRoZSBhbW91bnQgcGxhY2VkIGJ5IHRoZSBhY2NvdW50Lg0EpFRoZSBzdWJtaXNzaW9uIGRlcG9zaXQgaGFzIGJlZW4gcmVmdW5kZWQuLE1ldGFkYXRhU2V0CAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgEYEluZGV4IG9mIHRoZSByZWZlcmVuZHVtLgEQaGFzaDQBHFQ6Okhhc2gEOFByZWltYWdlIGhhc2guDgScTWV0YWRhdGEgZm9yIGEgcmVmZXJlbmR1bSBoYXMgYmVlbiBzZXQuPE1ldGFkYXRhQ2xlYXJlZAgBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4BGBJbmRleCBvZiB0aGUgcmVmZXJlbmR1bS4BEGhhc2g0ARxUOjpIYXNoBDhQcmVpbWFnZSBoYXNoLg8ErE1ldGFkYXRhIGZvciBhIHJlZmVyZW5kdW0gaGFzIGJlZW4gY2xlYXJlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXQNARA0ZnJhbWVfc3VwcG9ydBh0cmFpdHMkcHJlaW1hZ2VzHEJvdW5kZWQIBFQBEQEESAFFBwEMGExlZ2FjeQQBEGhhc2g0ASRIOjpPdXRwdXQAAAAYSW5saW5lBABJBwE0Qm91bmRlZElubGluZQABABhMb29rdXAIARBoYXNoNAEkSDo6T3V0cHV0AAEMbGVuEAEMdTMyAAIAABEBCDxoeWRyYWR4X3J1bnRpbWUsUnVudGltZUNhbGwAAQEBGFN5c3RlbQQAFQEBrQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8U3lzdGVtLCBSdW50aW1lPgABACRUaW1lc3RhbXAEACUBAbkBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFRpbWVzdGFtcCwgUnVudGltZT4AAwAgQmFsYW5jZXMEACkBAbUBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPEJhbGFuY2VzLCBSdW50aW1lPgAHAFxNdWx0aVRyYW5zYWN0aW9uUGF5bWVudAQAOQEB8QFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8TXVsdGlUcmFuc2FjdGlvblBheW1lbnQsIFJ1bnRpbWU+AMsAIFRyZWFzdXJ5BABRAQG1AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxUcmVhc3VyeSwgUnVudGltZT4ACwAcVXRpbGl0eQQAXQEBsQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8VXRpbGl0eSwgUnVudGltZT4ADQAgUHJlaW1hZ2UEAMUBAbUBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFByZWltYWdlLCBSdW50aW1lPgAPACBJZGVudGl0eQQAzQEBtQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8SWRlbnRpdHksIFJ1bnRpbWU+ABEAJERlbW9jcmFjeQQAfQIBuQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8RGVtb2NyYWN5LCBSdW50aW1lPgATAEhUZWNobmljYWxDb21taXR0ZWUEAIkCAd0Bc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFRlY2huaWNhbENvbW1pdHRlZSwgUnVudGltZT4AGQAUUHJveHkEAI0CAakBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFByb3h5LCBSdW50aW1lPgAdACBNdWx0aXNpZwQAlQIBtQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8TXVsdGlzaWcsIFJ1bnRpbWU+AB8AHFVuaXF1ZXMEAJ0CAbEBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFVuaXF1ZXMsIFJ1bnRpbWU+ACAASFN0YXRlVHJpZU1pZ3JhdGlvbgQApQIB3QFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8U3RhdGVUcmllTWlncmF0aW9uLCBSdW50aW1lPgAjAEBDb252aWN0aW9uVm90aW5nBAC9AgHVAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxDb252aWN0aW9uVm90aW5nLCBSdW50aW1lPgAkACRSZWZlcmVuZGEEAMkCAbkBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFJlZmVyZW5kYSwgUnVudGltZT4AJQAkV2hpdGVsaXN0BADRAgG5AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxXaGl0ZWxpc3QsIFJ1bnRpbWU+ACcAKERpc3BhdGNoZXIEANUCAb0Bc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPERpc3BhdGNoZXIsIFJ1bnRpbWU+ACgANEFzc2V0UmVnaXN0cnkEANkCAckBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPEFzc2V0UmVnaXN0cnksIFJ1bnRpbWU+ADMAGENsYWltcwQAEQMBrQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8Q2xhaW1zLCBSdW50aW1lPgA1ADhHZW5lc2lzSGlzdG9yeQQAGQMBzQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8R2VuZXNpc0hpc3RvcnksIFJ1bnRpbWU+ADcAIE9tbmlwb29sBAAdAwG1AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxPbW5pcG9vbCwgUnVudGltZT4AOwBAVHJhbnNhY3Rpb25QYXVzZQQALQMB1QFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8VHJhbnNhY3Rpb25QYXVzZSwgUnVudGltZT4APAAYRHVzdGVyBAAxAwGtAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxEdXN0ZXIsIFJ1bnRpbWU+AD0ATE9tbmlwb29sV2FyZWhvdXNlTE0EADUDAeEBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPE9tbmlwb29sV2FyZWhvdXNlTE0sIFJ1bnRpbWU+AD4AXE9tbmlwb29sTGlxdWlkaXR5TWluaW5nBAA5AwHxAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxPbW5pcG9vbExpcXVpZGl0eU1pbmluZywgUnVudGltZT4APwAMT1RDBABtAwGhAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxPVEMsIFJ1bnRpbWU+AEAAOENpcmN1aXRCcmVha2VyBABxAwHNAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxDaXJjdWl0QnJlYWtlciwgUnVudGltZT4AQQAYUm91dGVyBAB5AwGtAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxSb3V0ZXIsIFJ1bnRpbWU+AEMALER5bmFtaWNGZWVzBACRAwHBAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxEeW5hbWljRmVlcywgUnVudGltZT4ARAAcU3Rha2luZwQAnQMBsQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8U3Rha2luZywgUnVudGltZT4ARQAoU3RhYmxlc3dhcAQAoQMBvQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8U3RhYmxlc3dhcCwgUnVudGltZT4ARgAUQm9uZHMEAMUDAakBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPEJvbmRzLCBSdW50aW1lPgBHADhPdGNTZXR0bGVtZW50cwQAyQMBzQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8T3RjU2V0dGxlbWVudHMsIFJ1bnRpbWU+AEgADExCUAQAzQMBoQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8TEJQLCBSdW50aW1lPgBJAAxYWUsEANkDAaEBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFhZSywgUnVudGltZT4ASgAkUmVmZXJyYWxzBADdAwG5AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxSZWZlcnJhbHMsIFJ1bnRpbWU+AEsALExpcXVpZGF0aW9uBADtAwHBAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxMaXF1aWRhdGlvbiwgUnVudGltZT4ATAAMSFNNBADxAwGhAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxIU00sIFJ1bnRpbWU+AFIAGFRva2VucwQADQQBrQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8VG9rZW5zLCBSdW50aW1lPgBNAChDdXJyZW5jaWVzBAARBAG9AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxDdXJyZW5jaWVzLCBSdW50aW1lPgBPABxWZXN0aW5nBAAZBAGxAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxWZXN0aW5nLCBSdW50aW1lPgBRAAxFVk0EACUEAaEBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPEVWTSwgUnVudGltZT4AWgAgRXRoZXJldW0EADUEAbUBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPEV0aGVyZXVtLCBSdW50aW1lPgBcACxFVk1BY2NvdW50cwQAXQQBwQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8RVZNQWNjb3VudHMsIFJ1bnRpbWU+AF0ASFhZS0xpcXVpZGl0eU1pbmluZwQAYQQB3QFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8WFlLTGlxdWlkaXR5TWluaW5nLCBSdW50aW1lPgBfADhYWUtXYXJlaG91c2VMTQQAcQQBzQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8WFlLV2FyZWhvdXNlTE0sIFJ1bnRpbWU+AGAAOFJlbGF5Q2hhaW5JbmZvBAB1BAHNAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxSZWxheUNoYWluSW5mbywgUnVudGltZT4AyQAMRENBBAB5BAGhAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxEQ0EsIFJ1bnRpbWU+AEIAJFNjaGVkdWxlcgQAhQQBuQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8U2NoZWR1bGVyLCBSdW50aW1lPgAFADxQYXJhY2hhaW5TeXN0ZW0EAIkEAdEBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFBhcmFjaGFpblN5c3RlbSwgUnVudGltZT4AZwA0UGFyYWNoYWluSW5mbwQAvQQByQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8UGFyYWNoYWluSW5mbywgUnVudGltZT4AaQAsUG9sa2Fkb3RYY20EAMEEAcEBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFBvbGthZG90WGNtLCBSdW50aW1lPgBrAChDdW11bHVzWGNtBAAhBgG9AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxDdW11bHVzWGNtLCBSdW50aW1lPgBtADBNZXNzYWdlUXVldWUEACUGAcUBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPE1lc3NhZ2VRdWV1ZSwgUnVudGltZT4AcgAcT3JtbFhjbQQALQYBsQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8T3JtbFhjbSwgUnVudGltZT4AhwAcWFRva2VucwQAMQYBsQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8WFRva2VucywgUnVudGltZT4AiQBEQ29sbGF0b3JTZWxlY3Rpb24EAD0GAdkBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPENvbGxhdG9yU2VsZWN0aW9uLCBSdW50aW1lPgCjABxTZXNzaW9uBABBBgGxAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxTZXNzaW9uLCBSdW50aW1lPgClABBJc21wBABNBgGlAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxJc21wLCBSdW50aW1lPgC0ADRJc21wUGFyYWNoYWluBADlBgHJAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxJc21wUGFyYWNoYWluLCBSdW50aW1lPgC1ADBUb2tlbkdhdGV3YXkEAPEGAcUBc2VsZjo6c3BfYXBpX2hpZGRlbl9pbmNsdWRlc19jb25zdHJ1Y3RfcnVudGltZTo6aGlkZGVuX2luY2x1ZGU6OmRpc3BhdGNoCjo6Q2FsbGFibGVDYWxsRm9yPFRva2VuR2F0ZXdheSwgUnVudGltZT4AtwAkRW1hT3JhY2xlBAA9BwG5AXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjpkaXNwYXRjaAo6OkNhbGxhYmxlQ2FsbEZvcjxFbWFPcmFjbGUsIFJ1bnRpbWU+AMoAJEJyb2FkY2FzdAQAQQcBuQFzZWxmOjpzcF9hcGlfaGlkZGVuX2luY2x1ZGVzX2NvbnN0cnVjdF9ydW50aW1lOjpoaWRkZW5faW5jbHVkZTo6ZGlzcGF0Y2gKOjpDYWxsYWJsZUNhbGxGb3I8QnJvYWRjYXN0LCBSdW50aW1lPgDMAAAVAQwwZnJhbWVfc3lzdGVtGHBhbGxldBBDYWxsBARUAAEsGHJlbWFyawQBGHJlbWFyazgBHFZlYzx1OD4AAAxoTWFrZSBzb21lIG9uLWNoYWluIHJlbWFyay4AiENhbiBiZSBleGVjdXRlZCBieSBldmVyeSBgb3JpZ2luYC44c2V0X2hlYXBfcGFnZXMEARRwYWdlczABDHU2NAABBPhTZXQgdGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgV2ViQXNzZW1ibHkgZW52aXJvbm1lbnQncyBoZWFwLiBzZXRfY29kZQQBEGNvZGU4ARxWZWM8dTg+AAIEZFNldCB0aGUgbmV3IHJ1bnRpbWUgY29kZS5cc2V0X2NvZGVfd2l0aG91dF9jaGVja3MEARBjb2RlOAEcVmVjPHU4PgADEBkBU2V0IHRoZSBuZXcgcnVudGltZSBjb2RlIHdpdGhvdXQgZG9pbmcgYW55IGNoZWNrcyBvZiB0aGUgZ2l2ZW4gYGNvZGVgLgBRAU5vdGUgdGhhdCBydW50aW1lIHVwZ3JhZGVzIHdpbGwgbm90IHJ1biBpZiB0aGlzIGlzIGNhbGxlZCB3aXRoIGEgbm90LWluY3JlYXNpbmcgc3BlYyB2ZXJzaW9uISxzZXRfc3RvcmFnZQQBFGl0ZW1zGQEBNFZlYzxLZXlWYWx1ZT4ABARoU2V0IHNvbWUgaXRlbXMgb2Ygc3RvcmFnZS4wa2lsbF9zdG9yYWdlBAEQa2V5cyEBASBWZWM8S2V5PgAFBHRLaWxsIHNvbWUgaXRlbXMgZnJvbSBzdG9yYWdlLixraWxsX3ByZWZpeAgBGHByZWZpeDgBDEtleQABHHN1YmtleXMQAQx1MzIABhARAUtpbGwgYWxsIHN0b3JhZ2UgaXRlbXMgd2l0aCBhIGtleSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBwcmVmaXguADkBKipOT1RFOioqIFdlIHJlbHkgb24gdGhlIFJvb3Qgb3JpZ2luIHRvIHByb3ZpZGUgdXMgdGhlIG51bWJlciBvZiBzdWJrZXlzIHVuZGVyPQF0aGUgcHJlZml4IHdlIGFyZSByZW1vdmluZyB0byBhY2N1cmF0ZWx5IGNhbGN1bGF0ZSB0aGUgd2VpZ2h0IG9mIHRoaXMgZnVuY3Rpb24uRHJlbWFya193aXRoX2V2ZW50BAEYcmVtYXJrOAEcVmVjPHU4PgAHBKRNYWtlIHNvbWUgb24tY2hhaW4gcmVtYXJrIGFuZCBlbWl0IGV2ZW50LkRhdXRob3JpemVfdXBncmFkZQQBJGNvZGVfaGFzaDQBHFQ6Okhhc2gACRBhAUF1dGhvcml6ZSBhbiB1cGdyYWRlIHRvIGEgZ2l2ZW4gYGNvZGVfaGFzaGAgZm9yIHRoZSBydW50aW1lLiBUaGUgcnVudGltZSBjYW4gYmUgc3VwcGxpZWQYbGF0ZXIuAHxUaGlzIGNhbGwgcmVxdWlyZXMgUm9vdCBvcmlnaW4ugGF1dGhvcml6ZV91cGdyYWRlX3dpdGhvdXRfY2hlY2tzBAEkY29kZV9oYXNoNAEcVDo6SGFzaAAKIGEBQXV0aG9yaXplIGFuIHVwZ3JhZGUgdG8gYSBnaXZlbiBgY29kZV9oYXNoYCBmb3IgdGhlIHJ1bnRpbWUuIFRoZSBydW50aW1lIGNhbiBiZSBzdXBwbGllZBhsYXRlci4AXQFXQVJOSU5HOiBUaGlzIGF1dGhvcml6ZXMgYW4gdXBncmFkZSB0aGF0IHdpbGwgdGFrZSBwbGFjZSB3aXRob3V0IGFueSBzYWZldHkgY2hlY2tzLCBmb3JZAWV4YW1wbGUgdGhhdCB0aGUgc3BlYyBuYW1lIHJlbWFpbnMgdGhlIHNhbWUgYW5kIHRoYXQgdGhlIHZlcnNpb24gbnVtYmVyIGluY3JlYXNlcy4gTm908HJlY29tbWVuZGVkIGZvciBub3JtYWwgdXNlLiBVc2UgYGF1dGhvcml6ZV91cGdyYWRlYCBpbnN0ZWFkLgB8VGhpcyBjYWxsIHJlcXVpcmVzIFJvb3Qgb3JpZ2luLmBhcHBseV9hdXRob3JpemVkX3VwZ3JhZGUEARBjb2RlOAEcVmVjPHU4PgALJFUBUHJvdmlkZSB0aGUgcHJlaW1hZ2UgKHJ1bnRpbWUgYmluYXJ5KSBgY29kZWAgZm9yIGFuIHVwZ3JhZGUgdGhhdCBoYXMgYmVlbiBhdXRob3JpemVkLgBJAUlmIHRoZSBhdXRob3JpemF0aW9uIHJlcXVpcmVkIGEgdmVyc2lvbiBjaGVjaywgdGhpcyBjYWxsIHdpbGwgZW5zdXJlIHRoZSBzcGVjIG5hbWXocmVtYWlucyB1bmNoYW5nZWQgYW5kIHRoYXQgdGhlIHNwZWMgdmVyc2lvbiBoYXMgaW5jcmVhc2VkLgBZAURlcGVuZGluZyBvbiB0aGUgcnVudGltZSdzIGBPblNldENvZGVgIGNvbmZpZ3VyYXRpb24sIHRoaXMgZnVuY3Rpb24gbWF5IGRpcmVjdGx5IGFwcGx5EQF0aGUgbmV3IGBjb2RlYCBpbiB0aGUgc2FtZSBibG9jayBvciBhdHRlbXB0IHRvIHNjaGVkdWxlIHRoZSB1cGdyYWRlLgBgQWxsIG9yaWdpbnMgYXJlIGFsbG93ZWQuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLhkBAAACHQEAHQEAAAQIODgAIQEAAAI4ACUBDEBwYWxsZXRfdGltZXN0YW1wGHBhbGxldBBDYWxsBARUAAEEDHNldAQBDG5vdywBJFQ6Ok1vbWVudAAATFRTZXQgdGhlIGN1cnJlbnQgdGltZS4AVQFUaGlzIGNhbGwgc2hvdWxkIGJlIGludm9rZWQgZXhhY3RseSBvbmNlIHBlciBibG9jay4gSXQgd2lsbCBwYW5pYyBhdCB0aGUgZmluYWxpemF0aW9u1HBoYXNlLCBpZiB0aGlzIGNhbGwgaGFzbid0IGJlZW4gaW52b2tlZCBieSB0aGF0IHRpbWUuAEEBVGhlIHRpbWVzdGFtcCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyBvbmUgYnkgdGhlIGFtb3VudCBzcGVjaWZpZWQgYnloW2BDb25maWc6Ok1pbmltdW1QZXJpb2RgXS4AxFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9Ob25lXy4AUQFUaGlzIGRpc3BhdGNoIGNsYXNzIGlzIF9NYW5kYXRvcnlfIHRvIGVuc3VyZSBpdCBnZXRzIGV4ZWN1dGVkIGluIHRoZSBibG9jay4gQmUgYXdhcmVRAXRoYXQgY2hhbmdpbmcgdGhlIGNvbXBsZXhpdHkgb2YgdGhpcyBjYWxsIGNvdWxkIHJlc3VsdCBleGhhdXN0aW5nIHRoZSByZXNvdXJjZXMgaW4gYYRibG9jayB0byBleGVjdXRlIGFueSBvdGhlciBjYWxscy4ANCMjIENvbXBsZXhpdHkxAS0gYE8oMSlgIChOb3RlIHRoYXQgaW1wbGVtZW50YXRpb25zIG9mIGBPblRpbWVzdGFtcFNldGAgbXVzdCBhbHNvIGJlIGBPKDEpYClVAS0gMSBzdG9yYWdlIHJlYWQgYW5kIDEgc3RvcmFnZSBtdXRhdGlvbiAoY29kZWMgYE8oMSlgIGJlY2F1c2Ugb2YgYERpZFVwZGF0ZTo6dGFrZWAgaW5AICBgb25fZmluYWxpemVgKdQtIDEgZXZlbnQgaGFuZGxlciBgb25fdGltZXN0YW1wX3NldGAuIE11c3QgYmUgYE8oMSlgLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy4pAQw8cGFsbGV0X2JhbGFuY2VzGHBhbGxldBBDYWxsCARUAARJAAEkUHRyYW5zZmVyX2FsbG93X2RlYXRoCAEQZGVzdAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEUdmFsdWUtAQEoVDo6QmFsYW5jZQAAHNRUcmFuc2ZlciBzb21lIGxpcXVpZCBmcmVlIGJhbGFuY2UgdG8gYW5vdGhlciBhY2NvdW50LgA1AWB0cmFuc2Zlcl9hbGxvd19kZWF0aGAgd2lsbCBzZXQgdGhlIGBGcmVlQmFsYW5jZWAgb2YgdGhlIHNlbmRlciBhbmQgcmVjZWl2ZXIuEQFJZiB0aGUgc2VuZGVyJ3MgYWNjb3VudCBpcyBiZWxvdyB0aGUgZXhpc3RlbnRpYWwgZGVwb3NpdCBhcyBhIHJlc3VsdLBvZiB0aGUgdHJhbnNmZXIsIHRoZSBhY2NvdW50IHdpbGwgYmUgcmVhcGVkLgAVAVRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIGBTaWduZWRgIGJ5IHRoZSB0cmFuc2FjdG9yLjhmb3JjZV90cmFuc2ZlcgwBGHNvdXJjZQABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEQZGVzdAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEUdmFsdWUtAQEoVDo6QmFsYW5jZQACCGEBRXhhY3RseSBhcyBgdHJhbnNmZXJfYWxsb3dfZGVhdGhgLCBleGNlcHQgdGhlIG9yaWdpbiBtdXN0IGJlIHJvb3QgYW5kIHRoZSBzb3VyY2UgYWNjb3VudERtYXkgYmUgc3BlY2lmaWVkLkx0cmFuc2Zlcl9rZWVwX2FsaXZlCAEQZGVzdAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEUdmFsdWUtAQEoVDo6QmFsYW5jZQADGFkBU2FtZSBhcyB0aGUgW2B0cmFuc2Zlcl9hbGxvd19kZWF0aGBdIGNhbGwsIGJ1dCB3aXRoIGEgY2hlY2sgdGhhdCB0aGUgdHJhbnNmZXIgd2lsbCBub3Rga2lsbCB0aGUgb3JpZ2luIGFjY291bnQuAOg5OSUgb2YgdGhlIHRpbWUgeW91IHdhbnQgW2B0cmFuc2Zlcl9hbGxvd19kZWF0aGBdIGluc3RlYWQuAPBbYHRyYW5zZmVyX2FsbG93X2RlYXRoYF06IHN0cnVjdC5QYWxsZXQuaHRtbCNtZXRob2QudHJhbnNmZXIwdHJhbnNmZXJfYWxsCAEQZGVzdAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEoa2VlcF9hbGl2ZSABEGJvb2wABDwFAVRyYW5zZmVyIHRoZSBlbnRpcmUgdHJhbnNmZXJhYmxlIGJhbGFuY2UgZnJvbSB0aGUgY2FsbGVyIGFjY291bnQuAFkBTk9URTogVGhpcyBmdW5jdGlvbiBvbmx5IGF0dGVtcHRzIHRvIHRyYW5zZmVyIF90cmFuc2ZlcmFibGVfIGJhbGFuY2VzLiBUaGlzIG1lYW5zIHRoYXRhAWFueSBsb2NrZWQsIHJlc2VydmVkLCBvciBleGlzdGVudGlhbCBkZXBvc2l0cyAod2hlbiBga2VlcF9hbGl2ZWAgaXMgYHRydWVgKSwgd2lsbCBub3QgYmVdAXRyYW5zZmVycmVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIGVuc3VyZSB0aGF0IHRoaXMgZnVuY3Rpb24gcmVzdWx0cyBpbiBhIGtpbGxlZCBhY2NvdW50LEUBeW91IG1pZ2h0IG5lZWQgdG8gcHJlcGFyZSB0aGUgYWNjb3VudCBieSByZW1vdmluZyBhbnkgcmVmZXJlbmNlIGNvdW50ZXJzLCBzdG9yYWdlQGRlcG9zaXRzLCBldGMuLi4AwFRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgU2lnbmVkLgCgLSBgZGVzdGA6IFRoZSByZWNpcGllbnQgb2YgdGhlIHRyYW5zZmVyLlkBLSBga2VlcF9hbGl2ZWA6IEEgYm9vbGVhbiB0byBkZXRlcm1pbmUgaWYgdGhlIGB0cmFuc2Zlcl9hbGxgIG9wZXJhdGlvbiBzaG91bGQgc2VuZCBhbGxNASAgb2YgdGhlIGZ1bmRzIHRoZSBhY2NvdW50IGhhcywgY2F1c2luZyB0aGUgc2VuZGVyIGFjY291bnQgdG8gYmUga2lsbGVkIChmYWxzZSksIG9yWQEgIHRyYW5zZmVyIGV2ZXJ5dGhpbmcgZXhjZXB0IGF0IGxlYXN0IHRoZSBleGlzdGVudGlhbCBkZXBvc2l0LCB3aGljaCB3aWxsIGd1YXJhbnRlZSB0b5wgIGtlZXAgdGhlIHNlbmRlciBhY2NvdW50IGFsaXZlICh0cnVlKS48Zm9yY2VfdW5yZXNlcnZlCAEMd2hvAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AARhhbW91bnQYAShUOjpCYWxhbmNlAAUMsFVucmVzZXJ2ZSBzb21lIGJhbGFuY2UgZnJvbSBhIHVzZXIgYnkgZm9yY2UuAGxDYW4gb25seSBiZSBjYWxsZWQgYnkgUk9PVC5AdXBncmFkZV9hY2NvdW50cwQBDHdobzEBAURWZWM8VDo6QWNjb3VudElkPgAGIHBVcGdyYWRlIGEgc3BlY2lmaWVkIGFjY291bnQuAHQtIGBvcmlnaW5gOiBNdXN0IGJlIGBTaWduZWRgLpAtIGB3aG9gOiBUaGUgYWNjb3VudCB0byBiZSB1cGdyYWRlZC4AVQFUaGlzIHdpbGwgd2FpdmUgdGhlIHRyYW5zYWN0aW9uIGZlZSBpZiBhdCBsZWFzdCBhbGwgYnV0IDEwJSBvZiB0aGUgYWNjb3VudHMgbmVlZGVkIHRvQQFiZSB1cGdyYWRlZC4gKFdlIGxldCBzb21lIG5vdCBoYXZlIHRvIGJlIHVwZ3JhZGVkIGp1c3QgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHRoZVhwb3NzaWJpbGl0eSBvZiBjaHVybikuRGZvcmNlX3NldF9iYWxhbmNlCAEMd2hvAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AASBuZXdfZnJlZS0BAShUOjpCYWxhbmNlAAgMrFNldCB0aGUgcmVndWxhciBiYWxhbmNlIG9mIGEgZ2l2ZW4gYWNjb3VudC4AsFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBpcyBgcm9vdGAubGZvcmNlX2FkanVzdF90b3RhbF9pc3N1YW5jZQgBJGRpcmVjdGlvbjUBAUxBZGp1c3RtZW50RGlyZWN0aW9uAAEUZGVsdGEtAQEoVDo6QmFsYW5jZQAJFLhBZGp1c3QgdGhlIHRvdGFsIGlzc3VhbmNlIGluIGEgc2F0dXJhdGluZyB3YXkuAPxDYW4gb25seSBiZSBjYWxsZWQgYnkgcm9vdCBhbmQgYWx3YXlzIG5lZWRzIGEgcG9zaXRpdmUgYGRlbHRhYC4AJCMgRXhhbXBsZRBidXJuCAEUdmFsdWUtAQEoVDo6QmFsYW5jZQABKGtlZXBfYWxpdmUgARBib29sAAoc/EJ1cm4gdGhlIHNwZWNpZmllZCBsaXF1aWQgZnJlZSBiYWxhbmNlIGZyb20gdGhlIG9yaWdpbiBhY2NvdW50LgAlAUlmIHRoZSBvcmlnaW4ncyBhY2NvdW50IGVuZHMgdXAgYmVsb3cgdGhlIGV4aXN0ZW50aWFsIGRlcG9zaXQgYXMgYSByZXN1bHQJAW9mIHRoZSBidXJuIGFuZCBga2VlcF9hbGl2ZWAgaXMgZmFsc2UsIHRoZSBhY2NvdW50IHdpbGwgYmUgcmVhcGVkLgBRAVVubGlrZSBzZW5kaW5nIGZ1bmRzIHRvIGEgX2J1cm5fIGFkZHJlc3MsIHdoaWNoIG1lcmVseSBtYWtlcyB0aGUgZnVuZHMgaW5hY2Nlc3NpYmxlLCEBdGhpcyBgYnVybmAgb3BlcmF0aW9uIHdpbGwgcmVkdWNlIHRvdGFsIGlzc3VhbmNlIGJ5IHRoZSBhbW91bnQgX2J1cm5lZF8uBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLi0BAAAGGAAxAQAAAgAANQEMPHBhbGxldF9iYWxhbmNlcxR0eXBlc0xBZGp1c3RtZW50RGlyZWN0aW9uAAEIIEluY3JlYXNlAAAAIERlY3JlYXNlAAEAADkBDIBwYWxsZXRfdHJhbnNhY3Rpb25fbXVsdGlfcGF5bWVudBhwYWxsZXQQQ2FsbAQEVAABFDBzZXRfY3VycmVuY3kEASBjdXJyZW5jeRABMEFzc2V0SWRPZjxUPgAANKBTZXQgc2VsZWN0ZWQgY3VycmVuY3kgZm9yIGdpdmVuIGFjY291bnQuAGEBVGhpcyBhbGxvd3MgdG8gc2V0IGEgY3VycmVuY3kgZm9yIGFuIGFjY291bnQgaW4gd2hpY2ggYWxsIHRyYW5zYWN0aW9uIGZlZXMgd2lsbCBiZSBwYWlkLnxBY2NvdW50IGJhbGFuY2UgY2Fubm90IGJlIHplcm8uAG0BSW4gY2FzZSBvZiBzdWZmaWNpZW50IGFzc2V0LCB0aGUgY2hvc2VuIGN1cnJlbmN5IG11c3QgYmUgaW4gdGhlIGxpc3Qgb2YgYWNjZXB0ZWQgY3VycmVuY2llc0EBSW4gY2FzZSBvZiBpbnN1ZmZpY2llbnQgYXNzZXQsIHRoZSBjaG9zZW4gY3VycmVuY3kgbXVzdCBoYXZlIGEgWFlLIHBvb2wgd2l0aCBET1QAcQFXaGVuIGN1cnJlbmN5IGlzIHNldCwgZml4ZWQgZmVlIGlzIHdpdGhkcmF3biBmcm9tIHRoZSBhY2NvdW50IHRvIHBheSBmb3IgdGhlIGN1cnJlbmN5IGNoYW5nZQD4RVZNIGFjY291bnRzIGFyZSBub3cgYWxsb3dlZCB0byBjaGFuZ2UgdGhpZXIgcGF5bWVudCBjdXJyZW5jeS4AqEVtaXRzIGBDdXJyZW5jeVNldGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLjBhZGRfY3VycmVuY3kIASBjdXJyZW5jeRABMEFzc2V0SWRPZjxUPgABFHByaWNlPQEBFFByaWNlAAEcyEFkZCBhIGN1cnJlbmN5IHRvIHRoZSBsaXN0IG9mIGFjY2VwdGVkIGN1cnJlbmNpZXMuAJBPbmx5IG1lbWJlciBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4AQQFDdXJyZW5jeSBtdXN0IG5vdCBiZSBhbHJlYWR5IGFjY2VwdGVkLiBDb3JlIGFzc2V0IGlkIGNhbm5vdCBiZSBleHBsaWNpdGx5IGFkZGVkLgCwRW1pdHMgYEN1cnJlbmN5QWRkZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC48cmVtb3ZlX2N1cnJlbmN5BAEgY3VycmVuY3kQATBBc3NldElkT2Y8VD4AAhjUUmVtb3ZlIGN1cnJlbmN5IGZyb20gdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIGN1cnJlbmNpZXO0T25seSBzZWxlY3RlZCBtZW1iZXJzIGNhbiBwZXJmb3JtIHRoaXMgYWN0aW9uAHRDb3JlIGFzc2V0IGNhbm5vdCBiZSByZW1vdmVkLgCgRW1pdHMgYEN1cnJlbmN5UmVtb3ZlZGAgd2hlbiBzdWNjZXNzZnVsLlhyZXNldF9wYXltZW50X2N1cnJlbmN5BAEoYWNjb3VudF9pZAABMFQ6OkFjY291bnRJZAADFLxSZXNldCBjdXJyZW5jeSBvZiB0aGUgc3BlY2lmaWVkIGFjY291bnQgdG8gSERYLhUBSWYgdGhlIGFjY291bnQgaXMgRVZNIGFjY291bnQsIHRoZSBwYXltZW50IGN1cnJlbmN5IGlzIHJlc2V0IHRvIFdFVEguuE9ubHkgc2VsZWN0ZWQgbWVtYmVycyBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4AkEVtaXRzIGBDdXJyZW5jeVNldGAgd2hlbiBzdWNjZXNzZnVsLjxkaXNwYXRjaF9wZXJtaXQkARBmcm9tQQEBEEgxNjAAAQh0b0EBARBIMTYwAAEUdmFsdWVJAQEQVTI1NgABEGRhdGE4ARxWZWM8dTg+AAEkZ2FzX2xpbWl0MAEMdTY0AAEgZGVhZGxpbmVJAQEQVTI1NgABBHYIAQh1OAABBHI0ARBIMjU2AAEEczQBEEgyNTYABBBQRGlzcGF0Y2ggRVZNIHBlcm1pdC7BAVRoZSBtYWluIHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBhbGxvdyBFVk0gYWNjb3VudHMgdG8gcGF5IGZvciB0aGUgdHJhbnNhY3Rpb24gZmVlIGluIG5vbi1uYXRpdmUgY3VycmVuY3nQYnkgYWxsb3dpbmcgdGhlbSB0byBzZWxmLWRpc3BhdGNoIHByZS1zaWduZWQgcGVybWl0LuBUaGUgRVZNIGZlZSBpcyBwYWlkIGluIHRoZSBjdXJyZW5jeSBzZXQgZm9yIHRoZSBhY2NvdW50LgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy49AQw0c3BfYXJpdGhtZXRpYyxmaXhlZF9wb2ludCRGaXhlZFUxMjgAAAQAGAEQdTEyOAAAQQEIPHByaW1pdGl2ZV90eXBlcxBIMTYwAAAEAEUBASBbdTg7IDIwXQAARQEAAAMUAAAACABJAQg8cHJpbWl0aXZlX3R5cGVzEFUyNTYAAAQATQEBIFt1NjQ7IDRdAABNAQAAAwQAAAAwAFEBDDxwYWxsZXRfdHJlYXN1cnkYcGFsbGV0EENhbGwIBFQABEkAARgsc3BlbmRfbG9jYWwIARhhbW91bnQtAQE8QmFsYW5jZU9mPFQsIEk+AAEsYmVuZWZpY2lhcnkAAVBBY2NvdW50SWRMb29rdXBPZjxUPgADRLhQcm9wb3NlIGFuZCBhcHByb3ZlIGEgc3BlbmQgb2YgdHJlYXN1cnkgZnVuZHMuAEgjIyBEaXNwYXRjaCBPcmlnaW4ARQFNdXN0IGJlIFtgQ29uZmlnOjpTcGVuZE9yaWdpbmBdIHdpdGggdGhlIGBTdWNjZXNzYCB2YWx1ZSBiZWluZyBhdCBsZWFzdCBgYW1vdW50YC4ALCMjIyBEZXRhaWxzRQFOT1RFOiBGb3IgcmVjb3JkLWtlZXBpbmcgcHVycG9zZXMsIHRoZSBwcm9wb3NlciBpcyBkZWVtZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUwYmVuZWZpY2lhcnkuADgjIyMgUGFyYW1ldGVyc0EBLSBgYW1vdW50YDogVGhlIGFtb3VudCB0byBiZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSB0cmVhc3VyeSB0byB0aGUgYGJlbmVmaWNpYXJ5YC7oLSBgYmVuZWZpY2lhcnlgOiBUaGUgZGVzdGluYXRpb24gYWNjb3VudCBmb3IgdGhlIHRyYW5zZmVyLgAkIyMgRXZlbnRzALRFbWl0cyBbYEV2ZW50OjpTcGVuZEFwcHJvdmVkYF0gaWYgc3VjY2Vzc2Z1bC48cmVtb3ZlX2FwcHJvdmFsBAEscHJvcG9zYWxfaWRVAQE0UHJvcG9zYWxJbmRleAAEVC0BRm9yY2UgYSBwcmV2aW91c2x5IGFwcHJvdmVkIHByb3Bvc2FsIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgYXBwcm92YWwgcXVldWUuAEgjIyBEaXNwYXRjaCBPcmlnaW4AhE11c3QgYmUgW2BDb25maWc6OlJlamVjdE9yaWdpbmBdLgAoIyMgRGV0YWlscwDAVGhlIG9yaWdpbmFsIGRlcG9zaXQgd2lsbCBubyBsb25nZXIgYmUgcmV0dXJuZWQuADgjIyMgUGFyYW1ldGVyc6AtIGBwcm9wb3NhbF9pZGA6IFRoZSBpbmRleCBvZiBhIHByb3Bvc2FsADgjIyMgQ29tcGxleGl0eawtIE8oQSkgd2hlcmUgYEFgIGlzIHRoZSBudW1iZXIgb2YgYXBwcm92YWxzACgjIyMgRXJyb3JzRQEtIFtgRXJyb3I6OlByb3Bvc2FsTm90QXBwcm92ZWRgXTogVGhlIGBwcm9wb3NhbF9pZGAgc3VwcGxpZWQgd2FzIG5vdCBmb3VuZCBpbiB0aGVRASAgYXBwcm92YWwgcXVldWUsIGkuZS4sIHRoZSBwcm9wb3NhbCBoYXMgbm90IGJlZW4gYXBwcm92ZWQuIFRoaXMgY291bGQgYWxzbyBtZWFuIHRoZVkBICBwcm9wb3NhbCBkb2VzIG5vdCBleGlzdCBhbHRvZ2V0aGVyLCB0aHVzIHRoZXJlIGlzIG5vIHdheSBpdCB3b3VsZCBoYXZlIGJlZW4gYXBwcm92ZWRUICBpbiB0aGUgZmlyc3QgcGxhY2UuFHNwZW5kEAEoYXNzZXRfa2luZJABREJveDxUOjpBc3NldEtpbmQ+AAEYYW1vdW50LQEBUEFzc2V0QmFsYW5jZU9mPFQsIEk+AAEsYmVuZWZpY2lhcnkAAXhCb3g8QmVuZWZpY2lhcnlMb29rdXBPZjxULCBJPj4AASh2YWxpZF9mcm9tWQEBZE9wdGlvbjxCbG9ja051bWJlckZvcjxUPj4ABWi4UHJvcG9zZSBhbmQgYXBwcm92ZSBhIHNwZW5kIG9mIHRyZWFzdXJ5IGZ1bmRzLgBIIyMgRGlzcGF0Y2ggT3JpZ2luAB0BTXVzdCBiZSBbYENvbmZpZzo6U3BlbmRPcmlnaW5gXSB3aXRoIHRoZSBgU3VjY2Vzc2AgdmFsdWUgYmVpbmcgYXQgbGVhc3RVAWBhbW91bnRgIG9mIGBhc3NldF9raW5kYCBpbiB0aGUgbmF0aXZlIGFzc2V0LiBUaGUgYW1vdW50IG9mIGBhc3NldF9raW5kYCBpcyBjb252ZXJ0ZWTUZm9yIGFzc2VydGlvbiB1c2luZyB0aGUgW2BDb25maWc6OkJhbGFuY2VDb252ZXJ0ZXJgXS4AKCMjIERldGFpbHMASQFDcmVhdGUgYW4gYXBwcm92ZWQgc3BlbmQgZm9yIHRyYW5zZmVycmluZyBhIHNwZWNpZmljIGBhbW91bnRgIG9mIGBhc3NldF9raW5kYCB0byBhYQFkZXNpZ25hdGVkIGJlbmVmaWNpYXJ5LiBUaGUgc3BlbmQgbXVzdCBiZSBjbGFpbWVkIHVzaW5nIHRoZSBgcGF5b3V0YCBkaXNwYXRjaGFibGUgd2l0aGludHRoZSBbYENvbmZpZzo6UGF5b3V0UGVyaW9kYF0uADgjIyMgUGFyYW1ldGVycxUBLSBgYXNzZXRfa2luZGA6IEFuIGluZGljYXRvciBvZiB0aGUgc3BlY2lmaWMgYXNzZXQgY2xhc3MgdG8gYmUgc3BlbnQuQQEtIGBhbW91bnRgOiBUaGUgYW1vdW50IHRvIGJlIHRyYW5zZmVycmVkIGZyb20gdGhlIHRyZWFzdXJ5IHRvIHRoZSBgYmVuZWZpY2lhcnlgLrgtIGBiZW5lZmljaWFyeWA6IFRoZSBiZW5lZmljaWFyeSBvZiB0aGUgc3BlbmQuVQEtIGB2YWxpZF9mcm9tYDogVGhlIGJsb2NrIG51bWJlciBmcm9tIHdoaWNoIHRoZSBzcGVuZCBjYW4gYmUgY2xhaW1lZC4gSXQgY2FuIHJlZmVyIHRvGQEgIHRoZSBwYXN0IGlmIHRoZSByZXN1bHRpbmcgc3BlbmQgaGFzIG5vdCB5ZXQgZXhwaXJlZCBhY2NvcmRpbmcgdG8gdGhlRQEgIFtgQ29uZmlnOjpQYXlvdXRQZXJpb2RgXS4gSWYgYE5vbmVgLCB0aGUgc3BlbmQgY2FuIGJlIGNsYWltZWQgaW1tZWRpYXRlbHkgYWZ0ZXIsICBhcHByb3ZhbC4AJCMjIEV2ZW50cwDIRW1pdHMgW2BFdmVudDo6QXNzZXRTcGVuZEFwcHJvdmVkYF0gaWYgc3VjY2Vzc2Z1bC4YcGF5b3V0BAEUaW5kZXgQAShTcGVuZEluZGV4AAZMOENsYWltIGEgc3BlbmQuAEgjIyBEaXNwYXRjaCBPcmlnaW4AOE11c3QgYmUgc2lnbmVkACgjIyBEZXRhaWxzAFUBU3BlbmRzIG11c3QgYmUgY2xhaW1lZCB3aXRoaW4gc29tZSB0ZW1wb3JhbCBib3VuZHMuIEEgc3BlbmQgbWF5IGJlIGNsYWltZWQgd2l0aGluIG9uZdRbYENvbmZpZzo6UGF5b3V0UGVyaW9kYF0gZnJvbSB0aGUgYHZhbGlkX2Zyb21gIGJsb2NrLlUBSW4gY2FzZSBvZiBhIHBheW91dCBmYWlsdXJlLCB0aGUgc3BlbmQgc3RhdHVzIG11c3QgYmUgdXBkYXRlZCB3aXRoIHRoZSBgY2hlY2tfc3RhdHVzYNxkaXNwYXRjaGFibGUgYmVmb3JlIHJldHJ5aW5nIHdpdGggdGhlIGN1cnJlbnQgZnVuY3Rpb24uADgjIyMgUGFyYW1ldGVyc2wtIGBpbmRleGA6IFRoZSBzcGVuZCBpbmRleC4AJCMjIEV2ZW50cwCQRW1pdHMgW2BFdmVudDo6UGFpZGBdIGlmIHN1Y2Nlc3NmdWwuMGNoZWNrX3N0YXR1cwQBFGluZGV4EAEoU3BlbmRJbmRleAAHTCkBQ2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgc3BlbmQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBzdG9yYWdlIGlmIHByb2Nlc3NlZC4ASCMjIERpc3BhdGNoIE9yaWdpbgA8TXVzdCBiZSBzaWduZWQuACgjIyBEZXRhaWxzAAEBVGhlIHN0YXR1cyBjaGVjayBpcyBhIHByZXJlcXVpc2l0ZSBmb3IgcmV0cnlpbmcgYSBmYWlsZWQgcGF5b3V0LkkBSWYgYSBzcGVuZCBoYXMgZWl0aGVyIHN1Y2NlZWRlZCBvciBleHBpcmVkLCBpdCBpcyByZW1vdmVkIGZyb20gdGhlIHN0b3JhZ2UgYnkgdGhpc+xmdW5jdGlvbi4gSW4gc3VjaCBpbnN0YW5jZXMsIHRyYW5zYWN0aW9uIGZlZXMgYXJlIHJlZnVuZGVkLgA4IyMjIFBhcmFtZXRlcnNsLSBgaW5kZXhgOiBUaGUgc3BlbmQgaW5kZXguACQjIyBFdmVudHMA+EVtaXRzIFtgRXZlbnQ6OlBheW1lbnRGYWlsZWRgXSBpZiB0aGUgc3BlbmQgcGF5b3V0IGhhcyBmYWlsZWQuAQFFbWl0cyBbYEV2ZW50OjpTcGVuZFByb2Nlc3NlZGBdIGlmIHRoZSBzcGVuZCBwYXlvdXQgaGFzIHN1Y2NlZWQuKHZvaWRfc3BlbmQEARRpbmRleBABKFNwZW5kSW5kZXgACEB8Vm9pZCBwcmV2aW91c2x5IGFwcHJvdmVkIHNwZW5kLgBIIyMgRGlzcGF0Y2ggT3JpZ2luAIRNdXN0IGJlIFtgQ29uZmlnOjpSZWplY3RPcmlnaW5gXS4AKCMjIERldGFpbHMAHQFBIHNwZW5kIHZvaWQgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgcGF5b3V0IGhhcyBub3QgYmVlbiBhdHRlbXB0ZWQgeWV0LgA4IyMjIFBhcmFtZXRlcnNsLSBgaW5kZXhgOiBUaGUgc3BlbmQgaW5kZXguACQjIyBFdmVudHMAwEVtaXRzIFtgRXZlbnQ6OkFzc2V0U3BlbmRWb2lkZWRgXSBpZiBzdWNjZXNzZnVsLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5VAQAABhAAWQEEGE9wdGlvbgQEVAEQAQgQTm9uZQAAABBTb21lBAAQAAABAABdAQw4cGFsbGV0X3V0aWxpdHkYcGFsbGV0EENhbGwEBFQAARgUYmF0Y2gEARRjYWxsc2EBAXxWZWM8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AABIfFNlbmQgYSBiYXRjaCBvZiBkaXNwYXRjaCBjYWxscy4AsE1heSBiZSBjYWxsZWQgZnJvbSBhbnkgb3JpZ2luIGV4Y2VwdCBgTm9uZWAuAF0BLSBgY2FsbHNgOiBUaGUgY2FsbHMgdG8gYmUgZGlzcGF0Y2hlZCBmcm9tIHRoZSBzYW1lIG9yaWdpbi4gVGhlIG51bWJlciBvZiBjYWxsIG11c3Qgbm90OQEgIGV4Y2VlZCB0aGUgY29uc3RhbnQ6IGBiYXRjaGVkX2NhbGxzX2xpbWl0YCAoYXZhaWxhYmxlIGluIGNvbnN0YW50IG1ldGFkYXRhKS4AVQFJZiBvcmlnaW4gaXMgcm9vdCB0aGVuIHRoZSBjYWxscyBhcmUgZGlzcGF0Y2hlZCB3aXRob3V0IGNoZWNraW5nIG9yaWdpbiBmaWx0ZXIuIChUaGlz7GluY2x1ZGVzIGJ5cGFzc2luZyBgZnJhbWVfc3lzdGVtOjpDb25maWc6OkJhc2VDYWxsRmlsdGVyYCkuADQjIyBDb21wbGV4aXR50C0gTyhDKSB3aGVyZSBDIGlzIHRoZSBudW1iZXIgb2YgY2FsbHMgdG8gYmUgYmF0Y2hlZC4AVQFUaGlzIHdpbGwgcmV0dXJuIGBPa2AgaW4gYWxsIGNpcmN1bXN0YW5jZXMuIFRvIGRldGVybWluZSB0aGUgc3VjY2VzcyBvZiB0aGUgYmF0Y2gsIGFuMQFldmVudCBpcyBkZXBvc2l0ZWQuIElmIGEgY2FsbCBmYWlsZWQgYW5kIHRoZSBiYXRjaCB3YXMgaW50ZXJydXB0ZWQsIHRoZW4gdGhlVQFgQmF0Y2hJbnRlcnJ1cHRlZGAgZXZlbnQgaXMgZGVwb3NpdGVkLCBhbG9uZyB3aXRoIHRoZSBudW1iZXIgb2Ygc3VjY2Vzc2Z1bCBjYWxscyBtYWRlTQFhbmQgdGhlIGVycm9yIG9mIHRoZSBmYWlsZWQgY2FsbC4gSWYgYWxsIHdlcmUgc3VjY2Vzc2Z1bCwgdGhlbiB0aGUgYEJhdGNoQ29tcGxldGVkYExldmVudCBpcyBkZXBvc2l0ZWQuNGFzX2Rlcml2YXRpdmUIARRpbmRleMgBDHUxNgABEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgABNNxTZW5kIGEgY2FsbCB0aHJvdWdoIGFuIGluZGV4ZWQgcHNldWRvbnltIG9mIHRoZSBzZW5kZXIuAFUBRmlsdGVyIGZyb20gb3JpZ2luIGFyZSBwYXNzZWQgYWxvbmcuIFRoZSBjYWxsIHdpbGwgYmUgZGlzcGF0Y2hlZCB3aXRoIGFuIG9yaWdpbiB3aGljaLx1c2UgdGhlIHNhbWUgZmlsdGVyIGFzIHRoZSBvcmlnaW4gb2YgdGhpcyBjYWxsLgBFAU5PVEU6IElmIHlvdSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFueSBhY2NvdW50LWJhc2VkIGZpbHRlcmluZyBpcyBub3QgaG9ub3JlZCAoaS5lLmEBYmVjYXVzZSB5b3UgZXhwZWN0IGBwcm94eWAgdG8gaGF2ZSBiZWVuIHVzZWQgcHJpb3IgaW4gdGhlIGNhbGwgc3RhY2sgYW5kIHlvdSBkbyBub3Qgd2FudFEBdGhlIGNhbGwgcmVzdHJpY3Rpb25zIHRvIGFwcGx5IHRvIGFueSBzdWItYWNjb3VudHMpLCB0aGVuIHVzZSBgYXNfbXVsdGlfdGhyZXNob2xkXzFgfGluIHRoZSBNdWx0aXNpZyBwYWxsZXQgaW5zdGVhZC4A9E5PVEU6IFByaW9yIHRvIHZlcnNpb24gKjEyLCB0aGlzIHdhcyBjYWxsZWQgYGFzX2xpbWl0ZWRfc3ViYC4AzFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLiRiYXRjaF9hbGwEARRjYWxsc2EBAXxWZWM8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAI07FNlbmQgYSBiYXRjaCBvZiBkaXNwYXRjaCBjYWxscyBhbmQgYXRvbWljYWxseSBleGVjdXRlIHRoZW0uIQFUaGUgd2hvbGUgdHJhbnNhY3Rpb24gd2lsbCByb2xsYmFjayBhbmQgZmFpbCBpZiBhbnkgb2YgdGhlIGNhbGxzIGZhaWxlZC4AsE1heSBiZSBjYWxsZWQgZnJvbSBhbnkgb3JpZ2luIGV4Y2VwdCBgTm9uZWAuAF0BLSBgY2FsbHNgOiBUaGUgY2FsbHMgdG8gYmUgZGlzcGF0Y2hlZCBmcm9tIHRoZSBzYW1lIG9yaWdpbi4gVGhlIG51bWJlciBvZiBjYWxsIG11c3Qgbm90OQEgIGV4Y2VlZCB0aGUgY29uc3RhbnQ6IGBiYXRjaGVkX2NhbGxzX2xpbWl0YCAoYXZhaWxhYmxlIGluIGNvbnN0YW50IG1ldGFkYXRhKS4AVQFJZiBvcmlnaW4gaXMgcm9vdCB0aGVuIHRoZSBjYWxscyBhcmUgZGlzcGF0Y2hlZCB3aXRob3V0IGNoZWNraW5nIG9yaWdpbiBmaWx0ZXIuIChUaGlz7GluY2x1ZGVzIGJ5cGFzc2luZyBgZnJhbWVfc3lzdGVtOjpDb25maWc6OkJhc2VDYWxsRmlsdGVyYCkuADQjIyBDb21wbGV4aXR50C0gTyhDKSB3aGVyZSBDIGlzIHRoZSBudW1iZXIgb2YgY2FsbHMgdG8gYmUgYmF0Y2hlZC4sZGlzcGF0Y2hfYXMIASRhc19vcmlnaW5lAQFUQm94PFQ6OlBhbGxldHNPcmlnaW4+AAEQY2FsbBEBAXxCb3g8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAMYyERpc3BhdGNoZXMgYSBmdW5jdGlvbiBjYWxsIHdpdGggYSBwcm92aWRlZCBvcmlnaW4uAMRUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfUm9vdF8uADQjIyBDb21wbGV4aXR5HC0gTygxKS4sZm9yY2VfYmF0Y2gEARRjYWxsc2EBAXxWZWM8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAQ0fFNlbmQgYSBiYXRjaCBvZiBkaXNwYXRjaCBjYWxscy7UVW5saWtlIGBiYXRjaGAsIGl0IGFsbG93cyBlcnJvcnMgYW5kIHdvbid0IGludGVycnVwdC4AsE1heSBiZSBjYWxsZWQgZnJvbSBhbnkgb3JpZ2luIGV4Y2VwdCBgTm9uZWAuAF0BLSBgY2FsbHNgOiBUaGUgY2FsbHMgdG8gYmUgZGlzcGF0Y2hlZCBmcm9tIHRoZSBzYW1lIG9yaWdpbi4gVGhlIG51bWJlciBvZiBjYWxsIG11c3Qgbm90OQEgIGV4Y2VlZCB0aGUgY29uc3RhbnQ6IGBiYXRjaGVkX2NhbGxzX2xpbWl0YCAoYXZhaWxhYmxlIGluIGNvbnN0YW50IG1ldGFkYXRhKS4ATQFJZiBvcmlnaW4gaXMgcm9vdCB0aGVuIHRoZSBjYWxscyBhcmUgZGlzcGF0Y2ggd2l0aG91dCBjaGVja2luZyBvcmlnaW4gZmlsdGVyLiAoVGhpc+xpbmNsdWRlcyBieXBhc3NpbmcgYGZyYW1lX3N5c3RlbTo6Q29uZmlnOjpCYXNlQ2FsbEZpbHRlcmApLgA0IyMgQ29tcGxleGl0edAtIE8oQykgd2hlcmUgQyBpcyB0aGUgbnVtYmVyIG9mIGNhbGxzIHRvIGJlIGJhdGNoZWQuLHdpdGhfd2VpZ2h0CAEQY2FsbBEBAXxCb3g8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAEYd2VpZ2h0KAEYV2VpZ2h0AAUYxERpc3BhdGNoIGEgZnVuY3Rpb24gY2FsbCB3aXRoIGEgc3BlY2lmaWVkIHdlaWdodC4ALQFUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRoZSB3ZWlnaHQgb2YgdGhlIGNhbGwsIGFuZCBpbnN0ZWFkIGFsbG93cyB0aGW4Um9vdCBvcmlnaW4gdG8gc3BlY2lmeSB0aGUgd2VpZ2h0IG9mIHRoZSBjYWxsLgDEVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1Jvb3RfLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5hAQAAAhEBAGUBCDxoeWRyYWR4X3J1bnRpbWUwT3JpZ2luQ2FsbGVyAAEcGHN5c3RlbQQAaQEBdGZyYW1lX3N5c3RlbTo6T3JpZ2luPFJ1bnRpbWU+AAEASFRlY2huaWNhbENvbW1pdHRlZQQAbQEBAQFwYWxsZXRfY29sbGVjdGl2ZTo6T3JpZ2luPFJ1bnRpbWUsIHBhbGxldF9jb2xsZWN0aXZlOjpJbnN0YW5jZTI+ABkAHE9yaWdpbnMEAHEBAXRwYWxsZXRfY3VzdG9tX29yaWdpbnM6Ok9yaWdpbgAmACBFdGhlcmV1bQQAdQEBXHBhbGxldF9ldGhlcmV1bTo6T3JpZ2luAFwALFBvbGthZG90WGNtBAB5AQFIcGFsbGV0X3hjbTo6T3JpZ2luAGsAKEN1bXVsdXNYY20EALkBAWhjdW11bHVzX3BhbGxldF94Y206Ok9yaWdpbgBtABBWb2lkBADBAQFBAXNlbGY6OnNwX2FwaV9oaWRkZW5faW5jbHVkZXNfY29uc3RydWN0X3J1bnRpbWU6OmhpZGRlbl9pbmNsdWRlOjoKX19wcml2YXRlOjpWb2lkAAYAAGkBDDRmcmFtZV9zdXBwb3J0IGRpc3BhdGNoJFJhd09yaWdpbgQkQWNjb3VudElkAQABDBBSb290AAAAGFNpZ25lZAQAAAEkQWNjb3VudElkAAEAEE5vbmUAAgAAbQEIRHBhbGxldF9jb2xsZWN0aXZlJFJhd09yaWdpbggkQWNjb3VudElkAQAESQABDBxNZW1iZXJzCAAQASxNZW1iZXJDb3VudAAAEAEsTWVtYmVyQ291bnQAAAAYTWVtYmVyBAAAASRBY2NvdW50SWQAAQAgX1BoYW50b20AAgAAcQEUPGh5ZHJhZHhfcnVudGltZShnb3Zlcm5hbmNlHG9yaWdpbnNUcGFsbGV0X2N1c3RvbV9vcmlnaW5zGE9yaWdpbgABJERXaGl0ZWxpc3RlZENhbGxlcgAAAExSZWZlcmVuZHVtQ2FuY2VsbGVyAAEAQFJlZmVyZW5kdW1LaWxsZXIAAgAwR2VuZXJhbEFkbWluAAMANE9tbmlwb29sQWRtaW4ABAAkVHJlYXN1cmVyAAUAHFNwZW5kZXIABgAYVGlwcGVyAAcASEVjb25vbWljUGFyYW1ldGVycwAIAAB1AQg8cGFsbGV0X2V0aGVyZXVtJFJhd09yaWdpbgABBExFdGhlcmV1bVRyYW5zYWN0aW9uBABBAQEQSDE2MAAAAAB5AQwocGFsbGV0X3hjbRhwYWxsZXQYT3JpZ2luAAEIDFhjbQQAfQEBIExvY2F0aW9uAAAAIFJlc3BvbnNlBAB9AQEgTG9jYXRpb24AAQAAfQEQLHN0YWdpbmdfeGNtCHY0IGxvY2F0aW9uIExvY2F0aW9uAAAIARxwYXJlbnRzCAEIdTgAASBpbnRlcmlvcoEBASRKdW5jdGlvbnMAAIEBECxzdGFnaW5nX3hjbQh2NCRqdW5jdGlvbnMkSnVuY3Rpb25zAAEkEEhlcmUAAAAIWDEEAIUBAUhBcmM8W0p1bmN0aW9uOyAxXT4AAQAIWDIEAJ0BAUhBcmM8W0p1bmN0aW9uOyAyXT4AAgAIWDMEAKEBAUhBcmM8W0p1bmN0aW9uOyAzXT4AAwAIWDQEAKUBAUhBcmM8W0p1bmN0aW9uOyA0XT4ABAAIWDUEAKkBAUhBcmM8W0p1bmN0aW9uOyA1XT4ABQAIWDYEAK0BAUhBcmM8W0p1bmN0aW9uOyA2XT4ABgAIWDcEALEBAUhBcmM8W0p1bmN0aW9uOyA3XT4ABwAIWDgEALUBAUhBcmM8W0p1bmN0aW9uOyA4XT4ACAAAhQEAAAMBAAAAiQEAiQEQLHN0YWdpbmdfeGNtCHY0IGp1bmN0aW9uIEp1bmN0aW9uAAEoJFBhcmFjaGFpbgQAVQEBDHUzMgAAACxBY2NvdW50SWQzMggBHG5ldHdvcmuNAQFET3B0aW9uPE5ldHdvcmtJZD4AAQhpZAQBIFt1ODsgMzJdAAEAOEFjY291bnRJbmRleDY0CAEcbmV0d29ya40BAURPcHRpb248TmV0d29ya0lkPgABFGluZGV4LAEMdTY0AAIAMEFjY291bnRLZXkyMAgBHG5ldHdvcmuNAQFET3B0aW9uPE5ldHdvcmtJZD4AAQxrZXlFAQEgW3U4OyAyMF0AAwA4UGFsbGV0SW5zdGFuY2UEAAgBCHU4AAQAMEdlbmVyYWxJbmRleAQALQEBEHUxMjgABQAoR2VuZXJhbEtleQgBGGxlbmd0aAgBCHU4AAEQZGF0YQQBIFt1ODsgMzJdAAYAJE9ubHlDaGlsZAAHACRQbHVyYWxpdHkIAQhpZJUBARhCb2R5SWQAARBwYXJ0mQEBIEJvZHlQYXJ0AAgAPEdsb2JhbENvbnNlbnN1cwQAkQEBJE5ldHdvcmtJZAAJAACNAQQYT3B0aW9uBARUAZEBAQgQTm9uZQAAABBTb21lBACRAQAAAQAAkQEQLHN0YWdpbmdfeGNtCHY0IGp1bmN0aW9uJE5ldHdvcmtJZAABLCRCeUdlbmVzaXMEAAQBIFt1ODsgMzJdAAAAGEJ5Rm9yawgBMGJsb2NrX251bWJlcjABDHU2NAABKGJsb2NrX2hhc2gEASBbdTg7IDMyXQABACBQb2xrYWRvdAACABhLdXNhbWEAAwAcV2VzdGVuZAAEABhSb2NvY28ABQAYV29jb2NvAAYAIEV0aGVyZXVtBAEgY2hhaW5faWQsAQx1NjQABwAsQml0Y29pbkNvcmUACAAsQml0Y29pbkNhc2gACQBAUG9sa2Fkb3RCdWxsZXRpbgAKAACVARAMeGNtCHYzIGp1bmN0aW9uGEJvZHlJZAABKBBVbml0AAAAHE1vbmlrZXIEAEgBHFt1ODsgNF0AAQAUSW5kZXgEAFUBAQx1MzIAAgAkRXhlY3V0aXZlAAMAJFRlY2huaWNhbAAEACxMZWdpc2xhdGl2ZQAFACBKdWRpY2lhbAAGABxEZWZlbnNlAAcAOEFkbWluaXN0cmF0aW9uAAgAIFRyZWFzdXJ5AAkAAJkBEAx4Y20IdjMganVuY3Rpb24gQm9keVBhcnQAARQUVm9pY2UAAAAcTWVtYmVycwQBFGNvdW50VQEBDHUzMgABACBGcmFjdGlvbggBDG5vbVUBAQx1MzIAARRkZW5vbVUBAQx1MzIAAgBEQXRMZWFzdFByb3BvcnRpb24IAQxub21VAQEMdTMyAAEUZGVub21VAQEMdTMyAAMASE1vcmVUaGFuUHJvcG9ydGlvbggBDG5vbVUBAQx1MzIAARRkZW5vbVUBAQx1MzIABAAAnQEAAAMCAAAAiQEAoQEAAAMDAAAAiQEApQEAAAMEAAAAiQEAqQEAAAMFAAAAiQEArQEAAAMGAAAAiQEAsQEAAAMHAAAAiQEAtQEAAAMIAAAAiQEAuQEMSGN1bXVsdXNfcGFsbGV0X3hjbRhwYWxsZXQYT3JpZ2luAAEIFFJlbGF5AAAAQFNpYmxpbmdQYXJhY2hhaW4EAL0BARhQYXJhSWQAAQAAvQEMdHBvbGthZG90X3BhcmFjaGFpbl9wcmltaXRpdmVzKHByaW1pdGl2ZXMISWQAAAQAEAEMdTMyAADBAQgcc3BfY29yZRBWb2lkAAEAAMUBDDxwYWxsZXRfcHJlaW1hZ2UYcGFsbGV0EENhbGwEBFQAARQ0bm90ZV9wcmVpbWFnZQQBFGJ5dGVzOAEcVmVjPHU4PgAAEHRSZWdpc3RlciBhIHByZWltYWdlIG9uLWNoYWluLgBVAUlmIHRoZSBwcmVpbWFnZSB3YXMgcHJldmlvdXNseSByZXF1ZXN0ZWQsIG5vIGZlZXMgb3IgZGVwb3NpdHMgYXJlIHRha2VuIGZvciBwcm92aWRpbmdVAXRoZSBwcmVpbWFnZS4gT3RoZXJ3aXNlLCBhIGRlcG9zaXQgaXMgdGFrZW4gcHJvcG9ydGlvbmFsIHRvIHRoZSBzaXplIG9mIHRoZSBwcmVpbWFnZS48dW5ub3RlX3ByZWltYWdlBAEQaGFzaDQBHFQ6Okhhc2gAARjcQ2xlYXIgYW4gdW5yZXF1ZXN0ZWQgcHJlaW1hZ2UgZnJvbSB0aGUgcnVudGltZSBzdG9yYWdlLgD8SWYgYGxlbmAgaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBhIG11Y2ggY2hlYXBlciBvcGVyYXRpb24uAAEBLSBgaGFzaGA6IFRoZSBoYXNoIG9mIHRoZSBwcmVpbWFnZSB0byBiZSByZW1vdmVkIGZyb20gdGhlIHN0b3JlLrgtIGBsZW5gOiBUaGUgbGVuZ3RoIG9mIHRoZSBwcmVpbWFnZSBvZiBgaGFzaGAuQHJlcXVlc3RfcHJlaW1hZ2UEARBoYXNoNAEcVDo6SGFzaAACEEEBUmVxdWVzdCBhIHByZWltYWdlIGJlIHVwbG9hZGVkIHRvIHRoZSBjaGFpbiB3aXRob3V0IHBheWluZyBhbnkgZmVlcyBvciBkZXBvc2l0cy4AVQFJZiB0aGUgcHJlaW1hZ2UgcmVxdWVzdHMgaGFzIGFscmVhZHkgYmVlbiBwcm92aWRlZCBvbi1jaGFpbiwgd2UgdW5yZXNlcnZlIGFueSBkZXBvc2l0OQFhIHVzZXIgbWF5IGhhdmUgcGFpZCwgYW5kIHRha2UgdGhlIGNvbnRyb2wgb2YgdGhlIHByZWltYWdlIG91dCBvZiB0aGVpciBoYW5kcy5IdW5yZXF1ZXN0X3ByZWltYWdlBAEQaGFzaDQBHFQ6Okhhc2gAAwy8Q2xlYXIgYSBwcmV2aW91c2x5IG1hZGUgcmVxdWVzdCBmb3IgYSBwcmVpbWFnZS4ALQFOT1RFOiBUSElTIE1VU1QgTk9UIEJFIENBTExFRCBPTiBgaGFzaGAgTU9SRSBUSU1FUyBUSEFOIGByZXF1ZXN0X3ByZWltYWdlYC44ZW5zdXJlX3VwZGF0ZWQEARhoYXNoZXPJAQEwVmVjPFQ6Okhhc2g+AAQMxEVuc3VyZSB0aGF0IHRoZSBhIGJ1bGsgb2YgcHJlLWltYWdlcyBpcyB1cGdyYWRlZC4APQFUaGUgY2FsbGVyIHBheXMgbm8gZmVlIGlmIGF0IGxlYXN0IDkwJSBvZiBwcmUtaW1hZ2VzIHdlcmUgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLskBAAACNADNAQw8cGFsbGV0X2lkZW50aXR5GHBhbGxldBBDYWxsBARUAAFYNGFkZF9yZWdpc3RyYXIEARxhY2NvdW50AAFQQWNjb3VudElkTG9va3VwT2Y8VD4AABx4QWRkIGEgcmVnaXN0cmFyIHRvIHRoZSBzeXN0ZW0uAPxUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBgVDo6UmVnaXN0cmFyT3JpZ2luYC4AqC0gYGFjY291bnRgOiB0aGUgYWNjb3VudCBvZiB0aGUgcmVnaXN0cmFyLgCURW1pdHMgYFJlZ2lzdHJhckFkZGVkYCBpZiBzdWNjZXNzZnVsLjBzZXRfaWRlbnRpdHkEARBpbmZv0QEBbEJveDxUOjpJZGVudGl0eUluZm9ybWF0aW9uPgABKCkBU2V0IGFuIGFjY291bnQncyBpZGVudGl0eSBpbmZvcm1hdGlvbiBhbmQgcmVzZXJ2ZSB0aGUgYXBwcm9wcmlhdGUgZGVwb3NpdC4AVQFJZiB0aGUgYWNjb3VudCBhbHJlYWR5IGhhcyBpZGVudGl0eSBpbmZvcm1hdGlvbiwgdGhlIGRlcG9zaXQgaXMgdGFrZW4gYXMgcGFydCBwYXltZW50UGZvciB0aGUgbmV3IGRlcG9zaXQuAMxUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4AjC0gYGluZm9gOiBUaGUgaWRlbnRpdHkgaW5mb3JtYXRpb24uAIhFbWl0cyBgSWRlbnRpdHlTZXRgIGlmIHN1Y2Nlc3NmdWwuIHNldF9zdWJzBAEQc3Vic2ECAWRWZWM8KFQ6OkFjY291bnRJZCwgRGF0YSk+AAIkjFNldCB0aGUgc3ViLWFjY291bnRzIG9mIHRoZSBzZW5kZXIuAFUBUGF5bWVudDogQW55IGFnZ3JlZ2F0ZSBiYWxhbmNlIHJlc2VydmVkIGJ5IHByZXZpb3VzIGBzZXRfc3Vic2AgY2FsbHMgd2lsbCBiZSByZXR1cm5lZC0BYW5kIGFuIGFtb3VudCBgU3ViQWNjb3VudERlcG9zaXRgIHdpbGwgYmUgcmVzZXJ2ZWQgZm9yIGVhY2ggaXRlbSBpbiBgc3Vic2AuAGEBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzZW5kZXIgbXVzdCBoYXZlIGEgcmVnaXN0ZXJlZCRpZGVudGl0eS4AsC0gYHN1YnNgOiBUaGUgaWRlbnRpdHkncyAobmV3KSBzdWItYWNjb3VudHMuOGNsZWFyX2lkZW50aXR5AAMgOQFDbGVhciBhbiBhY2NvdW50J3MgaWRlbnRpdHkgaW5mbyBhbmQgYWxsIHN1Yi1hY2NvdW50cyBhbmQgcmV0dXJuIGFsbCBkZXBvc2l0cy4A7FBheW1lbnQ6IEFsbCByZXNlcnZlZCBiYWxhbmNlcyBvbiB0aGUgYWNjb3VudCBhcmUgcmV0dXJuZWQuAGEBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzZW5kZXIgbXVzdCBoYXZlIGEgcmVnaXN0ZXJlZCRpZGVudGl0eS4AmEVtaXRzIGBJZGVudGl0eUNsZWFyZWRgIGlmIHN1Y2Nlc3NmdWwuRHJlcXVlc3RfanVkZ2VtZW50CAEkcmVnX2luZGV4VQEBOFJlZ2lzdHJhckluZGV4AAEcbWF4X2ZlZS0BATBCYWxhbmNlT2Y8VD4ABECUUmVxdWVzdCBhIGp1ZGdlbWVudCBmcm9tIGEgcmVnaXN0cmFyLgBVAVBheW1lbnQ6IEF0IG1vc3QgYG1heF9mZWVgIHdpbGwgYmUgcmVzZXJ2ZWQgZm9yIHBheW1lbnQgdG8gdGhlIHJlZ2lzdHJhciBpZiBqdWRnZW1lbnQYZ2l2ZW4uADUBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzZW5kZXIgbXVzdCBoYXZlIGFQcmVnaXN0ZXJlZCBpZGVudGl0eS4AHQEtIGByZWdfaW5kZXhgOiBUaGUgaW5kZXggb2YgdGhlIHJlZ2lzdHJhciB3aG9zZSBqdWRnZW1lbnQgaXMgcmVxdWVzdGVkLlUBLSBgbWF4X2ZlZWA6IFRoZSBtYXhpbXVtIGZlZSB0aGF0IG1heSBiZSBwYWlkLiBUaGlzIHNob3VsZCBqdXN0IGJlIGF1dG8tcG9wdWxhdGVkIGFzOgAwYGBgbm9jb21waWxlyFJlZ2lzdHJhcnM6OjxUPjo6Z2V0KCkuZ2V0KHJlZ19pbmRleCkudW53cmFwKCkuZmVlDGBgYACkRW1pdHMgYEp1ZGdlbWVudFJlcXVlc3RlZGAgaWYgc3VjY2Vzc2Z1bC44Y2FuY2VsX3JlcXVlc3QEASRyZWdfaW5kZXgQAThSZWdpc3RyYXJJbmRleAAFKGhDYW5jZWwgYSBwcmV2aW91cyByZXF1ZXN0LgD4UGF5bWVudDogQSBwcmV2aW91c2x5IHJlc2VydmVkIGRlcG9zaXQgaXMgcmV0dXJuZWQgb24gc3VjY2Vzcy4ANQFUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNlbmRlciBtdXN0IGhhdmUgYVByZWdpc3RlcmVkIGlkZW50aXR5LgBFAS0gYHJlZ19pbmRleGA6IFRoZSBpbmRleCBvZiB0aGUgcmVnaXN0cmFyIHdob3NlIGp1ZGdlbWVudCBpcyBubyBsb25nZXIgcmVxdWVzdGVkLgCsRW1pdHMgYEp1ZGdlbWVudFVucmVxdWVzdGVkYCBpZiBzdWNjZXNzZnVsLhxzZXRfZmVlCAEUaW5kZXhVAQE4UmVnaXN0cmFySW5kZXgAAQxmZWUtAQEwQmFsYW5jZU9mPFQ+AAYcGQFTZXQgdGhlIGZlZSByZXF1aXJlZCBmb3IgYSBqdWRnZW1lbnQgdG8gYmUgcmVxdWVzdGVkIGZyb20gYSByZWdpc3RyYXIuAFUBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzZW5kZXIgbXVzdCBiZSB0aGUgYWNjb3VudKBvZiB0aGUgcmVnaXN0cmFyIHdob3NlIGluZGV4IGlzIGBpbmRleGAuAPQtIGBpbmRleGA6IHRoZSBpbmRleCBvZiB0aGUgcmVnaXN0cmFyIHdob3NlIGZlZSBpcyB0byBiZSBzZXQuVC0gYGZlZWA6IHRoZSBuZXcgZmVlLjhzZXRfYWNjb3VudF9pZAgBFGluZGV4VQEBOFJlZ2lzdHJhckluZGV4AAEMbmV3AAFQQWNjb3VudElkTG9va3VwT2Y8VD4ABxy8Q2hhbmdlIHRoZSBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdHJhci4AVQFUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNlbmRlciBtdXN0IGJlIHRoZSBhY2NvdW50oG9mIHRoZSByZWdpc3RyYXIgd2hvc2UgaW5kZXggaXMgYGluZGV4YC4A9C0gYGluZGV4YDogdGhlIGluZGV4IG9mIHRoZSByZWdpc3RyYXIgd2hvc2UgZmVlIGlzIHRvIGJlIHNldC5wLSBgbmV3YDogdGhlIG5ldyBhY2NvdW50IElELihzZXRfZmllbGRzCAEUaW5kZXhVAQE4UmVnaXN0cmFySW5kZXgAARhmaWVsZHMwASkBPFQ6OklkZW50aXR5SW5mb3JtYXRpb24gYXMgSWRlbnRpdHlJbmZvcm1hdGlvblByb3ZpZGVyPjo6CkZpZWxkc0lkZW50aWZpZXIACByoU2V0IHRoZSBmaWVsZCBpbmZvcm1hdGlvbiBmb3IgYSByZWdpc3RyYXIuAFUBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzZW5kZXIgbXVzdCBiZSB0aGUgYWNjb3VudKBvZiB0aGUgcmVnaXN0cmFyIHdob3NlIGluZGV4IGlzIGBpbmRleGAuAPQtIGBpbmRleGA6IHRoZSBpbmRleCBvZiB0aGUgcmVnaXN0cmFyIHdob3NlIGZlZSBpcyB0byBiZSBzZXQuDQEtIGBmaWVsZHNgOiB0aGUgZmllbGRzIHRoYXQgdGhlIHJlZ2lzdHJhciBjb25jZXJucyB0aGVtc2VsdmVzIHdpdGguRHByb3ZpZGVfanVkZ2VtZW50EAEkcmVnX2luZGV4VQEBOFJlZ2lzdHJhckluZGV4AAEYdGFyZ2V0AAFQQWNjb3VudElkTG9va3VwT2Y8VD4AASRqdWRnZW1lbnRpAgFcSnVkZ2VtZW50PEJhbGFuY2VPZjxUPj4AASBpZGVudGl0eTQBHFQ6Okhhc2gACTy4UHJvdmlkZSBhIGp1ZGdlbWVudCBmb3IgYW4gYWNjb3VudCdzIGlkZW50aXR5LgBVAVRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfIGFuZCB0aGUgc2VuZGVyIG11c3QgYmUgdGhlIGFjY291bnSwb2YgdGhlIHJlZ2lzdHJhciB3aG9zZSBpbmRleCBpcyBgcmVnX2luZGV4YC4AIQEtIGByZWdfaW5kZXhgOiB0aGUgaW5kZXggb2YgdGhlIHJlZ2lzdHJhciB3aG9zZSBqdWRnZW1lbnQgaXMgYmVpbmcgbWFkZS5VAS0gYHRhcmdldGA6IHRoZSBhY2NvdW50IHdob3NlIGlkZW50aXR5IHRoZSBqdWRnZW1lbnQgaXMgdXBvbi4gVGhpcyBtdXN0IGJlIGFuIGFjY291bnR0ICB3aXRoIGEgcmVnaXN0ZXJlZCBpZGVudGl0eS5JAS0gYGp1ZGdlbWVudGA6IHRoZSBqdWRnZW1lbnQgb2YgdGhlIHJlZ2lzdHJhciBvZiBpbmRleCBgcmVnX2luZGV4YCBhYm91dCBgdGFyZ2V0YC5dAS0gYGlkZW50aXR5YDogVGhlIGhhc2ggb2YgdGhlIFtgSWRlbnRpdHlJbmZvcm1hdGlvblByb3ZpZGVyYF0gZm9yIHRoYXQgdGhlIGp1ZGdlbWVudCBpcywgIHByb3ZpZGVkLgCwTm90ZTogSnVkZ2VtZW50cyBkbyBub3QgYXBwbHkgdG8gYSB1c2VybmFtZS4AlEVtaXRzIGBKdWRnZW1lbnRHaXZlbmAgaWYgc3VjY2Vzc2Z1bC40a2lsbF9pZGVudGl0eQQBGHRhcmdldAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAowQQFSZW1vdmUgYW4gYWNjb3VudCdzIGlkZW50aXR5IGFuZCBzdWItYWNjb3VudCBpbmZvcm1hdGlvbiBhbmQgc2xhc2ggdGhlIGRlcG9zaXRzLgBhAVBheW1lbnQ6IFJlc2VydmVkIGJhbGFuY2VzIGZyb20gYHNldF9zdWJzYCBhbmQgYHNldF9pZGVudGl0eWAgYXJlIHNsYXNoZWQgYW5kIGhhbmRsZWQgYnlFAWBTbGFzaGAuIFZlcmlmaWNhdGlvbiByZXF1ZXN0IGRlcG9zaXRzIGFyZSBub3QgcmV0dXJuZWQ7IHRoZXkgc2hvdWxkIGJlIGNhbmNlbGxlZIBtYW51YWxseSB1c2luZyBgY2FuY2VsX3JlcXVlc3RgLgD4VGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgbWF0Y2ggYFQ6OkZvcmNlT3JpZ2luYC4AVQEtIGB0YXJnZXRgOiB0aGUgYWNjb3VudCB3aG9zZSBpZGVudGl0eSB0aGUganVkZ2VtZW50IGlzIHVwb24uIFRoaXMgbXVzdCBiZSBhbiBhY2NvdW50dCAgd2l0aCBhIHJlZ2lzdGVyZWQgaWRlbnRpdHkuAJRFbWl0cyBgSWRlbnRpdHlLaWxsZWRgIGlmIHN1Y2Nlc3NmdWwuHGFkZF9zdWIIAQxzdWIAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABEGRhdGHdAQEQRGF0YQALHKxBZGQgdGhlIGdpdmVuIGFjY291bnQgdG8gdGhlIHNlbmRlcidzIHN1YnMuAF0BUGF5bWVudDogQmFsYW5jZSByZXNlcnZlZCBieSBhIHByZXZpb3VzIGBzZXRfc3Vic2AgY2FsbCBmb3Igb25lIHN1YiB3aWxsIGJlIHJlcGF0cmlhdGVkOHRvIHRoZSBzZW5kZXIuAGEBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzZW5kZXIgbXVzdCBoYXZlIGEgcmVnaXN0ZXJlZFhzdWIgaWRlbnRpdHkgb2YgYHN1YmAuKHJlbmFtZV9zdWIIAQxzdWIAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABEGRhdGHdAQEQRGF0YQAMEMxBbHRlciB0aGUgYXNzb2NpYXRlZCBuYW1lIG9mIHRoZSBnaXZlbiBzdWItYWNjb3VudC4AYQFUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNlbmRlciBtdXN0IGhhdmUgYSByZWdpc3RlcmVkWHN1YiBpZGVudGl0eSBvZiBgc3ViYC4ocmVtb3ZlX3N1YgQBDHN1YgABUEFjY291bnRJZExvb2t1cE9mPFQ+AA0cwFJlbW92ZSB0aGUgZ2l2ZW4gYWNjb3VudCBmcm9tIHRoZSBzZW5kZXIncyBzdWJzLgBdAVBheW1lbnQ6IEJhbGFuY2UgcmVzZXJ2ZWQgYnkgYSBwcmV2aW91cyBgc2V0X3N1YnNgIGNhbGwgZm9yIG9uZSBzdWIgd2lsbCBiZSByZXBhdHJpYXRlZDh0byB0aGUgc2VuZGVyLgBhAVRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfIGFuZCB0aGUgc2VuZGVyIG11c3QgaGF2ZSBhIHJlZ2lzdGVyZWRYc3ViIGlkZW50aXR5IG9mIGBzdWJgLiBxdWl0X3N1YgAOKIxSZW1vdmUgdGhlIHNlbmRlciBhcyBhIHN1Yi1hY2NvdW50LgBdAVBheW1lbnQ6IEJhbGFuY2UgcmVzZXJ2ZWQgYnkgYSBwcmV2aW91cyBgc2V0X3N1YnNgIGNhbGwgZm9yIG9uZSBzdWIgd2lsbCBiZSByZXBhdHJpYXRlZLR0byB0aGUgc2VuZGVyICgqbm90KiB0aGUgb3JpZ2luYWwgZGVwb3NpdG9yKS4AYQFUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNlbmRlciBtdXN0IGhhdmUgYSByZWdpc3RlcmVkPHN1cGVyLWlkZW50aXR5LgBFAU5PVEU6IFRoaXMgc2hvdWxkIG5vdCBub3JtYWxseSBiZSB1c2VkLCBidXQgaXMgcHJvdmlkZWQgaW4gdGhlIGNhc2UgdGhhdCB0aGUgbm9uLREBY29udHJvbGxlciBvZiBhbiBhY2NvdW50IGlzIG1hbGljaW91c2x5IHJlZ2lzdGVyZWQgYXMgYSBzdWItYWNjb3VudC5YYWRkX3VzZXJuYW1lX2F1dGhvcml0eQwBJGF1dGhvcml0eQABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEYc3VmZml4OAEcVmVjPHU4PgABKGFsbG9jYXRpb24QAQx1MzIADxBVAUFkZCBhbiBgQWNjb3VudElkYCB3aXRoIHBlcm1pc3Npb24gdG8gZ3JhbnQgdXNlcm5hbWVzIHdpdGggYSBnaXZlbiBgc3VmZml4YCBhcHBlbmRlZC4AWQFUaGUgYXV0aG9yaXR5IGNhbiBncmFudCB1cCB0byBgYWxsb2NhdGlvbmAgdXNlcm5hbWVzLiBUbyB0b3AgdXAgdGhlaXIgYWxsb2NhdGlvbiwgdGhleUkBc2hvdWxkIGp1c3QgaXNzdWUgKG9yIHJlcXVlc3QgdmlhIGdvdmVybmFuY2UpIGEgbmV3IGBhZGRfdXNlcm5hbWVfYXV0aG9yaXR5YCBjYWxsLmRyZW1vdmVfdXNlcm5hbWVfYXV0aG9yaXR5BAEkYXV0aG9yaXR5AAFQQWNjb3VudElkTG9va3VwT2Y8VD4AEATEUmVtb3ZlIGBhdXRob3JpdHlgIGZyb20gdGhlIHVzZXJuYW1lIGF1dGhvcml0aWVzLkBzZXRfdXNlcm5hbWVfZm9yDAEMd2hvAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AASB1c2VybmFtZTgBHFZlYzx1OD4AASRzaWduYXR1cmVtAgFwT3B0aW9uPFQ6Ok9mZmNoYWluU2lnbmF0dXJlPgARJA0BU2V0IHRoZSB1c2VybmFtZSBmb3IgYHdob2AuIE11c3QgYmUgY2FsbGVkIGJ5IGEgdXNlcm5hbWUgYXV0aG9yaXR5LgBVAVRoZSBhdXRob3JpdHkgbXVzdCBoYXZlIGFuIGBhbGxvY2F0aW9uYC4gVXNlcnMgY2FuIGVpdGhlciBwcmUtc2lnbiB0aGVpciB1c2VybmFtZXMgb3JIYWNjZXB0IHRoZW0gbGF0ZXIuADxVc2VybmFtZXMgbXVzdDrYICAtIE9ubHkgY29udGFpbiBsb3dlcmNhc2UgQVNDSUkgY2hhcmFjdGVycyBvciBkaWdpdHMuNQEgIC0gV2hlbiBjb21iaW5lZCB3aXRoIHRoZSBzdWZmaXggb2YgdGhlIGlzc3VpbmcgYXV0aG9yaXR5IGJlIF9sZXNzIHRoYW5fIHRoZWAgICAgYE1heFVzZXJuYW1lTGVuZ3RoYC48YWNjZXB0X3VzZXJuYW1lBAEgdXNlcm5hbWWkASxVc2VybmFtZTxUPgASCE0BQWNjZXB0IGEgZ2l2ZW4gdXNlcm5hbWUgdGhhdCBhbiBgYXV0aG9yaXR5YCBncmFudGVkLiBUaGUgY2FsbCBtdXN0IGluY2x1ZGUgdGhlIGZ1bGyIdXNlcm5hbWUsIGFzIGluIGB1c2VybmFtZS5zdWZmaXhgLlxyZW1vdmVfZXhwaXJlZF9hcHByb3ZhbAQBIHVzZXJuYW1lpAEsVXNlcm5hbWU8VD4AEwxhAVJlbW92ZSBhbiBleHBpcmVkIHVzZXJuYW1lIGFwcHJvdmFsLiBUaGUgdXNlcm5hbWUgd2FzIGFwcHJvdmVkIGJ5IGFuIGF1dGhvcml0eSBidXQgbmV2ZXJVAWFjY2VwdGVkIGJ5IHRoZSB1c2VyIGFuZCBtdXN0IG5vdyBiZSBiZXlvbmQgaXRzIGV4cGlyYXRpb24uIFRoZSBjYWxsIG11c3QgaW5jbHVkZSB0aGWcZnVsbCB1c2VybmFtZSwgYXMgaW4gYHVzZXJuYW1lLnN1ZmZpeGAuUHNldF9wcmltYXJ5X3VzZXJuYW1lBAEgdXNlcm5hbWWkASxVc2VybmFtZTxUPgAUBDEBU2V0IGEgZ2l2ZW4gdXNlcm5hbWUgYXMgdGhlIHByaW1hcnkuIFRoZSB1c2VybmFtZSBzaG91bGQgaW5jbHVkZSB0aGUgc3VmZml4LmByZW1vdmVfZGFuZ2xpbmdfdXNlcm5hbWUEASB1c2VybmFtZaQBLFVzZXJuYW1lPFQ+ABUIVQFSZW1vdmUgYSB1c2VybmFtZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGFuIGFjY291bnQgd2l0aCBubyBpZGVudGl0eS4gRXhpc3RzIHdoZW4gYSB1c2VywGdldHMgYSB1c2VybmFtZSBidXQgdGhlbiBjYWxscyBgY2xlYXJfaWRlbnRpdHlgLgRwSWRlbnRpdHkgcGFsbGV0IGRlY2xhcmF0aW9uLtEBDDxwYWxsZXRfaWRlbnRpdHkYbGVnYWN5MElkZW50aXR5SW5mbwQoRmllbGRMaW1pdAAAJAEoYWRkaXRpb25hbNUBAZBCb3VuZGVkVmVjPChEYXRhLCBEYXRhKSwgRmllbGRMaW1pdD4AARxkaXNwbGF53QEBEERhdGEAARRsZWdhbN0BARBEYXRhAAEMd2Vi3QEBEERhdGEAARByaW903QEBEERhdGEAARRlbWFpbN0BARBEYXRhAAE8cGdwX2ZpbmdlcnByaW50XQIBQE9wdGlvbjxbdTg7IDIwXT4AARRpbWFnZd0BARBEYXRhAAEcdHdpdHRlct0BARBEYXRhAADVAQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAdkBBFMAAAQAWQIBGFZlYzxUPgAA2QEAAAQI3QHdAQDdAQw8cGFsbGV0X2lkZW50aXR5FHR5cGVzEERhdGEAAZgQTm9uZQAAABBSYXcwBADhAQAAAQAQUmF3MQQA5QEAAAIAEFJhdzIEAOkBAAADABBSYXczBADtAQAABAAQUmF3NAQASAAABQAQUmF3NQQA8QEAAAYAEFJhdzYEAPUBAAAHABBSYXc3BAD5AQAACAAQUmF3OAQA/QEAAAkAEFJhdzkEAAECAAAKABRSYXcxMAQABQIAAAsAFFJhdzExBAAJAgAADAAUUmF3MTIEAA0CAAANABRSYXcxMwQAEQIAAA4AFFJhdzE0BAAVAgAADwAUUmF3MTUEABkCAAAQABRSYXcxNgQAHQIAABEAFFJhdzE3BAAhAgAAEgAUUmF3MTgEACUCAAATABRSYXcxOQQAKQIAABQAFFJhdzIwBABFAQAAFQAUUmF3MjEEAC0CAAAWABRSYXcyMgQAMQIAABcAFFJhdzIzBAA1AgAAGAAUUmF3MjQEADkCAAAZABRSYXcyNQQAPQIAABoAFFJhdzI2BABBAgAAGwAUUmF3MjcEAEUCAAAcABRSYXcyOAQASQIAAB0AFFJhdzI5BABNAgAAHgAUUmF3MzAEAFECAAAfABRSYXczMQQAVQIAACAAFFJhdzMyBAAEAAAhACxCbGFrZVR3bzI1NgQABAAAIgAYU2hhMjU2BAAEAAAjACRLZWNjYWsyNTYEAAQAACQALFNoYVRocmVlMjU2BAAEAAAlAADhAQAAAwAAAAAIAOUBAAADAQAAAAgA6QEAAAMCAAAACADtAQAAAwMAAAAIAPEBAAADBQAAAAgA9QEAAAMGAAAACAD5AQAAAwcAAAAIAP0BAAADCAAAAAgAAQIAAAMJAAAACAAFAgAAAwoAAAAIAAkCAAADCwAAAAgADQIAAAMMAAAACAARAgAAAw0AAAAIABUCAAADDgAAAAgAGQIAAAMPAAAACAAdAgAAAxAAAAAIACECAAADEQAAAAgAJQIAAAMSAAAACAApAgAAAxMAAAAIAC0CAAADFQAAAAgAMQIAAAMWAAAACAA1AgAAAxcAAAAIADkCAAADGAAAAAgAPQIAAAMZAAAACABBAgAAAxoAAAAIAEUCAAADGwAAAAgASQIAAAMcAAAACABNAgAAAx0AAAAIAFECAAADHgAAAAgAVQIAAAMfAAAACABZAgAAAtkBAF0CBBhPcHRpb24EBFQBRQEBCBBOb25lAAAAEFNvbWUEAEUBAAABAABhAgAAAmUCAGUCAAAECADdAQBpAgw8cGFsbGV0X2lkZW50aXR5FHR5cGVzJEp1ZGdlbWVudAQcQmFsYW5jZQEYARwcVW5rbm93bgAAABxGZWVQYWlkBAAYARxCYWxhbmNlAAEAKFJlYXNvbmFibGUAAgAkS25vd25Hb29kAAMAJE91dE9mRGF0ZQAEAChMb3dRdWFsaXR5AAUAJEVycm9uZW91cwAGAABtAgQYT3B0aW9uBARUAXECAQgQTm9uZQAAABBTb21lBABxAgAAAQAAcQIIKHNwX3J1bnRpbWU4TXVsdGlTaWduYXR1cmUAAQwcRWQyNTUxOQQAdQIBSGVkMjU1MTk6OlNpZ25hdHVyZQAAABxTcjI1NTE5BAB1AgFIc3IyNTUxOTo6U2lnbmF0dXJlAAEAFEVjZHNhBAB5AgFAZWNkc2E6OlNpZ25hdHVyZQACAAB1AgAAA0AAAAAIAHkCAAADQQAAAAgAfQIMQHBhbGxldF9kZW1vY3JhY3kYcGFsbGV0EENhbGwEBFQAAVAccHJvcG9zZQgBIHByb3Bvc2FsDQEBQEJvdW5kZWRDYWxsT2Y8VD4AARR2YWx1ZS0BATBCYWxhbmNlT2Y8VD4AACScUHJvcG9zZSBhIHNlbnNpdGl2ZSBhY3Rpb24gdG8gYmUgdGFrZW4uABUBVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNlbmRlciBtdXN0gGhhdmUgZnVuZHMgdG8gY292ZXIgdGhlIGRlcG9zaXQuANQtIGBwcm9wb3NhbF9oYXNoYDogVGhlIGhhc2ggb2YgdGhlIHByb3Bvc2FsIHByZWltYWdlLhUBLSBgdmFsdWVgOiBUaGUgYW1vdW50IG9mIGRlcG9zaXQgKG11c3QgYmUgYXQgbGVhc3QgYE1pbmltdW1EZXBvc2l0YCkuAERFbWl0cyBgUHJvcG9zZWRgLhhzZWNvbmQEASBwcm9wb3NhbFUBASRQcm9wSW5kZXgAARi0U2lnbmFscyBhZ3JlZW1lbnQgd2l0aCBhIHBhcnRpY3VsYXIgcHJvcG9zYWwuAAEBVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNlbmRlchEBbXVzdCBoYXZlIGZ1bmRzIHRvIGNvdmVyIHRoZSBkZXBvc2l0LCBlcXVhbCB0byB0aGUgb3JpZ2luYWwgZGVwb3NpdC4AyC0gYHByb3Bvc2FsYDogVGhlIGluZGV4IG9mIHRoZSBwcm9wb3NhbCB0byBzZWNvbmQuEHZvdGUIASRyZWZfaW5kZXhVAQE8UmVmZXJlbmR1bUluZGV4AAEQdm90ZbABZEFjY291bnRWb3RlPEJhbGFuY2VPZjxUPj4AAhwxAVZvdGUgaW4gYSByZWZlcmVuZHVtLiBJZiBgdm90ZS5pc19heWUoKWAsIHRoZSB2b3RlIGlzIHRvIGVuYWN0IHRoZSBwcm9wb3NhbDu4b3RoZXJ3aXNlIGl0IGlzIGEgdm90ZSB0byBrZWVwIHRoZSBzdGF0dXMgcXVvLgDIVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4A3C0gYHJlZl9pbmRleGA6IFRoZSBpbmRleCBvZiB0aGUgcmVmZXJlbmR1bSB0byB2b3RlIGZvci6ELSBgdm90ZWA6IFRoZSB2b3RlIGNvbmZpZ3VyYXRpb24uQGVtZXJnZW5jeV9jYW5jZWwEASRyZWZfaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgAAyBNAVNjaGVkdWxlIGFuIGVtZXJnZW5jeSBjYW5jZWxsYXRpb24gb2YgYSByZWZlcmVuZHVtLiBDYW5ub3QgaGFwcGVuIHR3aWNlIHRvIHRoZSBzYW1lLHJlZmVyZW5kdW0uAPhUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIGBDYW5jZWxsYXRpb25PcmlnaW5gLgDQLWByZWZfaW5kZXhgOiBUaGUgaW5kZXggb2YgdGhlIHJlZmVyZW5kdW0gdG8gY2FuY2VsLgA8V2VpZ2h0OiBgTygxKWAuQGV4dGVybmFsX3Byb3Bvc2UEASBwcm9wb3NhbA0BAUBCb3VuZGVkQ2FsbE9mPFQ+AAQYLQFTY2hlZHVsZSBhIHJlZmVyZW5kdW0gdG8gYmUgdGFibGVkIG9uY2UgaXQgaXMgbGVnYWwgdG8gc2NoZWR1bGUgYW4gZXh0ZXJuYWwscmVmZXJlbmR1bS4A6FRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgYEV4dGVybmFsT3JpZ2luYC4A1C0gYHByb3Bvc2FsX2hhc2hgOiBUaGUgcHJlaW1hZ2UgaGFzaCBvZiB0aGUgcHJvcG9zYWwuZGV4dGVybmFsX3Byb3Bvc2VfbWFqb3JpdHkEASBwcm9wb3NhbA0BAUBCb3VuZGVkQ2FsbE9mPFQ+AAUsVQFTY2hlZHVsZSBhIG1ham9yaXR5LWNhcnJpZXMgcmVmZXJlbmR1bSB0byBiZSB0YWJsZWQgbmV4dCBvbmNlIGl0IGlzIGxlZ2FsIHRvIHNjaGVkdWxlXGFuIGV4dGVybmFsIHJlZmVyZW5kdW0uAOxUaGUgZGlzcGF0Y2ggb2YgdGhpcyBjYWxsIG11c3QgYmUgYEV4dGVybmFsTWFqb3JpdHlPcmlnaW5gLgDULSBgcHJvcG9zYWxfaGFzaGA6IFRoZSBwcmVpbWFnZSBoYXNoIG9mIHRoZSBwcm9wb3NhbC4ASQFVbmxpa2UgYGV4dGVybmFsX3Byb3Bvc2VgLCBibGFja2xpc3RpbmcgaGFzIG5vIGVmZmVjdCBvbiB0aGlzIGFuZCBpdCBtYXkgcmVwbGFjZSBhmHByZS1zY2hlZHVsZWQgYGV4dGVybmFsX3Byb3Bvc2VgIGNhbGwuADhXZWlnaHQ6IGBPKDEpYGBleHRlcm5hbF9wcm9wb3NlX2RlZmF1bHQEASBwcm9wb3NhbA0BAUBCb3VuZGVkQ2FsbE9mPFQ+AAYsRQFTY2hlZHVsZSBhIG5lZ2F0aXZlLXR1cm5vdXQtYmlhcyByZWZlcmVuZHVtIHRvIGJlIHRhYmxlZCBuZXh0IG9uY2UgaXQgaXMgbGVnYWwgdG+Ac2NoZWR1bGUgYW4gZXh0ZXJuYWwgcmVmZXJlbmR1bS4A6FRoZSBkaXNwYXRjaCBvZiB0aGlzIGNhbGwgbXVzdCBiZSBgRXh0ZXJuYWxEZWZhdWx0T3JpZ2luYC4A1C0gYHByb3Bvc2FsX2hhc2hgOiBUaGUgcHJlaW1hZ2UgaGFzaCBvZiB0aGUgcHJvcG9zYWwuAEkBVW5saWtlIGBleHRlcm5hbF9wcm9wb3NlYCwgYmxhY2tsaXN0aW5nIGhhcyBubyBlZmZlY3Qgb24gdGhpcyBhbmQgaXQgbWF5IHJlcGxhY2UgYZhwcmUtc2NoZWR1bGVkIGBleHRlcm5hbF9wcm9wb3NlYCBjYWxsLgA4V2VpZ2h0OiBgTygxKWAoZmFzdF90cmFjawwBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAE0dm90aW5nX3BlcmlvZBABREJsb2NrTnVtYmVyRm9yPFQ+AAEUZGVsYXkQAURCbG9ja051bWJlckZvcjxUPgAHQE0BU2NoZWR1bGUgdGhlIGN1cnJlbnRseSBleHRlcm5hbGx5LXByb3Bvc2VkIG1ham9yaXR5LWNhcnJpZXMgcmVmZXJlbmR1bSB0byBiZSB0YWJsZWRhAWltbWVkaWF0ZWx5LiBJZiB0aGVyZSBpcyBubyBleHRlcm5hbGx5LXByb3Bvc2VkIHJlZmVyZW5kdW0gY3VycmVudGx5LCBvciBpZiB0aGVyZSBpcyBvbmXoYnV0IGl0IGlzIG5vdCBhIG1ham9yaXR5LWNhcnJpZXMgcmVmZXJlbmR1bSB0aGVuIGl0IGZhaWxzLgDQVGhlIGRpc3BhdGNoIG9mIHRoaXMgY2FsbCBtdXN0IGJlIGBGYXN0VHJhY2tPcmlnaW5gLgD0LSBgcHJvcG9zYWxfaGFzaGA6IFRoZSBoYXNoIG9mIHRoZSBjdXJyZW50IGV4dGVybmFsIHByb3Bvc2FsLl0BLSBgdm90aW5nX3BlcmlvZGA6IFRoZSBwZXJpb2QgdGhhdCBpcyBhbGxvd2VkIGZvciB2b3Rpbmcgb24gdGhpcyBwcm9wb3NhbC4gSW5jcmVhc2VkIHRviAlNdXN0IGJlIGFsd2F5cyBncmVhdGVyIHRoYW4gemVyby41AQlGb3IgYEZhc3RUcmFja09yaWdpbmAgbXVzdCBiZSBlcXVhbCBvciBncmVhdGVyIHRoYW4gYEZhc3RUcmFja1ZvdGluZ1BlcmlvZGAuUQEtIGBkZWxheWA6IFRoZSBudW1iZXIgb2YgYmxvY2sgYWZ0ZXIgdm90aW5nIGhhcyBlbmRlZCBpbiBhcHByb3ZhbCBhbmQgdGhpcyBzaG91bGQgYmW4ICBlbmFjdGVkLiBUaGlzIGRvZXNuJ3QgaGF2ZSBhIG1pbmltdW0gYW1vdW50LgBARW1pdHMgYFN0YXJ0ZWRgLgA4V2VpZ2h0OiBgTygxKWA0dmV0b19leHRlcm5hbAQBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAgkuFZldG8gYW5kIGJsYWNrbGlzdCB0aGUgZXh0ZXJuYWwgcHJvcG9zYWwgaGFzaC4A2FRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgYFZldG9PcmlnaW5gLgAtAS0gYHByb3Bvc2FsX2hhc2hgOiBUaGUgcHJlaW1hZ2UgaGFzaCBvZiB0aGUgcHJvcG9zYWwgdG8gdmV0byBhbmQgYmxhY2tsaXN0LgA8RW1pdHMgYFZldG9lZGAuAPxXZWlnaHQ6IGBPKFYgKyBsb2coVikpYCB3aGVyZSBWIGlzIG51bWJlciBvZiBgZXhpc3RpbmcgdmV0b2Vyc2BEY2FuY2VsX3JlZmVyZW5kdW0EASRyZWZfaW5kZXhVAQE8UmVmZXJlbmR1bUluZGV4AAkcUFJlbW92ZSBhIHJlZmVyZW5kdW0uAMBUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIF9Sb290Xy4A1C0gYHJlZl9pbmRleGA6IFRoZSBpbmRleCBvZiB0aGUgcmVmZXJlbmR1bSB0byBjYW5jZWwuAEQjIFdlaWdodDogYE8oMSlgLiBkZWxlZ2F0ZQwBCHRvAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AAShjb252aWN0aW9ugQIBKENvbnZpY3Rpb24AARxiYWxhbmNlGAEwQmFsYW5jZU9mPFQ+AApQOQFEZWxlZ2F0ZSB0aGUgdm90aW5nIHBvd2VyICh3aXRoIHNvbWUgZ2l2ZW4gY29udmljdGlvbikgb2YgdGhlIHNlbmRpbmcgYWNjb3VudC4AVQFUaGUgYmFsYW5jZSBkZWxlZ2F0ZWQgaXMgbG9ja2VkIGZvciBhcyBsb25nIGFzIGl0J3MgZGVsZWdhdGVkLCBhbmQgdGhlcmVhZnRlciBmb3IgdGhlyHRpbWUgYXBwcm9wcmlhdGUgZm9yIHRoZSBjb252aWN0aW9uJ3MgbG9jayBwZXJpb2QuAF0BVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXywgYW5kIHRoZSBzaWduaW5nIGFjY291bnQgbXVzdCBlaXRoZXI6dCAgLSBiZSBkZWxlZ2F0aW5nIGFscmVhZHk7IG9yWQEgIC0gaGF2ZSBubyB2b3RpbmcgYWN0aXZpdHkgKGlmIHRoZXJlIGlzLCB0aGVuIGl0IHdpbGwgbmVlZCB0byBiZSByZW1vdmVkL2NvbnNvbGlkYXRlZJQgICAgdGhyb3VnaCBgcmVhcF92b3RlYCBvciBgdW52b3RlYCkuAEUBLSBgdG9gOiBUaGUgYWNjb3VudCB3aG9zZSB2b3RpbmcgdGhlIGB0YXJnZXRgIGFjY291bnQncyB2b3RpbmcgcG93ZXIgd2lsbCBmb2xsb3cuVQEtIGBjb252aWN0aW9uYDogVGhlIGNvbnZpY3Rpb24gdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBkZWxlZ2F0ZWQgdm90ZXMuIFdoZW4gdGhlQQEgIGFjY291bnQgaXMgdW5kZWxlZ2F0ZWQsIHRoZSBmdW5kcyB3aWxsIGJlIGxvY2tlZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgcGVyaW9kLmEBLSBgYmFsYW5jZWA6IFRoZSBhbW91bnQgb2YgdGhlIGFjY291bnQncyBiYWxhbmNlIHRvIGJlIHVzZWQgaW4gZGVsZWdhdGluZy4gVGhpcyBtdXN0IG5vdLQgIGJlIG1vcmUgdGhhbiB0aGUgYWNjb3VudCdzIGN1cnJlbnQgYmFsYW5jZS4ASEVtaXRzIGBEZWxlZ2F0ZWRgLgA9AVdlaWdodDogYE8oUilgIHdoZXJlIFIgaXMgdGhlIG51bWJlciBvZiByZWZlcmVuZHVtcyB0aGUgdm90ZXIgZGVsZWdhdGluZyB0byBoYXPIICB2b3RlZCBvbi4gV2VpZ2h0IGlzIGNoYXJnZWQgYXMgaWYgbWF4aW11bSB2b3Rlcy4odW5kZWxlZ2F0ZQALMMxVbmRlbGVnYXRlIHRoZSB2b3RpbmcgcG93ZXIgb2YgdGhlIHNlbmRpbmcgYWNjb3VudC4AXQFUb2tlbnMgbWF5IGJlIHVubG9ja2VkIGZvbGxvd2luZyBvbmNlIGFuIGFtb3VudCBvZiB0aW1lIGNvbnNpc3RlbnQgd2l0aCB0aGUgbG9jayBwZXJpb2Tcb2YgdGhlIGNvbnZpY3Rpb24gd2l0aCB3aGljaCB0aGUgZGVsZWdhdGlvbiB3YXMgaXNzdWVkLgBFAVRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIHRoZSBzaWduaW5nIGFjY291bnQgbXVzdCBiZVRjdXJyZW50bHkgZGVsZWdhdGluZy4AUEVtaXRzIGBVbmRlbGVnYXRlZGAuAD0BV2VpZ2h0OiBgTyhSKWAgd2hlcmUgUiBpcyB0aGUgbnVtYmVyIG9mIHJlZmVyZW5kdW1zIHRoZSB2b3RlciBkZWxlZ2F0aW5nIHRvIGhhc8ggIHZvdGVkIG9uLiBXZWlnaHQgaXMgY2hhcmdlZCBhcyBpZiBtYXhpbXVtIHZvdGVzLlhjbGVhcl9wdWJsaWNfcHJvcG9zYWxzAAwUcENsZWFycyBhbGwgcHVibGljIHByb3Bvc2Fscy4AwFRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgX1Jvb3RfLgA8V2VpZ2h0OiBgTygxKWAuGHVubG9jawQBGHRhcmdldAABUEFjY291bnRJZExvb2t1cE9mPFQ+AA0coFVubG9jayB0b2tlbnMgdGhhdCBoYXZlIGFuIGV4cGlyZWQgbG9jay4AyFRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8uALgtIGB0YXJnZXRgOiBUaGUgYWNjb3VudCB0byByZW1vdmUgdGhlIGxvY2sgb24uALxXZWlnaHQ6IGBPKFIpYCB3aXRoIFIgbnVtYmVyIG9mIHZvdGUgb2YgdGFyZ2V0LixyZW1vdmVfdm90ZQQBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4AA5sfFJlbW92ZSBhIHZvdGUgZm9yIGEgcmVmZXJlbmR1bS4ADElmOogtIHRoZSByZWZlcmVuZHVtIHdhcyBjYW5jZWxsZWQsIG9yfC0gdGhlIHJlZmVyZW5kdW0gaXMgb25nb2luZywgb3KQLSB0aGUgcmVmZXJlbmR1bSBoYXMgZW5kZWQgc3VjaCB0aGF0/CAgLSB0aGUgdm90ZSBvZiB0aGUgYWNjb3VudCB3YXMgaW4gb3Bwb3NpdGlvbiB0byB0aGUgcmVzdWx0OyBvctQgIC0gdGhlcmUgd2FzIG5vIGNvbnZpY3Rpb24gdG8gdGhlIGFjY291bnQncyB2b3RlOyBvcoQgIC0gdGhlIGFjY291bnQgbWFkZSBhIHNwbGl0IHZvdGVdAS4uLnRoZW4gdGhlIHZvdGUgaXMgcmVtb3ZlZCBjbGVhbmx5IGFuZCBhIGZvbGxvd2luZyBjYWxsIHRvIGB1bmxvY2tgIG1heSByZXN1bHQgaW4gbW9yZVhmdW5kcyBiZWluZyBhdmFpbGFibGUuAKhJZiwgaG93ZXZlciwgdGhlIHJlZmVyZW5kdW0gaGFzIGVuZGVkIGFuZDrsLSBpdCBmaW5pc2hlZCBjb3JyZXNwb25kaW5nIHRvIHRoZSB2b3RlIG9mIHRoZSBhY2NvdW50LCBhbmTcLSB0aGUgYWNjb3VudCBtYWRlIGEgc3RhbmRhcmQgdm90ZSB3aXRoIGNvbnZpY3Rpb24sIGFuZLwtIHRoZSBsb2NrIHBlcmlvZCBvZiB0aGUgY29udmljdGlvbiBpcyBub3Qgb3ZlclkBLi4udGhlbiB0aGUgbG9jayB3aWxsIGJlIGFnZ3JlZ2F0ZWQgaW50byB0aGUgb3ZlcmFsbCBhY2NvdW50J3MgbG9jaywgd2hpY2ggbWF5IGludm9sdmVZASpvdmVybG9ja2luZyogKHdoZXJlIHRoZSB0d28gbG9ja3MgYXJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgbG9jayB0aGF0IGlzIHRoZSBtYXhpbXVt5G9mIGJvdGggdGhlIGFtb3VudCBsb2NrZWQgYW5kIHRoZSB0aW1lIGlzIGl0IGxvY2tlZCBmb3IpLgBJAVRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8sIGFuZCB0aGUgc2lnbmVyIG11c3QgaGF2ZSBhIHZvdGWIcmVnaXN0ZXJlZCBmb3IgcmVmZXJlbmR1bSBgaW5kZXhgLgD0LSBgaW5kZXhgOiBUaGUgaW5kZXggb2YgcmVmZXJlbmR1bSBvZiB0aGUgdm90ZSB0byBiZSByZW1vdmVkLgBVAVdlaWdodDogYE8oUiArIGxvZyBSKWAgd2hlcmUgUiBpcyB0aGUgbnVtYmVyIG9mIHJlZmVyZW5kYSB0aGF0IGB0YXJnZXRgIGhhcyB2b3RlZCBvbi7YICBXZWlnaHQgaXMgY2FsY3VsYXRlZCBmb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mIHZvdGUuRHJlbW92ZV9vdGhlcl92b3RlCAEYdGFyZ2V0AAFQQWNjb3VudElkTG9va3VwT2Y8VD4AARRpbmRleBABPFJlZmVyZW5kdW1JbmRleAAPPHxSZW1vdmUgYSB2b3RlIGZvciBhIHJlZmVyZW5kdW0uAE0BSWYgdGhlIGB0YXJnZXRgIGlzIGVxdWFsIHRvIHRoZSBzaWduZXIsIHRoZW4gdGhpcyBmdW5jdGlvbiBpcyBleGFjdGx5IGVxdWl2YWxlbnQgdG8tAWByZW1vdmVfdm90ZWAuIElmIG5vdCBlcXVhbCB0byB0aGUgc2lnbmVyLCB0aGVuIHRoZSB2b3RlIG11c3QgaGF2ZSBleHBpcmVkLFUBZWl0aGVyIGJlY2F1c2UgdGhlIHJlZmVyZW5kdW0gd2FzIGNhbmNlbGxlZCwgYmVjYXVzZSB0aGUgdm90ZXIgbG9zdCB0aGUgcmVmZXJlbmR1bSBvcphiZWNhdXNlIHRoZSBjb252aWN0aW9uIHBlcmlvZCBpcyBvdmVyLgDIVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4ATQEtIGB0YXJnZXRgOiBUaGUgYWNjb3VudCBvZiB0aGUgdm90ZSB0byBiZSByZW1vdmVkOyB0aGlzIGFjY291bnQgbXVzdCBoYXZlIHZvdGVkIGZvclQgIHJlZmVyZW5kdW0gYGluZGV4YC70LSBgaW5kZXhgOiBUaGUgaW5kZXggb2YgcmVmZXJlbmR1bSBvZiB0aGUgdm90ZSB0byBiZSByZW1vdmVkLgBVAVdlaWdodDogYE8oUiArIGxvZyBSKWAgd2hlcmUgUiBpcyB0aGUgbnVtYmVyIG9mIHJlZmVyZW5kYSB0aGF0IGB0YXJnZXRgIGhhcyB2b3RlZCBvbi7YICBXZWlnaHQgaXMgY2FsY3VsYXRlZCBmb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mIHZvdGUuJGJsYWNrbGlzdAgBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAE8bWF5YmVfcmVmX2luZGV4WQEBXE9wdGlvbjxSZWZlcmVuZHVtSW5kZXg+ABA8RQFQZXJtYW5lbnRseSBwbGFjZSBhIHByb3Bvc2FsIGludG8gdGhlIGJsYWNrbGlzdC4gVGhpcyBwcmV2ZW50cyBpdCBmcm9tIGV2ZXIgYmVpbmc8cHJvcG9zZWQgYWdhaW4uAFEBSWYgY2FsbGVkIG9uIGEgcXVldWVkIHB1YmxpYyBvciBleHRlcm5hbCBwcm9wb3NhbCwgdGhlbiB0aGlzIHdpbGwgcmVzdWx0IGluIGl0IGJlaW5nUQFyZW1vdmVkLiBJZiB0aGUgYHJlZl9pbmRleGAgc3VwcGxpZWQgaXMgYW4gYWN0aXZlIHJlZmVyZW5kdW0gd2l0aCB0aGUgcHJvcG9zYWwgaGFzaCxodGhlbiBpdCB3aWxsIGJlIGNhbmNlbGxlZC4A7FRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgYEJsYWNrbGlzdE9yaWdpbmAuAPgtIGBwcm9wb3NhbF9oYXNoYDogVGhlIHByb3Bvc2FsIGhhc2ggdG8gYmxhY2tsaXN0IHBlcm1hbmVudGx5LkUBLSBgcmVmX2luZGV4YDogQW4gb25nb2luZyByZWZlcmVuZHVtIHdob3NlIGhhc2ggaXMgYHByb3Bvc2FsX2hhc2hgLCB3aGljaCB3aWxsIGJlKGNhbmNlbGxlZC4AQQFXZWlnaHQ6IGBPKHApYCAodGhvdWdoIGFzIHRoaXMgaXMgYW4gaGlnaC1wcml2aWxlZ2UgZGlzcGF0Y2gsIHdlIGFzc3VtZSBpdCBoYXMgYVAgIHJlYXNvbmFibGUgdmFsdWUpLjxjYW5jZWxfcHJvcG9zYWwEAShwcm9wX2luZGV4VQEBJFByb3BJbmRleAARHEhSZW1vdmUgYSBwcm9wb3NhbC4AAQFUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIGBDYW5jZWxQcm9wb3NhbE9yaWdpbmAuANAtIGBwcm9wX2luZGV4YDogVGhlIGluZGV4IG9mIHRoZSBwcm9wb3NhbCB0byBjYW5jZWwuAORXZWlnaHQ6IGBPKHApYCB3aGVyZSBgcCA9IFB1YmxpY1Byb3BzOjo8VD46OmRlY29kZV9sZW4oKWAwc2V0X21ldGFkYXRhCAEUb3duZXK4ATRNZXRhZGF0YU93bmVyAAEobWF5YmVfaGFzaIUCATxPcHRpb248VDo6SGFzaD4AEjzYU2V0IG9yIGNsZWFyIGEgbWV0YWRhdGEgb2YgYSBwcm9wb3NhbCBvciBhIHJlZmVyZW5kdW0uACxQYXJhbWV0ZXJzOswtIGBvcmlnaW5gOiBNdXN0IGNvcnJlc3BvbmQgdG8gdGhlIGBNZXRhZGF0YU93bmVyYC49ASAgICAtIGBFeHRlcm5hbE9yaWdpbmAgZm9yIGFuIGV4dGVybmFsIHByb3Bvc2FsIHdpdGggdGhlIGBTdXBlck1ham9yaXR5QXBwcm92ZWBAICAgICAgdGhyZXNob2xkLlkBICAgIC0gYEV4dGVybmFsRGVmYXVsdE9yaWdpbmAgZm9yIGFuIGV4dGVybmFsIHByb3Bvc2FsIHdpdGggdGhlIGBTdXBlck1ham9yaXR5QWdhaW5zdGBAICAgICAgdGhyZXNob2xkLkUBICAgIC0gYEV4dGVybmFsTWFqb3JpdHlPcmlnaW5gIGZvciBhbiBleHRlcm5hbCBwcm9wb3NhbCB3aXRoIHRoZSBgU2ltcGxlTWFqb3JpdHlgQCAgICAgIHRocmVzaG9sZC7IICAgIC0gYFNpZ25lZGAgYnkgYSBjcmVhdG9yIGZvciBhIHB1YmxpYyBwcm9wb3NhbC70ICAgIC0gYFNpZ25lZGAgdG8gY2xlYXIgYSBtZXRhZGF0YSBmb3IgYSBmaW5pc2hlZCByZWZlcmVuZHVtLuQgICAgLSBgUm9vdGAgdG8gc2V0IGEgbWV0YWRhdGEgZm9yIGFuIG9uZ29pbmcgcmVmZXJlbmR1bS60LSBgb3duZXJgOiBhbiBpZGVudGlmaWVyIG9mIGEgbWV0YWRhdGEgb3duZXIuUQEtIGBtYXliZV9oYXNoYDogVGhlIGhhc2ggb2YgYW4gb24tY2hhaW4gc3RvcmVkIHByZWltYWdlLiBgTm9uZWAgdG8gY2xlYXIgYSBtZXRhZGF0YS5EZm9yY2VfcmVtb3ZlX3ZvdGUIARh0YXJnZXQAAWxjcmF0ZTo6QWNjb3VudElkTG9va3VwT2Y8VD4AARRpbmRleBABdGNyYXRlOjp0eXBlczo6UmVmZXJlbmR1bUluZGV4ABM8uEFsbG93IHRvIGZvcmNlIHJlbW92ZSBhIHZvdGUgZm9yIGEgcmVmZXJlbmR1bS4AKQFTYW1lIGFzIGByZW1vdmVfb3RoZXJfdm90ZWAsIGV4Y2VwdCB0aGUgc2NvcGUgaXMgb3ZlcnJpZGVuIGJ5IGZvcmNlZCBmbGFnLvRUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIGBWb3RlUmVtb3ZhbE9yaWdpbmAuAKxPbmx5IGFsbG93ZWQgaWYgdGhlIHJlZmVyZW5kdW0gaXMgZmluaXNoZWQuAMhUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgBNAS0gYHRhcmdldGA6IFRoZSBhY2NvdW50IG9mIHRoZSB2b3RlIHRvIGJlIHJlbW92ZWQ7IHRoaXMgYWNjb3VudCBtdXN0IGhhdmUgdm90ZWQgZm9yVCAgcmVmZXJlbmR1bSBgaW5kZXhgLvQtIGBpbmRleGA6IFRoZSBpbmRleCBvZiByZWZlcmVuZHVtIG9mIHRoZSB2b3RlIHRvIGJlIHJlbW92ZWQuAFUBV2VpZ2h0OiBgTyhSICsgbG9nIFIpYCB3aGVyZSBSIGlzIHRoZSBudW1iZXIgb2YgcmVmZXJlbmRhIHRoYXQgYHRhcmdldGAgaGFzIHZvdGVkIG9uLtggIFdlaWdodCBpcyBjYWxjdWxhdGVkIGZvciB0aGUgbWF4aW11bSBudW1iZXIgb2Ygdm90ZS4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMugQIMQHBhbGxldF9kZW1vY3JhY3koY29udmljdGlvbihDb252aWN0aW9uAAEcEE5vbmUAAAAgTG9ja2VkMXgAAQAgTG9ja2VkMngAAgAgTG9ja2VkM3gAAwAgTG9ja2VkNHgABAAgTG9ja2VkNXgABQAgTG9ja2VkNngABgAAhQIEGE9wdGlvbgQEVAE0AQgQTm9uZQAAABBTb21lBAA0AAABAACJAgxEcGFsbGV0X2NvbGxlY3RpdmUYcGFsbGV0EENhbGwIBFQABEkAARgsc2V0X21lbWJlcnMMASxuZXdfbWVtYmVyczEBAURWZWM8VDo6QWNjb3VudElkPgABFHByaW1l7AFQT3B0aW9uPFQ6OkFjY291bnRJZD4AASRvbGRfY291bnQQASxNZW1iZXJDb3VudAAAYIBTZXQgdGhlIGNvbGxlY3RpdmUncyBtZW1iZXJzaGlwLgBFAS0gYG5ld19tZW1iZXJzYDogVGhlIG5ldyBtZW1iZXIgbGlzdC4gQmUgbmljZSB0byB0aGUgY2hhaW4gYW5kIHByb3ZpZGUgaXQgc29ydGVkLuAtIGBwcmltZWA6IFRoZSBwcmltZSBtZW1iZXIgd2hvc2Ugdm90ZSBzZXRzIHRoZSBkZWZhdWx0LlkBLSBgb2xkX2NvdW50YDogVGhlIHVwcGVyIGJvdW5kIGZvciB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIG1lbWJlcnMgaW4gc3RvcmFnZS4gVXNlZCBmb3JQICB3ZWlnaHQgZXN0aW1hdGlvbi4A1FRoZSBkaXNwYXRjaCBvZiB0aGlzIGNhbGwgbXVzdCBiZSBgU2V0TWVtYmVyc09yaWdpbmAuAFEBTk9URTogRG9lcyBub3QgZW5mb3JjZSB0aGUgZXhwZWN0ZWQgYE1heE1lbWJlcnNgIGxpbWl0IG9uIHRoZSBhbW91bnQgb2YgbWVtYmVycywgYnV0IQEgICAgICB0aGUgd2VpZ2h0IGVzdGltYXRpb25zIHJlbHkgb24gaXQgdG8gZXN0aW1hdGUgZGlzcGF0Y2hhYmxlIHdlaWdodC4AKCMgV0FSTklORzoAWQFUaGUgYHBhbGxldC1jb2xsZWN0aXZlYCBjYW4gYWxzbyBiZSBtYW5hZ2VkIGJ5IGxvZ2ljIG91dHNpZGUgb2YgdGhlIHBhbGxldCB0aHJvdWdoIHRoZbhpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHJhaXQgW2BDaGFuZ2VNZW1iZXJzYF0uVQFBbnkgY2FsbCB0byBgc2V0X21lbWJlcnNgIG11c3QgYmUgY2FyZWZ1bCB0aGF0IHRoZSBtZW1iZXIgc2V0IGRvZXNuJ3QgZ2V0IG91dCBvZiBzeW5jpHdpdGggb3RoZXIgbG9naWMgbWFuYWdpbmcgdGhlIG1lbWJlciBzZXQuADgjIyBDb21wbGV4aXR5OlAtIGBPKE1QICsgTilgIHdoZXJlOuAgIC0gYE1gIG9sZC1tZW1iZXJzLWNvdW50IChjb2RlLSBhbmQgZ292ZXJuYW5jZS1ib3VuZGVkKeAgIC0gYE5gIG5ldy1tZW1iZXJzLWNvdW50IChjb2RlLSBhbmQgZ292ZXJuYW5jZS1ib3VuZGVkKZggIC0gYFBgIHByb3Bvc2Fscy1jb3VudCAoY29kZS1ib3VuZGVkKRxleGVjdXRlCAEgcHJvcG9zYWwRAQF8Qm94PDxUIGFzIENvbmZpZzxJPj46OlByb3Bvc2FsPgABMGxlbmd0aF9ib3VuZFUBAQx1MzIAASTwRGlzcGF0Y2ggYSBwcm9wb3NhbCBmcm9tIGEgbWVtYmVyIHVzaW5nIHRoZSBgTWVtYmVyYCBvcmlnaW4uAKhPcmlnaW4gbXVzdCBiZSBhIG1lbWJlciBvZiB0aGUgY29sbGVjdGl2ZS4AOCMjIENvbXBsZXhpdHk6XC0gYE8oQiArIE0gKyBQKWAgd2hlcmU62C0gYEJgIGlzIGBwcm9wb3NhbGAgc2l6ZSBpbiBieXRlcyAobGVuZ3RoLWZlZS1ib3VuZGVkKYgtIGBNYCBtZW1iZXJzLWNvdW50IChjb2RlLWJvdW5kZWQpqC0gYFBgIGNvbXBsZXhpdHkgb2YgZGlzcGF0Y2hpbmcgYHByb3Bvc2FsYBxwcm9wb3NlDAEkdGhyZXNob2xkVQEBLE1lbWJlckNvdW50AAEgcHJvcG9zYWwRAQF8Qm94PDxUIGFzIENvbmZpZzxJPj46OlByb3Bvc2FsPgABMGxlbmd0aF9ib3VuZFUBAQx1MzIAAjj4QWRkIGEgbmV3IHByb3Bvc2FsIHRvIGVpdGhlciBiZSB2b3RlZCBvbiBvciBleGVjdXRlZCBkaXJlY3RseS4AhFJlcXVpcmVzIHRoZSBzZW5kZXIgdG8gYmUgbWVtYmVyLgBBAWB0aHJlc2hvbGRgIGRldGVybWluZXMgd2hldGhlciBgcHJvcG9zYWxgIGlzIGV4ZWN1dGVkIGRpcmVjdGx5IChgdGhyZXNob2xkIDwgMmApVG9yIHB1dCB1cCBmb3Igdm90aW5nLgA0IyMgQ29tcGxleGl0eawtIGBPKEIgKyBNICsgUDEpYCBvciBgTyhCICsgTSArIFAyKWAgd2hlcmU64CAgLSBgQmAgaXMgYHByb3Bvc2FsYCBzaXplIGluIGJ5dGVzIChsZW5ndGgtZmVlLWJvdW5kZWQp3CAgLSBgTWAgaXMgbWVtYmVycy1jb3VudCAoY29kZS0gYW5kIGdvdmVybmFuY2UtYm91bmRlZCnEICAtIGJyYW5jaGluZyBpcyBpbmZsdWVuY2VkIGJ5IGB0aHJlc2hvbGRgIHdoZXJlOvQgICAgLSBgUDFgIGlzIHByb3Bvc2FsIGV4ZWN1dGlvbiBjb21wbGV4aXR5IChgdGhyZXNob2xkIDwgMmAp/CAgICAtIGBQMmAgaXMgcHJvcG9zYWxzLWNvdW50IChjb2RlLWJvdW5kZWQpIChgdGhyZXNob2xkID49IDJgKRB2b3RlDAEgcHJvcG9zYWw0ARxUOjpIYXNoAAEUaW5kZXhVAQE0UHJvcG9zYWxJbmRleAABHGFwcHJvdmUgARBib29sAAMk8EFkZCBhbiBheWUgb3IgbmF5IHZvdGUgZm9yIHRoZSBzZW5kZXIgdG8gdGhlIGdpdmVuIHByb3Bvc2FsLgCMUmVxdWlyZXMgdGhlIHNlbmRlciB0byBiZSBhIG1lbWJlci4ASQFUcmFuc2FjdGlvbiBmZWVzIHdpbGwgYmUgd2FpdmVkIGlmIHRoZSBtZW1iZXIgaXMgdm90aW5nIG9uIGFueSBwYXJ0aWN1bGFyIHByb3Bvc2FsUQFmb3IgdGhlIGZpcnN0IHRpbWUgYW5kIHRoZSBjYWxsIGlzIHN1Y2Nlc3NmdWwuIFN1YnNlcXVlbnQgdm90ZSBjaGFuZ2VzIHdpbGwgY2hhcmdlIGEQZmVlLjQjIyBDb21wbGV4aXR5CQEtIGBPKE0pYCB3aGVyZSBgTWAgaXMgbWVtYmVycy1jb3VudCAoY29kZS0gYW5kIGdvdmVybmFuY2UtYm91bmRlZClMZGlzYXBwcm92ZV9wcm9wb3NhbAQBNHByb3Bvc2FsX2hhc2g0ARxUOjpIYXNoAAUoWQFEaXNhcHByb3ZlIGEgcHJvcG9zYWwsIGNsb3NlLCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHN5c3RlbSwgcmVnYXJkbGVzcyBvZiBpdHMgY3VycmVudBhzdGF0ZS4AiE11c3QgYmUgY2FsbGVkIGJ5IHRoZSBSb290IG9yaWdpbi4ALFBhcmFtZXRlcnM6HQEqIGBwcm9wb3NhbF9oYXNoYDogVGhlIGhhc2ggb2YgdGhlIHByb3Bvc2FsIHRoYXQgc2hvdWxkIGJlIGRpc2FwcHJvdmVkLgA0IyMgQ29tcGxleGl0eaxPKFApIHdoZXJlIFAgaXMgdGhlIG51bWJlciBvZiBtYXggcHJvcG9zYWxzFGNsb3NlEAE0cHJvcG9zYWxfaGFzaDQBHFQ6Okhhc2gAARRpbmRleFUBATRQcm9wb3NhbEluZGV4AAFUcHJvcG9zYWxfd2VpZ2h0X2JvdW5kKAEYV2VpZ2h0AAEwbGVuZ3RoX2JvdW5kVQEBDHUzMgAGYE0BQ2xvc2UgYSB2b3RlIHRoYXQgaXMgZWl0aGVyIGFwcHJvdmVkLCBkaXNhcHByb3ZlZCBvciB3aG9zZSB2b3RpbmcgcGVyaW9kIGhhcyBlbmRlZC4AVQFNYXkgYmUgY2FsbGVkIGJ5IGFueSBzaWduZWQgYWNjb3VudCBpbiBvcmRlciB0byBmaW5pc2ggdm90aW5nIGFuZCBjbG9zZSB0aGUgcHJvcG9zYWwuAEkBSWYgY2FsbGVkIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSB2b3RpbmcgcGVyaW9kIGl0IHdpbGwgb25seSBjbG9zZSB0aGUgdm90ZSBpZiBpdCBpc7xoYXMgZW5vdWdoIHZvdGVzIHRvIGJlIGFwcHJvdmVkIG9yIGRpc2FwcHJvdmVkLgBJAUlmIGNhbGxlZCBhZnRlciB0aGUgZW5kIG9mIHRoZSB2b3RpbmcgcGVyaW9kIGFic3RlbnRpb25zIGFyZSBjb3VudGVkIGFzIHJlamVjdGlvbnMlAXVubGVzcyB0aGVyZSBpcyBhIHByaW1lIG1lbWJlciBzZXQgYW5kIHRoZSBwcmltZSBtZW1iZXIgY2FzdCBhbiBhcHByb3ZhbC4AYQFJZiB0aGUgY2xvc2Ugb3BlcmF0aW9uIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkgd2l0aCBkaXNhcHByb3ZhbCwgdGhlIHRyYW5zYWN0aW9uIGZlZSB3aWxsXQFiZSB3YWl2ZWQuIE90aGVyd2lzZSBleGVjdXRpb24gb2YgdGhlIGFwcHJvdmVkIG9wZXJhdGlvbiB3aWxsIGJlIGNoYXJnZWQgdG8gdGhlIGNhbGxlci4AYQErIGBwcm9wb3NhbF93ZWlnaHRfYm91bmRgOiBUaGUgbWF4aW11bSBhbW91bnQgb2Ygd2VpZ2h0IGNvbnN1bWVkIGJ5IGV4ZWN1dGluZyB0aGUgY2xvc2VkJHByb3Bvc2FsLmEBKyBgbGVuZ3RoX2JvdW5kYDogVGhlIHVwcGVyIGJvdW5kIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBwcm9wb3NhbCBpbiBzdG9yYWdlLiBDaGVja2VkIHZpYTUBYHN0b3JhZ2U6OnJlYWRgIHNvIGl0IGlzIGBzaXplX29mOjo8dTMyPigpID09IDRgIGxhcmdlciB0aGFuIHRoZSBwdXJlIGxlbmd0aC4ANCMjIENvbXBsZXhpdHl0LSBgTyhCICsgTSArIFAxICsgUDIpYCB3aGVyZTrgICAtIGBCYCBpcyBgcHJvcG9zYWxgIHNpemUgaW4gYnl0ZXMgKGxlbmd0aC1mZWUtYm91bmRlZCncICAtIGBNYCBpcyBtZW1iZXJzLWNvdW50IChjb2RlLSBhbmQgZ292ZXJuYW5jZS1ib3VuZGVkKcggIC0gYFAxYCBpcyB0aGUgY29tcGxleGl0eSBvZiBgcHJvcG9zYWxgIHByZWltYWdlLqQgIC0gYFAyYCBpcyBwcm9wb3NhbC1jb3VudCAoY29kZS1ib3VuZGVkKQQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy6NAgwwcGFsbGV0X3Byb3h5GHBhbGxldBBDYWxsBARUAAEoFHByb3h5DAEQcmVhbAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAFAZm9yY2VfcHJveHlfdHlwZZECAVBPcHRpb248VDo6UHJveHlUeXBlPgABEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgAAJE0BRGlzcGF0Y2ggdGhlIGdpdmVuIGBjYWxsYCBmcm9tIGFuIGFjY291bnQgdGhhdCB0aGUgc2VuZGVyIGlzIGF1dGhvcmlzZWQgZm9yIHRocm91Z2gwYGFkZF9wcm94eWAuAMxUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4ALFBhcmFtZXRlcnM6DQEtIGByZWFsYDogVGhlIGFjY291bnQgdGhhdCB0aGUgcHJveHkgd2lsbCBtYWtlIGEgY2FsbCBvbiBiZWhhbGYgb2YuYQEtIGBmb3JjZV9wcm94eV90eXBlYDogU3BlY2lmeSB0aGUgZXhhY3QgcHJveHkgdHlwZSB0byBiZSB1c2VkIGFuZCBjaGVja2VkIGZvciB0aGlzIGNhbGwu0C0gYGNhbGxgOiBUaGUgY2FsbCB0byBiZSBtYWRlIGJ5IHRoZSBgcmVhbGAgYWNjb3VudC4kYWRkX3Byb3h5DAEgZGVsZWdhdGUAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABKHByb3h5X3R5cGXEATBUOjpQcm94eVR5cGUAARRkZWxheRABREJsb2NrTnVtYmVyRm9yPFQ+AAEkRQFSZWdpc3RlciBhIHByb3h5IGFjY291bnQgZm9yIHRoZSBzZW5kZXIgdGhhdCBpcyBhYmxlIHRvIG1ha2UgY2FsbHMgb24gaXRzIGJlaGFsZi4AzFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgAsUGFyYW1ldGVyczoRAS0gYHByb3h5YDogVGhlIGFjY291bnQgdGhhdCB0aGUgYGNhbGxlcmAgd291bGQgbGlrZSB0byBtYWtlIGEgcHJveHku/C0gYHByb3h5X3R5cGVgOiBUaGUgcGVybWlzc2lvbnMgYWxsb3dlZCBmb3IgdGhpcyBwcm94eSBhY2NvdW50Lk0BLSBgZGVsYXlgOiBUaGUgYW5ub3VuY2VtZW50IHBlcmlvZCByZXF1aXJlZCBvZiB0aGUgaW5pdGlhbCBwcm94eS4gV2lsbCBnZW5lcmFsbHkgYmUUemVyby4wcmVtb3ZlX3Byb3h5DAEgZGVsZWdhdGUAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABKHByb3h5X3R5cGXEATBUOjpQcm94eVR5cGUAARRkZWxheRABREJsb2NrTnVtYmVyRm9yPFQ+AAIcqFVucmVnaXN0ZXIgYSBwcm94eSBhY2NvdW50IGZvciB0aGUgc2VuZGVyLgDMVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8uACxQYXJhbWV0ZXJzOiUBLSBgcHJveHlgOiBUaGUgYWNjb3VudCB0aGF0IHRoZSBgY2FsbGVyYCB3b3VsZCBsaWtlIHRvIHJlbW92ZSBhcyBhIHByb3h5LkEBLSBgcHJveHlfdHlwZWA6IFRoZSBwZXJtaXNzaW9ucyBjdXJyZW50bHkgZW5hYmxlZCBmb3IgdGhlIHJlbW92ZWQgcHJveHkgYWNjb3VudC44cmVtb3ZlX3Byb3hpZXMAAxi0VW5yZWdpc3RlciBhbGwgcHJveHkgYWNjb3VudHMgZm9yIHRoZSBzZW5kZXIuAMxUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4AQQFXQVJOSU5HOiBUaGlzIG1heSBiZSBjYWxsZWQgb24gYWNjb3VudHMgY3JlYXRlZCBieSBgcHVyZWAsIGhvd2V2ZXIgaWYgZG9uZSwgdGhlblkBdGhlIHVucmVzZXJ2ZWQgZmVlcyB3aWxsIGJlIGluYWNjZXNzaWJsZS4gKipBbGwgYWNjZXNzIHRvIHRoaXMgYWNjb3VudCB3aWxsIGJlIGxvc3QuKiosY3JlYXRlX3B1cmUMAShwcm94eV90eXBlxAEwVDo6UHJveHlUeXBlAAEUZGVsYXkQAURCbG9ja051bWJlckZvcjxUPgABFGluZGV4yAEMdTE2AARIOQFTcGF3biBhIGZyZXNoIG5ldyBhY2NvdW50IHRoYXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvdGhlcndpc2UgaW5hY2Nlc3NpYmxlLCBhbmT8aW5pdGlhbGl6ZSBpdCB3aXRoIGEgcHJveHkgb2YgYHByb3h5X3R5cGVgIGZvciBgb3JpZ2luYCBzZW5kZXIuAGxSZXF1aXJlcyBhIGBTaWduZWRgIG9yaWdpbi4AUQEtIGBwcm94eV90eXBlYDogVGhlIHR5cGUgb2YgdGhlIHByb3h5IHRoYXQgdGhlIHNlbmRlciB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgb3ZlciB0aGVNAW5ldyBhY2NvdW50LiBUaGlzIHdpbGwgYWxtb3N0IGFsd2F5cyBiZSB0aGUgbW9zdCBwZXJtaXNzaXZlIGBQcm94eVR5cGVgIHBvc3NpYmxlIHRveGFsbG93IGZvciBtYXhpbXVtIGZsZXhpYmlsaXR5LlEBLSBgaW5kZXhgOiBBIGRpc2FtYmlndWF0aW9uIGluZGV4LCBpbiBjYXNlIHRoaXMgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lXQF0cmFuc2FjdGlvbiAoZS5nLiB3aXRoIGB1dGlsaXR5OjpiYXRjaGApLiBVbmxlc3MgeW91J3JlIHVzaW5nIGBiYXRjaGAgeW91IHByb2JhYmx5IGp1c3RAd2FudCB0byB1c2UgYDBgLk0BLSBgZGVsYXlgOiBUaGUgYW5ub3VuY2VtZW50IHBlcmlvZCByZXF1aXJlZCBvZiB0aGUgaW5pdGlhbCBwcm94eS4gV2lsbCBnZW5lcmFsbHkgYmUUemVyby4AUQFGYWlscyB3aXRoIGBEdXBsaWNhdGVgIGlmIHRoaXMgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiwgZnJvbSB0aGWYc2FtZSBzZW5kZXIsIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy4A5EZhaWxzIGlmIHRoZXJlIGFyZSBpbnN1ZmZpY2llbnQgZnVuZHMgdG8gcGF5IGZvciBkZXBvc2l0LiRraWxsX3B1cmUUARxzcGF3bmVyAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AAShwcm94eV90eXBlxAEwVDo6UHJveHlUeXBlAAEUaW5kZXjIAQx1MTYAARhoZWlnaHRVAQFEQmxvY2tOdW1iZXJGb3I8VD4AASRleHRfaW5kZXhVAQEMdTMyAAVAoFJlbW92ZXMgYSBwcmV2aW91c2x5IHNwYXduZWQgcHVyZSBwcm94eS4ASQFXQVJOSU5HOiAqKkFsbCBhY2Nlc3MgdG8gdGhpcyBhY2NvdW50IHdpbGwgYmUgbG9zdC4qKiBBbnkgZnVuZHMgaGVsZCBpbiBpdCB3aWxsIGJlNGluYWNjZXNzaWJsZS4AWQFSZXF1aXJlcyBhIGBTaWduZWRgIG9yaWdpbiwgYW5kIHRoZSBzZW5kZXIgYWNjb3VudCBtdXN0IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IGEgY2FsbCB0b5RgcHVyZWAgd2l0aCBjb3JyZXNwb25kaW5nIHBhcmFtZXRlcnMuADkBLSBgc3Bhd25lcmA6IFRoZSBhY2NvdW50IHRoYXQgb3JpZ2luYWxseSBjYWxsZWQgYHB1cmVgIHRvIGNyZWF0ZSB0aGlzIGFjY291bnQuOQEtIGBpbmRleGA6IFRoZSBkaXNhbWJpZ3VhdGlvbiBpbmRleCBvcmlnaW5hbGx5IHBhc3NlZCB0byBgcHVyZWAuIFByb2JhYmx5IGAwYC7sLSBgcHJveHlfdHlwZWA6IFRoZSBwcm94eSB0eXBlIG9yaWdpbmFsbHkgcGFzc2VkIHRvIGBwdXJlYC4pAS0gYGhlaWdodGA6IFRoZSBoZWlnaHQgb2YgdGhlIGNoYWluIHdoZW4gdGhlIGNhbGwgdG8gYHB1cmVgIHdhcyBwcm9jZXNzZWQuNQEtIGBleHRfaW5kZXhgOiBUaGUgZXh0cmluc2ljIGluZGV4IGluIHdoaWNoIHRoZSBjYWxsIHRvIGBwdXJlYCB3YXMgcHJvY2Vzc2VkLgA1AUZhaWxzIHdpdGggYE5vUGVybWlzc2lvbmAgaW4gY2FzZSB0aGUgY2FsbGVyIGlzIG5vdCBhIHByZXZpb3VzbHkgY3JlYXRlZCBwdXJl3GFjY291bnQgd2hvc2UgYHB1cmVgIGNhbGwgaGFzIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVycy4gYW5ub3VuY2UIARByZWFsAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AASRjYWxsX2hhc2g0ATRDYWxsSGFzaE9mPFQ+AAY8BQFQdWJsaXNoIHRoZSBoYXNoIG9mIGEgcHJveHktY2FsbCB0aGF0IHdpbGwgYmUgbWFkZSBpbiB0aGUgZnV0dXJlLgBdAVRoaXMgbXVzdCBiZSBjYWxsZWQgc29tZSBudW1iZXIgb2YgYmxvY2tzIGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZyBgcHJveHlgIGlzIGF0dGVtcHRlZCUBaWYgdGhlIGRlbGF5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJveHkgcmVsYXRpb25zaGlwIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLgARAU5vIG1vcmUgdGhhbiBgTWF4UGVuZGluZ2AgYW5ub3VuY2VtZW50cyBtYXkgYmUgbWFkZSBhdCBhbnkgb25lIHRpbWUuAAkBVGhpcyB3aWxsIHRha2UgYSBkZXBvc2l0IG9mIGBBbm5vdW5jZW1lbnREZXBvc2l0RmFjdG9yYCBhcyB3ZWxsIGFzGQFgQW5ub3VuY2VtZW50RGVwb3NpdEJhc2VgIGlmIHRoZXJlIGFyZSBubyBvdGhlciBwZW5kaW5nIGFubm91bmNlbWVudHMuACUBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8gYW5kIGEgcHJveHkgb2YgYHJlYWxgLgAsUGFyYW1ldGVyczoNAS0gYHJlYWxgOiBUaGUgYWNjb3VudCB0aGF0IHRoZSBwcm94eSB3aWxsIG1ha2UgYSBjYWxsIG9uIGJlaGFsZiBvZi4VAS0gYGNhbGxfaGFzaGA6IFRoZSBoYXNoIG9mIHRoZSBjYWxsIHRvIGJlIG1hZGUgYnkgdGhlIGByZWFsYCBhY2NvdW50LkxyZW1vdmVfYW5ub3VuY2VtZW50CAEQcmVhbAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEkY2FsbF9oYXNoNAE0Q2FsbEhhc2hPZjxUPgAHKHBSZW1vdmUgYSBnaXZlbiBhbm5vdW5jZW1lbnQuAFkBTWF5IGJlIGNhbGxlZCBieSBhIHByb3h5IGFjY291bnQgdG8gcmVtb3ZlIGEgY2FsbCB0aGV5IHByZXZpb3VzbHkgYW5ub3VuY2VkIGFuZCByZXR1cm4wdGhlIGRlcG9zaXQuAMxUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4ALFBhcmFtZXRlcnM6DQEtIGByZWFsYDogVGhlIGFjY291bnQgdGhhdCB0aGUgcHJveHkgd2lsbCBtYWtlIGEgY2FsbCBvbiBiZWhhbGYgb2YuFQEtIGBjYWxsX2hhc2hgOiBUaGUgaGFzaCBvZiB0aGUgY2FsbCB0byBiZSBtYWRlIGJ5IHRoZSBgcmVhbGAgYWNjb3VudC5McmVqZWN0X2Fubm91bmNlbWVudAgBIGRlbGVnYXRlAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AASRjYWxsX2hhc2g0ATRDYWxsSGFzaE9mPFQ+AAgosFJlbW92ZSB0aGUgZ2l2ZW4gYW5ub3VuY2VtZW50IG9mIGEgZGVsZWdhdGUuAGEBTWF5IGJlIGNhbGxlZCBieSBhIHRhcmdldCAocHJveGllZCkgYWNjb3VudCB0byByZW1vdmUgYSBjYWxsIHRoYXQgb25lIG9mIHRoZWlyIGRlbGVnYXRlcyUBKGBkZWxlZ2F0ZWApIGhhcyBhbm5vdW5jZWQgdGhleSB3YW50IHRvIGV4ZWN1dGUuIFRoZSBkZXBvc2l0IGlzIHJldHVybmVkLgDMVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8uACxQYXJhbWV0ZXJzOvQtIGBkZWxlZ2F0ZWA6IFRoZSBhY2NvdW50IHRoYXQgcHJldmlvdXNseSBhbm5vdW5jZWQgdGhlIGNhbGwuvC0gYGNhbGxfaGFzaGA6IFRoZSBoYXNoIG9mIHRoZSBjYWxsIHRvIGJlIG1hZGUuPHByb3h5X2Fubm91bmNlZBABIGRlbGVnYXRlAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AARByZWFsAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AAUBmb3JjZV9wcm94eV90eXBlkQIBUE9wdGlvbjxUOjpQcm94eVR5cGU+AAEQY2FsbBEBAXxCb3g8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAksTQFEaXNwYXRjaCB0aGUgZ2l2ZW4gYGNhbGxgIGZyb20gYW4gYWNjb3VudCB0aGF0IHRoZSBzZW5kZXIgaXMgYXV0aG9yaXplZCBmb3IgdGhyb3VnaDBgYWRkX3Byb3h5YC4AqFJlbW92ZXMgYW55IGNvcnJlc3BvbmRpbmcgYW5ub3VuY2VtZW50KHMpLgDMVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8uACxQYXJhbWV0ZXJzOg0BLSBgcmVhbGA6IFRoZSBhY2NvdW50IHRoYXQgdGhlIHByb3h5IHdpbGwgbWFrZSBhIGNhbGwgb24gYmVoYWxmIG9mLmEBLSBgZm9yY2VfcHJveHlfdHlwZWA6IFNwZWNpZnkgdGhlIGV4YWN0IHByb3h5IHR5cGUgdG8gYmUgdXNlZCBhbmQgY2hlY2tlZCBmb3IgdGhpcyBjYWxsLtAtIGBjYWxsYDogVGhlIGNhbGwgdG8gYmUgbWFkZSBieSB0aGUgYHJlYWxgIGFjY291bnQuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLpECBBhPcHRpb24EBFQBxAEIEE5vbmUAAAAQU29tZQQAxAAAAQAAlQIMPHBhbGxldF9tdWx0aXNpZxhwYWxsZXQQQ2FsbAQEVAABEFBhc19tdWx0aV90aHJlc2hvbGRfMQgBRG90aGVyX3NpZ25hdG9yaWVzMQEBRFZlYzxUOjpBY2NvdW50SWQ+AAEQY2FsbBEBAXxCb3g8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAAwUQFJbW1lZGlhdGVseSBkaXNwYXRjaCBhIG11bHRpLXNpZ25hdHVyZSBjYWxsIHVzaW5nIGEgc2luZ2xlIGFwcHJvdmFsIGZyb20gdGhlIGNhbGxlci4AzFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgA9AS0gYG90aGVyX3NpZ25hdG9yaWVzYDogVGhlIGFjY291bnRzIChvdGhlciB0aGFuIHRoZSBzZW5kZXIpIHdobyBhcmUgcGFydCBvZiB0aGUBAW11bHRpLXNpZ25hdHVyZSwgYnV0IGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiB0aGUgYXBwcm92YWwgcHJvY2Vzcy6ILSBgY2FsbGA6IFRoZSBjYWxsIHRvIGJlIGV4ZWN1dGVkLgC4UmVzdWx0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGRpc3BhdGNoZWQgcmVzdWx0LgA0IyMgQ29tcGxleGl0eRkBTyhaICsgQykgd2hlcmUgWiBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBjYWxsIGFuZCBDIGl0cyBleGVjdXRpb24gd2VpZ2h0LiBhc19tdWx0aRQBJHRocmVzaG9sZMgBDHUxNgABRG90aGVyX3NpZ25hdG9yaWVzMQEBRFZlYzxUOjpBY2NvdW50SWQ+AAE8bWF5YmVfdGltZXBvaW50mQIBkE9wdGlvbjxUaW1lcG9pbnQ8QmxvY2tOdW1iZXJGb3I8VD4+PgABEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgABKG1heF93ZWlnaHQoARhXZWlnaHQAAZxVAVJlZ2lzdGVyIGFwcHJvdmFsIGZvciBhIGRpc3BhdGNoIHRvIGJlIG1hZGUgZnJvbSBhIGRldGVybWluaXN0aWMgY29tcG9zaXRlIGFjY291bnQgaWb4YXBwcm92ZWQgYnkgYSB0b3RhbCBvZiBgdGhyZXNob2xkIC0gMWAgb2YgYG90aGVyX3NpZ25hdG9yaWVzYC4AsElmIHRoZXJlIGFyZSBlbm91Z2gsIHRoZW4gZGlzcGF0Y2ggdGhlIGNhbGwuAC0BUGF5bWVudDogYERlcG9zaXRCYXNlYCB3aWxsIGJlIHJlc2VydmVkIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGFwcHJvdmFsLCBwbHVzPQFgdGhyZXNob2xkYCB0aW1lcyBgRGVwb3NpdEZhY3RvcmAuIEl0IGlzIHJldHVybmVkIG9uY2UgdGhpcyBkaXNwYXRjaCBoYXBwZW5zIG9yNGlzIGNhbmNlbGxlZC4AzFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgBVAS0gYHRocmVzaG9sZGA6IFRoZSB0b3RhbCBudW1iZXIgb2YgYXBwcm92YWxzIGZvciB0aGlzIGRpc3BhdGNoIGJlZm9yZSBpdCBpcyBleGVjdXRlZC5BAS0gYG90aGVyX3NpZ25hdG9yaWVzYDogVGhlIGFjY291bnRzIChvdGhlciB0aGFuIHRoZSBzZW5kZXIpIHdobyBjYW4gYXBwcm92ZSB0aGlzbGRpc3BhdGNoLiBNYXkgbm90IGJlIGVtcHR5LlkBLSBgbWF5YmVfdGltZXBvaW50YDogSWYgdGhpcyBpcyB0aGUgZmlyc3QgYXBwcm92YWwsIHRoZW4gdGhpcyBtdXN0IGJlIGBOb25lYC4gSWYgaXQgaXNRAW5vdCB0aGUgZmlyc3QgYXBwcm92YWwsIHRoZW4gaXQgbXVzdCBiZSBgU29tZWAsIHdpdGggdGhlIHRpbWVwb2ludCAoYmxvY2sgbnVtYmVyIGFuZNR0cmFuc2FjdGlvbiBpbmRleCkgb2YgdGhlIGZpcnN0IGFwcHJvdmFsIHRyYW5zYWN0aW9uLogtIGBjYWxsYDogVGhlIGNhbGwgdG8gYmUgZXhlY3V0ZWQuAB0BTk9URTogVW5sZXNzIHRoaXMgaXMgdGhlIGZpbmFsIGFwcHJvdmFsLCB5b3Ugd2lsbCBnZW5lcmFsbHkgd2FudCB0byB1c2UZAWBhcHByb3ZlX2FzX211bHRpYCBpbnN0ZWFkLCBzaW5jZSBpdCBvbmx5IHJlcXVpcmVzIGEgaGFzaCBvZiB0aGUgY2FsbC4AWQFSZXN1bHQgaXMgZXF1aXZhbGVudCB0byB0aGUgZGlzcGF0Y2hlZCByZXN1bHQgaWYgYHRocmVzaG9sZGAgaXMgZXhhY3RseSBgMWAuIE90aGVyd2lzZVUBb24gc3VjY2VzcywgcmVzdWx0IGlzIGBPa2AgYW5kIHRoZSByZXN1bHQgZnJvbSB0aGUgaW50ZXJpb3IgY2FsbCwgaWYgaXQgd2FzIGV4ZWN1dGVkLNxtYXkgYmUgZm91bmQgaW4gdGhlIGRlcG9zaXRlZCBgTXVsdGlzaWdFeGVjdXRlZGAgZXZlbnQuADQjIyBDb21wbGV4aXR5UC0gYE8oUyArIFogKyBDYWxsKWAuzC0gVXAgdG8gb25lIGJhbGFuY2UtcmVzZXJ2ZSBvciB1bnJlc2VydmUgb3BlcmF0aW9uLj0BLSBPbmUgcGFzc3Rocm91Z2ggb3BlcmF0aW9uLCBvbmUgaW5zZXJ0LCBib3RoIGBPKFMpYCB3aGVyZSBgU2AgaXMgdGhlIG51bWJlciBvZkUBICBzaWduYXRvcmllcy4gYFNgIGlzIGNhcHBlZCBieSBgTWF4U2lnbmF0b3JpZXNgLCB3aXRoIHdlaWdodCBiZWluZyBwcm9wb3J0aW9uYWwuIQEtIE9uZSBjYWxsIGVuY29kZSAmIGhhc2gsIGJvdGggb2YgY29tcGxleGl0eSBgTyhaKWAgd2hlcmUgYFpgIGlzIHR4LWxlbi68LSBPbmUgZW5jb2RlICYgaGFzaCwgYm90aCBvZiBjb21wbGV4aXR5IGBPKFMpYC7ULSBVcCB0byBvbmUgYmluYXJ5IHNlYXJjaCBhbmQgaW5zZXJ0IChgTyhsb2dTICsgUylgKS74LSBJL086IDEgcmVhZCBgTyhTKWAsIHVwIHRvIDEgbXV0YXRlIGBPKFMpYC4gVXAgdG8gb25lIHJlbW92ZS4wLSBPbmUgZXZlbnQubC0gVGhlIHdlaWdodCBvZiB0aGUgYGNhbGxgLk0BLSBTdG9yYWdlOiBpbnNlcnRzIG9uZSBpdGVtLCB2YWx1ZSBzaXplIGJvdW5kZWQgYnkgYE1heFNpZ25hdG9yaWVzYCwgd2l0aCBhIGRlcG9zaXQZASAgdGFrZW4gZm9yIGl0cyBsaWZldGltZSBvZiBgRGVwb3NpdEJhc2UgKyB0aHJlc2hvbGQgKiBEZXBvc2l0RmFjdG9yYC5AYXBwcm92ZV9hc19tdWx0aRQBJHRocmVzaG9sZMgBDHUxNgABRG90aGVyX3NpZ25hdG9yaWVzMQEBRFZlYzxUOjpBY2NvdW50SWQ+AAE8bWF5YmVfdGltZXBvaW50mQIBkE9wdGlvbjxUaW1lcG9pbnQ8QmxvY2tOdW1iZXJGb3I8VD4+PgABJGNhbGxfaGFzaAQBIFt1ODsgMzJdAAEobWF4X3dlaWdodCgBGFdlaWdodAACeFUBUmVnaXN0ZXIgYXBwcm92YWwgZm9yIGEgZGlzcGF0Y2ggdG8gYmUgbWFkZSBmcm9tIGEgZGV0ZXJtaW5pc3RpYyBjb21wb3NpdGUgYWNjb3VudCBpZvhhcHByb3ZlZCBieSBhIHRvdGFsIG9mIGB0aHJlc2hvbGQgLSAxYCBvZiBgb3RoZXJfc2lnbmF0b3JpZXNgLgAtAVBheW1lbnQ6IGBEZXBvc2l0QmFzZWAgd2lsbCBiZSByZXNlcnZlZCBpZiB0aGlzIGlzIHRoZSBmaXJzdCBhcHByb3ZhbCwgcGx1cz0BYHRocmVzaG9sZGAgdGltZXMgYERlcG9zaXRGYWN0b3JgLiBJdCBpcyByZXR1cm5lZCBvbmNlIHRoaXMgZGlzcGF0Y2ggaGFwcGVucyBvcjRpcyBjYW5jZWxsZWQuAMxUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXy4AVQEtIGB0aHJlc2hvbGRgOiBUaGUgdG90YWwgbnVtYmVyIG9mIGFwcHJvdmFscyBmb3IgdGhpcyBkaXNwYXRjaCBiZWZvcmUgaXQgaXMgZXhlY3V0ZWQuQQEtIGBvdGhlcl9zaWduYXRvcmllc2A6IFRoZSBhY2NvdW50cyAob3RoZXIgdGhhbiB0aGUgc2VuZGVyKSB3aG8gY2FuIGFwcHJvdmUgdGhpc2xkaXNwYXRjaC4gTWF5IG5vdCBiZSBlbXB0eS5ZAS0gYG1heWJlX3RpbWVwb2ludGA6IElmIHRoaXMgaXMgdGhlIGZpcnN0IGFwcHJvdmFsLCB0aGVuIHRoaXMgbXVzdCBiZSBgTm9uZWAuIElmIGl0IGlzUQFub3QgdGhlIGZpcnN0IGFwcHJvdmFsLCB0aGVuIGl0IG11c3QgYmUgYFNvbWVgLCB3aXRoIHRoZSB0aW1lcG9pbnQgKGJsb2NrIG51bWJlciBhbmTUdHJhbnNhY3Rpb24gaW5kZXgpIG9mIHRoZSBmaXJzdCBhcHByb3ZhbCB0cmFuc2FjdGlvbi7MLSBgY2FsbF9oYXNoYDogVGhlIGhhc2ggb2YgdGhlIGNhbGwgdG8gYmUgZXhlY3V0ZWQuADUBTk9URTogSWYgdGhpcyBpcyB0aGUgZmluYWwgYXBwcm92YWwsIHlvdSB3aWxsIHdhbnQgdG8gdXNlIGBhc19tdWx0aWAgaW5zdGVhZC4ANCMjIENvbXBsZXhpdHkkLSBgTyhTKWAuzC0gVXAgdG8gb25lIGJhbGFuY2UtcmVzZXJ2ZSBvciB1bnJlc2VydmUgb3BlcmF0aW9uLj0BLSBPbmUgcGFzc3Rocm91Z2ggb3BlcmF0aW9uLCBvbmUgaW5zZXJ0LCBib3RoIGBPKFMpYCB3aGVyZSBgU2AgaXMgdGhlIG51bWJlciBvZkUBICBzaWduYXRvcmllcy4gYFNgIGlzIGNhcHBlZCBieSBgTWF4U2lnbmF0b3JpZXNgLCB3aXRoIHdlaWdodCBiZWluZyBwcm9wb3J0aW9uYWwuvC0gT25lIGVuY29kZSAmIGhhc2gsIGJvdGggb2YgY29tcGxleGl0eSBgTyhTKWAu1C0gVXAgdG8gb25lIGJpbmFyeSBzZWFyY2ggYW5kIGluc2VydCAoYE8obG9nUyArIFMpYCku+C0gSS9POiAxIHJlYWQgYE8oUylgLCB1cCB0byAxIG11dGF0ZSBgTyhTKWAuIFVwIHRvIG9uZSByZW1vdmUuMC0gT25lIGV2ZW50Lk0BLSBTdG9yYWdlOiBpbnNlcnRzIG9uZSBpdGVtLCB2YWx1ZSBzaXplIGJvdW5kZWQgYnkgYE1heFNpZ25hdG9yaWVzYCwgd2l0aCBhIGRlcG9zaXQZASAgdGFrZW4gZm9yIGl0cyBsaWZldGltZSBvZiBgRGVwb3NpdEJhc2UgKyB0aHJlc2hvbGQgKiBEZXBvc2l0RmFjdG9yYC48Y2FuY2VsX2FzX211bHRpEAEkdGhyZXNob2xkyAEMdTE2AAFEb3RoZXJfc2lnbmF0b3JpZXMxAQFEVmVjPFQ6OkFjY291bnRJZD4AASR0aW1lcG9pbnTQAXBUaW1lcG9pbnQ8QmxvY2tOdW1iZXJGb3I8VD4+AAEkY2FsbF9oYXNoBAEgW3U4OyAzMl0AA1RVAUNhbmNlbCBhIHByZS1leGlzdGluZywgb24tZ29pbmcgbXVsdGlzaWcgdHJhbnNhY3Rpb24uIEFueSBkZXBvc2l0IHJlc2VydmVkIHByZXZpb3VzbHnEZm9yIHRoaXMgb3BlcmF0aW9uIHdpbGwgYmUgdW5yZXNlcnZlZCBvbiBzdWNjZXNzLgDMVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8uAFUBLSBgdGhyZXNob2xkYDogVGhlIHRvdGFsIG51bWJlciBvZiBhcHByb3ZhbHMgZm9yIHRoaXMgZGlzcGF0Y2ggYmVmb3JlIGl0IGlzIGV4ZWN1dGVkLkEBLSBgb3RoZXJfc2lnbmF0b3JpZXNgOiBUaGUgYWNjb3VudHMgKG90aGVyIHRoYW4gdGhlIHNlbmRlcikgd2hvIGNhbiBhcHByb3ZlIHRoaXNsZGlzcGF0Y2guIE1heSBub3QgYmUgZW1wdHkuXQEtIGB0aW1lcG9pbnRgOiBUaGUgdGltZXBvaW50IChibG9jayBudW1iZXIgYW5kIHRyYW5zYWN0aW9uIGluZGV4KSBvZiB0aGUgZmlyc3QgYXBwcm92YWx4dHJhbnNhY3Rpb24gZm9yIHRoaXMgZGlzcGF0Y2guzC0gYGNhbGxfaGFzaGA6IFRoZSBoYXNoIG9mIHRoZSBjYWxsIHRvIGJlIGV4ZWN1dGVkLgA0IyMgQ29tcGxleGl0eSQtIGBPKFMpYC7MLSBVcCB0byBvbmUgYmFsYW5jZS1yZXNlcnZlIG9yIHVucmVzZXJ2ZSBvcGVyYXRpb24uPQEtIE9uZSBwYXNzdGhyb3VnaCBvcGVyYXRpb24sIG9uZSBpbnNlcnQsIGJvdGggYE8oUylgIHdoZXJlIGBTYCBpcyB0aGUgbnVtYmVyIG9mRQEgIHNpZ25hdG9yaWVzLiBgU2AgaXMgY2FwcGVkIGJ5IGBNYXhTaWduYXRvcmllc2AsIHdpdGggd2VpZ2h0IGJlaW5nIHByb3BvcnRpb25hbC68LSBPbmUgZW5jb2RlICYgaGFzaCwgYm90aCBvZiBjb21wbGV4aXR5IGBPKFMpYC4wLSBPbmUgZXZlbnQuhC0gSS9POiAxIHJlYWQgYE8oUylgLCBvbmUgcmVtb3ZlLnAtIFN0b3JhZ2U6IHJlbW92ZXMgb25lIGl0ZW0uBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLpkCBBhPcHRpb24EBFQB0AEIEE5vbmUAAAAQU29tZQQA0AAAAQAAnQIMOHBhbGxldF91bmlxdWVzGHBhbGxldBBDYWxsCARUAARJAAFoGGNyZWF0ZQgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARRhZG1pbgABUEFjY291bnRJZExvb2t1cE9mPFQ+AABACQFJc3N1ZSBhIG5ldyBjb2xsZWN0aW9uIG9mIG5vbi1mdW5naWJsZSBpdGVtcyBmcm9tIGEgcHVibGljIG9yaWdpbi4AHQFUaGlzIG5ldyBjb2xsZWN0aW9uIGhhcyBubyBpdGVtcyBpbml0aWFsbHkgYW5kIGl0cyBvd25lciBpcyB0aGUgb3JpZ2luLgBhAVRoZSBvcmlnaW4gbXVzdCBjb25mb3JtIHRvIHRoZSBjb25maWd1cmVkIGBDcmVhdGVPcmlnaW5gIGFuZCBoYXZlIHN1ZmZpY2llbnQgZnVuZHMgZnJlZS4ArGBJdGVtRGVwb3NpdGAgZnVuZHMgb2Ygc2VuZGVyIGFyZSByZXNlcnZlZC4ALFBhcmFtZXRlcnM6YQEtIGBjb2xsZWN0aW9uYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ldyBjb2xsZWN0aW9uLiBUaGlzIG11c3Qgbm90IGJlIGN1cnJlbnRseSBpbiB1c2UuRQEtIGBhZG1pbmA6IFRoZSBhZG1pbiBvZiB0aGlzIGNvbGxlY3Rpb24uIFRoZSBhZG1pbiBpcyB0aGUgaW5pdGlhbCBhZGRyZXNzIG9mIGVhY2iYbWVtYmVyIG9mIHRoZSBjb2xsZWN0aW9uJ3MgYWRtaW4gdGVhbS4AmEVtaXRzIGBDcmVhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuADhXZWlnaHQ6IGBPKDEpYDBmb3JjZV9jcmVhdGUMAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEUb3duZXIAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABMGZyZWVfaG9sZGluZyABEGJvb2wAAUQZAUlzc3VlIGEgbmV3IGNvbGxlY3Rpb24gb2Ygbm9uLWZ1bmdpYmxlIGl0ZW1zIGZyb20gYSBwcml2aWxlZ2VkIG9yaWdpbi4ArFRoaXMgbmV3IGNvbGxlY3Rpb24gaGFzIG5vIGl0ZW1zIGluaXRpYWxseS4ApFRoZSBvcmlnaW4gbXVzdCBjb25mb3JtIHRvIGBGb3JjZU9yaWdpbmAuAJxVbmxpa2UgYGNyZWF0ZWAsIG5vIGZ1bmRzIGFyZSByZXNlcnZlZC4ASQEtIGBjb2xsZWN0aW9uYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ldyBpdGVtLiBUaGlzIG11c3Qgbm90IGJlIGN1cnJlbnRseSBpbiB1c2UuOQEtIGBvd25lcmA6IFRoZSBvd25lciBvZiB0aGlzIGNvbGxlY3Rpb24gb2YgaXRlbXMuIFRoZSBvd25lciBoYXMgZnVsbCBzdXBlcnVzZXI0ICBwZXJtaXNzaW9ucyEBb3ZlciB0aGlzIGl0ZW0sIGJ1dCBtYXkgbGF0ZXIgY2hhbmdlIGFuZCBjb25maWd1cmUgdGhlIHBlcm1pc3Npb25zIHVzaW5nkGB0cmFuc2Zlcl9vd25lcnNoaXBgIGFuZCBgc2V0X3RlYW1gLgCsRW1pdHMgYEZvcmNlQ3JlYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgA4V2VpZ2h0OiBgTygxKWAcZGVzdHJveQgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARx3aXRuZXNzoQIBOERlc3Ryb3lXaXRuZXNzAAI8nERlc3Ryb3kgYSBjb2xsZWN0aW9uIG9mIGZ1bmdpYmxlIGl0ZW1zLgBdAVRoZSBvcmlnaW4gbXVzdCBjb25mb3JtIHRvIGBGb3JjZU9yaWdpbmAgb3IgbXVzdCBiZSBgU2lnbmVkYCBhbmQgdGhlIHNlbmRlciBtdXN0IGJlIHRoZWhvd25lciBvZiB0aGUgYGNvbGxlY3Rpb25gLgAFAS0gYGNvbGxlY3Rpb25gOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgY29sbGVjdGlvbiB0byBiZSBkZXN0cm95ZWQuMQEtIGB3aXRuZXNzYDogSW5mb3JtYXRpb24gb24gdGhlIGl0ZW1zIG1pbnRlZCBpbiB0aGUgY29sbGVjdGlvbi4gVGhpcyBtdXN0IGJlIGNvcnJlY3QuAKBFbWl0cyBgRGVzdHJveWVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAGRXZWlnaHQ6IGBPKG4gKyBtKWAgd2hlcmU6VC0gYG4gPSB3aXRuZXNzLml0ZW1zYHgtIGBtID0gd2l0bmVzcy5pdGVtX21ldGFkYXRhc2BoLSBgYSA9IHdpdG5lc3MuYXR0cmlidXRlc2AQbWludAwBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEUb3duZXIAAVBBY2NvdW50SWRMb29rdXBPZjxUPgADLKBNaW50IGFuIGl0ZW0gb2YgYSBwYXJ0aWN1bGFyIGNvbGxlY3Rpb24uAEEBVGhlIG9yaWdpbiBtdXN0IGJlIFNpZ25lZCBhbmQgdGhlIHNlbmRlciBtdXN0IGJlIHRoZSBJc3N1ZXIgb2YgdGhlIGBjb2xsZWN0aW9uYC4A4C0gYGNvbGxlY3Rpb25gOiBUaGUgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSB0byBiZSBtaW50ZWQuyC0gYGl0ZW1gOiBUaGUgaXRlbSB2YWx1ZSBvZiB0aGUgaXRlbSB0byBiZSBtaW50ZWQu2C0gYGJlbmVmaWNpYXJ5YDogVGhlIGluaXRpYWwgb3duZXIgb2YgdGhlIG1pbnRlZCBpdGVtLgCURW1pdHMgYElzc3VlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgA4V2VpZ2h0OiBgTygxKWAQYnVybgwBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEsY2hlY2tfb3duZXLsAXBPcHRpb248QWNjb3VudElkTG9va3VwT2Y8VD4+AAQ8WERlc3Ryb3kgYSBzaW5nbGUgaXRlbS4A9E9yaWdpbiBtdXN0IGJlIFNpZ25lZCBhbmQgdGhlIHNpZ25pbmcgYWNjb3VudCBtdXN0IGJlIGVpdGhlcjqALSB0aGUgQWRtaW4gb2YgdGhlIGBjb2xsZWN0aW9uYDtoLSB0aGUgT3duZXIgb2YgdGhlIGBpdGVtYDsA4C0gYGNvbGxlY3Rpb25gOiBUaGUgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSB0byBiZSBidXJuZWQusC0gYGl0ZW1gOiBUaGUgaXRlbSBvZiB0aGUgaXRlbSB0byBiZSBidXJuZWQuUQEtIGBjaGVja19vd25lcmA6IElmIGBTb21lYCB0aGVuIHRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIHdpdGggYFdyb25nT3duZXJgIHVubGVzcyB0aGV4ICBpdGVtIGlzIG93bmVkIGJ5IHRoaXMgdmFsdWUuALRFbWl0cyBgQnVybmVkYCB3aXRoIHRoZSBhY3R1YWwgYW1vdW50IGJ1cm5lZC4AOFdlaWdodDogYE8oMSlgfE1vZGVzOiBgY2hlY2tfb3duZXIuaXNfc29tZSgpYC4gdHJhbnNmZXIMAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQaXRlbRgBJFQ6Okl0ZW1JZAABEGRlc3QAAVBBY2NvdW50SWRMb29rdXBPZjxUPgAFRMBNb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgc2VuZGVyIGFjY291bnQgdG8gYW5vdGhlci4AtFRoaXMgcmVzZXRzIHRoZSBhcHByb3ZlZCBhY2NvdW50IG9mIHRoZSBpdGVtLgD0T3JpZ2luIG11c3QgYmUgU2lnbmVkIGFuZCB0aGUgc2lnbmluZyBhY2NvdW50IG11c3QgYmUgZWl0aGVyOoAtIHRoZSBBZG1pbiBvZiB0aGUgYGNvbGxlY3Rpb25gO2gtIHRoZSBPd25lciBvZiB0aGUgYGl0ZW1gOzUBLSB0aGUgYXBwcm92ZWQgZGVsZWdhdGUgZm9yIHRoZSBgaXRlbWAgKGluIHRoaXMgY2FzZSwgdGhlIGFwcHJvdmFsIGlzIHJlc2V0KS4AKEFyZ3VtZW50czr0LSBgY29sbGVjdGlvbmA6IFRoZSBjb2xsZWN0aW9uIG9mIHRoZSBpdGVtIHRvIGJlIHRyYW5zZmVycmVkLsQtIGBpdGVtYDogVGhlIGl0ZW0gb2YgdGhlIGl0ZW0gdG8gYmUgdHJhbnNmZXJyZWQu3C0gYGRlc3RgOiBUaGUgYWNjb3VudCB0byByZWNlaXZlIG93bmVyc2hpcCBvZiB0aGUgaXRlbS4AUEVtaXRzIGBUcmFuc2ZlcnJlZGAuADhXZWlnaHQ6IGBPKDEpYCRyZWRlcG9zaXQIAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEUaXRlbXPcAThWZWM8VDo6SXRlbUlkPgAGRJhSZWV2YWx1YXRlIHRoZSBkZXBvc2l0cyBvbiBzb21lIGl0ZW1zLgA1AU9yaWdpbiBtdXN0IGJlIFNpZ25lZCBhbmQgdGhlIHNlbmRlciBzaG91bGQgYmUgdGhlIE93bmVyIG9mIHRoZSBgY29sbGVjdGlvbmAuALAtIGBjb2xsZWN0aW9uYDogVGhlIGNvbGxlY3Rpb24gdG8gYmUgZnJvemVuLikBLSBgaXRlbXNgOiBUaGUgaXRlbXMgb2YgdGhlIGNvbGxlY3Rpb24gd2hvc2UgZGVwb3NpdHMgd2lsbCBiZSByZWV2YWx1YXRlZC4ALQFOT1RFOiBUaGlzIGV4aXN0cyBhcyBhIGJlc3QtZWZmb3J0IGZ1bmN0aW9uLiBBbnkgaXRlbXMgd2hpY2ggYXJlIHVua25vd24gb3I5AWluIHRoZSBjYXNlIHRoYXQgdGhlIG93bmVyIGFjY291bnQgZG9lcyBub3QgaGF2ZSByZXNlcnZhYmxlIGZ1bmRzIHRvIHBheSBmb3IgYU0BZGVwb3NpdCBpbmNyZWFzZSBhcmUgaWdub3JlZC4gR2VuZXJhbGx5IHRoZSBvd25lciBpc24ndCBnb2luZyB0byBjYWxsIHRoaXMgb24gaXRlbXNVAXdob3NlIGV4aXN0aW5nIGRlcG9zaXQgaXMgbGVzcyB0aGFuIHRoZSByZWZyZXNoZWQgZGVwb3NpdCBhcyBpdCB3b3VsZCBvbmx5IGNvc3QgdGhlbSx4c28gaXQncyBvZiBsaXR0bGUgY29uc2VxdWVuY2UuAFkBSXQgd2lsbCBzdGlsbCByZXR1cm4gYW4gZXJyb3IgaW4gdGhlIGNhc2UgdGhhdCB0aGUgY29sbGVjdGlvbiBpcyB1bmtub3duIG9mIHRoZSBzaWduZXJwaXMgbm90IHBlcm1pdHRlZCB0byBjYWxsIGl0LgBgV2VpZ2h0OiBgTyhpdGVtcy5sZW4oKSlgGGZyZWV6ZQgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAcoyERpc2FsbG93IGZ1cnRoZXIgdW5wcml2aWxlZ2VkIHRyYW5zZmVyIG9mIGFuIGl0ZW0uAD0BT3JpZ2luIG11c3QgYmUgU2lnbmVkIGFuZCB0aGUgc2VuZGVyIHNob3VsZCBiZSB0aGUgRnJlZXplciBvZiB0aGUgYGNvbGxlY3Rpb25gLgDgLSBgY29sbGVjdGlvbmA6IFRoZSBjb2xsZWN0aW9uIG9mIHRoZSBpdGVtIHRvIGJlIGZyb3plbi6wLSBgaXRlbWA6IFRoZSBpdGVtIG9mIHRoZSBpdGVtIHRvIGJlIGZyb3plbi4APEVtaXRzIGBGcm96ZW5gLgA4V2VpZ2h0OiBgTygxKWAQdGhhdwgBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAgoqFJlLWFsbG93IHVucHJpdmlsZWdlZCB0cmFuc2ZlciBvZiBhbiBpdGVtLgA9AU9yaWdpbiBtdXN0IGJlIFNpZ25lZCBhbmQgdGhlIHNlbmRlciBzaG91bGQgYmUgdGhlIEZyZWV6ZXIgb2YgdGhlIGBjb2xsZWN0aW9uYC4A4C0gYGNvbGxlY3Rpb25gOiBUaGUgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSB0byBiZSB0aGF3ZWQusC0gYGl0ZW1gOiBUaGUgaXRlbSBvZiB0aGUgaXRlbSB0byBiZSB0aGF3ZWQuADxFbWl0cyBgVGhhd2VkYC4AOFdlaWdodDogYE8oMSlgRGZyZWV6ZV9jb2xsZWN0aW9uBAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAAJJPxEaXNhbGxvdyBmdXJ0aGVyIHVucHJpdmlsZWdlZCB0cmFuc2ZlcnMgZm9yIGEgd2hvbGUgY29sbGVjdGlvbi4APQFPcmlnaW4gbXVzdCBiZSBTaWduZWQgYW5kIHRoZSBzZW5kZXIgc2hvdWxkIGJlIHRoZSBGcmVlemVyIG9mIHRoZSBgY29sbGVjdGlvbmAuALAtIGBjb2xsZWN0aW9uYDogVGhlIGNvbGxlY3Rpb24gdG8gYmUgZnJvemVuLgBkRW1pdHMgYENvbGxlY3Rpb25Gcm96ZW5gLgA4V2VpZ2h0OiBgTygxKWA8dGhhd19jb2xsZWN0aW9uBAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAAKJNxSZS1hbGxvdyB1bnByaXZpbGVnZWQgdHJhbnNmZXJzIGZvciBhIHdob2xlIGNvbGxlY3Rpb24uADUBT3JpZ2luIG11c3QgYmUgU2lnbmVkIGFuZCB0aGUgc2VuZGVyIHNob3VsZCBiZSB0aGUgQWRtaW4gb2YgdGhlIGBjb2xsZWN0aW9uYC4AsC0gYGNvbGxlY3Rpb25gOiBUaGUgY29sbGVjdGlvbiB0byBiZSB0aGF3ZWQuAGRFbWl0cyBgQ29sbGVjdGlvblRoYXdlZGAuADhXZWlnaHQ6IGBPKDEpYEh0cmFuc2Zlcl9vd25lcnNoaXAIAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEkbmV3X293bmVyAAFQQWNjb3VudElkTG9va3VwT2Y8VD4ACyyEQ2hhbmdlIHRoZSBPd25lciBvZiBhIGNvbGxlY3Rpb24uADUBT3JpZ2luIG11c3QgYmUgU2lnbmVkIGFuZCB0aGUgc2VuZGVyIHNob3VsZCBiZSB0aGUgT3duZXIgb2YgdGhlIGBjb2xsZWN0aW9uYC4A9C0gYGNvbGxlY3Rpb25gOiBUaGUgY29sbGVjdGlvbiB3aG9zZSBvd25lciBzaG91bGQgYmUgY2hhbmdlZC4JAS0gYG93bmVyYDogVGhlIG5ldyBPd25lciBvZiB0aGlzIGNvbGxlY3Rpb24uIFRoZXkgbXVzdCBoYXZlIGNhbGxlZEkBICBgc2V0X2FjY2VwdF9vd25lcnNoaXBgIHdpdGggYGNvbGxlY3Rpb25gIGluIG9yZGVyIGZvciB0aGlzIG9wZXJhdGlvbiB0byBzdWNjZWVkLgBURW1pdHMgYE93bmVyQ2hhbmdlZGAuADhXZWlnaHQ6IGBPKDEpYCBzZXRfdGVhbRABKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARhpc3N1ZXIAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABFGFkbWluAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AARxmcmVlemVyAAFQQWNjb3VudElkTG9va3VwT2Y8VD4ADDDUQ2hhbmdlIHRoZSBJc3N1ZXIsIEFkbWluIGFuZCBGcmVlemVyIG9mIGEgY29sbGVjdGlvbi4ANQFPcmlnaW4gbXVzdCBiZSBTaWduZWQgYW5kIHRoZSBzZW5kZXIgc2hvdWxkIGJlIHRoZSBPd25lciBvZiB0aGUgYGNvbGxlY3Rpb25gLgDwLSBgY29sbGVjdGlvbmA6IFRoZSBjb2xsZWN0aW9uIHdob3NlIHRlYW0gc2hvdWxkIGJlIGNoYW5nZWQuuC0gYGlzc3VlcmA6IFRoZSBuZXcgSXNzdWVyIG9mIHRoaXMgY29sbGVjdGlvbi6wLSBgYWRtaW5gOiBUaGUgbmV3IEFkbWluIG9mIHRoaXMgY29sbGVjdGlvbi7ALSBgZnJlZXplcmA6IFRoZSBuZXcgRnJlZXplciBvZiB0aGlzIGNvbGxlY3Rpb24uAFBFbWl0cyBgVGVhbUNoYW5nZWRgLgA4V2VpZ2h0OiBgTygxKWBAYXBwcm92ZV90cmFuc2ZlcgwBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAARBpdGVtGAEkVDo6SXRlbUlkAAEgZGVsZWdhdGUAAVBBY2NvdW50SWRMb29rdXBPZjxUPgANOBUBQXBwcm92ZSBhbiBpdGVtIHRvIGJlIHRyYW5zZmVycmVkIGJ5IGEgZGVsZWdhdGVkIHRoaXJkLXBhcnR5IGFjY291bnQuAE0BVGhlIG9yaWdpbiBtdXN0IGNvbmZvcm0gdG8gYEZvcmNlT3JpZ2luYCBvciBtdXN0IGJlIGBTaWduZWRgIGFuZCB0aGUgc2VuZGVyIG11c3QgYmX4ZWl0aGVyIHRoZSBvd25lciBvZiB0aGUgYGl0ZW1gIG9yIHRoZSBhZG1pbiBvZiB0aGUgY29sbGVjdGlvbi4ARQEtIGBjb2xsZWN0aW9uYDogVGhlIGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0gdG8gYmUgYXBwcm92ZWQgZm9yIGRlbGVnYXRlZCB0cmFuc2Zlci4VAS0gYGl0ZW1gOiBUaGUgaXRlbSBvZiB0aGUgaXRlbSB0byBiZSBhcHByb3ZlZCBmb3IgZGVsZWdhdGVkIHRyYW5zZmVyLhkBLSBgZGVsZWdhdGVgOiBUaGUgYWNjb3VudCB0byBkZWxlZ2F0ZSBwZXJtaXNzaW9uIHRvIHRyYW5zZmVyIHRoZSBpdGVtLgAZAUltcG9ydGFudCBOT1RFOiBUaGUgYGFwcHJvdmVkYCBhY2NvdW50IGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCB0cmFuc2Zlci4AkEVtaXRzIGBBcHByb3ZlZFRyYW5zZmVyYCBvbiBzdWNjZXNzLgA4V2VpZ2h0OiBgTygxKWA8Y2FuY2VsX2FwcHJvdmFsDAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGl0ZW0YASRUOjpJdGVtSWQAAVBtYXliZV9jaGVja19kZWxlZ2F0ZewBcE9wdGlvbjxBY2NvdW50SWRMb29rdXBPZjxUPj4ADkARAUNhbmNlbCB0aGUgcHJpb3IgYXBwcm92YWwgZm9yIHRoZSB0cmFuc2ZlciBvZiBhbiBpdGVtIGJ5IGEgZGVsZWdhdGUuAFhPcmlnaW4gbXVzdCBiZSBlaXRoZXI6VC0gdGhlIGBGb3JjZWAgb3JpZ2luO/wtIGBTaWduZWRgIHdpdGggdGhlIHNpZ25lciBiZWluZyB0aGUgQWRtaW4gb2YgdGhlIGBjb2xsZWN0aW9uYDvkLSBgU2lnbmVkYCB3aXRoIHRoZSBzaWduZXIgYmVpbmcgdGhlIE93bmVyIG9mIHRoZSBgaXRlbWA7AChBcmd1bWVudHM6PQEtIGBjb2xsZWN0aW9uYDogVGhlIGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0gb2Ygd2hvc2UgYXBwcm92YWwgd2lsbCBiZSBjYW5jZWxsZWQuDQEtIGBpdGVtYDogVGhlIGl0ZW0gb2YgdGhlIGl0ZW0gb2Ygd2hvc2UgYXBwcm92YWwgd2lsbCBiZSBjYW5jZWxsZWQuUQEtIGBtYXliZV9jaGVja19kZWxlZ2F0ZWA6IElmIGBTb21lYCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBnaXZlbiBhY2NvdW50IGlzIHRoZSBvbmUgdG+wICB3aGljaCBwZXJtaXNzaW9uIG9mIHRyYW5zZmVyIGlzIGRlbGVnYXRlZC4AlEVtaXRzIGBBcHByb3ZhbENhbmNlbGxlZGAgb24gc3VjY2Vzcy4AOFdlaWdodDogYE8oMSlgRGZvcmNlX2l0ZW1fc3RhdHVzHAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABFG93bmVyAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AARhpc3N1ZXIAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABFGFkbWluAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AARxmcmVlemVyAAFQQWNjb3VudElkTG9va3VwT2Y8VD4AATBmcmVlX2hvbGRpbmcgARBib29sAAEkaXNfZnJvemVuIAEQYm9vbAAPQJRBbHRlciB0aGUgYXR0cmlidXRlcyBvZiBhIGdpdmVuIGl0ZW0uAHRPcmlnaW4gbXVzdCBiZSBgRm9yY2VPcmlnaW5gLgCsLSBgY29sbGVjdGlvbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBpdGVtLpgtIGBvd25lcmA6IFRoZSBuZXcgT3duZXIgb2YgdGhpcyBpdGVtLqAtIGBpc3N1ZXJgOiBUaGUgbmV3IElzc3VlciBvZiB0aGlzIGl0ZW0umC0gYGFkbWluYDogVGhlIG5ldyBBZG1pbiBvZiB0aGlzIGl0ZW0uqC0gYGZyZWV6ZXJgOiBUaGUgbmV3IEZyZWV6ZXIgb2YgdGhpcyBpdGVtLlEBLSBgZnJlZV9ob2xkaW5nYDogV2hldGhlciBhIGRlcG9zaXQgaXMgdGFrZW4gZm9yIGhvbGRpbmcgYW4gaXRlbSBvZiB0aGlzIGNvbGxlY3Rpb24uOQEtIGBpc19mcm96ZW5gOiBXaGV0aGVyIHRoaXMgY29sbGVjdGlvbiBpcyBmcm96ZW4gZXhjZXB0IGZvciBwZXJtaXNzaW9uZWQvYWRtaW40aW5zdHJ1Y3Rpb25zLgDgRW1pdHMgYEl0ZW1TdGF0dXNDaGFuZ2VkYCB3aXRoIHRoZSBpZGVudGl0eSBvZiB0aGUgaXRlbS4AOFdlaWdodDogYE8oMSlgNHNldF9hdHRyaWJ1dGUQAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEobWF5YmVfaXRlbeABRE9wdGlvbjxUOjpJdGVtSWQ+AAEMa2V55AFsQm91bmRlZFZlYzx1OCwgVDo6S2V5TGltaXQ+AAEUdmFsdWXoAXRCb3VuZGVkVmVjPHU4LCBUOjpWYWx1ZUxpbWl0PgAQRKhTZXQgYW4gYXR0cmlidXRlIGZvciBhIGNvbGxlY3Rpb24gb3IgaXRlbS4AXQFPcmlnaW4gbXVzdCBiZSBlaXRoZXIgYEZvcmNlT3JpZ2luYCBvciBTaWduZWQgYW5kIHRoZSBzZW5kZXIgc2hvdWxkIGJlIHRoZSBPd25lciBvZiB0aGU0YGNvbGxlY3Rpb25gLgBRAUlmIHRoZSBvcmlnaW4gaXMgU2lnbmVkLCB0aGVuIGZ1bmRzIG9mIHNpZ25lciBhcmUgcmVzZXJ2ZWQgYWNjb3JkaW5nIHRvIHRoZSBmb3JtdWxhOikBYE1ldGFkYXRhRGVwb3NpdEJhc2UgKyBEZXBvc2l0UGVyQnl0ZSAqIChrZXkubGVuICsgdmFsdWUubGVuKWAgdGFraW5nIGludG+MYWNjb3VudCBhbnkgYWxyZWFkeSByZXNlcnZlZCBmdW5kcy4AOQEtIGBjb2xsZWN0aW9uYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3Rpb24gd2hvc2UgaXRlbSdzIG1ldGFkYXRhIHRvIHNldC4FAS0gYG1heWJlX2l0ZW1gOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgaXRlbSB3aG9zZSBtZXRhZGF0YSB0byBzZXQuiC0gYGtleWA6IFRoZSBrZXkgb2YgdGhlIGF0dHJpYnV0ZS7MLSBgdmFsdWVgOiBUaGUgdmFsdWUgdG8gd2hpY2ggdG8gc2V0IHRoZSBhdHRyaWJ1dGUuAFRFbWl0cyBgQXR0cmlidXRlU2V0YC4AOFdlaWdodDogYE8oMSlgPGNsZWFyX2F0dHJpYnV0ZQwBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAAShtYXliZV9pdGVt4AFET3B0aW9uPFQ6Okl0ZW1JZD4AAQxrZXnkAWxCb3VuZGVkVmVjPHU4LCBUOjpLZXlMaW1pdD4AETiwQ2xlYXIgYW4gYXR0cmlidXRlIGZvciBhIGNvbGxlY3Rpb24gb3IgaXRlbS4AXQFPcmlnaW4gbXVzdCBiZSBlaXRoZXIgYEZvcmNlT3JpZ2luYCBvciBTaWduZWQgYW5kIHRoZSBzZW5kZXIgc2hvdWxkIGJlIHRoZSBPd25lciBvZiB0aGU0YGNvbGxlY3Rpb25gLgDAQW55IGRlcG9zaXQgaXMgZnJlZWQgZm9yIHRoZSBjb2xsZWN0aW9uJ3Mgb3duZXIuAEEBLSBgY29sbGVjdGlvbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aW9uIHdob3NlIGl0ZW0ncyBtZXRhZGF0YSB0byBjbGVhci4NAS0gYG1heWJlX2l0ZW1gOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgaXRlbSB3aG9zZSBtZXRhZGF0YSB0byBjbGVhci6ILSBga2V5YDogVGhlIGtleSBvZiB0aGUgYXR0cmlidXRlLgBkRW1pdHMgYEF0dHJpYnV0ZUNsZWFyZWRgLgA4V2VpZ2h0OiBgTygxKWAwc2V0X21ldGFkYXRhEAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGl0ZW0YASRUOjpJdGVtSWQAARBkYXRh2AF4Qm91bmRlZFZlYzx1OCwgVDo6U3RyaW5nTGltaXQ+AAEkaXNfZnJvemVuIAEQYm9vbAASRHRTZXQgdGhlIG1ldGFkYXRhIGZvciBhbiBpdGVtLgBdAU9yaWdpbiBtdXN0IGJlIGVpdGhlciBgRm9yY2VPcmlnaW5gIG9yIFNpZ25lZCBhbmQgdGhlIHNlbmRlciBzaG91bGQgYmUgdGhlIE93bmVyIG9mIHRoZTRgY29sbGVjdGlvbmAuAFEBSWYgdGhlIG9yaWdpbiBpcyBTaWduZWQsIHRoZW4gZnVuZHMgb2Ygc2lnbmVyIGFyZSByZXNlcnZlZCBhY2NvcmRpbmcgdG8gdGhlIGZvcm11bGE69GBNZXRhZGF0YURlcG9zaXRCYXNlICsgRGVwb3NpdFBlckJ5dGUgKiBkYXRhLmxlbmAgdGFraW5nIGludG+MYWNjb3VudCBhbnkgYWxyZWFkeSByZXNlcnZlZCBmdW5kcy4AOQEtIGBjb2xsZWN0aW9uYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3Rpb24gd2hvc2UgaXRlbSdzIG1ldGFkYXRhIHRvIHNldC7sLSBgaXRlbWA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBpdGVtIHdob3NlIG1ldGFkYXRhIHRvIHNldC5NAS0gYGRhdGFgOiBUaGUgZ2VuZXJhbCBpbmZvcm1hdGlvbiBvZiB0aGlzIGl0ZW0uIExpbWl0ZWQgaW4gbGVuZ3RoIGJ5IGBTdHJpbmdMaW1pdGAuNQEtIGBpc19mcm96ZW5gOiBXaGV0aGVyIHRoZSBtZXRhZGF0YSBzaG91bGQgYmUgZnJvemVuIGFnYWluc3QgZnVydGhlciBjaGFuZ2VzLgBQRW1pdHMgYE1ldGFkYXRhU2V0YC4AOFdlaWdodDogYE8oMSlgOGNsZWFyX21ldGFkYXRhCAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGl0ZW0YASRUOjpJdGVtSWQAEzR8Q2xlYXIgdGhlIG1ldGFkYXRhIGZvciBhbiBpdGVtLgBdAU9yaWdpbiBtdXN0IGJlIGVpdGhlciBgRm9yY2VPcmlnaW5gIG9yIFNpZ25lZCBhbmQgdGhlIHNlbmRlciBzaG91bGQgYmUgdGhlIE93bmVyIG9mIHRoZRxgaXRlbWAuAMBBbnkgZGVwb3NpdCBpcyBmcmVlZCBmb3IgdGhlIGNvbGxlY3Rpb24ncyBvd25lci4AQQEtIGBjb2xsZWN0aW9uYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3Rpb24gd2hvc2UgaXRlbSdzIG1ldGFkYXRhIHRvIGNsZWFyLvQtIGBpdGVtYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGl0ZW0gd2hvc2UgbWV0YWRhdGEgdG8gY2xlYXIuAGBFbWl0cyBgTWV0YWRhdGFDbGVhcmVkYC4AOFdlaWdodDogYE8oMSlgXHNldF9jb2xsZWN0aW9uX21ldGFkYXRhDAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGRhdGHYAXhCb3VuZGVkVmVjPHU4LCBUOjpTdHJpbmdMaW1pdD4AASRpc19mcm96ZW4gARBib29sABRAiFNldCB0aGUgbWV0YWRhdGEgZm9yIGEgY29sbGVjdGlvbi4AVQFPcmlnaW4gbXVzdCBiZSBlaXRoZXIgYEZvcmNlT3JpZ2luYCBvciBgU2lnbmVkYCBhbmQgdGhlIHNlbmRlciBzaG91bGQgYmUgdGhlIE93bmVyIG9mRHRoZSBgY29sbGVjdGlvbmAuAFkBSWYgdGhlIG9yaWdpbiBpcyBgU2lnbmVkYCwgdGhlbiBmdW5kcyBvZiBzaWduZXIgYXJlIHJlc2VydmVkIGFjY29yZGluZyB0byB0aGUgZm9ybXVsYTr0YE1ldGFkYXRhRGVwb3NpdEJhc2UgKyBEZXBvc2l0UGVyQnl0ZSAqIGRhdGEubGVuYCB0YWtpbmcgaW50b4xhY2NvdW50IGFueSBhbHJlYWR5IHJlc2VydmVkIGZ1bmRzLgARAS0gYGNvbGxlY3Rpb25gOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgaXRlbSB3aG9zZSBtZXRhZGF0YSB0byB1cGRhdGUuTQEtIGBkYXRhYDogVGhlIGdlbmVyYWwgaW5mb3JtYXRpb24gb2YgdGhpcyBpdGVtLiBMaW1pdGVkIGluIGxlbmd0aCBieSBgU3RyaW5nTGltaXRgLjUBLSBgaXNfZnJvemVuYDogV2hldGhlciB0aGUgbWV0YWRhdGEgc2hvdWxkIGJlIGZyb3plbiBhZ2FpbnN0IGZ1cnRoZXIgY2hhbmdlcy4AeEVtaXRzIGBDb2xsZWN0aW9uTWV0YWRhdGFTZXRgLgA4V2VpZ2h0OiBgTygxKWBkY2xlYXJfY29sbGVjdGlvbl9tZXRhZGF0YQQBKGNvbGxlY3Rpb24YATxUOjpDb2xsZWN0aW9uSWQAFTCQQ2xlYXIgdGhlIG1ldGFkYXRhIGZvciBhIGNvbGxlY3Rpb24uAFUBT3JpZ2luIG11c3QgYmUgZWl0aGVyIGBGb3JjZU9yaWdpbmAgb3IgYFNpZ25lZGAgYW5kIHRoZSBzZW5kZXIgc2hvdWxkIGJlIHRoZSBPd25lciBvZkR0aGUgYGNvbGxlY3Rpb25gLgDAQW55IGRlcG9zaXQgaXMgZnJlZWQgZm9yIHRoZSBjb2xsZWN0aW9uJ3Mgb3duZXIuACUBLSBgY29sbGVjdGlvbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aW9uIHdob3NlIG1ldGFkYXRhIHRvIGNsZWFyLgCIRW1pdHMgYENvbGxlY3Rpb25NZXRhZGF0YUNsZWFyZWRgLgA4V2VpZ2h0OiBgTygxKWBQc2V0X2FjY2VwdF9vd25lcnNoaXAEAUBtYXliZV9jb2xsZWN0aW9u4AFcT3B0aW9uPFQ6OkNvbGxlY3Rpb25JZD4AFigRAVNldCAob3IgcmVzZXQpIHRoZSBhY2NlcHRhbmNlIG9mIG93bmVyc2hpcCBmb3IgYSBwYXJ0aWN1bGFyIGFjY291bnQuAGEBT3JpZ2luIG11c3QgYmUgYFNpZ25lZGAgYW5kIGlmIGBtYXliZV9jb2xsZWN0aW9uYCBpcyBgU29tZWAsIHRoZW4gdGhlIHNpZ25lciBtdXN0IGhhdmUgYUxwcm92aWRlciByZWZlcmVuY2UuAFEBLSBgbWF5YmVfY29sbGVjdGlvbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aW9uIHdob3NlIG93bmVyc2hpcCB0aGUgc2lnbmVyIGlzYQEgIHdpbGxpbmcgdG8gYWNjZXB0LCBvciBpZiBgTm9uZWAsIGFuIGluZGljYXRpb24gdGhhdCB0aGUgc2lnbmVyIGlzIHdpbGxpbmcgdG8gYWNjZXB0IG5vXCAgb3duZXJzaGlwIHRyYW5zZmVyYWwuAIxFbWl0cyBgT3duZXJzaGlwQWNjZXB0YW5jZUNoYW5nZWRgLmRzZXRfY29sbGVjdGlvbl9tYXhfc3VwcGx5CAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABKG1heF9zdXBwbHkQAQx1MzIAFyzgU2V0IHRoZSBtYXhpbXVtIGFtb3VudCBvZiBpdGVtcyBhIGNvbGxlY3Rpb24gY291bGQgaGF2ZS4AVQFPcmlnaW4gbXVzdCBiZSBlaXRoZXIgYEZvcmNlT3JpZ2luYCBvciBgU2lnbmVkYCBhbmQgdGhlIHNlbmRlciBzaG91bGQgYmUgdGhlIE93bmVyIG9mRHRoZSBgY29sbGVjdGlvbmAuAOROb3RlOiBUaGlzIGZ1bmN0aW9uIGNhbiBvbmx5IHN1Y2NlZWQgb25jZSBwZXIgY29sbGVjdGlvbi4A7C0gYGNvbGxlY3Rpb25gOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgY29sbGVjdGlvbiB0byBjaGFuZ2UuEQEtIGBtYXhfc3VwcGx5YDogVGhlIG1heGltdW0gYW1vdW50IG9mIGl0ZW1zIGEgY29sbGVjdGlvbiBjb3VsZCBoYXZlLgDURW1pdHMgYENvbGxlY3Rpb25NYXhTdXBwbHlTZXRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4kc2V0X3ByaWNlEAEoY29sbGVjdGlvbhgBPFQ6OkNvbGxlY3Rpb25JZAABEGl0ZW0YASRUOjpJdGVtSWQAARRwcmljZeABXE9wdGlvbjxJdGVtUHJpY2U8VCwgST4+AAFEd2hpdGVsaXN0ZWRfYnV5ZXLsAXBPcHRpb248QWNjb3VudElkTG9va3VwT2Y8VD4+ABgslFNldCAob3IgcmVzZXQpIHRoZSBwcmljZSBmb3IgYW4gaXRlbS4AAQFPcmlnaW4gbXVzdCBiZSBTaWduZWQgYW5kIG11c3QgYmUgdGhlIG93bmVyIG9mIHRoZSBhc3NldCBgaXRlbWAuAKwtIGBjb2xsZWN0aW9uYDogVGhlIGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0uoC0gYGl0ZW1gOiBUaGUgaXRlbSB0byBzZXQgdGhlIHByaWNlIGZvci4NAS0gYHByaWNlYDogVGhlIHByaWNlIGZvciB0aGUgaXRlbS4gUGFzcyBgTm9uZWAsIHRvIHJlc2V0IHRoZSBwcmljZS70LSBgYnV5ZXJgOiBSZXN0cmljdHMgdGhlIGJ1eSBvcGVyYXRpb24gdG8gYSBzcGVjaWZpYyBhY2NvdW50LgDsRW1pdHMgYEl0ZW1QcmljZVNldGAgb24gc3VjY2VzcyBpZiB0aGUgcHJpY2UgaXMgbm90IGBOb25lYC7sRW1pdHMgYEl0ZW1QcmljZVJlbW92ZWRgIG9uIHN1Y2Nlc3MgaWYgdGhlIHByaWNlIGlzIGBOb25lYC4gYnV5X2l0ZW0MAShjb2xsZWN0aW9uGAE8VDo6Q29sbGVjdGlvbklkAAEQaXRlbRgBJFQ6Okl0ZW1JZAABJGJpZF9wcmljZRgBPEl0ZW1QcmljZTxULCBJPgAZJKhBbGxvd3MgdG8gYnV5IGFuIGl0ZW0gaWYgaXQncyB1cCBmb3Igc2FsZS4A+E9yaWdpbiBtdXN0IGJlIFNpZ25lZCBhbmQgbXVzdCBub3QgYmUgdGhlIG93bmVyIG9mIHRoZSBgaXRlbWAuAKwtIGBjb2xsZWN0aW9uYDogVGhlIGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0urC0gYGl0ZW1gOiBUaGUgaXRlbSB0aGUgc2VuZGVyIHdhbnRzIHRvIGJ1eS7YLSBgYmlkX3ByaWNlYDogVGhlIHByaWNlIHRoZSBzZW5kZXIgaXMgd2lsbGluZyB0byBwYXkuAHhFbWl0cyBgSXRlbUJvdWdodGAgb24gc3VjY2Vzcy4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuoQIMOHBhbGxldF91bmlxdWVzFHR5cGVzOERlc3Ryb3lXaXRuZXNzAAAMARRpdGVtc1UBAQx1MzIAAThpdGVtX21ldGFkYXRhc1UBAQx1MzIAAShhdHRyaWJ1dGVzVQEBDHUzMgAApQIMbHBhbGxldF9zdGF0ZV90cmllX21pZ3JhdGlvbhhwYWxsZXQQQ2FsbAQEVAABGFhjb250cm9sX2F1dG9fbWlncmF0aW9uBAEwbWF5YmVfY29uZmlnqQIBXE9wdGlvbjxNaWdyYXRpb25MaW1pdHM+AAAMgENvbnRyb2wgdGhlIGF1dG9tYXRpYyBtaWdyYXRpb24uAA0BVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBbYENvbmZpZzo6Q29udHJvbE9yaWdpbmBdLkBjb250aW51ZV9taWdyYXRlDAEYbGltaXRzrQIBPE1pZ3JhdGlvbkxpbWl0cwABPHJlYWxfc2l6ZV91cHBlchABDHUzMgABMHdpdG5lc3NfdGFza7ECAUBNaWdyYXRpb25UYXNrPFQ+AAFUuENvbnRpbnVlIHRoZSBtaWdyYXRpb24gZm9yIHRoZSBnaXZlbiBgbGltaXRzYC4A7FRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIGNhbiBiZSBhbnkgc2lnbmVkIGFjY291bnQuAF0BVGhpcyB0cmFuc2FjdGlvbiBoYXMgTk8gTU9ORVRBUlkgSU5DRU5USVZFUy4gY2FsbGluZyBpdCB3aWxsIG5vdCByZXdhcmQgYW55b25lLiBBbGJlaXQs7FVwb24gc3VjY2Vzc2Z1bCBleGVjdXRpb24sIHRoZSB0cmFuc2FjdGlvbiBmZWUgaXMgcmV0dXJuZWQuAEEBVGhlIChwb3RlbnRpYWxseSBvdmVyLWVzdGltYXRlZCkgb2YgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFsbCB0aGUgZGF0YSByZWFkIG11c3QgYmVZAXByb3ZpZGVkIGZvciB1cC1mcm9udCBmZWUtcGF5bWVudCBhbmQgd2VpZ2hpbmcuIEluIGVzc2VuY2UsIHRoZSBjYWxsZXIgaXMgZ3VhcmFudGVlaW5nSQF0aGF0IGV4ZWN1dGluZyB0aGUgY3VycmVudCBgTWlncmF0aW9uVGFza2Agd2l0aCB0aGUgZ2l2ZW4gYGxpbWl0c2Agd2lsbCBub3QgZXhjZWVklGByZWFsX3NpemVfdXBwZXJgIGJ5dGVzIG9mIHJlYWQgZGF0YS4ARQFUaGUgYHdpdG5lc3NfdGFza2AgaXMgbWVyZWx5IGEgaGVscGVyIHRvIHByZXZlbnQgdGhlIGNhbGxlciBmcm9tIGJlaW5nIHNsYXNoZWQgb3JdAWdlbmVyYWxseSB0cmlnZ2VyIGEgbWlncmF0aW9uIHRoYXQgdGhleSBkbyBub3QgaW50ZW5kLiBUaGlzIHBhcmFtZXRlciBpcyBqdXN0IGEgbWVzc2FnZT0BZnJvbSBjYWxsZXIsIHNheWluZyB0aGF0IHRoZXkgYmVsaWV2ZWQgYHdpdG5lc3NfdGFza2Agd2FzIHRoZSBsYXN0IHN0YXRlIG9mIHRoZVkBbWlncmF0aW9uLCBhbmQgdGhleSBvbmx5IHdpc2ggZm9yIHRoZWlyIHRyYW5zYWN0aW9uIHRvIGRvIGFueXRoaW5nLCBpZiB0aGlzIGFzc3VtcHRpb24RAWhvbGRzLiBJbiBjYXNlIGB3aXRuZXNzX3Rhc2tgIGRvZXMgbm90IG1hdGNoLCB0aGUgdHJhbnNhY3Rpb24gZmFpbHMuADkBQmFzZWQgb24gdGhlIGRvY3VtZW50YXRpb24gb2YgW2BNaWdyYXRpb25UYXNrOjptaWdyYXRlX3VudGlsX2V4aGF1c3Rpb25gXSwgdGhlTQFyZWNvbW1lbmRlZCB3YXkgb2YgZG9pbmcgdGhpcyBpcyB0byBwYXNzIGEgYGxpbWl0YCB0aGF0IG9ubHkgYm91bmRzIGBjb3VudGAsIGFzIHRoZZxgc2l6ZWAgbGltaXQgY2FuIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5IbWlncmF0ZV9jdXN0b21fdG9wCAEQa2V5cyEBATBWZWM8VmVjPHU4Pj4AATB3aXRuZXNzX3NpemUQAQx1MzIAAhAJAU1pZ3JhdGUgdGhlIGxpc3Qgb2YgdG9wIGtleXMgYnkgaXRlcmF0aW5nIGVhY2ggb2YgdGhlbSBvbmUgYnkgb25lLgBVAVRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSBnbG9iYWwgbWlncmF0aW9uIHByb2Nlc3MgdHJhY2tlciAoW2BNaWdyYXRpb25Qcm9jZXNzYF0pLCBhbmT8c2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBjYXNlIGFueSBrZXlzIGFyZSBsZWZ0b3ZlciBkdWUgdG8gYSBidWcuUG1pZ3JhdGVfY3VzdG9tX2NoaWxkDAEQcm9vdDgBHFZlYzx1OD4AAShjaGlsZF9rZXlzIQEBMFZlYzxWZWM8dTg+PgABKHRvdGFsX3NpemUQAQx1MzIAAxgRAU1pZ3JhdGUgdGhlIGxpc3Qgb2YgY2hpbGQga2V5cyBieSBpdGVyYXRpbmcgZWFjaCBvZiB0aGVtIG9uZSBieSBvbmUuAA0BQWxsIG9mIHRoZSBnaXZlbiBjaGlsZCBrZXlzIG11c3QgYmUgcHJlc2VudCB1bmRlciBvbmUgYGNoaWxkX3Jvb3RgLgBVAVRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSBnbG9iYWwgbWlncmF0aW9uIHByb2Nlc3MgdHJhY2tlciAoW2BNaWdyYXRpb25Qcm9jZXNzYF0pLCBhbmT8c2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBjYXNlIGFueSBrZXlzIGFyZSBsZWZ0b3ZlciBkdWUgdG8gYSBidWcuVHNldF9zaWduZWRfbWF4X2xpbWl0cwQBGGxpbWl0c60CATxNaWdyYXRpb25MaW1pdHMABAS4U2V0IHRoZSBtYXhpbXVtIGxpbWl0IG9mIHRoZSBzaWduZWQgbWlncmF0aW9uLkhmb3JjZV9zZXRfcHJvZ3Jlc3MIATBwcm9ncmVzc190b3C1AgE0UHJvZ3Jlc3NPZjxUPgABOHByb2dyZXNzX2NoaWxktQIBNFByb2dyZXNzT2Y8VD4ABSTIRm9yY2VmdWxseSBzZXQgdGhlIHByb2dyZXNzIHRoZSBydW5uaW5nIG1pZ3JhdGlvbi4AXQFUaGlzIGlzIG9ubHkgdXNlZnVsIGluIG9uZSBjYXNlOiB0aGUgbmV4dCBrZXkgdG8gbWlncmF0ZSBpcyB0b28gYmlnIHRvIGJlIG1pZ3JhdGVkIHdpdGhVAWEgc2lnbmVkIGFjY291bnQsIGluIGEgcGFyYWNoYWluIGNvbnRleHQsIGFuZCB3ZSBzaW1wbHkgd2FudCB0byBza2lwIGl0LiBBIHJlYXNvbmFibGVhAWV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBgOmNvZGU6YCwgd2hpY2ggaXMgYm90aCB2ZXJ5IGV4cGVuc2l2ZSB0byBtaWdyYXRlLCBhbmQgY29tbW9ubHmkdXNlZCwgc28gcHJvYmFibHkgaXQgaXMgYWxyZWFkeSBtaWdyYXRlZC4AXQFJbiBjYXNlIHlvdSBtZXNzIHRoaW5ncyB1cCwgeW91IGNhbiBhbHNvLCBpbiBwcmluY2lwbGUsIHVzZSB0aGlzIHRvIHJlc2V0IHRoZSBtaWdyYXRpb24gcHJvY2Vzcy4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuqQIEGE9wdGlvbgQEVAGtAgEIEE5vbmUAAAAQU29tZQQArQIAAAEAAK0CDGxwYWxsZXRfc3RhdGVfdHJpZV9taWdyYXRpb24YcGFsbGV0PE1pZ3JhdGlvbkxpbWl0cwAACAEQc2l6ZRABDHUzMgABEGl0ZW0QAQx1MzIAALECDGxwYWxsZXRfc3RhdGVfdHJpZV9taWdyYXRpb24YcGFsbGV0NE1pZ3JhdGlvblRhc2sEBFQAABQBMHByb2dyZXNzX3RvcLUCATRQcm9ncmVzc09mPFQ+AAE4cHJvZ3Jlc3NfY2hpbGS1AgE0UHJvZ3Jlc3NPZjxUPgABEHNpemUQAQx1MzIAASR0b3BfaXRlbXMQAQx1MzIAASxjaGlsZF9pdGVtcxABDHUzMgAAtQIMbHBhbGxldF9zdGF0ZV90cmllX21pZ3JhdGlvbhhwYWxsZXQgUHJvZ3Jlc3MEJE1heEtleUxlbgABDBxUb1N0YXJ0AAAAHExhc3RLZXkEALkCAWRCb3VuZGVkVmVjPHU4LCBNYXhLZXlMZW4+AAEAIENvbXBsZXRlAAIAALkCDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAAvQIMYHBhbGxldF9jb252aWN0aW9uX3ZvdGluZxhwYWxsZXQQQ2FsbAgEVAAESQABHBB2b3RlCAEocG9sbF9pbmRleFUBAURQb2xsSW5kZXhPZjxULCBJPgABEHZvdGUBAQFwQWNjb3VudFZvdGU8QmFsYW5jZU9mPFQsIEk+PgAAJBkBVm90ZSBpbiBhIHBvbGwuIElmIGB2b3RlLmlzX2F5ZSgpYCwgdGhlIHZvdGUgaXMgdG8gZW5hY3QgdGhlIHByb3Bvc2FsO7hvdGhlcndpc2UgaXQgaXMgYSB2b3RlIHRvIGtlZXAgdGhlIHN0YXR1cyBxdW8uAMhUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgDILSBgcG9sbF9pbmRleGA6IFRoZSBpbmRleCBvZiB0aGUgcG9sbCB0byB2b3RlIGZvci6ELSBgdm90ZWA6IFRoZSB2b3RlIGNvbmZpZ3VyYXRpb24uABUBV2VpZ2h0OiBgTyhSKWAgd2hlcmUgUiBpcyB0aGUgbnVtYmVyIG9mIHBvbGxzIHRoZSB2b3RlciBoYXMgdm90ZWQgb24uIGRlbGVnYXRlEAEUY2xhc3PIATRDbGFzc09mPFQsIEk+AAEIdG8AAVBBY2NvdW50SWRMb29rdXBPZjxUPgABKGNvbnZpY3Rpb27BAgEoQ29udmljdGlvbgABHGJhbGFuY2UYATxCYWxhbmNlT2Y8VCwgST4AAVxNAURlbGVnYXRlIHRoZSB2b3RpbmcgcG93ZXIgKHdpdGggc29tZSBnaXZlbiBjb252aWN0aW9uKSBvZiB0aGUgc2VuZGluZyBhY2NvdW50IGZvciBhaHBhcnRpY3VsYXIgY2xhc3Mgb2YgcG9sbHMuAFUBVGhlIGJhbGFuY2UgZGVsZWdhdGVkIGlzIGxvY2tlZCBmb3IgYXMgbG9uZyBhcyBpdCdzIGRlbGVnYXRlZCwgYW5kIHRoZXJlYWZ0ZXIgZm9yIHRoZch0aW1lIGFwcHJvcHJpYXRlIGZvciB0aGUgY29udmljdGlvbidzIGxvY2sgcGVyaW9kLgBdAVRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8sIGFuZCB0aGUgc2lnbmluZyBhY2NvdW50IG11c3QgZWl0aGVyOnQgIC0gYmUgZGVsZWdhdGluZyBhbHJlYWR5OyBvckUBICAtIGhhdmUgbm8gdm90aW5nIGFjdGl2aXR5IChpZiB0aGVyZSBpcywgdGhlbiBpdCB3aWxsIG5lZWQgdG8gYmUgcmVtb3ZlZCB0aHJvdWdoTCAgICBgcmVtb3ZlX3ZvdGVgKS4ARQEtIGB0b2A6IFRoZSBhY2NvdW50IHdob3NlIHZvdGluZyB0aGUgYHRhcmdldGAgYWNjb3VudCdzIHZvdGluZyBwb3dlciB3aWxsIGZvbGxvdy5dAS0gYGNsYXNzYDogVGhlIGNsYXNzIG9mIHBvbGxzIHRvIGRlbGVnYXRlLiBUbyBkZWxlZ2F0ZSBtdWx0aXBsZSBjbGFzc2VzLCBtdWx0aXBsZSBjYWxsc4AgIHRvIHRoaXMgZnVuY3Rpb24gYXJlIHJlcXVpcmVkLlUBLSBgY29udmljdGlvbmA6IFRoZSBjb252aWN0aW9uIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgZGVsZWdhdGVkIHZvdGVzLiBXaGVuIHRoZUEBICBhY2NvdW50IGlzIHVuZGVsZWdhdGVkLCB0aGUgZnVuZHMgd2lsbCBiZSBsb2NrZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIHBlcmlvZC5hAS0gYGJhbGFuY2VgOiBUaGUgYW1vdW50IG9mIHRoZSBhY2NvdW50J3MgYmFsYW5jZSB0byBiZSB1c2VkIGluIGRlbGVnYXRpbmcuIFRoaXMgbXVzdCBub3S0ICBiZSBtb3JlIHRoYW4gdGhlIGFjY291bnQncyBjdXJyZW50IGJhbGFuY2UuAEhFbWl0cyBgRGVsZWdhdGVkYC4AJQFXZWlnaHQ6IGBPKFIpYCB3aGVyZSBSIGlzIHRoZSBudW1iZXIgb2YgcG9sbHMgdGhlIHZvdGVyIGRlbGVnYXRpbmcgdG8gaGFzTQEgIHZvdGVkIG9uLiBXZWlnaHQgaXMgaW5pdGlhbGx5IGNoYXJnZWQgYXMgaWYgbWF4aW11bSB2b3RlcywgYnV0IGlzIHJlZnVuZGVkIGxhdGVyLih1bmRlbGVnYXRlBAEUY2xhc3PIATRDbGFzc09mPFQsIEk+AAI4TQFVbmRlbGVnYXRlIHRoZSB2b3RpbmcgcG93ZXIgb2YgdGhlIHNlbmRpbmcgYWNjb3VudCBmb3IgYSBwYXJ0aWN1bGFyIGNsYXNzIG9mIHBvbGxzLgBdAVRva2VucyBtYXkgYmUgdW5sb2NrZWQgZm9sbG93aW5nIG9uY2UgYW4gYW1vdW50IG9mIHRpbWUgY29uc2lzdGVudCB3aXRoIHRoZSBsb2NrIHBlcmlvZAkBb2YgdGhlIGNvbnZpY3Rpb24gd2l0aCB3aGljaCB0aGUgZGVsZWdhdGlvbiB3YXMgaXNzdWVkIGhhcyBwYXNzZWQuAEUBVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXyBhbmQgdGhlIHNpZ25pbmcgYWNjb3VudCBtdXN0IGJlVGN1cnJlbnRseSBkZWxlZ2F0aW5nLgDwLSBgY2xhc3NgOiBUaGUgY2xhc3Mgb2YgcG9sbHMgdG8gcmVtb3ZlIHRoZSBkZWxlZ2F0aW9uIGZyb20uAFBFbWl0cyBgVW5kZWxlZ2F0ZWRgLgAlAVdlaWdodDogYE8oUilgIHdoZXJlIFIgaXMgdGhlIG51bWJlciBvZiBwb2xscyB0aGUgdm90ZXIgZGVsZWdhdGluZyB0byBoYXNNASAgdm90ZWQgb24uIFdlaWdodCBpcyBpbml0aWFsbHkgY2hhcmdlZCBhcyBpZiBtYXhpbXVtIHZvdGVzLCBidXQgaXMgcmVmdW5kZWQgbGF0ZXIuGHVubG9jawgBFGNsYXNzyAE0Q2xhc3NPZjxULCBJPgABGHRhcmdldAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAMkXQFSZW1vdmUgdGhlIGxvY2sgY2F1c2VkIGJ5IHByaW9yIHZvdGluZy9kZWxlZ2F0aW5nIHdoaWNoIGhhcyBleHBpcmVkIHdpdGhpbiBhIHBhcnRpY3VsYXIYY2xhc3MuAMhUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgCgLSBgY2xhc3NgOiBUaGUgY2xhc3Mgb2YgcG9sbHMgdG8gdW5sb2NrLrgtIGB0YXJnZXRgOiBUaGUgYWNjb3VudCB0byByZW1vdmUgdGhlIGxvY2sgb24uALxXZWlnaHQ6IGBPKFIpYCB3aXRoIFIgbnVtYmVyIG9mIHZvdGUgb2YgdGFyZ2V0LixyZW1vdmVfdm90ZQgBFGNsYXNzxQIBVE9wdGlvbjxDbGFzc09mPFQsIEk+PgABFGluZGV4EAFEUG9sbEluZGV4T2Y8VCwgST4ABHRkUmVtb3ZlIGEgdm90ZSBmb3IgYSBwb2xsLgAMSWY6cC0gdGhlIHBvbGwgd2FzIGNhbmNlbGxlZCwgb3JkLSB0aGUgcG9sbCBpcyBvbmdvaW5nLCBvcngtIHRoZSBwb2xsIGhhcyBlbmRlZCBzdWNoIHRoYXT8ICAtIHRoZSB2b3RlIG9mIHRoZSBhY2NvdW50IHdhcyBpbiBvcHBvc2l0aW9uIHRvIHRoZSByZXN1bHQ7IG9y1CAgLSB0aGVyZSB3YXMgbm8gY29udmljdGlvbiB0byB0aGUgYWNjb3VudCdzIHZvdGU7IG9yhCAgLSB0aGUgYWNjb3VudCBtYWRlIGEgc3BsaXQgdm90ZV0BLi4udGhlbiB0aGUgdm90ZSBpcyByZW1vdmVkIGNsZWFubHkgYW5kIGEgZm9sbG93aW5nIGNhbGwgdG8gYHVubG9ja2AgbWF5IHJlc3VsdCBpbiBtb3JlWGZ1bmRzIGJlaW5nIGF2YWlsYWJsZS4AkElmLCBob3dldmVyLCB0aGUgcG9sbCBoYXMgZW5kZWQgYW5kOuwtIGl0IGZpbmlzaGVkIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZvdGUgb2YgdGhlIGFjY291bnQsIGFuZNwtIHRoZSBhY2NvdW50IG1hZGUgYSBzdGFuZGFyZCB2b3RlIHdpdGggY29udmljdGlvbiwgYW5kvC0gdGhlIGxvY2sgcGVyaW9kIG9mIHRoZSBjb252aWN0aW9uIGlzIG5vdCBvdmVyWQEuLi50aGVuIHRoZSBsb2NrIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIHRoZSBvdmVyYWxsIGFjY291bnQncyBsb2NrLCB3aGljaCBtYXkgaW52b2x2ZVkBKm92ZXJsb2NraW5nKiAod2hlcmUgdGhlIHR3byBsb2NrcyBhcmUgY29tYmluZWQgaW50byBhIHNpbmdsZSBsb2NrIHRoYXQgaXMgdGhlIG1heGltdW3kb2YgYm90aCB0aGUgYW1vdW50IGxvY2tlZCBhbmQgdGhlIHRpbWUgaXMgaXQgbG9ja2VkIGZvcikuAEkBVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGNhbGwgbXVzdCBiZSBfU2lnbmVkXywgYW5kIHRoZSBzaWduZXIgbXVzdCBoYXZlIGEgdm90ZXByZWdpc3RlcmVkIGZvciBwb2xsIGBpbmRleGAuANwtIGBpbmRleGA6IFRoZSBpbmRleCBvZiBwb2xsIG9mIHRoZSB2b3RlIHRvIGJlIHJlbW92ZWQuVQEtIGBjbGFzc2A6IE9wdGlvbmFsIHBhcmFtZXRlciwgaWYgZ2l2ZW4gaXQgaW5kaWNhdGVzIHRoZSBjbGFzcyBvZiB0aGUgcG9sbC4gRm9yIHBvbGxz8CAgd2hpY2ggaGF2ZSBmaW5pc2hlZCBvciBhcmUgY2FuY2VsbGVkLCB0aGlzIG11c3QgYmUgYFNvbWVgLgBFAVdlaWdodDogYE8oUiArIGxvZyBSKWAgd2hlcmUgUiBpcyB0aGUgbnVtYmVyIG9mIHBvbGxzIHRoYXQgYHRhcmdldGAgaGFzIHZvdGVkIG9uLtggIFdlaWdodCBpcyBjYWxjdWxhdGVkIGZvciB0aGUgbWF4aW11bSBudW1iZXIgb2Ygdm90ZS5EcmVtb3ZlX290aGVyX3ZvdGUMARh0YXJnZXQAAVBBY2NvdW50SWRMb29rdXBPZjxUPgABFGNsYXNzyAE0Q2xhc3NPZjxULCBJPgABFGluZGV4EAFEUG9sbEluZGV4T2Y8VCwgST4ABUBkUmVtb3ZlIGEgdm90ZSBmb3IgYSBwb2xsLgBNAUlmIHRoZSBgdGFyZ2V0YCBpcyBlcXVhbCB0byB0aGUgc2lnbmVyLCB0aGVuIHRoaXMgZnVuY3Rpb24gaXMgZXhhY3RseSBlcXVpdmFsZW50IHRvLQFgcmVtb3ZlX3ZvdGVgLiBJZiBub3QgZXF1YWwgdG8gdGhlIHNpZ25lciwgdGhlbiB0aGUgdm90ZSBtdXN0IGhhdmUgZXhwaXJlZCwlAWVpdGhlciBiZWNhdXNlIHRoZSBwb2xsIHdhcyBjYW5jZWxsZWQsIGJlY2F1c2UgdGhlIHZvdGVyIGxvc3QgdGhlIHBvbGwgb3KYYmVjYXVzZSB0aGUgY29udmljdGlvbiBwZXJpb2QgaXMgb3Zlci4AyFRoZSBkaXNwYXRjaCBvcmlnaW4gb2YgdGhpcyBjYWxsIG11c3QgYmUgX1NpZ25lZF8uAGEBLSBgdGFyZ2V0YDogVGhlIGFjY291bnQgb2YgdGhlIHZvdGUgdG8gYmUgcmVtb3ZlZDsgdGhpcyBhY2NvdW50IG11c3QgaGF2ZSB2b3RlZCBmb3IgcG9sbCggIGBpbmRleGAu3C0gYGluZGV4YDogVGhlIGluZGV4IG9mIHBvbGwgb2YgdGhlIHZvdGUgdG8gYmUgcmVtb3ZlZC6ELSBgY2xhc3NgOiBUaGUgY2xhc3Mgb2YgdGhlIHBvbGwuAEUBV2VpZ2h0OiBgTyhSICsgbG9nIFIpYCB3aGVyZSBSIGlzIHRoZSBudW1iZXIgb2YgcG9sbHMgdGhhdCBgdGFyZ2V0YCBoYXMgdm90ZWQgb24u2CAgV2VpZ2h0IGlzIGNhbGN1bGF0ZWQgZm9yIHRoZSBtYXhpbXVtIG51bWJlciBvZiB2b3RlLkRmb3JjZV9yZW1vdmVfdm90ZQwBGHRhcmdldAABUEFjY291bnRJZExvb2t1cE9mPFQ+AAEUY2xhc3PIATRDbGFzc09mPFQsIEk+AAEUaW5kZXgQAURQb2xsSW5kZXhPZjxULCBJPgATOLhBbGxvdyB0byBmb3JjZSByZW1vdmUgYSB2b3RlIGZvciBhIHJlZmVyZW5kdW0uAPRUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIGBWb3RlUmVtb3ZhbE9yaWdpbmAuAKxPbmx5IGFsbG93ZWQgaWYgdGhlIHJlZmVyZW5kdW0gaXMgZmluaXNoZWQuAMhUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIF9TaWduZWRfLgBNAS0gYHRhcmdldGA6IFRoZSBhY2NvdW50IG9mIHRoZSB2b3RlIHRvIGJlIHJlbW92ZWQ7IHRoaXMgYWNjb3VudCBtdXN0IGhhdmUgdm90ZWQgZm9yVCAgcmVmZXJlbmR1bSBgaW5kZXhgLvQtIGBpbmRleGA6IFRoZSBpbmRleCBvZiByZWZlcmVuZHVtIG9mIHRoZSB2b3RlIHRvIGJlIHJlbW92ZWQuAFUBV2VpZ2h0OiBgTyhSICsgbG9nIFIpYCB3aGVyZSBSIGlzIHRoZSBudW1iZXIgb2YgcmVmZXJlbmRhIHRoYXQgYHRhcmdldGAgaGFzIHZvdGVkIG9uLtggIFdlaWdodCBpcyBjYWxjdWxhdGVkIGZvciB0aGUgbWF4aW11bSBudW1iZXIgb2Ygdm90ZS4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuwQIMYHBhbGxldF9jb252aWN0aW9uX3ZvdGluZyhjb252aWN0aW9uKENvbnZpY3Rpb24AARwQTm9uZQAAACBMb2NrZWQxeAABACBMb2NrZWQyeAACACBMb2NrZWQzeAADACBMb2NrZWQ0eAAEACBMb2NrZWQ1eAAFACBMb2NrZWQ2eAAGAADFAgQYT3B0aW9uBARUAcgBCBBOb25lAAAAEFNvbWUEAMgAAAEAAMkCDEBwYWxsZXRfcmVmZXJlbmRhGHBhbGxldBBDYWxsCARUAARJAAEkGHN1Ym1pdAwBPHByb3Bvc2FsX29yaWdpbmUBAVxCb3g8UGFsbGV0c09yaWdpbk9mPFQ+PgABIHByb3Bvc2FsDQEBTEJvdW5kZWRDYWxsT2Y8VCwgST4AAUBlbmFjdG1lbnRfbW9tZW50zQIBfERpc3BhdGNoVGltZTxCbG9ja051bWJlckZvcjxUPj4AACSwUHJvcG9zZSBhIHJlZmVyZW5kdW0gb24gYSBwcml2aWxlZ2VkIGFjdGlvbi4AWQEtIGBvcmlnaW5gOiBtdXN0IGJlIGBTdWJtaXRPcmlnaW5gIGFuZCB0aGUgYWNjb3VudCBtdXN0IGhhdmUgYFN1Ym1pc3Npb25EZXBvc2l0YCBmdW5kczAgIGF2YWlsYWJsZS4tAS0gYHByb3Bvc2FsX29yaWdpbmA6IFRoZSBvcmlnaW4gZnJvbSB3aGljaCB0aGUgcHJvcG9zYWwgc2hvdWxkIGJlIGV4ZWN1dGVkLmwtIGBwcm9wb3NhbGA6IFRoZSBwcm9wb3NhbC4VAS0gYGVuYWN0bWVudF9tb21lbnRgOiBUaGUgbW9tZW50IHRoYXQgdGhlIHByb3Bvc2FsIHNob3VsZCBiZSBlbmFjdGVkLgBIRW1pdHMgYFN1Ym1pdHRlZGAuWHBsYWNlX2RlY2lzaW9uX2RlcG9zaXQEARRpbmRleBABPFJlZmVyZW5kdW1JbmRleAABIKxQb3N0IHRoZSBEZWNpc2lvbiBEZXBvc2l0IGZvciBhIHJlZmVyZW5kdW0uADkBLSBgb3JpZ2luYDogbXVzdCBiZSBgU2lnbmVkYCBhbmQgdGhlIGFjY291bnQgbXVzdCBoYXZlIGZ1bmRzIGF2YWlsYWJsZSBmb3IgdGhloCAgcmVmZXJlbmR1bSdzIHRyYWNrJ3MgRGVjaXNpb24gRGVwb3NpdC5RAS0gYGluZGV4YDogVGhlIGluZGV4IG9mIHRoZSBzdWJtaXR0ZWQgcmVmZXJlbmR1bSB3aG9zZSBEZWNpc2lvbiBEZXBvc2l0IGlzIHlldCB0byBiZSQgIHBvc3RlZC4AeEVtaXRzIGBEZWNpc2lvbkRlcG9zaXRQbGFjZWRgLlxyZWZ1bmRfZGVjaXNpb25fZGVwb3NpdAQBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4AAIcKQFSZWZ1bmQgdGhlIERlY2lzaW9uIERlcG9zaXQgZm9yIGEgY2xvc2VkIHJlZmVyZW5kdW0gYmFjayB0byB0aGUgZGVwb3NpdG9yLgCcLSBgb3JpZ2luYDogbXVzdCBiZSBgU2lnbmVkYCBvciBgUm9vdGAuTQEtIGBpbmRleGA6IFRoZSBpbmRleCBvZiBhIGNsb3NlZCByZWZlcmVuZHVtIHdob3NlIERlY2lzaW9uIERlcG9zaXQgaGFzIG5vdCB5ZXQgYmVlbiwgIHJlZnVuZGVkLgCARW1pdHMgYERlY2lzaW9uRGVwb3NpdFJlZnVuZGVkYC4YY2FuY2VsBAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgAAxh0Q2FuY2VsIGFuIG9uZ29pbmcgcmVmZXJlbmR1bS4AnC0gYG9yaWdpbmA6IG11c3QgYmUgdGhlIGBDYW5jZWxPcmlnaW5gLtwtIGBpbmRleGA6IFRoZSBpbmRleCBvZiB0aGUgcmVmZXJlbmR1bSB0byBiZSBjYW5jZWxsZWQuAEhFbWl0cyBgQ2FuY2VsbGVkYC4Qa2lsbAQBFGluZGV4EAE8UmVmZXJlbmR1bUluZGV4AAQY0ENhbmNlbCBhbiBvbmdvaW5nIHJlZmVyZW5kdW0gYW5kIHNsYXNoIHRoZSBkZXBvc2l0cy4AlC0gYG9yaWdpbmA6IG11c3QgYmUgdGhlIGBLaWxsT3JpZ2luYC7cLSBgaW5kZXhgOiBUaGUgaW5kZXggb2YgdGhlIHJlZmVyZW5kdW0gdG8gYmUgY2FuY2VsbGVkLgCQRW1pdHMgYEtpbGxlZGAgYW5kIGBEZXBvc2l0U2xhc2hlZGAuQG51ZGdlX3JlZmVyZW5kdW0EARRpbmRleBABPFJlZmVyZW5kdW1JbmRleAAFEB0BQWR2YW5jZSBhIHJlZmVyZW5kdW0gb250byBpdHMgbmV4dCBsb2dpY2FsIHN0YXRlLiBPbmx5IHVzZWQgaW50ZXJuYWxseS4AbC0gYG9yaWdpbmA6IG11c3QgYmUgYFJvb3RgLqQtIGBpbmRleGA6IHRoZSByZWZlcmVuZHVtIHRvIGJlIGFkdmFuY2VkLkhvbmVfZmV3ZXJfZGVjaWRpbmcEARR0cmFja8gBPFRyYWNrSWRPZjxULCBJPgAGJAkBQWR2YW5jZSBhIHRyYWNrIG9udG8gaXRzIG5leHQgbG9naWNhbCBzdGF0ZS4gT25seSB1c2VkIGludGVybmFsbHkuAGwtIGBvcmlnaW5gOiBtdXN0IGJlIGBSb290YC6QLSBgdHJhY2tgOiB0aGUgdHJhY2sgdG8gYmUgYWR2YW5jZWQuAFEBQWN0aW9uIGl0ZW0gZm9yIHdoZW4gdGhlcmUgaXMgbm93IG9uZSBmZXdlciByZWZlcmVuZHVtIGluIHRoZSBkZWNpZGluZyBwaGFzZSBhbmQgdGhlFQFgRGVjaWRpbmdDb3VudGAgaXMgbm90IHlldCB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGVpdGhlcjolAS0gYmVnaW4gZGVjaWRpbmcgYW5vdGhlciByZWZlcmVuZHVtIChhbmQgbGVhdmUgYERlY2lkaW5nQ291bnRgIGFsb25lKTsgb3JwLSBkZWNyZW1lbnQgYERlY2lkaW5nQ291bnRgLmRyZWZ1bmRfc3VibWlzc2lvbl9kZXBvc2l0BAEUaW5kZXgQATxSZWZlcmVuZHVtSW5kZXgABxwxAVJlZnVuZCB0aGUgU3VibWlzc2lvbiBEZXBvc2l0IGZvciBhIGNsb3NlZCByZWZlcmVuZHVtIGJhY2sgdG8gdGhlIGRlcG9zaXRvci4AnC0gYG9yaWdpbmA6IG11c3QgYmUgYFNpZ25lZGAgb3IgYFJvb3RgLlUBLSBgaW5kZXhgOiBUaGUgaW5kZXggb2YgYSBjbG9zZWQgcmVmZXJlbmR1bSB3aG9zZSBTdWJtaXNzaW9uIERlcG9zaXQgaGFzIG5vdCB5ZXQgYmVlbiwgIHJlZnVuZGVkLgCIRW1pdHMgYFN1Ym1pc3Npb25EZXBvc2l0UmVmdW5kZWRgLjBzZXRfbWV0YWRhdGEIARRpbmRleBABPFJlZmVyZW5kdW1JbmRleAABKG1heWJlX2hhc2iFAgE8T3B0aW9uPFQ6Okhhc2g+AAgcmFNldCBvciBjbGVhciBtZXRhZGF0YSBvZiBhIHJlZmVyZW5kdW0uACxQYXJhbWV0ZXJzOkUBLSBgb3JpZ2luYDogTXVzdCBiZSBgU2lnbmVkYCBieSBhIGNyZWF0b3Igb2YgYSByZWZlcmVuZHVtIG9yIGJ5IGFueW9uZSB0byBjbGVhciBhkCAgbWV0YWRhdGEgb2YgYSBmaW5pc2hlZCByZWZlcmVuZHVtLg0BLSBgaW5kZXhgOiAgVGhlIGluZGV4IG9mIGEgcmVmZXJlbmR1bSB0byBzZXQgb3IgY2xlYXIgbWV0YWRhdGEgZm9yLlEBLSBgbWF5YmVfaGFzaGA6IFRoZSBoYXNoIG9mIGFuIG9uLWNoYWluIHN0b3JlZCBwcmVpbWFnZS4gYE5vbmVgIHRvIGNsZWFyIGEgbWV0YWRhdGEuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLs0CEDRmcmFtZV9zdXBwb3J0GHRyYWl0cyBzY2hlZHVsZTBEaXNwYXRjaFRpbWUELEJsb2NrTnVtYmVyARABCAhBdAQAEAEsQmxvY2tOdW1iZXIAAAAUQWZ0ZXIEABABLEJsb2NrTnVtYmVyAAEAANECDEBwYWxsZXRfd2hpdGVsaXN0GHBhbGxldBBDYWxsBARUAAEQOHdoaXRlbGlzdF9jYWxsBAEkY2FsbF9oYXNoNAEcVDo6SGFzaAAAAFxyZW1vdmVfd2hpdGVsaXN0ZWRfY2FsbAQBJGNhbGxfaGFzaDQBHFQ6Okhhc2gAAQBkZGlzcGF0Y2hfd2hpdGVsaXN0ZWRfY2FsbAwBJGNhbGxfaGFzaDQBHFQ6Okhhc2gAAUBjYWxsX2VuY29kZWRfbGVuEAEMdTMyAAFMY2FsbF93ZWlnaHRfd2l0bmVzcygBGFdlaWdodAACAJxkaXNwYXRjaF93aGl0ZWxpc3RlZF9jYWxsX3dpdGhfcHJlaW1hZ2UEARBjYWxsEQEBfEJveDw8VCBhcyBDb25maWc+OjpSdW50aW1lQ2FsbD4AAwAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMu1QIMRHBhbGxldF9kaXNwYXRjaGVyGHBhbGxldBBDYWxsBARUAAEUUGRpc3BhdGNoX2FzX3RyZWFzdXJ5BAEQY2FsbBEBAXxCb3g8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAAAYGRpc3BhdGNoX2FzX2FhdmVfbWFuYWdlcgQBEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgABAERub3RlX2FhdmVfbWFuYWdlcgQBHGFjY291bnQAATBUOjpBY2NvdW50SWQAAhglAVNldHMgdGhlIEFhdmUgbWFuYWdlciBhY2NvdW50IHRvIGJlIHVzZWQgYXMgb3JpZ2luIGZvciBkaXNwYXRjaGluZyBjYWxscy4AyFRoaXMgZG9lc24ndCBhY3R1YWxseSBjaGFuZ2VzIGFueSBBQ0wgaW4gdGhlIHBvb2wuAFUBVGhpcyBpcyBpbnRlbnRlZCB0byBiZSBtYWlubHkgdXNlZCBpbiB0ZXN0bmV0IGVudmlyb25tZW50cywgd2hlcmUgdGhlIG1hbmFnZXIgYWNjb3VudERjYW4gYmUgZGlmZmVyZW50LlxkaXNwYXRjaF93aXRoX2V4dHJhX2dhcwgBEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgABJGV4dHJhX2dhczABDHU2NAADEHxEaXNwYXRjaCBhIGNhbGwgd2l0aCBleHRyYSBnYXMuAPxUaGlzIGFsbG93cyBleGVjdXRpbmcgY2FsbHMgd2l0aCBhZGRpdGlvbmFsIHdlaWdodCAoZ2FzKSBsaW1pdC7AVGhlIGV4dHJhIGdhcyBpcyBub3QgcmVmdW5kZWQsIGV2ZW4gaWYgbm90IHVzZWQuRGRpc3BhdGNoX2V2bV9jYWxsBAEQY2FsbBEBAXxCb3g8PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+AAQkaEV4ZWN1dGUgYSBzaW5nbGUgRVZNIGNhbGwu9QFUaGlzIGV4dHJpbnNpYyB3aWxsIGZhaWwgaWYgdGhlIEVWTSBjYWxsIHJldHVybnMgYW55IG90aGVyIEV4aXRSZWFzb24gdGhhbiBgRXhpdFN1Y2NlZWQoUmV0dXJuZWQpYCBvciBgRXhpdFN1Y2NlZWQoU3RvcHBlZClgLj0BTG9vayB0aGUgW2h5ZHJhZHhfcnVudGltZTo6ZXZtOjpydW5uZXI6OldyYXBSdW5uZXJdIGltcGxlbWVudGF0aW9uIGZvciBkZXRhaWxzLgAsUGFyYW1ldGVyczpoLSBgb3JpZ2luYDogU2lnbmVkIG9yaWdpbi4VAS0gYGNhbGxgOiBwcmVzdW1hYmx5IGBwYWxsZXRfZXZtOjpDYWxsOjpjYWxsYCBhcyBib3hlZCBgUnVudGltZUNhbGxgLgCgRW1pdHMgYEV2bUNhbGxGYWlsZWRgIGV2ZW50IHdoZW4gZmFpbGVkLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy7ZAgxUcGFsbGV0X2Fzc2V0X3JlZ2lzdHJ5GHBhbGxldBBDYWxsBARUAAEUIHJlZ2lzdGVyJAEgYXNzZXRfaWRZAQFIT3B0aW9uPFQ6OkFzc2V0SWQ+AAEQbmFtZd0CAXBPcHRpb248TmFtZTxUOjpTdHJpbmdMaW1pdD4+AAEoYXNzZXRfdHlwZeUCASRBc3NldFR5cGUAAUxleGlzdGVudGlhbF9kZXBvc2l04AE8T3B0aW9uPEJhbGFuY2U+AAEYc3ltYm9s3QIBeE9wdGlvbjxTeW1ib2w8VDo6U3RyaW5nTGltaXQ+PgABIGRlY2ltYWxz6QIBKE9wdGlvbjx1OD4AASBsb2NhdGlvbu0CAXhPcHRpb248VDo6QXNzZXROYXRpdmVMb2NhdGlvbj4AATh4Y21fcmF0ZV9saW1pdOABPE9wdGlvbjxCYWxhbmNlPgABNGlzX3N1ZmZpY2llbnQgARBib29sAAAwVFJlZ2lzdGVyIGEgbmV3IGFzc2V0LgDYTmV3IGFzc2V0IGlzIGdpdmVuIGBOZXh0QXNzZXRJZGAgLSBzZXF1ZW50aWFsIGFzc2V0IGlkADkBQXNzZXQncyBpZCBpcyBvcHRpb25hbCBhbmQgaXQgY2FuJ3QgYmUgdXNlZCBieSBhbm90aGVyIGFzc2V0IGlmIGl0J3MgcHJvdmlkZWQu3FByb3ZpZGVkIGBhc3NldF9pZGAgbXVzdCBiZSBmcm9tIHdpdGhpbiByZXNlcnZlZCByYW5nZS4JAUlmIGBhc3NldF9pZGAgaXMgYE5vbmVgLCBuZXcgYXNzZXQgaXMgZ2l2ZW4gaWQgZm9yIHNlcXVlbnRpYWwgaWRzLgBBAUFzc2V0J3MgbmFtZSBpcyBvcHRpb25hbCBhbmQgaXQgY2FuJ3QgYmUgdXNlZCBieSBhbm90aGVyIGFzc2V0IGlmIGl0J3MgcHJvdmlkZWQuWQJBZGRzIG1hcHBpbmcgYmV0d2VlbiBgbmFtZWAgYW5kIGFzc2lnbmVkIGBhc3NldF9pZGAgc28gYXNzZXQgaWQgY2FuIGJlIHJldHJpZXZlZCBieSBuYW1lIHRvbyAoTm90ZTogdGhpcyBhcHByb2FjaCBpcyB1c2VkIGluIEFNTSBpbXBsZW1lbnRhdGlvbiAoeHlrKSkApEVtaXRzICdSZWdpc3RlcmVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuGHVwZGF0ZSQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABEG5hbWXdAgFwT3B0aW9uPE5hbWU8VDo6U3RyaW5nTGltaXQ+PgABKGFzc2V0X3R5cGUJAwFET3B0aW9uPEFzc2V0VHlwZT4AAUxleGlzdGVudGlhbF9kZXBvc2l04AE8T3B0aW9uPEJhbGFuY2U+AAE4eGNtX3JhdGVfbGltaXTgATxPcHRpb248QmFsYW5jZT4AATRpc19zdWZmaWNpZW50DQMBME9wdGlvbjxib29sPgABGHN5bWJvbN0CAXhPcHRpb248U3ltYm9sPFQ6OlN0cmluZ0xpbWl0Pj4AASBkZWNpbWFsc+kCAShPcHRpb248dTg+AAEgbG9jYXRpb27tAgF4T3B0aW9uPFQ6OkFzc2V0TmF0aXZlTG9jYXRpb24+AAEoYFVwZGF0ZSByZWdpc3RlcmVkIGFzc2V0LgAlAUFsbCBwYXJhbWV0ZXJlcyBhcmUgb3B0aW9uYWwgYW5kIHZhbHVlIGlzIG5vdCB1cGRhdGVkIGlmIHBhcmFtIGlzIGBOb25lYC4AMQFgZGVjaW1hbHNgIC0gY2FuIGJlIHVwZGF0ZSBieSBgVXBkYXRlT3JpZ2luYCBvbmx5IGlmIGl0IHdhc24ndCBzZXQgeWV0LiBPbmx5AQFgUmVnaXN0cnlPcmlnaW5gIGNhbiB1cGRhdGUgYGRlY2ltYWxzYCBpZiBpdCB3YXMgcHJldmlvdXNseSBzZXQuANRgbG9jYXRpb25gIC0gY2FuIGJlIHVwZGF0ZWQgb25seSBieSBgUmVnaXN0cnlPcmlnaW5gLgCYRW1pdHMgYFVwZGF0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC5EcmVnaXN0ZXJfZXh0ZXJuYWwEASBsb2NhdGlvbvECAVhUOjpBc3NldE5hdGl2ZUxvY2F0aW9uAAQAJGJhbl9hc3NldAQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAFACx1bmJhbl9hc3NldAQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAGAAQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy7dAgQYT3B0aW9uBARUAeECAQgQTm9uZQAAABBTb21lBADhAgAAAQAA4QIMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AADlAgxUcGFsbGV0X2Fzc2V0X3JlZ2lzdHJ5FHR5cGVzJEFzc2V0VHlwZQABGBRUb2tlbgAAAAxYWUsAAQAoU3RhYmxlU3dhcAACABBCb25kAAMAIEV4dGVybmFsAAQAFEVyYzIwAAUAAOkCBBhPcHRpb24EBFQBCAEIEE5vbmUAAAAQU29tZQQACAAAAQAA7QIEGE9wdGlvbgQEVAHxAgEIEE5vbmUAAAAQU29tZQQA8QIAAAEAAPECDDxoeWRyYWR4X3J1bnRpbWUMeGNtNEFzc2V0TG9jYXRpb24AAAQA9QIBaHBvbGthZG90X3hjbTo6djM6OkxvY2F0aW9uAAD1AhAsc3RhZ2luZ194Y20IdjM0bXVsdGlsb2NhdGlvbjRNdWx0aUxvY2F0aW9uAAAIARxwYXJlbnRzCAEIdTgAASBpbnRlcmlvcvkCASRKdW5jdGlvbnMAAPkCEAx4Y20IdjMkanVuY3Rpb25zJEp1bmN0aW9ucwABJBBIZXJlAAAACFgxBAD9AgEgSnVuY3Rpb24AAQAIWDIIAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAIACFgzDAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAMACFg0EAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24ABAAIWDUUAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAUACFg2GAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAYACFg3HAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24ABwAIWDggAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAD9AgEgSnVuY3Rpb24AAP0CASBKdW5jdGlvbgAA/QIBIEp1bmN0aW9uAAgAAP0CEAx4Y20IdjMganVuY3Rpb24gSnVuY3Rpb24AASgkUGFyYWNoYWluBABVAQEMdTMyAAAALEFjY291bnRJZDMyCAEcbmV0d29yawEDAURPcHRpb248TmV0d29ya0lkPgABCGlkBAEgW3U4OyAzMl0AAQA4QWNjb3VudEluZGV4NjQIARxuZXR3b3JrAQMBRE9wdGlvbjxOZXR3b3JrSWQ+AAEUaW5kZXgsAQx1NjQAAgAwQWNjb3VudEtleTIwCAEcbmV0d29yawEDAURPcHRpb248TmV0d29ya0lkPgABDGtleUUBASBbdTg7IDIwXQADADhQYWxsZXRJbnN0YW5jZQQACAEIdTgABAAwR2VuZXJhbEluZGV4BAAtAQEQdTEyOAAFAChHZW5lcmFsS2V5CAEYbGVuZ3RoCAEIdTgAARBkYXRhBAEgW3U4OyAzMl0ABgAkT25seUNoaWxkAAcAJFBsdXJhbGl0eQgBCGlklQEBGEJvZHlJZAABEHBhcnSZAQEgQm9keVBhcnQACAA8R2xvYmFsQ29uc2Vuc3VzBAAFAwEkTmV0d29ya0lkAAkAAAEDBBhPcHRpb24EBFQBBQMBCBBOb25lAAAAEFNvbWUEAAUDAAABAAAFAxAMeGNtCHYzIGp1bmN0aW9uJE5ldHdvcmtJZAABLCRCeUdlbmVzaXMEAAQBIFt1ODsgMzJdAAAAGEJ5Rm9yawgBMGJsb2NrX251bWJlcjABDHU2NAABKGJsb2NrX2hhc2gEASBbdTg7IDMyXQABACBQb2xrYWRvdAACABhLdXNhbWEAAwAcV2VzdGVuZAAEABhSb2NvY28ABQAYV29jb2NvAAYAIEV0aGVyZXVtBAEgY2hhaW5faWQsAQx1NjQABwAsQml0Y29pbkNvcmUACAAsQml0Y29pbkNhc2gACQBAUG9sa2Fkb3RCdWxsZXRpbgAKAAAJAwQYT3B0aW9uBARUAeUCAQgQTm9uZQAAABBTb21lBADlAgAAAQAADQMEGE9wdGlvbgQEVAEgAQgQTm9uZQAAABBTb21lBAAgAAABAAARAww0cGFsbGV0X2NsYWltcxhwYWxsZXQQQ2FsbAQEVAABBBRjbGFpbQQBSGV0aGVyZXVtX3NpZ25hdHVyZRUDAThFY2RzYVNpZ25hdHVyZQAABPRDbGFpbSB4SERYIGJ5IHByb3ZpZGluZyBzaWduZWQgbWVzc2FnZSB3aXRoIEV0aGVyZXVtIGFkZHJlc3MuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLhUDDDRwYWxsZXRfY2xhaW1zGHRyYWl0czhFY2RzYVNpZ25hdHVyZQAABAB5AgEgW3U4OyA2NV0AABkDDFhwYWxsZXRfZ2VuZXNpc19oaXN0b3J5GHBhbGxldBBDYWxsBARUAAEABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLh0DDDxwYWxsZXRfb21uaXBvb2wYcGFsbGV0EENhbGwEBFQAATQkYWRkX3Rva2VuEAEUYXNzZXQQAShUOjpBc3NldElkAAE0aW5pdGlhbF9wcmljZT0BARRQcmljZQABKHdlaWdodF9jYXAhAwEcUGVybWlsbAABOHBvc2l0aW9uX293bmVyAAEwVDo6QWNjb3VudElkAAFAHQFBZGQgbmV3IHRva2VuIHRvIG9tbmlwb29sIGluIHF1YW50aXR5IGBhbW91bnRgIGF0IHByaWNlIGBpbml0aWFsX3ByaWNlYADFAUluaXRpYWwgbGlxdWlkaXR5IG11c3QgYmUgdHJhbnNmZXJyZWQgdG8gcG9vbCdzIGFjY291bnQgZm9yIHRoaXMgbmV3IHRva2VuIG1hbnVhbGx5IHByaW9yIHRvIGNhbGxpbmcgYGFkZF90b2tlbmAuAORJbml0aWFsIGxpcXVpZGl0eSBpcyBwb29sJ3MgYWNjb3VudCBiYWxhbmNlIG9mIHRoZSB0b2tlbi4AyFBvc2l0aW9uIE5GVCB0b2tlbiBpcyBtaW50ZWQgZm9yIGBwb3NpdGlvbl9vd25lcmAuACxQYXJhbWV0ZXJzOokBLSBgYXNzZXRgOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgbmV3IGFzc2V0IGFkZGVkIHRvIHRoZSBwb29sLiBNdXN0IGJlIHJlZ2lzdGVyZWQgaW4gQXNzZXQgcmVnaXN0cnmALSBgaW5pdGlhbF9wcmljZWA6IEluaXRpYWwgcHJpY2U1AS0gYHBvc2l0aW9uX293bmVyYDogYWNjb3VudCBpZCBmb3Igd2hpY2ggc2hhcmUgYXJlIGRpc3RyaWJ1dGVkIGluIGZvcm0gb24gTkZUgC0gYHdlaWdodF9jYXBgOiBhc3NldCB3ZWlnaHQgY2FwAKRFbWl0cyBgVG9rZW5BZGRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgA0YWRkX2xpcXVpZGl0eQgBFGFzc2V0EAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAAlD8QWRkIGxpcXVpZGl0eSBvZiBhc3NldCBgYXNzZXRgIGluIHF1YW50aXR5IGBhbW91bnRgIHRvIE9tbmlwb29sAGEBYGFkZF9saXF1aWRpdHlgIGFkZHMgc3BlY2lmaWVkIGFzc2V0IGFtb3VudCB0byBPbW5pcG9vbCBhbmQgaW4gZXhjaGFuZ2UgZ2l2ZXMgdGhlIG9yaWdpbvBjb3JyZXNwb25kaW5nIHNoYXJlcyBhbW91bnQgaW4gZm9ybSBvZiBORlQgYXQgY3VycmVudCBwcmljZS4AhQFBc3NldCdzIHRyYWRhYmxlIHN0YXRlIG11c3QgY29udGFpbiBBRERfTElRVUlESVRZIGZsYWcsIG90aGVyd2lzZSBgTm90QWxsb3dlZGAgZXJyb3IgaXMgcmV0dXJuZWQuAGEBTkZUIGlzIG1pbnRlZCB1c2luZyBOVEZIYW5kbGVyIHdoaWNoIGltcGxlbWVudHMgbm9uLWZ1bmdpYmxlcyB0cmFpdHMgZnJvbSBmcmFtZV9zdXBwb3J0LgBZAUFzc2V0IHdlaWdodCBjYXAgbXVzdCBiZSByZXNwZWN0ZWQsIG90aGVyd2lzZSBgQXNzZXRXZWlnaHRFeGNlZWRlZGAgZXJyb3IgaXMgcmV0dXJuZWQueQFBc3NldCB3ZWlnaHQgaXMgcmF0aW8gYmV0d2VlbiBuZXcgSHViQXNzZXQgcmVzZXJ2ZSBhbmQgdG90YWwgcmVzZXJ2ZSBvZiBIdWIgYXNzZXQgaW4gT21uaXBvb2wuANUBQWRkIGxpcXVpZGl0eSBmYWlscyBpZiBwcmljZSBkaWZmZXJlbmNlIGJldHdlZW4gc3BvdCBwcmljZSBhbmQgb3JhY2xlIHByaWNlIGlzIGhpZ2hlciB0aGFuIGFsbG93ZWQgYnkgYFByaWNlQmFycmllcmAuACxQYXJhbWV0ZXJzOmUBLSBgYXNzZXRgOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgbmV3IGFzc2V0IGFkZGVkIHRvIHRoZSBwb29sLiBNdXN0IGJlIGFscmVhZHkgaW4gdGhlIHBvb2y0LSBgYW1vdW50YDogQW1vdW50IG9mIGFzc2V0IGFkZGVkIHRvIG9tbmlwb29sALRFbWl0cyBgTGlxdWlkaXR5QWRkZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AYGFkZF9saXF1aWRpdHlfd2l0aF9saW1pdAwBFGFzc2V0EAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAAUBtaW5fc2hhcmVzX2xpbWl0GAEcQmFsYW5jZQANXAEBQWRkIGxpcXVpZGl0eSBvZiBhc3NldCBgYXNzZXRgIGluIHF1YW50aXR5IGBhbW91bnRgIHRvIE9tbmlwb29sLgBwTGltaXQgcHJvdGVjdGlvbiBpcyBhcHBsaWVkLgBhAWBhZGRfbGlxdWlkaXR5YCBhZGRzIHNwZWNpZmllZCBhc3NldCBhbW91bnQgdG8gT21uaXBvb2wgYW5kIGluIGV4Y2hhbmdlIGdpdmVzIHRoZSBvcmlnaW7wY29ycmVzcG9uZGluZyBzaGFyZXMgYW1vdW50IGluIGZvcm0gb2YgTkZUIGF0IGN1cnJlbnQgcHJpY2UuAIUBQXNzZXQncyB0cmFkYWJsZSBzdGF0ZSBtdXN0IGNvbnRhaW4gQUREX0xJUVVJRElUWSBmbGFnLCBvdGhlcndpc2UgYE5vdEFsbG93ZWRgIGVycm9yIGlzIHJldHVybmVkLgBhAU5GVCBpcyBtaW50ZWQgdXNpbmcgTlRGSGFuZGxlciB3aGljaCBpbXBsZW1lbnRzIG5vbi1mdW5naWJsZXMgdHJhaXRzIGZyb20gZnJhbWVfc3VwcG9ydC4AWQFBc3NldCB3ZWlnaHQgY2FwIG11c3QgYmUgcmVzcGVjdGVkLCBvdGhlcndpc2UgYEFzc2V0V2VpZ2h0RXhjZWVkZWRgIGVycm9yIGlzIHJldHVybmVkLnkBQXNzZXQgd2VpZ2h0IGlzIHJhdGlvIGJldHdlZW4gbmV3IEh1YkFzc2V0IHJlc2VydmUgYW5kIHRvdGFsIHJlc2VydmUgb2YgSHViIGFzc2V0IGluIE9tbmlwb29sLgDVAUFkZCBsaXF1aWRpdHkgZmFpbHMgaWYgcHJpY2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHNwb3QgcHJpY2UgYW5kIG9yYWNsZSBwcmljZSBpcyBoaWdoZXIgdGhhbiBhbGxvd2VkIGJ5IGBQcmljZUJhcnJpZXJgLgAsUGFyYW1ldGVyczplAS0gYGFzc2V0YDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ldyBhc3NldCBhZGRlZCB0byB0aGUgcG9vbC4gTXVzdCBiZSBhbHJlYWR5IGluIHRoZSBwb29stC0gYGFtb3VudGA6IEFtb3VudCBvZiBhc3NldCBhZGRlZCB0byBvbW5pcG9vbIUBLSBgbWluX3NoYXJlc19saW1pdGA6IFRoZSBtaW4gYW1vdW50IG9mIGRlbHRhIHNoYXJlIGFzc2V0IHRoZSB1c2VyIHNob3VsZCByZWNlaXZlIGluIHRoZSBwb3NpdGlvbgC0RW1pdHMgYExpcXVpZGl0eUFkZGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAEByZW1vdmVfbGlxdWlkaXR5CAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAABGGFtb3VudBgBHEJhbGFuY2UAA0wRAVJlbW92ZSBsaXF1aWRpdHkgb2YgYXNzZXQgYGFzc2V0YCBpbiBxdWFudGl0eSBgYW1vdW50YCBmcm9tIE9tbmlwb29sAGEBYHJlbW92ZV9saXF1aWRpdHlgIHJlbW92ZXMgc3BlY2lmaWVkIHNoYXJlcyBhbW91bnQgZnJvbSBnaXZlbiBQb3NpdGlvbklkIChORlQgaW5zdGFuY2UpLgCRAUFzc2V0J3MgdHJhZGFibGUgc3RhdGUgbXVzdCBjb250YWluIFJFTU9WRV9MSVFVSURJVFkgZmxhZywgb3RoZXJ3aXNlIGBOb3RBbGxvd2VkYCBlcnJvciBpcyByZXR1cm5lZC4AXQFpZiBhbGwgc2hhcmVzIGZyb20gZ2l2ZW4gcG9zaXRpb24gYXJlIHJlbW92ZWQsIHBvc2l0aW9uIGlzIGRlc3Ryb3llZCBhbmQgTkZUIGlzIGJ1cm5lZC4A4QFSZW1vdmUgbGlxdWlkaXR5IGZhaWxzIGlmIHByaWNlIGRpZmZlcmVuY2UgYmV0d2VlbiBzcG90IHByaWNlIGFuZCBvcmFjbGUgcHJpY2UgaXMgaGlnaGVyIHRoYW4gYWxsb3dlZCBieSBgUHJpY2VCYXJyaWVyYC4A5QFEeW5hbWljIHdpdGhkcmF3YWwgZmVlIGlzIGFwcGxpZWQgaWYgd2l0aGRyYXdhbCBpcyBub3Qgc2FmZS4gSXQgaXMgY2FsY3VsYXRlZCB1c2luZyBzcG90IHByaWNlIGFuZCBleHRlcm5hbCBwcmljZSBvcmFjbGUu3FdpdGhkcmF3YWwgaXMgY29uc2lkZXJlZCBzYWZlIHdoZW4gdHJhZGluZyBpcyBkaXNhYmxlZC4ALFBhcmFtZXRlcnM6MQEtIGBwb3NpdGlvbl9pZGA6IFRoZSBpZGVudGlmaWVyIG9mIHBvc2l0aW9uIHdoaWNoIGxpcXVpZGl0eSBpcyByZW1vdmVkIGZyb20uyC0gYGFtb3VudGA6IEFtb3VudCBvZiBzaGFyZXMgcmVtb3ZlZCBmcm9tIG9tbmlwb29sALxFbWl0cyBgTGlxdWlkaXR5UmVtb3ZlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgBscmVtb3ZlX2xpcXVpZGl0eV93aXRoX2xpbWl0DAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAABGGFtb3VudBgBHEJhbGFuY2UAASRtaW5fbGltaXQYARxCYWxhbmNlAA5YEQFSZW1vdmUgbGlxdWlkaXR5IG9mIGFzc2V0IGBhc3NldGAgaW4gcXVhbnRpdHkgYGFtb3VudGAgZnJvbSBPbW5pcG9vbABwTGltaXQgcHJvdGVjdGlvbiBpcyBhcHBsaWVkLgBhAWByZW1vdmVfbGlxdWlkaXR5YCByZW1vdmVzIHNwZWNpZmllZCBzaGFyZXMgYW1vdW50IGZyb20gZ2l2ZW4gUG9zaXRpb25JZCAoTkZUIGluc3RhbmNlKS4AkQFBc3NldCdzIHRyYWRhYmxlIHN0YXRlIG11c3QgY29udGFpbiBSRU1PVkVfTElRVUlESVRZIGZsYWcsIG90aGVyd2lzZSBgTm90QWxsb3dlZGAgZXJyb3IgaXMgcmV0dXJuZWQuAF0BaWYgYWxsIHNoYXJlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGFyZSByZW1vdmVkLCBwb3NpdGlvbiBpcyBkZXN0cm95ZWQgYW5kIE5GVCBpcyBidXJuZWQuAOEBUmVtb3ZlIGxpcXVpZGl0eSBmYWlscyBpZiBwcmljZSBkaWZmZXJlbmNlIGJldHdlZW4gc3BvdCBwcmljZSBhbmQgb3JhY2xlIHByaWNlIGlzIGhpZ2hlciB0aGFuIGFsbG93ZWQgYnkgYFByaWNlQmFycmllcmAuAOUBRHluYW1pYyB3aXRoZHJhd2FsIGZlZSBpcyBhcHBsaWVkIGlmIHdpdGhkcmF3YWwgaXMgbm90IHNhZmUuIEl0IGlzIGNhbGN1bGF0ZWQgdXNpbmcgc3BvdCBwcmljZSBhbmQgZXh0ZXJuYWwgcHJpY2Ugb3JhY2xlLtxXaXRoZHJhd2FsIGlzIGNvbnNpZGVyZWQgc2FmZSB3aGVuIHRyYWRpbmcgaXMgZGlzYWJsZWQuACxQYXJhbWV0ZXJzOjEBLSBgcG9zaXRpb25faWRgOiBUaGUgaWRlbnRpZmllciBvZiBwb3NpdGlvbiB3aGljaCBsaXF1aWRpdHkgaXMgcmVtb3ZlZCBmcm9tLsgtIGBhbW91bnRgOiBBbW91bnQgb2Ygc2hhcmVzIHJlbW92ZWQgZnJvbSBvbW5pcG9vbAUBLSBgbWluX2xpbWl0YDogVGhlIG1pbiBhbW91bnQgb2YgYXNzZXQgdG8gYmUgcmVtb3ZlZCBmb3IgdGhlIHVzZXIAvEVtaXRzIGBMaXF1aWRpdHlSZW1vdmVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAEhzYWNyaWZpY2VfcG9zaXRpb24EASxwb3NpdGlvbl9pZBgBRFQ6OlBvc2l0aW9uSXRlbUlkAAQcnFNhY3JpZmljZSBMUCBwb3NpdGlvbiBpbiBmYXZvciBvZiBwb29sLgA9AUEgcG9zaXRpb24gaXMgZGVzdHJveWVkIGFuZCBsaXF1aWRpdHkgb3duZWQgYnkgTFAgYmVjb21lcyBwb29sIG93bmVkIGxpcXVpZGl0eS4AvE9ubHkgb3duZXIgb2YgcG9zaXRpb24gY2FuIHBlcmZvcm0gdGhpcyBhY3Rpb24uAGhFbWl0cyBgUG9zaXRpb25EZXN0cm95ZWRgLhBzZWxsEAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAAThtaW5fYnV5X2Ftb3VudBgBHEJhbGFuY2UABUS0RXhlY3V0ZSBhIHN3YXAgb2YgYGFzc2V0X2luYCBmb3IgYGFzc2V0X291dGAuAJBQcmljZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBPbW5pcG9vbC4AfEh1YiBhc3NldCBpcyB0cmFkZWQgc2VwYXJhdGVseS4ABQJBc3NldCdzIHRyYWRhYmxlIHN0YXRlcyBtdXN0IGNvbnRhaW4gU0VMTCBmbGFnIGZvciBhc3NldF9pbiBhbmQgQlVZIGZsYWcgZm9yIGFzc2V0X291dCwgb3RoZXJ3aXNlIGBOb3RBbGxvd2VkYCBlcnJvciBpcyByZXR1cm5lZC4ALFBhcmFtZXRlcnM6qC0gYGFzc2V0X2luYDogSUQgb2YgYXNzZXQgc29sZCB0byB0aGUgcG9vbLwtIGBhc3NldF9vdXRgOiBJRCBvZiBhc3NldCBib3VnaHQgZnJvbSB0aGUgcG9vbIAtIGBhbW91bnRgOiBBbW91bnQgb2YgYXNzZXQgc29sZNgtIGBtaW5fYnV5X2Ftb3VudGA6IE1pbmltdW0gYW1vdW50IHJlcXVpcmVkIHRvIHJlY2VpdmUA3EVtaXRzIGBTZWxsRXhlY3V0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4gRGVwcmVjYXRlZC7gRW1pdHMgYHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4ADGJ1eRABJGFzc2V0X291dBABKFQ6OkFzc2V0SWQAASBhc3NldF9pbhABKFQ6OkFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAE8bWF4X3NlbGxfYW1vdW50GAEcQmFsYW5jZQAGRLRFeGVjdXRlIGEgc3dhcCBvZiBgYXNzZXRfb3V0YCBmb3IgYGFzc2V0X2luYC4AkFByaWNlIGlzIGRldGVybWluZWQgYnkgdGhlIE9tbmlwb29sLgB8SHViIGFzc2V0IGlzIHRyYWRlZCBzZXBhcmF0ZWx5LgAFAkFzc2V0J3MgdHJhZGFibGUgc3RhdGVzIG11c3QgY29udGFpbiBTRUxMIGZsYWcgZm9yIGFzc2V0X2luIGFuZCBCVVkgZmxhZyBmb3IgYXNzZXRfb3V0LCBvdGhlcndpc2UgYE5vdEFsbG93ZWRgIGVycm9yIGlzIHJldHVybmVkLgAsUGFyYW1ldGVyczqoLSBgYXNzZXRfaW5gOiBJRCBvZiBhc3NldCBzb2xkIHRvIHRoZSBwb29svC0gYGFzc2V0X291dGA6IElEIG9mIGFzc2V0IGJvdWdodCBmcm9tIHRoZSBwb29sgC0gYGFtb3VudGA6IEFtb3VudCBvZiBhc3NldCBzb2xkvC0gYG1heF9zZWxsX2Ftb3VudGA6IE1heGltdW0gYW1vdW50IHRvIGJlIHNvbGQuANhFbWl0cyBgQnV5RXhlY3V0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4gRGVwcmVjYXRlZC7gRW1pdHMgYHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AYHNldF9hc3NldF90cmFkYWJsZV9zdGF0ZQgBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABFHN0YXRlJQMBLFRyYWRhYmlsaXR5AAcgeFVwZGF0ZSBhc3NldCdzIHRyYWRhYmxlIHN0YXRlLgAsUGFyYW1ldGVyczpYLSBgYXNzZXRfaWRgOiBhc3NldCBpZFAtIGBzdGF0ZWA6IG5ldyBzdGF0ZQDMRW1pdHMgYFRyYWRhYmxlU3RhdGVVcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAFByZWZ1bmRfcmVmdXNlZF9hc3NldAwBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAASRyZWNpcGllbnQAATBUOjpBY2NvdW50SWQACCSwUmVmdW5kIGdpdmVuIGFtb3VudCBvZiBhc3NldCB0byBhIHJlY2lwaWVudC4AWQJBIHJlZnVuZCBpcyBuZWVkZWQgd2hlbiBhIHRva2VuIGlzIHJlZnVzZWQgdG8gYmUgYWRkZWQgdG8gT21uaXBvb2wsIGFuZCBpbml0aWFsIGxpcXVpZGl0eSBvZiB0aGUgYXNzZXQgaGFzIGJlZW4gYWxyZWFkeSB0cmFuc2ZlcnJlZCB0byBwb29sJ3MgYWNjb3VudC4AjQFUcmFuc2ZlciBjYW4gYmUgZXhlY3V0ZWQgb25seSBpZiBhc3NldCBpcyBub3QgaW4gT21uaXBvb2wgYW5kIHBvb2wncyBiYWxhbmNlIGhhcyBzdWZmaWNpZW50IGFtb3VudC4AyE9ubHkgYEF1dGhvcml0eU9yaWdpbmAgY2FuIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24uAFRFbWl0cyBgQXNzZXRSZWZ1bmRlZGBQc2V0X2Fzc2V0X3dlaWdodF9jYXAIASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAQxjYXAhAwEcUGVybWlsbAAJIGRVcGRhdGUgYXNzZXQncyB3ZWlnaHQgY2FwACxQYXJhbWV0ZXJzOlgtIGBhc3NldF9pZGA6IGFzc2V0IGlkXC0gYGNhcGA6IG5ldyB3ZWlnaHQgY2FwANBFbWl0cyBgQXNzZXRXZWlnaHRDYXBVcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAGx3aXRoZHJhd19wcm90b2NvbF9saXF1aWRpdHkQASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAEUcHJpY2UpAwFIKEJhbGFuY2UsIEJhbGFuY2UpAAEQZGVzdAABMFQ6OkFjY291bnRJZAALLGxSZW1vdmVzIHByb3RvY29sIGxpcXVpZGl0eS4AhQFQcm90b2NvbCBsaXF1aWRpdHkgaXMgbGlxdWlkaXR5IGZyb20gc2FjcmlmaWNlZCBwb3NpdGlvbnMuIEluIG9yZGVyIHRvIHJlbW92ZSBwcm90b2NvbCBsaXF1aWRpdHkseQF3ZSBuZWVkIHRoZSBrbm93IHRoZSBwcmljZSBvZiB0aGUgcG9zaXRpb24gYXQgdGhlIHRpbWUgb2Ygc2FjcmlmaWNlLiBIZW5jZSB0aGlzIHNwZWNpZmljIGNhbGwuALRPbmx5IGBBdXRob3JpdHlPcmlnaW5gIGNhbiBwZXJmb3JtIHRoaXMgY2FsbC4AeQFOb3RlIHRoYXQgc2FjcmlmaWNlIHBvc2l0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiBmdXR1cmUuIFRoZXJlIGlzIG5vIGxvbmdlciBhIG5lZWQgZm9yIHRoYXQuAGEBSXQgd29ya3MgdGhlIHNhbWUgd2F5IGFzIHJlbW92ZSBsaXF1aWRpdHkgY2FsbCwgYnV0IHBvc2l0aW9uIGlzIHRlbXBvcmFyeSByZWNvbnN0cnVjdGVkLgAwcmVtb3ZlX3Rva2VuCAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEsYmVuZWZpY2lhcnkAATBUOjpBY2NvdW50SWQADCxwUmVtb3ZlcyB0b2tlbiBmcm9tIE9tbmlwb29sLgBFAUFzc2V0J3MgdHJhZGFiaWxpdHkgbXVzdCBiZSBGUk9aRU4sIG90aGVyd2lzZSBgQXNzZXROb3RGcm96ZW5gIGVycm9yIGlzIHJldHVybmVkLgBhAVJlbWFpbmluZyBzaGFyZXMgbXVzdCBiZWxvbmcgdG8gcHJvdG9jb2wsIG90aGVyd2lzZSBgU2hhcmVzUmVtYWluaW5nYCBlcnJvciBpcyByZXR1cm5lZC4AeQFQcm90b2NvbCdzIGxpcXVpZGl0eSBpcyB0cmFuc2ZlcnJlZCB0byB0aGUgYmVuZWZpY2lhcnkgYWNjb3VudCBhbmQgaHViIGFzc2V0IGFtb3VudCBpcyBidXJuZWQuALRPbmx5IGBBdXRob3JpdHlPcmlnaW5gIGNhbiBwZXJmb3JtIHRoaXMgY2FsbC4ArEVtaXRzIGBUb2tlblJlbW92ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuIQMMNHNwX2FyaXRobWV0aWMocGVyX3RoaW5ncxxQZXJtaWxsAAAEABABDHUzMgAAJQMMPHBhbGxldF9vbW5pcG9vbBR0eXBlcyxUcmFkYWJpbGl0eQAABAEQYml0cwgBCHU4AAApAwAABAgYGAAtAwxgcGFsbGV0X3RyYW5zYWN0aW9uX3BhdXNlGHBhbGxldBBDYWxsBARUAAEIRHBhdXNlX3RyYW5zYWN0aW9uCAEscGFsbGV0X25hbWU4ARxWZWM8dTg+AAE0ZnVuY3Rpb25fbmFtZTgBHFZlYzx1OD4AAABMdW5wYXVzZV90cmFuc2FjdGlvbggBLHBhbGxldF9uYW1lOAEcVmVjPHU4PgABNGZ1bmN0aW9uX25hbWU4ARxWZWM8dTg+AAEABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLjEDDDRwYWxsZXRfZHVzdGVyGHBhbGxldBBDYWxsBARUAAEMMGR1c3RfYWNjb3VudAgBHGFjY291bnQAATBUOjpBY2NvdW50SWQAASxjdXJyZW5jeV9pZBABKFQ6OkFzc2V0SWQAACxcRHVzdCBzcGVjaWZpZWQgYWNjb3VudC51AUlGIGFjY291bnQgYmFsYW5jZSBpcyA8IG1pbi4gZXhpc3RlbnRpYWwgZGVwb3NpdCBvZiBnaXZlbiBjdXJyZW5jeSwgYW5kIGFjY291bnQgaXMgYWxsb3dlZCB0bxEBYmUgZHVzdGVkLCB0aGUgcmVtYWluaW5nIGJhbGFuY2UgaXMgdHJhbnNmZXJyZWQgdG8gdHJlYXN1cnkgYWNjb3VudC4A4QFJbiBjYXNlIG9mIEFUb2tlbiwgd2UgcGVyZm9ybSBhbiBlcmMyMCBkdXN0LCB3aGljaCBkb2VzIGEgd2lodGRyYXcgYWxsIHRoZW4gc3VwcGx5IGF0b2tlbiBvbiBiZWhhbGYgb2YgdGhlIGR1c3QgcmVjZWl2ZXIADQFUaGUgdHJhbnNhY3Rpb24gZmVlIGlzIHJldHVybmVkIGJhY2sgaW4gY2FzZSBvZiBzdWNjZXNzZnVsIGR1c3RpbmcuAJRUcmVhc3VyeSBhY2NvdW50IGNhbiBuZXZlciBiZSBkdXN0ZWQuAJRFbWl0cyBgRHVzdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuRHdoaXRlbGlzdF9hY2NvdW50BAEcYWNjb3VudAABMFQ6OkFjY291bnRJZAABGE0BQWRkIGFjY291bnQgdG8gbGlzdCBvZiB3aGl0ZWxpc3QgYWNjb3VudHMuIEFjY291bnQgd2hpY2ggYXJlIGV4Y2x1ZGVkIGZyb20gZHVzdGluZy4pAUlmIHN1Y2ggYWNjb3VudCBzaG91bGQgYmUgZHVzdGVkIC0gYEFjY291bnRXaGl0ZWxpc3RlZGAgZXJyb3IgaXMgcmV0dXJuZWQuiE9ubHkgcm9vdCBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4AkEVtaXRzIGBBZGRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgBUcmVtb3ZlX2Zyb21fd2hpdGVsaXN0BAEcYWNjb3VudAABMFQ6OkFjY291bnRJZAACEF0BUmVtb3ZlIGFjY291bnQgZnJvbSBsaXN0IG9mIHdoaXRlbGlzdCBhY2NvdW50cy4gVGhhdCBtZWFucyBhY2NvdW50IGNhbiBiZSBkdXN0ZWQgYWdhaW4uAJhFbWl0cyBgUmVtb3ZlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuNQMMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nGHBhbGxldBBDYWxsCARUAARJAAEABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLjkDDIBwYWxsZXRfb21uaXBvb2xfbGlxdWlkaXR5X21pbmluZxhwYWxsZXQQQ2FsbAQEVAABQEhjcmVhdGVfZ2xvYmFsX2Zhcm0gATR0b3RhbF9yZXdhcmRzGAEcQmFsYW5jZQABYHBsYW5uZWRfeWllbGRpbmdfcGVyaW9kcxABLFBlcmlvZE9mPFQ+AAFEYmxvY2tzX3Blcl9wZXJpb2QQAURCbG9ja051bWJlckZvcjxUPgABPHJld2FyZF9jdXJyZW5jeRABKFQ6OkFzc2V0SWQAARRvd25lcgABMFQ6OkFjY291bnRJZAABQHlpZWxkX3Blcl9wZXJpb2Q9AwEsUGVycXVpbnRpbGwAASxtaW5fZGVwb3NpdBgBHEJhbGFuY2UAAVRscm5hX3ByaWNlX2FkanVzdG1lbnQ9AQEkRml4ZWRVMTI4AABw/ENyZWF0ZSBhIG5ldyBsaXF1aWRpdHkgbWluaW5nIHByb2dyYW0gd2l0aCBwcm92aWRlZCBwYXJhbWV0ZXJzLgBFAWBvd25lcmAgYWNjb3VudCBoYXMgdG8gaGF2ZSBhdCBsZWFzdCBgdG90YWxfcmV3YXJkc2AgYmFsYW5jZS4gVGhlc2UgZnVuZHMgd2lsbCBiZaR0cmFuc2ZlcnJlZCBmcm9tIGBvd25lcmAgdG8gZmFybSBhY2NvdW50LgDwVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgYFQ6OkNyZWF0ZU9yaWdpbmAuVQEhISFXQVJOOiBgVDo6Q3JlYXRlT3JpZ2luYCBoYXMgcG93ZXIgb3ZlciBmdW5kcyBvZiBgb3duZXJgJ3MgYWNjb3VudCBhbmQgaXQgc2hvdWxkIGJl0GNvbmZpZ3VyZWQgdG8gdHJ1c3RlZCBvcmlnaW4gZS5nIFN1ZG8gb3IgR292ZXJuYW5jZS4ALFBhcmFtZXRlcnM6VQEtIGBvcmlnaW5gOiBhY2NvdW50IGFsbG93ZWQgdG8gY3JlYXRlIG5ldyBsaXF1aWRpdHkgbWluaW5nIHByb2dyYW0ocm9vdCwgZ292ZXJuYW5jZSkuNQEtIGB0b3RhbF9yZXdhcmRzYDogdG90YWwgcmV3YXJkcyBwbGFubmVkIHRvIGRpc3RyaWJ1dGUuIFRoZXNlIHJld2FyZHMgd2lsbCBiZdxkaXN0cmlidXRlZCBiZXR3ZWVuIGFsbCB5aWVsZCBmYXJtcyBpbiB0aGUgZ2xvYmFsIGZhcm0uWQEtIGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHNgOiBwbGFubmVkIG51bWJlciBvZiBwZXJpb2RzIHRvIGRpc3RyaWJ1dGUgYHRvdGFsX3Jld2FyZHNgLikBV0FSTjogVEhJUyBJUyBOT1QgSEFSRCBERUFETElORS4gTm90IGFsbCByZXdhcmRzIGhhdmUgdG8gYmUgZGlzdHJpYnV0ZWQgaW5dAWBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHNgLiBSZXdhcmRzIGFyZSBkaXN0cmlidXRlZCBiYXNlZCBvbiB0aGUgc2l0dWF0aW9uIGluIHRoZSB5aWVsZEEBZmFybXMgYW5kIGNhbiBiZSBkaXN0cmlidXRlZCBpbiBhIGxvbmdlciwgdGhvdWdoIG5ldmVyIGluIGEgc2hvcnRlciwgdGltZSBmcmFtZS5ZAS0gYGJsb2Nrc19wZXJfcGVyaW9kYDogIG51bWJlciBvZiBibG9ja3MgaW4gYSBzaW5nbGUgcGVyaW9kLiBNaW4uIG51bWJlciBvZiBibG9ja3MgcGVyMHBlcmlvZCBpcyAxLsAtIGByZXdhcmRfY3VycmVuY3lgOiBwYXlvZmYgY3VycmVuY3kgb2YgcmV3YXJkcy45AS0gYG93bmVyYDogbGlxLiBtaW5pbmcgZmFybSBvd25lci4gVGhpcyBhY2NvdW50IHdpbGwgYmUgYWJsZSB0byBtYW5hZ2UgY3JlYXRlZGRsaXF1aWRpdHkgbWluaW5nIHByb2dyYW0uKQEtIGB5aWVsZF9wZXJfcGVyaW9kYDogcGVyY2VudGFnZSByZXR1cm4gb24gYHJld2FyZF9jdXJyZW5jeWAgb2YgYWxsIGZhcm1zLpEBLSBgbWluX2RlcG9zaXRgOiBtaW5pbXVtIGFtb3VudCBvZiBMUCBzaGFyZXMgdG8gYmUgZGVwb3NpdGVkIGludG8gdGhlIGxpcXVpZGl0eSBtaW5pbmcgYnkgZWFjaCB1c2VyLk0BLSBgbHJuYV9wcmljZV9hZGp1c3RtZW50YDogcHJpY2UgYWRqdXN0bWVudCBiZXR3ZWVuIGBbTFJOQV1gIGFuZCBgcmV3YXJkX2N1cnJlbmN5YC4AqEVtaXRzIGBHbG9iYWxGYXJtQ3JlYXRlZGAgd2hlbiBzdWNjZXNzZnVsLgBUdGVybWluYXRlX2dsb2JhbF9mYXJtBAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAAjScVGVybWluYXRlIGV4aXN0aW5nIGxpcS4gbWluaW5nIHByb2dyYW0uAKBPbmx5IGZhcm0gb3duZXIgY2FuIHBlcmZvcm0gdGhpcyBhY3Rpb24uABEBV0FSTjogVG8gc3VjY2Vzc2Z1bGx5IHRlcm1pbmF0ZSBhIGdsb2JhbCBmYXJtLCBmYXJtIGhhdmUgdG8gYmUgZW1wdHngKGFsbCB5aWVsZCBmYXJtcyBpbiB0aGUgZ2xvYmFsIGZhcm0gbXVzdCBiZSB0ZXJtaW5hdGVkKS4ALFBhcmFtZXRlcnM6gC0gYG9yaWdpbmA6IGdsb2JhbCBmYXJtJ3Mgb3duZXIu3C0gYGdsb2JhbF9mYXJtX2lkYDogaWQgb2YgZ2xvYmFsIGZhcm0gdG8gYmUgdGVybWluYXRlZC4AzEVtaXRzIGBHbG9iYWxGYXJtVGVybWluYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgBEY3JlYXRlX3lpZWxkX2Zhcm0QAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIAATRsb3lhbHR5X2N1cnZlQQMBUE9wdGlvbjxMb3lhbHR5Q3VydmU+AANI3ENyZWF0ZSB5aWVsZCBmYXJtIGZvciBnaXZlbiBgYXNzZXRfaWRgIGluIHRoZSBvbW5pcG9vbC4EIKBPbmx5IGZhcm0gb3duZXIgY2FuIHBlcmZvcm0gdGhpcyBhY3Rpb24uAOxBc3NldCB3aXRoIGBhc3NldF9pZGAgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9tbmlwb29sLlUBQXQgbW9zdCBvbmUgYGFjdGl2ZWAgeWllbGQgZmFybSBjYW4gZXhpc3QgaW4gb25lIGdsb2JhbCBmYXJtIGZvciB0aGUgc2FtZSBgYXNzZXRfaWRgLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci4dAS0gYGdsb2JhbF9mYXJtX2lkYDogZ2xvYmFsIGZhcm0gaWQgdG8gd2hpY2ggYSB5aWVsZCBmYXJtIHdpbGwgYmUgYWRkZWQuHQEtIGBhc3NldF9pZGA6IGlkIG9mIGEgYXNzZXQgaW4gdGhlIG9tbmlwb29sLiBZaWVsZCBmYXJtIHdpbGwgYmUgY3JlYXRlZGEBZm9yIHRoaXMgYXNzZXQgYW5kIHVzZXIgd2lsbCBiZSBhYmxlIHRvIGxvY2sgTFAgc2hhcmVzIGludG8gdGhpcyB5aWVsZCBmYXJtIGltbWVkaWF0ZWx5LqAtIGBtdWx0aXBsaWVyYDogeWllbGQgZmFybSdzIG11bHRpcGxpZXIuXQEtIGBsb3lhbHR5X2N1cnZlYDogY3VydmUgdG8gY2FsY3VsYXRlIGxveWFsdHkgbXVsdGlwbGllciB0byBkaXN0cmlidXRlIHJld2FyZHMgdG8gdXNlcnPgd2l0aCB0aW1lIGluY2VudGl2ZS4gYE5vbmVgIG1lYW5zIG5vIGxveWFsdHkgbXVsdGlwbGllci4AvEVtaXRzIGBZaWVsZEZhcm1DcmVhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAER1cGRhdGVfeWllbGRfZmFybQwBOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEobXVsdGlwbGllcj0BAThGYXJtTXVsdGlwbGllcgAEMHxVcGRhdGUgeWllbGQgZmFybSdzIG11bHRpcGxpZXIuBCCgT25seSBmYXJtIG93bmVyIGNhbiBwZXJmb3JtIHRoaXMgYWN0aW9uLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci4dAS0gYGdsb2JhbF9mYXJtX2lkYDogZ2xvYmFsIGZhcm0gaWQgaW4gd2hpY2ggeWllbGQgZmFybSB3aWxsIGJlIHVwZGF0ZWQuIQEtIGBhc3NldF9pZGA6IGlkIG9mIHRoZSBhc3NldCBpZGVudGlmeWluZyB5aWVsZCBmYXJtIGluIHRoZSBnbG9iYWwgZmFybS6wLSBgbXVsdGlwbGllcmA6IG5ldyB5aWVsZCBmYXJtJ3MgbXVsdGlwbGllci4AvEVtaXRzIGBZaWVsZEZhcm1VcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuADxzdG9wX3lpZWxkX2Zhcm0IAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAFQLhTdG9wIGxpcXVpZGl0eSBtaW1pbmcgZm9yIHNwZWNpZmljIHlpZWxkIGZhcm0uADEBVGhpcyBmdW5jdGlvbiBjbGFpbXMgcmV3YXJkcyBmcm9tIGBHbG9iYWxGYXJtYCBsYXN0IHRpbWUgYW5kIHN0b3AgeWllbGQgZmFybSEBaW5jZW50aXZpemF0aW9uIGZyb20gYSBgR2xvYmFsRmFybWAuIFVzZXJzIHdpbGwgYmUgYWJsZSB0byBvbmx5IHdpdGhkcmF3yHNoYXJlcyh3aXRoIGNsYWltaW5nKSBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24u4GBkZXBvc2l0X3NoYXJlcygpYCBpcyBub3QgYWxsb3dlZCBvbiBzdG9wcGVkIHlpZWxkIGZhcm0uBCCgT25seSBmYXJtIG93bmVyIGNhbiBwZXJmb3JtIHRoaXMgYWN0aW9uLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci4FAS0gYGdsb2JhbF9mYXJtX2lkYDogZmFybSBpZCBpbiB3aGljaCB5aWVsZCBmYXJtIHdpbGwgYmUgY2FuY2VsZWQuIQEtIGBhc3NldF9pZGA6IGlkIG9mIHRoZSBhc3NldCBpZGVudGlmeWluZyB5aWVsZCBmYXJtIGluIHRoZSBnbG9iYWwgZmFybS4AvEVtaXRzIGBZaWVsZEZhcm1TdG9wcGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAERyZXN1bWVfeWllbGRfZmFybRABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEobXVsdGlwbGllcj0BAThGYXJtTXVsdGlwbGllcgAGTPhSZXN1bWUgaW5jZW50aXZpemF0aW9uIG9mIHRoZSBhc3NldCByZXByZXNlbnRlZCBieSB5aWVsZCBmYXJtLgAtAVRoaXMgZnVuY3Rpb24gcmVzdW1lIGluY2VudGl2aXphdGlvbiBvZiB0aGUgYXNzZXQgZnJvbSB0aGUgYEdsb2JhbEZhcm1gIGFuZDEBcmVzdG9yZSBmdWxsIGZ1bmN0aW9uYWxpdHkgb3IgdGhlIHlpZWxkIGZhcm0uIFVzZXJzIHdpbGwgYmUgYWJsZSB0byBkZXBvc2l0LGRjbGFpbSBhbmQgd2l0aGRyYXcgYWdhaW4uABEBV0FSTjogWWllbGQgZmFybShhbmQgdXNlcnMpIGlzIE5PVCByZXdhcmRlZCBmb3IgdGltZSBpdCB3YXMgc3RvcHBlZC4AoE9ubHkgZmFybSBvd25lciBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4ALFBhcmFtZXRlcnM6gC0gYG9yaWdpbmA6IGdsb2JhbCBmYXJtJ3Mgb3duZXIuHQEtIGBnbG9iYWxfZmFybV9pZGA6IGdsb2JhbCBmYXJtIGlkIGluIHdoaWNoIHlpZWxkIGZhcm0gd2lsbCBiZSByZXN1bWVkLtgtIGB5aWVsZF9mYXJtX2lkYDogaWQgb2YgdGhlIHlpZWxkIGZhcm0gdG8gYmUgcmVzdW1lZC4hAS0gYGFzc2V0X2lkYDogaWQgb2YgdGhlIGFzc2V0IGlkZW50aWZ5aW5nIHlpZWxkIGZhcm0gaW4gdGhlIGdsb2JhbCBmYXJtLpgtIGBtdWx0aXBsaWVyYDogeWllbGQgZmFybSBtdWx0aXBsaWVyLgC8RW1pdHMgYFlpZWxkRmFybVJlc3VtZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AUHRlcm1pbmF0ZV95aWVsZF9mYXJtDAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAB1BUVGVybWluYXRlIHlpZWxkIGZhcm0uAIEBVGhpcyBmdW5jdGlvbiBtYXJrcyBhIHlpZWxkIGZhcm0gYXMgcmVhZHkgdG8gYmUgcmVtb3ZlZCBmcm9tIHN0b3JhZ2Ugd2hlbiBpdCdzIGVtcHR5LiBVc2VycyB3aWxsZQFiZSBhYmxlIHRvIG9ubHkgd2l0aGRyYXcgc2hhcmVzKHdpdGhvdXQgY2xhaW1pbmcgcmV3YXJkcyBmcm9tIHlpZWxkIGZhcm0pLiBVbnBhaWQgcmV3YXJkc30Bd2lsbCBiZSB0cmFuc2ZlcnJlZCBiYWNrIHRvIGdsb2JhbCBmYXJtIGFuZCBpdCB3aWxsIGJlIHVzZWQgdG8gZGlzdHJpYnV0ZSB0byBvdGhlciB5aWVsZCBmYXJtcy4A3FlpZWxkIGZhcm0gbXVzdCBiZSBzdG9wcGVkIGJlZm9yZSBpdCBjYW4gYmUgdGVybWluYXRlZC4AcQFPbmx5IGdsb2JhbCBmYXJtJ3Mgb3duZXIgY2FuIHBlcmZvcm0gdGhpcyBhY3Rpb24uIFlpZWxkIGZhcm0gc3RheXMgaW4gdGhlIHN0b3JhZ2UgdW50aWwgaXQnc20BZW1wdHkoYWxsIGZhcm0gZW50cmllcyBhcmUgd2l0aGRyYXduKS4gTGFzdCB3aXRoZHJhd24gZnJvbSB5aWVsZCBmYXJtIHRyaWdnZXIgcmVtb3ZpbmcgZnJvbTB0aGUgc3RvcmFnZS4ALFBhcmFtZXRlcnM6gC0gYG9yaWdpbmA6IGdsb2JhbCBmYXJtJ3Mgb3duZXIuMQEtIGBnbG9iYWxfZmFybV9pZGA6IGdsb2JhbCBmYXJtIGlkIGluIHdoaWNoIHlpZWxkIGZhcm0gc2hvdWxkIGJlIHRlcm1pbmF0ZWQu1C0gYHlpZWxkX2Zhcm1faWRgOiBpZCBvZiB5aWVsZCBmYXJtIHRvIGJlIHRlcm1pbmF0ZWQu1C0gYGFzc2V0X2lkYDogaWQgb2YgdGhlIGFzc2V0IGlkZW50aWZ5aW5nIHlpZWxkIGZhcm0uAMhFbWl0cyBgWWllbGRGYXJtVGVybWluYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgA4ZGVwb3NpdF9zaGFyZXMMAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQACDjsRGVwb3NpdCBvbW5pcG9vbCBwb3NpdGlvbihMUCBzaGFyZXMpIHRvIGEgbGlxdWlkaXR5IG1pbmluZy4AcQFUaGlzIGZ1bmN0aW9uIHRyYW5zZmVycyBvbW5pcG9vbCBwb3NpdGlvbiBmcm9tIGBvcmlnaW5gIHRvIHBhbGxldCdzIGFjY291bnQgYW5kIG1pbnQgTkZUIGZvckUBYG9yaWdpbmAgYWNjb3VudC4gTWludGVkIE5GVCByZXByZXNlbnRzIGRlcG9zaXQgaW4gdGhlIGxpcXVpZGl0eSBtaW5pbmcuIFVzZXIgY2FuIQFkZXBvc2l0IG9tbmlwb29sIHBvc2l0aW9uIGFzIGEgd2hvbGUoYWxsIHRoZSBMUCBzaGFyZXMgaW4gdGhlIHBvc2l0aW9uKS4ALFBhcmFtZXRlcnM6QQEtIGBvcmlnaW5gOiBvd25lciBvZiB0aGUgb21uaXBvb2wgcG9zaXRpb24gdG8gZGVwb3NpdCBpbnRvIHRoZSBsaXF1aWRpdHkgbWluaW5nLj0BLSBgZ2xvYmFsX2Zhcm1faWRgOiBpZCBvZiBnbG9iYWwgZmFybSB0byB3aGljaCB1c2VyIHdhbnRzIHRvIGRlcG9zaXQgTFAgc2hhcmVzLsgtIGB5aWVsZF9mYXJtX2lkYDogaWQgb2YgeWllbGQgZmFybSB0byBkZXBvc2l0IHRvLl0BLSBgcG9zaXRpb25faWRgOiBpZCBvZiB0aGUgb21uaXBvb2wgcG9zaXRpb24gdG8gYmUgZGVwb3NpdGVkIGludG8gdGhlIGxpcXVpZGl0eSBtaW5pbmcuALhFbWl0cyBgU2hhcmVzRGVwb3NpdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAEByZWRlcG9zaXRfc2hhcmVzDAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAShkZXBvc2l0X2lkGAEkRGVwb3NpdElkAAk88FJlZGVwb3NpdCBMUCBzaGFyZXMgaW4gdGhlIGFscmVhZHkgbG9ja2VkIG9tbmlwb29sIHBvc2l0aW9uLgBRAVRoaXMgZnVuY3Rpb24gY3JlYXRlIHlpZWxkIGZhcm0gZW50cnkgZm9yIGV4aXN0aW5nIGRlcG9zaXQuIEFtb3VudCBvZiByZWRlcG9zaXRlZCBMUC0Bc2hhcmVzIGlzIHNhbWUgYXMgYW1vdW50IHNoYXJlcyB3aGljaCBhcmUgYWxyZWFkeSBkZXBvc2l0ZWQgaW4gdGhlIGRlcG9zaXQuALhUaGlzIGZ1bmN0aW9uIERPRVNOJ1QgY3JlYXRlIG5ldyBkZXBvc2l0KE5GVCkuACxQYXJhbWV0ZXJzOrgtIGBvcmlnaW5gOiBvd25lciBvZiB0aGUgZGVwb3NpdCB0byByZWRlcG9zaXQuVQEtIGBnbG9iYWxfZmFybV9pZGA6IGlkIG9mIHRoZSBnbG9iYWwgZmFybSB0byB3aGljaCB1c2VyIHdhbnRzIHRvIHJlZGVwb3NpdCBMUCBzaGFyZXMu4C0gYHlpZWxkX2Zhcm1faWRgOiBpZCBvZiB0aGUgeWllbGQgZmFybSB0byByZWRlcG9zaXQgdG8u3C0gYGRlcG9zaXRfaWRgOiBpZGVudGlmaWVyIG9mIHRoZSBkZXBvc2l0IHRvIHJlZGVwb3NpdC4AwEVtaXRzIGBTaGFyZXNSZWRlcG9zaXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgA0Y2xhaW1fcmV3YXJkcwgBKGRlcG9zaXRfaWQYASREZXBvc2l0SWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQACjBhAUNsYWltIHJld2FyZHMgZnJvbSBsaXF1aWRpdHkgbWluaW5nIHByb2dyYW0gZm9yIGRlcG9zaXQgcmVwcmVzZW50ZWQgYnkgdGhlIGBkZXBvc2l0X2lkYC4AbQFUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZSB1c2VyIHJld2FyZHMgZnJvbSBsaXF1aWRpdHkgbWluaW5nIGFuZCB0cmFuc2ZlciByZXdhcmRzIHRvIGBvcmlnaW5g/GFjY291bnQuIENsYWltaW5nIG11bHRpcGxlIHRpbWUgdGhlIHNhbWUgcGVyaW9kIGlzIG5vdCBhbGxvd2VkLgAsUGFyYW1ldGVyczp0LSBgb3JpZ2luYDogb3duZXIgb2YgZGVwb3NpdC7cLSBgZGVwb3NpdF9pZGA6IGlkIG9mIHRoZSBkZXBvc2l0IHRvIGNsYWltIHJld2FyZHMgZm9yLvgtIGB5aWVsZF9mYXJtX2lkYDogaWQgb2YgdGhlIHlpZWxkIGZhcm0gdG8gY2xhaW0gcmV3YXJkcyBmcm9tLgCwRW1pdHMgYFJld2FyZENsYWltZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4APHdpdGhkcmF3X3NoYXJlcwgBKGRlcG9zaXRfaWQYASREZXBvc2l0SWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAC1BVAVRoaXMgZnVuY3Rpb24gY2xhaW0gcmV3YXJkcyBhbmQgd2l0aGRyYXcgTFAgc2hhcmVzIGZyb20geWllbGQgZmFybS4gT21uaXBvb2wgcG9zaXRpb25RAWlzIHRyYW5zZmVycmVkIHRvIG9yaWdpbiBvbmx5IGlmIHRoaXMgaXMgbGFzdCB3aXRoZHJhdyBpbiB0aGUgZGVwb3NpdCBhbmQgZGVwb3NpdCBpc1EBZGVzdHJveWVkLiBUaGlzIGZ1bmN0aW9uIGNsYWltIHJld2FyZHMgb25seSBpZiB5aWVsZCBmYXJtIGlzIG5vdCB0ZXJtaW5hdGVkIGFuZCB1c2VyvGRpZG4ndCBhbHJlYWR5IGNsYWltIHJld2FyZHMgaW4gY3VycmVudCBwZXJpb2QuAE0BVW5jbGFpbWFibGUgcmV3YXJkcyByZXByZXNlbnRzIHJld2FyZHMgd2hpY2ggdXNlciB3b24ndCBiZSBhYmxlIHRvIGNsYWltIGJlY2F1c2Ugb2ZJAWV4aXRpbmcgZWFybHkgYW5kIHRoZXNlIHJld2FyZHMgd2lsbCBiZSB0cmFuc2ZlcnJlZCBiYWNrIHRvIGdsb2JhbCBmYXJtIGZvciBmdXR1cmU8cmVkaXN0cmlidXRpb24uACxQYXJhbWV0ZXJzOnQtIGBvcmlnaW5gOiBvd25lciBvZiBkZXBvc2l0LtwtIGBkZXBvc2l0X2lkYDogaWQgb2YgdGhlIGRlcG9zaXQgdG8gY2xhaW0gcmV3YXJkcyBmb3Iu+C0gYHlpZWxkX2Zhcm1faWRgOiBpZCBvZiB0aGUgeWllbGQgZmFybSB0byBjbGFpbSByZXdhcmRzIGZyb20uABhFbWl0czrEKiBgUmV3YXJkQ2xhaW1lZGAgZXZlbnQgaWYgY2xhaW1lZCByZXdhcmRzIGlzID4gMKQqIGBTaGFyZXNXaXRoZHJhd25gIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bF0BKiBgRGVwb3NpdERlc3Ryb3llZGAgZXZlbnQgd2hlbiB0aGlzIHdhcyBsYXN0IHdpdGhkcmF3IGZyb20gdGhlIGRlcG9zaXQgYW5kIGRlcG9zaXQgd2FzKGRlc3Ryb3llZC4ASHVwZGF0ZV9nbG9iYWxfZmFybRABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAFgcGxhbm5lZF95aWVsZGluZ19wZXJpb2RzEAFIY3JhdGU6OlBlcmlvZE9mPFQ+AAFAeWllbGRfcGVyX3BlcmlvZD0DASxQZXJxdWludGlsbAABLG1pbl9kZXBvc2l0GAEcQmFsYW5jZQAMONRUaGlzIGV4dHJpbnNpYyB1cGRhdGVzIGdsb2JhbCBmYXJtJ3MgbWFpbiBwYXJhbWV0ZXJzLgDwVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgYFQ6OkNyZWF0ZU9yaWdpbmAuVQEhISFXQVJOOiBgVDo6Q3JlYXRlT3JpZ2luYCBoYXMgcG93ZXIgb3ZlciBmdW5kcyBvZiBgb3duZXJgJ3MgYWNjb3VudCBhbmQgaXQgc2hvdWxkIGJl0GNvbmZpZ3VyZWQgdG8gdHJ1c3RlZCBvcmlnaW4gZS5nIFN1ZG8gb3IgR292ZXJuYW5jZS4ALFBhcmFtZXRlcnM6VQEtIGBvcmlnaW5gOiBhY2NvdW50IGFsbG93ZWQgdG8gY3JlYXRlIG5ldyBsaXF1aWRpdHkgbWluaW5nIHByb2dyYW0ocm9vdCwgZ292ZXJuYW5jZSku0C0gYGdsb2JhbF9mYXJtX2lkYDogaWQgb2YgdGhlIGdsb2JhbCBmYXJtIHRvIHVwZGF0ZS5ZAS0gYHBsYW5uZWRfeWllbGRpbmdfcGVyaW9kc2A6IHBsYW5uZWQgbnVtYmVyIG9mIHBlcmlvZHMgdG8gZGlzdHJpYnV0ZSBgdG90YWxfcmV3YXJkc2AuKQEtIGB5aWVsZF9wZXJfcGVyaW9kYDogcGVyY2VudGFnZSByZXR1cm4gb24gYHJld2FyZF9jdXJyZW5jeWAgb2YgYWxsIGZhcm1zLpEBLSBgbWluX2RlcG9zaXRgOiBtaW5pbXVtIGFtb3VudCBvZiBMUCBzaGFyZXMgdG8gYmUgZGVwb3NpdGVkIGludG8gdGhlIGxpcXVpZGl0eSBtaW5pbmcgYnkgZWFjaCB1c2VyLgDARW1pdHMgYEdsb2JhbEZhcm1VcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuKGpvaW5fZmFybXMIATBmYXJtX2VudHJpZXNJAwERAUJvdW5kZWRWZWM8KEdsb2JhbEZhcm1JZCwgWWllbGRGYXJtSWQpLCBUOjpNYXhGYXJtRW50cmllc1BlckRlcG9zaXQ+AAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAANJEUBVGhpcyBmdW5jdGlvbiBhbGxvd3MgdXNlciB0byBqb2luIG11bHRpcGxlIGZhcm1zIHdpdGggYSBzaW5nbGUgb21uaXBvb2wgcG9zaXRpb24uACxQYXJhbWV0ZXJzOkEBLSBgb3JpZ2luYDogb3duZXIgb2YgdGhlIG9tbmlwb29sIHBvc2l0aW9uIHRvIGRlcG9zaXQgaW50byB0aGUgbGlxdWlkaXR5IG1pbmluZy6gLSBgZmFybV9lbnRyaWVzYDogbGlzdCBvZiBmYXJtcyB0byBqb2luLl0BLSBgcG9zaXRpb25faWRgOiBpZCBvZiB0aGUgb21uaXBvb2wgcG9zaXRpb24gdG8gYmUgZGVwb3NpdGVkIGludG8gdGhlIGxpcXVpZGl0eSBtaW5pbmcuANhFbWl0cyBgU2hhcmVzRGVwb3NpdGVkYCBldmVudCBmb3IgdGhlIGZpcnN0IGZhcm0gZW50cnkdAUVtaXRzIGBTaGFyZXNSZWRlcG9zaXRlZGAgZXZlbnQgZm9yIGVhY2ggZmFybSBlbnRyeSBhZnRlciB0aGUgZmlyc3Qgb25lcGFkZF9saXF1aWRpdHlfYW5kX2pvaW5fZmFybXMQATBmYXJtX2VudHJpZXNJAwERAUJvdW5kZWRWZWM8KEdsb2JhbEZhcm1JZCwgWWllbGRGYXJtSWQpLCBUOjpNYXhGYXJtRW50cmllc1BlckRlcG9zaXQ+AAEUYXNzZXQQAShUOjpBc3NldElkAAEYYW1vdW50GAEcQmFsYW5jZQABQG1pbl9zaGFyZXNfbGltaXTgATxPcHRpb248QmFsYW5jZT4ADixdAVRoaXMgZnVuY3Rpb24gYWxsb3dzIHVzZXIgdG8gYWRkIGxpcXVpZGl0eSB0aGVuIHVzZSB0aGF0IHNoYXJlcyB0byBqb2luIG11bHRpcGxlIGZhcm1zLgAsUGFyYW1ldGVyczpBAS0gYG9yaWdpbmA6IG93bmVyIG9mIHRoZSBvbW5pcG9vbCBwb3NpdGlvbiB0byBkZXBvc2l0IGludG8gdGhlIGxpcXVpZGl0eSBtaW5pbmcuoC0gYGZhcm1fZW50cmllc2A6IGxpc3Qgb2YgZmFybXMgdG8gam9pbi4VAS0gYGFzc2V0YDogaWQgb2YgdGhlIGFzc2V0IHRvIGJlIGRlcG9zaXRlZCBpbnRvIHRoZSBsaXF1aWRpdHkgbWluaW5nLikBLSBgYW1vdW50YDogYW1vdW50IG9mIHRoZSBhc3NldCB0byBiZSBkZXBvc2l0ZWQgaW50byB0aGUgbGlxdWlkaXR5IG1pbmluZy6FAS0gYG1pbl9zaGFyZXNfbGltaXRgOiBUaGUgbWluIGFtb3VudCBvZiBkZWx0YSBzaGFyZSBhc3NldCB0aGUgdXNlciBzaG91bGQgcmVjZWl2ZSBpbiB0aGUgcG9zaXRpb24A2EVtaXRzIGBTaGFyZXNEZXBvc2l0ZWRgIGV2ZW50IGZvciB0aGUgZmlyc3QgZmFybSBlbnRyeR0BRW1pdHMgYFNoYXJlc1JlZGVwb3NpdGVkYCBldmVudCBmb3IgZWFjaCBmYXJtIGVudHJ5IGFmdGVyIHRoZSBmaXJzdCBvbmUoZXhpdF9mYXJtcwgBKGRlcG9zaXRfaWQYASREZXBvc2l0SWQAATh5aWVsZF9mYXJtX2lkc1UDAdBCb3VuZGVkVmVjPFlpZWxkRmFybUlkLCBUOjpNYXhGYXJtRW50cmllc1BlckRlcG9zaXQ+AA88jEV4aXQgZnJvbSBhbGwgc3BlY2lmaWVkIHlpZWxkIGZhcm1zAF0BVGhpcyBmdW5jdGlvbiB3aWxsIGF0dGVtcHQgdG8gd2l0aGRyYXcgc2hhcmVzIGFuZCBjbGFpbSByZXdhcmRzIChpZiBhdmFpbGFibGUpIGZyb20gYWxsqHNwZWNpZmllZCB5aWVsZCBmYXJtcyBmb3IgYSBnaXZlbiBkZXBvc2l0LgAsUGFyYW1ldGVyczqoLSBgb3JpZ2luYDogYWNjb3VudCBvd25lciBvZiBkZXBvc2l0KG5mdCku3C0gYGRlcG9zaXRfaWRgOiBpZCBvZiB0aGUgZGVwb3NpdCB0byBjbGFpbSByZXdhcmRzIGZvci7gLSBgeWllbGRfZmFybV9pZHNgOiBpZChzKSBvZiB5aWVsZCBmYXJtKHMpIHRvIGV4aXQgZnJvbS4AGEVtaXRzOqwqIGBSZXdhcmRDbGFpbWVkYCBmb3IgZWFjaCBzdWNjZXNzZnVsIGNsYWltyCogYFNoYXJlc1dpdGhkcmF3bmAgZm9yIGVhY2ggc3VjY2Vzc2Z1bCB3aXRoZHJhd2Fs2CogYERlcG9zaXREZXN0cm95ZWRgIGlmIHRoZSBkZXBvc2l0IGlzIGZ1bGx5IHdpdGhkcmF3bgDAYWRkX2xpcXVpZGl0eV9zdGFibGVzd2FwX29tbmlwb29sX2FuZF9qb2luX2Zhcm1zDAE4c3RhYmxlX3Bvb2xfaWQQAShUOjpBc3NldElkAAFQc3RhYmxlX2Fzc2V0X2Ftb3VudHNdAwEFAUJvdW5kZWRWZWM8QXNzZXRBbW91bnQ8VDo6QXNzZXRJZD4sIENvbnN0VTMyPE1BWF9BU1NFVFNfSU5fUE9PTD4+AAEwZmFybV9lbnRyaWVzaQMBNQFPcHRpb248Qm91bmRlZFZlYzwoR2xvYmFsRmFybUlkLCBZaWVsZEZhcm1JZCksIFQ6OgpNYXhGYXJtRW50cmllc1BlckRlcG9zaXQ+PgAQQPhUaGlzIGZ1bmN0aW9uIGFsbG93cyB1c2VyIHRvIGFkZCBsaXF1aWRpdHkgdG8gc3RhYmxlc3dhcCBwb29sLNh0aGVuIGFkZGluZyB0aGUgc3RhYmxlIHNoYXJlcyBhcyBsaXF1aWRpdHkgdG8gb21uaXBvb2zUdGhlbiB1c2UgdGhhdCBvbW5pcG9vbCBzaGFyZXMgdG8gam9pbiBtdWx0aXBsZSBmYXJtcy4AjQFJZiBmYXJtIGVudHJpZXMgYXJlIG5vdCBzcGVjaWZpZWQgKGVtcHR5IHZlY3RvbyksIHRoZW4gdGhlIGxpcXVpZGl0aWVzIGFyZSBzdGlsbCBhZGRlZCB0byB0aGUgcG9vbHMALFBhcmFtZXRlcnM6QQEtIGBvcmlnaW5gOiBvd25lciBvZiB0aGUgb21uaXBvb2wgcG9zaXRpb24gdG8gZGVwb3NpdCBpbnRvIHRoZSBsaXF1aWRpdHkgbWluaW5nLgkBLSBgc3RhYmxlX3Bvb2xfaWRgOiBpZCBvZiB0aGUgc3RhYmxlc3dhcCBwb29sIHRvIGFkZCBsaXF1aWRpdHkgdG8uYQEtIGBzdGFibGVfYXNzZXRfYW1vdW50c2A6IGFtb3VudCBvZiBlYWNoIGFzc2V0IHRvIGJlIGRlcG9zaXRlZCBpbnRvIHRoZSBzdGFibGVzd2FwIHBvb2wuoC0gYGZhcm1fZW50cmllc2A6IGxpc3Qgb2YgZmFybXMgdG8gam9pbi4AsEVtaXRzIGBMaXF1aWRpdHlBZGRlZGAgZXZlbnRzIGZyb20gYm90aCBwb29s2EVtaXRzIGBTaGFyZXNEZXBvc2l0ZWRgIGV2ZW50IGZvciB0aGUgZmlyc3QgZmFybSBlbnRyeR0BRW1pdHMgYFNoYXJlc1JlZGVwb3NpdGVkYCBldmVudCBmb3IgZWFjaCBmYXJtIGVudHJ5IGFmdGVyIHRoZSBmaXJzdCBvbmUABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLj0DDDRzcF9hcml0aG1ldGljKHBlcl90aGluZ3MsUGVycXVpbnRpbGwAAAQAMAEMdTY0AABBAwQYT3B0aW9uBARUAUUDAQgQTm9uZQAAABBTb21lBABFAwAAAQAARQMMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nFHR5cGVzMExveWFsdHlDdXJ2ZQAACAFkaW5pdGlhbF9yZXdhcmRfcGVyY2VudGFnZT0BASRGaXhlZFUxMjgAAShzY2FsZV9jb2VmEAEMdTMyAABJAwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAU0DBFMAAAQAUQMBGFZlYzxUPgAATQMAAAQIEBAAUQMAAAJNAwBVAwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUARAEUwAABABZAwEYVmVjPFQ+AABZAwAAAhAAXQMMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAFhAwRTAAAEAGUDARhWZWM8VD4AAGEDDDhoeWRyYWR4X3RyYWl0cyhzdGFibGVzd2FwLEFzc2V0QW1vdW50BBxBc3NldElkARAACAEgYXNzZXRfaWQQARxBc3NldElkAAEYYW1vdW50GAEQdTEyOAAAZQMAAAJhAwBpAwQYT3B0aW9uBARUAUkDAQgQTm9uZQAAABBTb21lBABJAwAAAQAAbQMMKHBhbGxldF9vdGMYcGFsbGV0EENhbGwEBFQAARAscGxhY2Vfb3JkZXIUASBhc3NldF9pbhABKFQ6OkFzc2V0SWQAASRhc3NldF9vdXQQAShUOjpBc3NldElkAAEkYW1vdW50X2luGAEcQmFsYW5jZQABKGFtb3VudF9vdXQYARxCYWxhbmNlAAFIcGFydGlhbGx5X2ZpbGxhYmxlIAEQYm9vbAAASFhDcmVhdGUgYSBuZXcgT1RDIG9yZGVyBCAsUGFyYW1ldGVyczqkLSBgYXNzZXRfaW5gOiBBc3NldCB3aGljaCBpcyBiZWluZyBib3VnaHSgLSBgYXNzZXRfb3V0YDogQXNzZXQgd2hpY2ggaXMgYmVpbmcgc29sZNgtIGBhbW91bnRfaW5gOiBBbW91bnQgdGhhdCB0aGUgb3JkZXIgaXMgc2Vla2luZyB0byBidXnALSBgYW1vdW50X291dGA6IEFtb3VudCB0aGF0IHRoZSBvcmRlciBpcyBzZWxsaW5nSQEtIGBwYXJ0aWFsbHlfZmlsbGFibGVgOiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB1c2VycyBjYW4gZmlsbCB0aGUgb3JkZXIgcGFydGlhbGx5ADBWYWxpZGF0aW9uczp0LSBhc3NldF9pbiBtdXN0IGJlIHJlZ2lzdGVyZWRFAS0gYW1vdW50X2luIG11c3QgYmUgaGlnaGVyIHRoYW4gdGhlIGV4aXN0ZW50aWFsIGRlcG9zaXQgb2YgYXNzZXRfaW4gbXVsdGlwbGllZCBieXggIEV4aXN0ZW50aWFsRGVwb3NpdE11bHRpcGxpZXJNAS0gYW1vdW50X291dCBtdXN0IGJlIGhpZ2hlciB0aGFuIHRoZSBleGlzdGVudGlhbCBkZXBvc2l0IG9mIGFzc2V0X291dCBtdWx0aXBsaWVkIGJ5eCAgRXhpc3RlbnRpYWxEZXBvc2l0TXVsdGlwbGllcgAcRXZlbnRzOoQtIGBQbGFjZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC5IcGFydGlhbF9maWxsX29yZGVyCAEgb3JkZXJfaWQQARxPcmRlcklkAAEkYW1vdW50X2luGAEcQmFsYW5jZQABQHRGaWxsIGFuIE9UQyBvcmRlciAocGFydGlhbGx5KQQgLFBhcmFtZXRlcnM6dC0gYG9yZGVyX2lkYDogSUQgb2YgdGhlIG9yZGVy6C0gYGFtb3VudF9pbmA6IEFtb3VudCB3aXRoIHdoaWNoIHRoZSBvcmRlciBpcyBiZWluZyBmaWxsZWQAMFZhbGlkYXRpb25zOogtIG9yZGVyIG11c3QgYmUgcGFydGlhbGx5X2ZpbGxhYmxljQEtIGFmdGVyIHRoZSBwYXJ0aWFsX2ZpbGwsIHRoZSByZW1haW5pbmcgb3JkZXIuYW1vdW50X2luIG11c3QgYmUgaGlnaGVyIHRoYW4gdGhlIGV4aXN0ZW50aWFsIGRlcG9zaXTgICBvZiBhc3NldF9pbiBtdWx0aXBsaWVkIGJ5IEV4aXN0ZW50aWFsRGVwb3NpdE11bHRpcGxpZXKRAS0gYWZ0ZXIgdGhlIHBhcnRpYWxfZmlsbCwgdGhlIHJlbWFpbmluZyBvcmRlci5hbW91bnRfb3V0IG11c3QgYmUgaGlnaGVyIHRoYW4gdGhlIGV4aXN0ZW50aWFsIGRlcG9zaXTkICBvZiBhc3NldF9vdXQgbXVsdGlwbGllZCBieSBFeGlzdGVudGlhbERlcG9zaXRNdWx0aXBsaWVyABxFdmVudHM60GBQYXJ0aWFsbHlGaWxsZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4gRGVwcmVjYXRlZC7IYHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4oZmlsbF9vcmRlcgQBIG9yZGVyX2lkEAEcT3JkZXJJZAACIHhGaWxsIGFuIE9UQyBvcmRlciAoY29tcGxldGVseSkEICxQYXJhbWV0ZXJzOnQtIGBvcmRlcl9pZGA6IElEIG9mIHRoZSBvcmRlcgAcRXZlbnRzOqxgRmlsbGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuIERlcHJlY2F0ZWQuyGBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuMGNhbmNlbF9vcmRlcgQBIG9yZGVyX2lkEAEcT3JkZXJJZAADLGBDYW5jZWwgYW4gb3BlbiBPVEMgb3JkZXIEICxQYXJhbWV0ZXJzOnQtIGBvcmRlcl9pZGA6IElEIG9mIHRoZSBvcmRlcpgtIGBhc3NldGA6IEFzc2V0IHdoaWNoIGlzIGJlaW5nIGZpbGxlZKAtIGBhbW91bnRgOiBBbW91bnQgd2hpY2ggaXMgYmVpbmcgZmlsbGVkADBWYWxpZGF0aW9uczpcLSBjYWxsZXIgaXMgb3JkZXIgb3duZXIAoEVtaXRzIGBDYW5jZWxsZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMucQMMWHBhbGxldF9jaXJjdWl0X2JyZWFrZXIYcGFsbGV0EENhbGwEBFQAARhYc2V0X3RyYWRlX3ZvbHVtZV9saW1pdAgBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABSHRyYWRlX3ZvbHVtZV9saW1pdE0DASgodTMyLCB1MzIpAAAkkFNldCB0cmFkZSB2b2x1bWUgbGltaXQgZm9yIGFuIGFzc2V0LgAsUGFyYW1ldGVyczotAS0gYG9yaWdpbmA6IFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbC4gTXVzdCBiZSBgVXBkYXRlTGltaXRzT3JpZ2luYKAtIGBhc3NldF9pZGA6IFRoZSBpZGVudGlmaWVyIG9mIGFuIGFzc2V0KQEtIGB0cmFkZV92b2x1bWVfbGltaXRgOiBOZXcgdHJhZGUgdm9sdW1lIGxpbWl0IHJlcHJlc2VudGVkIGFzIGEgcGVyY2VudGFnZQDYRW1pdHMgYFRyYWRlVm9sdW1lTGltaXRDaGFuZ2VkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAFxzZXRfYWRkX2xpcXVpZGl0eV9saW1pdAgBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABPGxpcXVpZGl0eV9saW1pdHUDAUhPcHRpb248KHUzMiwgdTMyKT4AASSUU2V0IGFkZCBsaXF1aWRpdHkgbGltaXQgZm9yIGFuIGFzc2V0LgAsUGFyYW1ldGVyczotAS0gYG9yaWdpbmA6IFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbC4gTXVzdCBiZSBgVXBkYXRlTGltaXRzT3JpZ2luYKAtIGBhc3NldF9pZGA6IFRoZSBpZGVudGlmaWVyIG9mIGFuIGFzc2V0NQEtIGBsaXF1aWRpdHlfbGltaXRgOiBPcHRpb25hbCBhZGQgbGlxdWlkaXR5IGxpbWl0IHJlcHJlc2VudGVkIGFzIGEgcGVyY2VudGFnZQDcRW1pdHMgYEFkZExpcXVpZGl0eUxpbWl0Q2hhbmdlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgBoc2V0X3JlbW92ZV9saXF1aWRpdHlfbGltaXQIASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAATxsaXF1aWRpdHlfbGltaXR1AwFIT3B0aW9uPCh1MzIsIHUzMik+AAIkoFNldCByZW1vdmUgbGlxdWlkaXR5IGxpbWl0IGZvciBhbiBhc3NldC4ALFBhcmFtZXRlcnM6LQEtIGBvcmlnaW5gOiBUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwuIE11c3QgYmUgYFVwZGF0ZUxpbWl0c09yaWdpbmCgLSBgYXNzZXRfaWRgOiBUaGUgaWRlbnRpZmllciBvZiBhbiBhc3NldEEBLSBgbGlxdWlkaXR5X2xpbWl0YDogT3B0aW9uYWwgcmVtb3ZlIGxpcXVpZGl0eSBsaW1pdCByZXByZXNlbnRlZCBhcyBhIHBlcmNlbnRhZ2UA6EVtaXRzIGBSZW1vdmVMaXF1aWRpdHlMaW1pdENoYW5nZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AOGxvY2tkb3duX2Fzc2V0CAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEUdW50aWwQAURCbG9ja051bWJlckZvcjxUPgADKHRMb2NrZG93biBhbiBhc3NldCBmb3IgbWludGluZwCkQ2FuIGJlIGNhbGxlZCBvbmx5IGJ5IGFuIGF1dGhvcml0eSBvcmlnaW4ALFBhcmFtZXRlcnM6IQEtIGBvcmlnaW5gOiBUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwuIE11c3QgYmUgYEF1dGhvcml0eU9yaWdpbmCgLSBgYXNzZXRfaWRgOiBUaGUgaWRlbnRpZmllciBvZiBhbiBhc3NldOwtIGB1bnRpbGA6IFRoZSBibG9jayBudW1iZXIgdW50aWwgd2hpY2ggdGhlIGFzc2V0IGlzIGxvY2tlZADILy8vIEVtaXRzIGBBc3NldExvY2tkb3duZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC5MZm9yY2VfbGlmdF9sb2NrZG93bgQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAEKLhSZW1vdmUgYXNzZXQgbG9ja2Rvd24gcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUuAKRDYW4gYmUgY2FsbGVkIG9ubHkgYnkgYW4gYXV0aG9yaXR5IG9yaWdpbgAsUGFyYW1ldGVyczoAIQEtIGBvcmlnaW5gOiBUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwuIE11c3QgYmUgYEF1dGhvcml0eU9yaWdpbmCgLSBgYXNzZXRfaWRgOiBUaGUgaWRlbnRpZmllciBvZiBhbiBhc3NldADMRW1pdHMgYEFzc2V0TG9ja2Rvd25SZW1vdmVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuPHJlbGVhc2VfZGVwb3NpdAgBDHdobwABMFQ6OkFjY291bnRJZAABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAFOHBSZWxlYXNlIGRlcG9zaXQgb2YgYW4gYXNzZXQuADkBSXQgcmVsZWFzZXMgYWxsIHRoZSBwYWxsZXQgcmVzZXJ2ZWQgYmFsYW5jZSBvZiB0aGUgYXNzZXQgZm9yIHRoZSBnaXZlbiBhY2NvdW50ADUBQ2FuIGJlIGNhbGxlZCBieSBhbnkgb3JpZ2luLCBidXQgb25seSBpZiB0aGUgYXNzZXQgaXMgbm90IGluIGFjdGl2ZSBsb2NrZG93bi4A0FRoZSBjYWxsZXIgZG9lcyBub3QgcGF5IGZvciB0aGlzIGNhbGwgaWYgc3VjY2Vzc2Z1bC4ALFBhcmFtZXRlcnM6FQEtIGBvcmlnaW5gOiBUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwuIENhbiBiZSBzaWduZWQgb3Igcm9vdC7ALSBgd2hvYDogVGhlIGFjY291bnQgdGhhdCBpcyBzYXZpbmcgdGhlIGRlcG9zaXQuqC0gYGFzc2V0X2lkYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0LgC4RW1pdHMgYERlcG9zaXRSZWxlYXNlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy51AwQYT3B0aW9uBARUAU0DAQgQTm9uZQAAABBTb21lBABNAwAAAQAAeQMMVHBhbGxldF9yb3V0ZV9leGVjdXRvchhwYWxsZXQQQ2FsbAQEVAABFBBzZWxsFAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABJGFtb3VudF9pbhgBKFQ6OkJhbGFuY2UAAThtaW5fYW1vdW50X291dBgBKFQ6OkJhbGFuY2UAARRyb3V0ZX0DAURSb3V0ZTxUOjpBc3NldElkPgAANPxFeGVjdXRlcyBhIHNlbGwgd2l0aCBhIHNlcmllcyBvZiB0cmFkZXMgc3BlY2lmaWVkIGluIHRoZSByb3V0ZS4BAVRoZSBwcmljZSBmb3IgZWFjaCB0cmFkZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIEFNTS4AlC0gYG9yaWdpbmA6IFRoZSBleGVjdXRvciBvZiB0aGUgdHJhZGXELSBgYXNzZXRfaW5gOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgYXNzZXQgdG8gc2VsbNQtIGBhc3NldF9vdXRgOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgYXNzZXQgdG8gcmVjZWl2ZbwtIGBhbW91bnRfaW5gOiBUaGUgYW1vdW50IG9mIGBhc3NldF9pbmAgdG8gc2VsbAUBLSBgbWluX2Ftb3VudF9vdXRgOiBUaGUgbWluaW11bSBhbW91bnQgb2YgYGFzc2V0X291dGAgdG8gcmVjZWl2ZS7RAi0gYHJvdXRlYDogU2VyaWVzIG9mIFtgVHJhZGU8QXNzZXRJZD5gXSB0byBiZSBleGVjdXRlZC4gQSBbYFRyYWRlPEFzc2V0SWQ+YF0gc3BlY2lmaWVzIHRoZSBhc3NldCBwYWlyIChgYXNzZXRfaW5gLCBgYXNzZXRfb3V0YCkgYW5kIHRoZSBBTU0gKGBwb29sYCkgaW4gd2hpY2ggdGhlIHRyYWRlIGlzIGV4ZWN1dGVkLtwJCSAgIElmIG5vdCBzcGVjaWZpZWQsIHRoYW4gdGhlIG9uLWNoYWluIHJvdXRlIGlzIHVzZWQuGQEJCSAgIElmIG5vIG9uLWNoYWluIGlzIHByZXNlbnQsIHRoZW4gb21uaXBvb2wgcm91dGUgaXMgdXNlZCBhcyBkZWZhdWx0AJhFbWl0cyBgUm91dGVFeGVjdXRlZGAgd2hlbiBzdWNjZXNzZnVsLgxidXkUASBhc3NldF9pbhABKFQ6OkFzc2V0SWQAASRhc3NldF9vdXQQAShUOjpBc3NldElkAAEoYW1vdW50X291dBgBKFQ6OkJhbGFuY2UAATRtYXhfYW1vdW50X2luGAEoVDo6QmFsYW5jZQABFHJvdXRlfQMBRFJvdXRlPFQ6OkFzc2V0SWQ+AAE0+EV4ZWN1dGVzIGEgYnV5IHdpdGggYSBzZXJpZXMgb2YgdHJhZGVzIHNwZWNpZmllZCBpbiB0aGUgcm91dGUuAQFUaGUgcHJpY2UgZm9yIGVhY2ggdHJhZGUgaXMgZGV0ZXJtaW5lZCBieSB0aGUgY29ycmVzcG9uZGluZyBBTU0uAJQtIGBvcmlnaW5gOiBUaGUgZXhlY3V0b3Igb2YgdGhlIHRyYWRlKQEtIGBhc3NldF9pbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBhc3NldCB0byBiZSBzd2FwcGVkIHRvIGJ1eSBgYXNzZXRfb3V0YMQtIGBhc3NldF9vdXRgOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgYXNzZXQgdG8gYnV5wC0gYGFtb3VudF9vdXRgOiBUaGUgYW1vdW50IG9mIGBhc3NldF9vdXRgIHRvIGJ1eREBLSBgbWF4X2Ftb3VudF9pbmA6IFRoZSBtYXggYW1vdW50IG9mIGBhc3NldF9pbmAgdG8gc3BlbmQgb24gdGhlIGJ1eS7RAi0gYHJvdXRlYDogU2VyaWVzIG9mIFtgVHJhZGU8QXNzZXRJZD5gXSB0byBiZSBleGVjdXRlZC4gQSBbYFRyYWRlPEFzc2V0SWQ+YF0gc3BlY2lmaWVzIHRoZSBhc3NldCBwYWlyIChgYXNzZXRfaW5gLCBgYXNzZXRfb3V0YCkgYW5kIHRoZSBBTU0gKGBwb29sYCkgaW4gd2hpY2ggdGhlIHRyYWRlIGlzIGV4ZWN1dGVkLtwJCSAgIElmIG5vdCBzcGVjaWZpZWQsIHRoYW4gdGhlIG9uLWNoYWluIHJvdXRlIGlzIHVzZWQuGQEJCSAgIElmIG5vIG9uLWNoYWluIGlzIHByZXNlbnQsIHRoZW4gb21uaXBvb2wgcm91dGUgaXMgdXNlZCBhcyBkZWZhdWx0AJhFbWl0cyBgUm91dGVFeGVjdXRlZGAgd2hlbiBzdWNjZXNzZnVsLiRzZXRfcm91dGUIAShhc3NldF9wYWlyjQMBVEFzc2V0UGFpcjxUOjpBc3NldElkPgABJG5ld19yb3V0ZX0DAURSb3V0ZTxUOjpBc3NldElkPgACVLxTZXRzIHRoZSBvbi1jaGFpbiByb3V0ZSBmb3IgYSBnaXZlbiBhc3NldCBwYWlyLgD4VGhlIG5ldyByb3V0ZSBpcyB2YWxpZGF0ZWQgYnkgYmVpbmcgZXhlY3V0ZWQgaW4gYSBkcnktcnVuIG1vZGUAhQFJZiB0aGVyZSBpcyBubyByb3V0ZSBleHBsaWNpdGx5IHNldCBmb3IgYW4gYXNzZXQgcGFpciwgdGhlbiB3ZSB1c2UgdGhlIG9tbmlwb29sIHJvdXRlIGFzIGRlZmF1bHQuACkBV2hlbiBhIG5ldyByb3V0ZSBpcyBzZXQsIHdlIGNvbXBhcmUgaXQgdG8gdGhlIGV4aXN0aW5nIChvciBkZWZhdWx0KSByb3V0ZS6hAVRoZSBjb21wYXJpc29uIGhhcHBlbnMgYnkgY2FsY3VsYXRpbmcgc2VsbCBhbW91bnRfb3V0cyBmb3IgdGhlIHJvdXRlcywgYnV0IGFsc28gZm9yIHRoZSBpbnZlcnNlZCByb3V0ZXMuAGUBVGhlIHJvdXRlIGlzIHN0b3JlZCBpbiBhbiBvcmRlcmVkIG1hbm5lciwgYmFzZWQgb24gdGhlIG9kZXIgb2YgdGhlIGlkcyBpbiB0aGUgYXNzZXQgcGFpci4A9ElmIHRoZSByb3V0ZSBpcyBzZXQgc3VjY2Vzc2Z1bGx5LCB0aGVuIHRoZSBmZWUgaXMgcGF5ZWQgYmFjay4AqC0gYG9yaWdpbmA6IFRoZSBvcmlnaW4gb2YgdGhlIHJvdXRlIHNldHRlci0BLSBgYXNzZXRfcGFpcmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBhc3NldC1wYWlyIGZvciB3aGljaCB0aGUgcm91dGUgaXMgc2V04QItIGBuZXdfcm91dGVgOiBTZXJpZXMgb2YgW2BUcmFkZTxBc3NldElkPmBdIHRvIGJlIGV4ZWN1dGVkLiBBIFtgVHJhZGU8QXNzZXRJZD5gXSBzcGVjaWZpZXMgdGhlIGFzc2V0IHBhaXIgKGBhc3NldF9pbmAsIGBhc3NldF9vdXRgKSBhbmQgdGhlIEFNTSAoYHBvb2xgKSBpbiB3aGljaCB0aGUgdHJhZGUgaXMgZXhlY3V0ZWQuAJRFbWl0cyBgUm91dGVVcGRhdGVkYCB3aGVuIHN1Y2Nlc3NmdWwuACkBRmFpbHMgd2l0aCBgUm91dGVVcGRhdGVJc05vdFN1Y2Nlc3NmdWxgIGVycm9yIHdoZW4gZmFpbGVkIHRvIHNldCB0aGUgcm91dGUASGZvcmNlX2luc2VydF9yb3V0ZQgBKGFzc2V0X3BhaXKNAwFUQXNzZXRQYWlyPFQ6OkFzc2V0SWQ+AAEkbmV3X3JvdXRlfQMBRFJvdXRlPFQ6OkFzc2V0SWQ+AAM4kQFGb3JjZSBpbnNlcnRzIHRoZSBvbi1jaGFpbiByb3V0ZSBmb3IgYSBnaXZlbiBhc3NldCBwYWlyLCBzbyB0aGVyZSBpcyBubyBhbnkgdmFsaWRhdGlvbiBmb3IgdGhlIHJvdXRlAKhDYW4gb25seSBiZSBjYWxsZWQgYnkgVDo6Rm9yY2VJbnNlcnRPcmlnaW4AZQFUaGUgcm91dGUgaXMgc3RvcmVkIGluIGFuIG9yZGVyZWQgbWFubmVyLCBiYXNlZCBvbiB0aGUgb2RlciBvZiB0aGUgaWRzIGluIHRoZSBhc3NldCBwYWlyLgD0SWYgdGhlIHJvdXRlIGlzIHNldCBzdWNjZXNzZnVsbHksIHRoZW4gdGhlIGZlZSBpcyBwYXllZCBiYWNrLgCoLSBgb3JpZ2luYDogVGhlIG9yaWdpbiBvZiB0aGUgcm91dGUgc2V0dGVyLQEtIGBhc3NldF9wYWlyYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0LXBhaXIgZm9yIHdoaWNoIHRoZSByb3V0ZSBpcyBzZXThAi0gYG5ld19yb3V0ZWA6IFNlcmllcyBvZiBbYFRyYWRlPEFzc2V0SWQ+YF0gdG8gYmUgZXhlY3V0ZWQuIEEgW2BUcmFkZTxBc3NldElkPmBdIHNwZWNpZmllcyB0aGUgYXNzZXQgcGFpciAoYGFzc2V0X2luYCwgYGFzc2V0X291dGApIGFuZCB0aGUgQU1NIChgcG9vbGApIGluIHdoaWNoIHRoZSB0cmFkZSBpcyBleGVjdXRlZC4AlEVtaXRzIGBSb3V0ZVVwZGF0ZWRgIHdoZW4gc3VjY2Vzc2Z1bC4AIHNlbGxfYWxsEAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABOG1pbl9hbW91bnRfb3V0GAEoVDo6QmFsYW5jZQABFHJvdXRlfQMBRFJvdXRlPFQ6OkFzc2V0SWQ+AAQ4/EV4ZWN1dGVzIGEgc2VsbCB3aXRoIGEgc2VyaWVzIG9mIHRyYWRlcyBzcGVjaWZpZWQgaW4gdGhlIHJvdXRlLsRJdCBzZWxscyBhbGwgcmVkdWNpYmxlIHVzZXIgYmFsYW5jZSBvZiBgYXNzZXRfaW5gAQFUaGUgcHJpY2UgZm9yIGVhY2ggdHJhZGUgaXMgZGV0ZXJtaW5lZCBieSB0aGUgY29ycmVzcG9uZGluZyBBTU0uAJQtIGBvcmlnaW5gOiBUaGUgZXhlY3V0b3Igb2YgdGhlIHRyYWRlxC0gYGFzc2V0X2luYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0IHRvIHNlbGzULSBgYXNzZXRfb3V0YDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0IHRvIHJlY2VpdmUFAS0gYG1pbl9hbW91bnRfb3V0YDogVGhlIG1pbmltdW0gYW1vdW50IG9mIGBhc3NldF9vdXRgIHRvIHJlY2VpdmUu0QItIGByb3V0ZWA6IFNlcmllcyBvZiBbYFRyYWRlPEFzc2V0SWQ+YF0gdG8gYmUgZXhlY3V0ZWQuIEEgW2BUcmFkZTxBc3NldElkPmBdIHNwZWNpZmllcyB0aGUgYXNzZXQgcGFpciAoYGFzc2V0X2luYCwgYGFzc2V0X291dGApIGFuZCB0aGUgQU1NIChgcG9vbGApIGluIHdoaWNoIHRoZSB0cmFkZSBpcyBleGVjdXRlZC7cCQkgICBJZiBub3Qgc3BlY2lmaWVkLCB0aGFuIHRoZSBvbi1jaGFpbiByb3V0ZSBpcyB1c2VkLhkBCQkgICBJZiBubyBvbi1jaGFpbiBpcyBwcmVzZW50LCB0aGVuIG9tbmlwb29sIHJvdXRlIGlzIHVzZWQgYXMgZGVmYXVsdACYRW1pdHMgYFJvdXRlRXhlY3V0ZWRgIHdoZW4gc3VjY2Vzc2Z1bC4ABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLn0DDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBgQMEUwAABACJAwEYVmVjPFQ+AACBAww4aHlkcmFkeF90cmFpdHMYcm91dGVyFFRyYWRlBBxBc3NldElkARAADAEQcG9vbIUDAURQb29sVHlwZTxBc3NldElkPgABIGFzc2V0X2luEAEcQXNzZXRJZAABJGFzc2V0X291dBABHEFzc2V0SWQAAIUDDDhoeWRyYWR4X3RyYWl0cxhyb3V0ZXIgUG9vbFR5cGUEHEFzc2V0SWQBEAEYDFhZSwAAAAxMQlAAAQAoU3RhYmxlc3dhcAQAEAEcQXNzZXRJZAACACBPbW5pcG9vbAADABBBYXZlAAQADEhTTQAFAACJAwAAAoEDAI0DDDhoeWRyYWR4X3RyYWl0cxhyb3V0ZXIkQXNzZXRQYWlyBBxBc3NldElkARAACAEgYXNzZXRfaW4QARxBc3NldElkAAEkYXNzZXRfb3V0EAEcQXNzZXRJZAAAkQMMTHBhbGxldF9keW5hbWljX2ZlZXMYcGFsbGV0EENhbGwEBFQAAQg0c2V0X2Fzc2V0X2ZlZQgBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABGGNvbmZpZ5UDAVhBc3NldEZlZUNvbmZpZzxUOjpGZWU+AAAgiFNldCBmZWUgY29uZmlndXJhdGlvbiBmb3IgYW4gYXNzZXQAcQFUaGlzIGZ1bmN0aW9uIGFsbG93cyBzZXR0aW5nIGVpdGhlciBmaXhlZCBvciBkeW5hbWljIGZlZSBjb25maWd1cmF0aW9uIGZvciBhIHNwZWNpZmljIGFzc2V0LgAsIyBBcmd1bWVudHOYKiBgb3JpZ2luYCAtIEF1dGhvcml0eSBvcmlnaW4gcmVxdWlyZWSgKiBgYXNzZXRfaWRgIC0gVGhlIGFzc2V0IElEIHRvIGNvbmZpZ3VyZcQqIGBjb25maWdgIC0gRmVlIGNvbmZpZ3VyYXRpb24gKEZpeGVkIG9yIER5bmFtaWMpQHJlbW92ZV9hc3NldF9mZWUEASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAASANAVJlbW92ZSBmZWUgY29uZmlndXJhdGlvbiBmb3IgYW4gYXNzZXQgKHdpbGwgdXNlIGRlZmF1bHQgcGFyYW1ldGVycykALQFUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgYW55IGN1c3RvbSBmZWUgY29uZmlndXJhdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBhc3NldC59AUFmdGVyIHJlbW92YWwsIHRoZSBhc3NldCB3aWxsIHVzZSB0aGUgZGVmYXVsdCBkeW5hbWljIGZlZSBwYXJhbWV0ZXJzIGNvbmZpZ3VyZWQgaW4gdGhlIHJ1bnRpbWUuACwjIEFyZ3VtZW50c5gqIGBvcmlnaW5gIC0gQXV0aG9yaXR5IG9yaWdpbiByZXF1aXJlZNwqIGBhc3NldF9pZGAgLSBUaGUgYXNzZXQgSUQgdG8gcmVtb3ZlIGNvbmZpZ3VyYXRpb24gZm9yBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLpUDDExwYWxsZXRfZHluYW1pY19mZWVzFHR5cGVzOEFzc2V0RmVlQ29uZmlnBAxGZWUBIQMBCBRGaXhlZAgBJGFzc2V0X2ZlZSEDAQxGZWUAATBwcm90b2NvbF9mZWUhAwEMRmVlAAAAHER5bmFtaWMIAUBhc3NldF9mZWVfcGFyYW1zmQMBOEZlZVBhcmFtczxGZWU+AAFMcHJvdG9jb2xfZmVlX3BhcmFtc5kDAThGZWVQYXJhbXM8RmVlPgABAACZAwxMcGFsbGV0X2R5bmFtaWNfZmVlcxR0eXBlcyRGZWVQYXJhbXMEDEZlZQEhAwAQARxtaW5fZmVlIQMBDEZlZQABHG1heF9mZWUhAwEMRmVlAAEUZGVjYXk9AQEkRml4ZWRVMTI4AAE0YW1wbGlmaWNhdGlvbj0BASRGaXhlZFUxMjgAAJ0DDDhwYWxsZXRfc3Rha2luZxhwYWxsZXQQQ2FsbAQEVAABFEhpbml0aWFsaXplX3N0YWtpbmcAABxFAVN0YWtpbmcgcGFsbGV0IGluaXRpYWxpemF0aW9uLiBUaGlzIGNhbGwgd2lsbCByZXNlcnZlZCBgcG90YCdzIGJhbGFuY2UgdG8gcHJldmVudAUBYWNjb3VudCBkdXN0aW5nIGFuZCBzdGFydCBjb2xsZWN0aW5nIGZlZXMgZnJvbSB0cmFkZXMgYXMgcmV3YXJkcy4AaQFgcG90YOKAmXMgYWNjb3VudCBoYXMgdG8gaGF2ZSBhIGJhbGFuY2Ugd2hpY2ggd2lsbCBiZSByZXNlcnZlZCB0byBwcmV2ZW50IGFjY291bnQgZHVzdGluZy4AxEVtaXRzIGBTdGFraW5nSW5pdGlhbGl6ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AFHN0YWtlBAEYYW1vdW50GAEcQmFsYW5jZQABOKxTdGFrZSBgYW1vdW50YCBpbnRvIGEgbmV3IHN0YWtpbmcgcG9zaXRpb24uAFkBYHN0YWtlYCBsb2NrcyBzcGVjaWZpZWQgYGFtb3VudGAgaW50byBzdGFraW5nIGFuZCBjcmVhdGVzIG5ldyBORlQgcmVwcmVzZW50aW5nIHN0YWtpbmckcG9zaXRpb24uOQFVc2VycyBjYW4gc3Rha2UgYE5hdGl2ZUFzc2V0SWRgIGJhbGFuY2Ugd2hpY2ggaXMgbm90IHZlc3RlZCBvciBhbHJlYWR5IHN0YWtlZC4AMQFTdGFraW5nIHBhbGxldCBtdXN0IGJlIGluaXRpYWxpemVkIG90aGVyd2lzZSBleHRyaW5zaWMgd2lsbCBmYWlsIHdpdGggZXJyb3IuACxQYXJhbWV0ZXJzOlEBLSBgYW1vdW50YDogQW1vdW50IG9mIG5hdGl2ZSBhc3NldCB0byBiZSBzdGFrZWQuIGBhbW91bnRgIGNhbid0IGJlIHZlc3RlZCBvciBhbHJlYWR5GHN0YWtlZAC4RW1pdHMgYFBvc2l0aW9uQ3JlYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgA4aW5jcmVhc2Vfc3Rha2UIASxwb3NpdGlvbl9pZBgBRFQ6OlBvc2l0aW9uSXRlbUlkAAEYYW1vdW50GAEcQmFsYW5jZQACQF0BRXh0cmluc2ljIHRvIGluY3JlYXNlIHN0YWtlZCBhbW91bnQgb2YgZXhpc3Rpbmcgc3Rha2luZyBwb3NpdGlvbiBieSBzcGVjaWZpZWQgYGFtb3VudGAuAFUBYGluY3JlYXNlX3N0YWtlYCBpbmNyZWFzZXMgc3Rha2VkIGFtb3VudCBvZiBwb3NpdGlvbiBzcGVjaWZpZWQgYnkgYHBvc3Rpb25faWRgIGJ5IHRoZXxgYW1vdW50YCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuNQFTdGFraW5nIHBvc2l0aW9uIG11c3QgZXhpc3QgYW5kIGBvcmlnaW5gIGhhcyB0byBiZSB0aGUgb3duZXIgb2YgdGhlIHBvc2l0aW9uLvhVc2VycyBjYW4gc3Rha2UgdG9rZW5zIHdoaWNoIGFyZSBub3QgdmVzdGVkIG9yIGFscmVhZHkgc3Rha2VkLjUBUG9zaXRpb24ncyBwYXJhbXMgZS5nIHBvaW50cyBhcmUgdXBkYXRlZCB0byBvZmZzZXQgc3Rha2UgaW5jcmVhc2UgYW5kIHJld2FyZHP0YWNjdW11bGF0ZWQgdW50aWwgdGhpcyBwb2ludCBhcmUgcGFpZCBhbmQgbG9ja2VkIHRvIHRoZSB1c2VyLgAsUGFyYW1ldGVyczo5AS0gYHBvc2l0aW9uX2lkYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHBvc2l0aW9uIHdoaWNoIHN0YWtlIHdpbGwgYmUgaW5jcmVhc2VkLnEBLSBgYW1vdW50YDogQW1vdW50IG9mIG5hdGl2ZSBhc3NldCB0byBiZSBhZGRlZCB0byBzdGFrZWQgYW1vdW50LiBgYW1vdW50YCBjYW4ndCBiZSB2ZXN0ZWQgb3I4YWxyZWFkeSBzdGFrZWQApEVtaXRzIGBTdGFrZUFkZGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuABRjbGFpbQQBLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQAAzjgQ2xhaW0gcmV3YXJkcyBhY2N1bXVsYXRlZCBmb3Igc3BlY2lmaWMgc3Rha2luZyBwb3NpdGlvbi4AUQFGdW5jdGlvbiBjYWxjdWxhdGVzIGFtb3VudCBvZiByZXdhcmRzIHRvIHBheSBmb3Igc3BlY2lmaWVkIHN0YWtpbmcgcG9zaXRpb24gYmFzZWQgb25dAXRoZSBhbW91bnQgb2YgcG9pbnRzIHBvc2l0aW9uIGFjY3VtdWxhdGVkLiBGdW5jdGlvbiBhbHNvIHVubG9ja3MgYWxsIHRoZSByZXdhcmRzIGxvY2tlZOBmcm9tIGBpbmNyZWFzZV9zdGFrZWAgYmFzZWQgb24gdGhlIGFtb3VudCBvZiB0aGUgcG9pbnRzLgBpAVRoaXMgYWN0aW9uIGlzIHBlbmFsaXplZCBieSByZW1vdmluZyBhbGwgdGhlIHBvaW50cyBhbmQgcmV0dXJuaW5nIGFsbG9jYXRlZCB1bnBhaWQgcmV3YXJkc0xmb3IgcmVkaXN0cmlidXRpb24uACxQYXJhbWV0ZXJzOhUBLSBgcG9zaXRpb25faWRgOiBUaGUgaWRlbnRpZmllciBvZiB0aGUgcG9zaXRpb24gdG8gY2xhaW0gcmV3YXJkcyBmb3IuALRFbWl0cyBgUmV3YXJkc0NsYWltZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AHHVuc3Rha2UEASxwb3NpdGlvbl9pZBgBRFQ6OlBvc2l0aW9uSXRlbUlkAAQwSQFGdW5jdGlvbiBwYXlzIHJld2FyZHMsIHVubG9ja3MgYWxsIHRoZSBzdGFrZWQgYXNzZXRzIGFuZCBkZXN0cm95cyBzdGFraW5nIHBvc2l0aW9ubHNwZWNpZmllZCBieSBgcG9zaXRpb25faWRgLgBZAUZ1bmN0aW9uIGNhbGN1bGF0ZXMgYW5kIHBheXMgbGF0ZXN0IHJld2FyZHMsIHVubG9ja3MgYWxsIHRoZSBsb2NrZWQgcmV3YXJkcyBhbmQgc3Rha2VkIQF0b2tlbnMgZm9yIHN0YWtpbmcgcG9zaXRpb24gYW5kIGJ1cm5zIE5GVCByZXByZXNlbnRpbmcgc3Rha2luZyBwb3NpdGlvbi4hAVVucGFpZCBhbGxvY2F0ZWQgcmV3YXJkcyBhcmUgcmV0dXJuZWQgdG8gdGhlIFN0YWtpbmcgZm9yIHJlZGlzdHJpYnV0aW9uLgAsUGFyYW1ldGVyczoBAS0gYHBvc2l0aW9uX2lkYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHBvc2l0aW9uIHRvIGJlIGRlc3Ryb3llZC4A9EVtaXRzIGBSZXdhcmRzQ2xhaW1lZGAgYW5kIGBVbnN0YWtlZGAgZXZlbnRzIHdoZW4gc3VjY2Vzc2Z1bC4ABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLqEDDERwYWxsZXRfc3RhYmxlc3dhcBhwYWxsZXQQQ2FsbAQEVAABPCxjcmVhdGVfcG9vbBABLHNoYXJlX2Fzc2V0EAEoVDo6QXNzZXRJZAABGGFzc2V0c6UDAdBCb3VuZGVkVmVjPFQ6OkFzc2V0SWQsIENvbnN0VTMyPE1BWF9BU1NFVFNfSU5fUE9PTD4+AAE0YW1wbGlmaWNhdGlvbsgBDHUxNgABDGZlZSEDARxQZXJtaWxsAAA4vENyZWF0ZSBhIHN0YWJsZSBwb29sIHdpdGggZ2l2ZW4gbGlzdCBvZiBhc3NldHMuAPhBbGwgYXNzZXRzIG11c3QgYmUgY29ycmVjdGx5IHJlZ2lzdGVyZWQgaW4gYFQ6OkFzc2V0UmVnaXN0cnlgLm0BTm90ZSB0aGF0IHRoaXMgZG9lcyBub3Qgc2VlZCB0aGUgcG9vbCB3aXRoIGxpcXVpZGl0eS4gVXNlIGBhZGRfYXNzZXRzX2xpcXVpZGl0eWAgdG8gcHJvdmlkZUhpbml0aWFsIGxpcXVpZGl0eS4ALFBhcmFtZXRlcnM6mC0gYG9yaWdpbmA6IE11c3QgYmUgVDo6QXV0aG9yaXR5T3JpZ2lu1C0gYHNoYXJlX2Fzc2V0YDogUHJlcmVnaXN0ZXJlZCBzaGFyZSBhc3NldCBpZGVudGlmaWVydC0gYGFzc2V0c2A6IExpc3Qgb2YgQXNzZXQgaWRzlC0gYGFtcGxpZmljYXRpb25gOiBQb29sIGFtcGxpZmljYXRpb27wLSBgZmVlYDogZmVlIHRvIGJlIGFwcGxpZWQgb24gdHJhZGUgYW5kIGxpcXVpZGl0eSBvcGVyYXRpb25zAKBFbWl0cyBgUG9vbENyZWF0ZWRgIGV2ZW50IGlmIHN1Y2Nlc3NmdWwuPHVwZGF0ZV9wb29sX2ZlZQgBHHBvb2xfaWQQAShUOjpBc3NldElkAAEMZmVlIQMBHFBlcm1pbGwAAShIVXBkYXRlIHBvb2wncyBmZWUuAMxpZiBwb29sIGRvZXMgbm90IGV4aXN0LCBgUG9vbE5vdEZvdW5kYCBpcyByZXR1cm5lZC4ALFBhcmFtZXRlcnM6mC0gYG9yaWdpbmA6IE11c3QgYmUgVDo6QXV0aG9yaXR5T3JpZ2lubC0gYHBvb2xfaWRgOiBwb29sIHRvIHVwZGF0ZVQtIGBmZWVgOiBuZXcgcG9vbCBmZWUAnEVtaXRzIGBGZWVVcGRhdGVkYCBldmVudCBpZiBzdWNjZXNzZnVsLlB1cGRhdGVfYW1wbGlmaWNhdGlvbhABHHBvb2xfaWQQAShUOjpBc3NldElkAAFMZmluYWxfYW1wbGlmaWNhdGlvbsgBDHUxNgABLHN0YXJ0X2Jsb2NrEAFEQmxvY2tOdW1iZXJGb3I8VD4AASRlbmRfYmxvY2sQAURCbG9ja051bWJlckZvcjxUPgACKHBVcGRhdGUgcG9vbCdzIGFtcGxpZmljYXRpb24uACxQYXJhbWV0ZXJzOpgtIGBvcmlnaW5gOiBNdXN0IGJlIFQ6OkF1dGhvcml0eU9yaWdpbmwtIGBwb29sX2lkYDogcG9vbCB0byB1cGRhdGXcLSBgZmluYWxfYW1wbGlmaWNhdGlvbmA6IG5ldyBkZXNpcmVkIHBvb2wgYW1wbGlmaWNhdGlvbnUBLSBgc3RhcnRfYmxvY2tgOiBibG9jayBudW1iZXIgd2hlbiB0aGUgYW1wbGlmaWNhdGlvbiBzdGFydHMgdG8gbW92ZSB0b3dhcmRzIGZpbmFsX2FtcGxpY2F0aW9uOQEtIGBlbmRfYmxvY2tgOiBibG9jayBudW1iZXIgd2hlbiB0aGUgYW1wbGlmaWNhdGlvbiByZWFjaGVzIGZpbmFsX2FtcGxpZmljYXRpb24AxEVtaXRzIGBBbXBsaWZpY2F0aW9uVXBkYXRlZGAgZXZlbnQgaWYgc3VjY2Vzc2Z1bC40YWRkX2xpcXVpZGl0eQgBHHBvb2xfaWQQAShUOjpBc3NldElkAAEYYXNzZXRzXQMBBQFCb3VuZGVkVmVjPEFzc2V0QW1vdW50PFQ6OkFzc2V0SWQ+LCBDb25zdFUzMjxNQVhfQVNTRVRTX0lOX1BPT0w+PgADUHxBZGQgbGlxdWlkaXR5IHRvIHNlbGVjdGVkIHBvb2wuAIxVc2UgYGFkZF9hc3NldHNfbGlxdWlkaXR5YCBpbnN0ZWFkLrhUaGlzIGV4dHJpbnNpY3Mgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuADUBRmlyc3QgY2FsbCBvZiBgYWRkX2xpcXVpZGl0eWAgbXVzdCBwcm92aWRlICJpbml0aWFsIGxpcXVpZGl0eSIgb2YgYWxsIGFzc2V0cy4AhQFJZiB0aGVyZSBpcyBsaXF1aWRpdHkgYWxyZWFkeSBpbiB0aGUgcG9vbCwgTFAgY2FuIHByb3ZpZGUgbGlxdWlkaXR5IG9mIGFueSBudW1iZXIgb2YgcG9vbCBhc3NldHMuALRMUCBtdXN0IGhhdmUgc3VmZmljaWVudCBhbW91bnQgb2YgZWFjaCBhc3NldC4AvE9yaWdpbiBpcyBnaXZlbiBjb3JyZXNwb25kaW5nIGFtb3VudCBvZiBzaGFyZXMuACxQYXJhbWV0ZXJzOngtIGBvcmlnaW5gOiBsaXF1aWRpdHkgcHJvdmlkZXJQLSBgcG9vbF9pZGA6IFBvb2wgSWTILSBgYXNzZXRzYDogYXNzZXQgaWQgYW5kIGxpcXVpZGl0eSBhbW91bnQgcHJvdmlkZWQAtEVtaXRzIGBMaXF1aWRpdHlBZGRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLuBFbWl0cyBgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLlBhZGRfbGlxdWlkaXR5X3NoYXJlcxABHHBvb2xfaWQQAShUOjpBc3NldElkAAEYc2hhcmVzGAEcQmFsYW5jZQABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABQG1heF9hc3NldF9hbW91bnQYARxCYWxhbmNlAAQ8HQFBZGQgbGlxdWlkaXR5IHRvIHNlbGVjdGVkIHBvb2wgZ2l2ZW4gZXhhY3QgYW1vdW50IG9mIHNoYXJlcyB0byByZWNlaXZlLgA5AVNpbWlsYXIgdG8gYGFkZF9saXF1aWRpdHlgIGJ1dCBMUCBzcGVjaWZpZXMgZXhhY3QgYW1vdW50IG9mIHNoYXJlcyB0byByZWNlaXZlLgDdAVRoaXMgZnVuY3Rpb25hbGl0eSBpcyB1c2VkIG1haW5seSBieSBvbi1jaGFpbiByb3V0aW5nIHdoZW4gYSBzd2FwIGJldHdlZW4gT21uaXBvb2wgYXNzZXQgYW5kIHN0YWJsZSBhc3NldCBpcyBwZXJmb3JtZWQuACxQYXJhbWV0ZXJzOngtIGBvcmlnaW5gOiBsaXF1aWRpdHkgcHJvdmlkZXJQLSBgcG9vbF9pZGA6IFBvb2wgSWScLSBgc2hhcmVzYDogYW1vdW50IG9mIHNoYXJlcyB0byByZWNlaXZl6C0gYGFzc2V0X2lkYDogYXNzZXQgaWQgb2YgYW4gYXNzZXQgdG8gcHJvdmlkZSBhcyBsaXF1aWRpdHnoLSBgbWF4X2Fzc2V0X2Ftb3VudGA6IHNsaXBwYWdlIGxpbWl0LiBNYXggYW1vdW50IG9mIGFzc2V0LgC0RW1pdHMgYExpcXVpZGl0eUFkZGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwu4EVtaXRzIGBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuaHJlbW92ZV9saXF1aWRpdHlfb25lX2Fzc2V0EAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAATBzaGFyZV9hbW91bnQYARxCYWxhbmNlAAE4bWluX2Ftb3VudF9vdXQYARxCYWxhbmNlAAVEkFJlbW92ZSBsaXF1aWRpdHkgZnJvbSBzZWxlY3RlZCBwb29sLgDIV2l0aGRyYXdzIGxpcXVpZGl0eSBvZiBzZWxlY3RlZCBhc3NldCBmcm9tIGEgcG9vbC4AMQFTaGFyZSBhbW91bnQgaXMgYnVybmVkIGFuZCBMUCByZWNlaXZlcyBjb3JyZXNwb25kaW5nIGFtb3VudCBvZiBjaG9zZW4gYXNzZXQuALBXaXRoZHJhdyBmZWUgaXMgYXBwbGllZCB0byB0aGUgYXNzZXQgYW1vdW50LgAsUGFyYW1ldGVyczp4LSBgb3JpZ2luYDogbGlxdWlkaXR5IHByb3ZpZGVyUC0gYHBvb2xfaWRgOiBQb29sIElkkC0gYGFzc2V0X2lkYDogaWQgb2YgYXNzZXQgdG8gcmVjZWl2ZbgtICdzaGFyZV9hbW91bnQnOiBhbW91bnQgb2Ygc2hhcmVzIHRvIHdpdGhkcmF3tC0gJ21pbl9hbW91bnRfb3V0JzogbWluaW11bSBhbW91bnQgdG8gcmVjZWl2ZQC8RW1pdHMgYExpcXVpZGl0eVJlbW92ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC7gRW1pdHMgYHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC5Ud2l0aGRyYXdfYXNzZXRfYW1vdW50EAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAFAbWF4X3NoYXJlX2Ftb3VudBgBHEJhbGFuY2UABjRNAVJlbW92ZSBsaXF1aWRpdHkgZnJvbSBzZWxlY3RlZCBwb29sIGJ5IHNwZWNpZnlpbmcgZXhhY3QgYW1vdW50IG9mIGFzc2V0IHRvIHJlY2VpdmUuAMkBU2ltaWxhciB0byBgcmVtb3ZlX2xpcXVpZGl0eV9vbmVfYXNzZXRgIGJ1dCBMUCBzcGVjaWZpZXMgZXhhY3QgYW1vdW50IG9mIGFzc2V0IHRvIHJlY2VpdmUgaW5zdGVhZCBvZiBzaGFyZSBhbW91bnQuACxQYXJhbWV0ZXJzOngtIGBvcmlnaW5gOiBsaXF1aWRpdHkgcHJvdmlkZXJQLSBgcG9vbF9pZGA6IFBvb2wgSWSQLSBgYXNzZXRfaWRgOiBpZCBvZiBhc3NldCB0byByZWNlaXZlmC0gJ2Ftb3VudCc6IGFtb3VudCBvZiBhc3NldCB0byByZWNlaXZlDQEtICdtYXhfc2hhcmVfYW1vdW50JzogU2xpcHBhZ2UgbGltaXQuIE1heCBhbW91bnQgb2Ygc2hhcmVzIHRvIGJ1cm4uALxFbWl0cyBgTGlxdWlkaXR5UmVtb3ZlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLuBFbWl0cyBgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLhBzZWxsFAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAASBhc3NldF9pbhABKFQ6OkFzc2V0SWQAASRhc3NldF9vdXQQAShUOjpBc3NldElkAAEkYW1vdW50X2luGAEcQmFsYW5jZQABOG1pbl9idXlfYW1vdW50GAEcQmFsYW5jZQAHNLRFeGVjdXRlIGEgc3dhcCBvZiBgYXNzZXRfaW5gIGZvciBgYXNzZXRfb3V0YC4ALFBhcmFtZXRlcnM6gC0gYG9yaWdpbmA6IG9yaWdpbiBvZiB0aGUgY2FsbGVyZC0gYHBvb2xfaWRgOiBJZCBvZiBhIHBvb2yoLSBgYXNzZXRfaW5gOiBJRCBvZiBhc3NldCBzb2xkIHRvIHRoZSBwb29svC0gYGFzc2V0X291dGA6IElEIG9mIGFzc2V0IGJvdWdodCBmcm9tIHRoZSBwb29s1C0gYGFtb3VudF9pbmA6IEFtb3VudCBvZiBhc3NldCB0byBiZSBzb2xkIHRvIHRoZSBwb29s2C0gYG1pbl9idXlfYW1vdW50YDogTWluaW11bSBhbW91bnQgcmVxdWlyZWQgdG8gcmVjZWl2ZQDcRW1pdHMgYFNlbGxFeGVjdXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLiBEZXByZWNhdGVkLuBFbWl0cyBgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgAMYnV5FAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAASRhc3NldF9vdXQQAShUOjpBc3NldElkAAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEoYW1vdW50X291dBgBHEJhbGFuY2UAATxtYXhfc2VsbF9hbW91bnQYARxCYWxhbmNlAAg0tEV4ZWN1dGUgYSBzd2FwIG9mIGBhc3NldF9vdXRgIGZvciBgYXNzZXRfaW5gLgAsUGFyYW1ldGVyczosLSBgb3JpZ2luYDpkLSBgcG9vbF9pZGA6IElkIG9mIGEgcG9vbLwtIGBhc3NldF9vdXRgOiBJRCBvZiBhc3NldCBib3VnaHQgZnJvbSB0aGUgcG9vbKgtIGBhc3NldF9pbmA6IElEIG9mIGFzc2V0IHNvbGQgdG8gdGhlIHBvb2zgLSBgYW1vdW50X291dGA6IEFtb3VudCBvZiBhc3NldCB0byByZWNlaXZlIGZyb20gdGhlIHBvb2zYLSBgbWF4X3NlbGxfYW1vdW50YDogTWF4aW11bSBhbW91bnQgYWxsb3dlZCB0byBiZSBzb2xkANhFbWl0cyBgQnV5RXhlY3V0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4gRGVwcmVjYXRlZC7gRW1pdHMgYHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AYHNldF9hc3NldF90cmFkYWJsZV9zdGF0ZQwBHHBvb2xfaWQQAShUOjpBc3NldElkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEUc3RhdGWpAwEsVHJhZGFiaWxpdHkACUDgVXBkYXRlIHRoZSB0cmFkYWJsZSBzdGF0ZSBvZiBhIHNwZWNpZmljIGFzc2V0IGluIGEgcG9vbC4AnQNUaGlzIGZ1bmN0aW9uIGFsbG93cyB1cGRhdGluZyB0aGUgdHJhZGFiaWxpdHkgc3RhdGUgb2YgYW4gYXNzZXQgd2l0aGluIGEgcG9vbC4gVGhlIHRyYWRhYmlsaXR5IHN0YXRlIGRldGVybWluZXMgd2hldGhlciB0aGUgYXNzZXQgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZmljIG9wZXJhdGlvbnMgc3VjaCBhcyBhZGRpbmcgbGlxdWlkaXR5LCByZW1vdmluZyBsaXF1aWRpdHksIGJ1eWluZywgb3Igc2VsbGluZy4ALFBhcmFtZXRlcnM6xC0gYG9yaWdpbmA6IE11c3QgYmUgYFQ6OlVwZGF0ZVRyYWRhYmlsaXR5T3JpZ2luYC7ULSBgcG9vbF9pZGA6IFRoZSBJRCBvZiB0aGUgcG9vbCBjb250YWluaW5nIHRoZSBhc3NldC4tAS0gYGFzc2V0X2lkYDogVGhlIElEIG9mIHRoZSBhc3NldCB3aG9zZSB0cmFkYWJpbGl0eSBzdGF0ZSBpcyB0byBiZSB1cGRhdGVkLsgtIGBzdGF0ZWA6IFRoZSBuZXcgdHJhZGFiaWxpdHkgc3RhdGUgb2YgdGhlIGFzc2V0LgDMRW1pdHMgYFRyYWRhYmxlU3RhdGVVcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuACAjIEVycm9yc9wtIGBQb29sTm90Rm91bmRgOiBJZiB0aGUgc3BlY2lmaWVkIHBvb2wgZG9lcyBub3QgZXhpc3QuDQEtIGBBc3NldE5vdEluUG9vbGA6IElmIHRoZSBzcGVjaWZpZWQgYXNzZXQgaXMgbm90IHBhcnQgb2YgdGhlIHBvb2wuAEByZW1vdmVfbGlxdWlkaXR5DAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAATBzaGFyZV9hbW91bnQYARxCYWxhbmNlAAE8bWluX2Ftb3VudHNfb3V0XQMBBQFCb3VuZGVkVmVjPEFzc2V0QW1vdW50PFQ6OkFzc2V0SWQ+LCBDb25zdFUzMjxNQVhfQVNTRVRTX0lOX1BPT0w+PgAKbMBSZW1vdmUgbGlxdWlkaXR5IGZyb20gYSBzZWxlY3RlZCBwb29sIHVuaWZvcm1seS4AMQFUaGlzIGZ1bmN0aW9uIGFsbG93cyBhIGxpcXVpZGl0eSBwcm92aWRlciB0byB3aXRoZHJhdyBsaXF1aWRpdHkgZnJvbSBhIHBvb2wulQFUaGUgcHJvdmlkZXIgc3BlY2lmaWVzIHRoZSBhbW91bnQgb2Ygc2hhcmVzIHRvIGJ1cm4gYW5kIHRoZSBtaW5pbXVtIGFtb3VudHMgb2YgZWFjaCBhc3NldCB0byByZWNlaXZlLgAsUGFyYW1ldGVyczqMLSBgb3JpZ2luYDogVGhlIGxpcXVpZGl0eSBwcm92aWRlci78LSBgcG9vbF9pZGA6IFRoZSBJRCBvZiB0aGUgcG9vbCBmcm9tIHdoaWNoIHRvIHJlbW92ZSBsaXF1aWRpdHkuvC0gYHNoYXJlX2Ftb3VudGA6IFRoZSBhbW91bnQgb2Ygc2hhcmVzIHRvIGJ1cm4ueQEtIGBtaW5fYW1vdW50c19vdXRgOiBBIGJvdW5kZWQgdmVjdG9yIHNwZWNpZnlpbmcgdGhlIG1pbmltdW0gYW1vdW50cyBvZiBlYWNoIGFzc2V0IHRvIHJlY2VpdmUuALxFbWl0cyBgTGlxdWlkaXR5UmVtb3ZlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLuBFbWl0cyBgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgAgIyBFcnJvcnPYLSBgSW52YWxpZEFzc2V0QW1vdW50YDogSWYgdGhlIGBzaGFyZV9hbW91bnRgIGlzIHplcm8uEQEtIGBJbnN1ZmZpY2llbnRTaGFyZXNgOiBJZiB0aGUgcHJvdmlkZXIgZG9lcyBub3QgaGF2ZSBlbm91Z2ggc2hhcmVzLtwtIGBQb29sTm90Rm91bmRgOiBJZiB0aGUgc3BlY2lmaWVkIHBvb2wgZG9lcyBub3QgZXhpc3Qu/C0gYFVua25vd25EZWNpbWFsc2A6IElmIHRoZSBhc3NldCBkZWNpbWFscyBjYW5ub3QgYmUgcmV0cmlldmVkLlkBLSBgSW5jb3JyZWN0QXNzZXRzYDogSWYgdGhlIHByb3ZpZGVkIGBtaW5fYW1vdW50c19vdXRgIGRvZXMgbm90IG1hdGNoIHRoZSBwb29sIGFzc2V0cy74LSBgTm90QWxsb3dlZGA6IElmIHRoZSBhc3NldCBpcyBub3QgYWxsb3dlZCBmb3IgdGhlIG9wZXJhdGlvbi5RAS0gYFNsaXBwYWdlTGltaXRgOiBJZiB0aGUgYW1vdW50IHJlY2VpdmVkIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIG1pbmltdW0gYW1vdW50LqUBLSBgSW5zdWZmaWNpZW50TGlxdWlkaXR5UmVtYWluaW5nYDogSWYgdGhlIHJlbWFpbmluZyBsaXF1aWRpdHkgaW4gdGhlIHBvb2wgaXMgYmVsb3cgdGhlIG1pbmltdW0gcmVxdWlyZWQuADAjIEludmFyaWFudHNFAS0gRW5zdXJlcyB0aGF0IHRoZSBwb29sJ3MgcmVzZXJ2ZXMgYXJlIHVwZGF0ZWQgY29ycmVjdGx5IGFmdGVyIGxpcXVpZGl0eSByZW1vdmFsLsgtIEVuc3VyZXMgdGhhdCB0aGUgcG9vbCdzIGludmFyaWFudCBpcyBtYWludGFpbmVkLlRjcmVhdGVfcG9vbF93aXRoX3BlZ3MYASxzaGFyZV9hc3NldBABKFQ6OkFzc2V0SWQAARhhc3NldHOlAwHQQm91bmRlZFZlYzxUOjpBc3NldElkLCBDb25zdFUzMjxNQVhfQVNTRVRTX0lOX1BPT0w+PgABNGFtcGxpZmljYXRpb27IAQx1MTYAAQxmZWUhAwEcUGVybWlsbAABKHBlZ19zb3VyY2WtAwF0Qm91bmRlZFBlZ1NvdXJjZXM8VDo6QXNzZXRJZD4AAThtYXhfcGVnX3VwZGF0ZcEDARxQZXJiaWxsAAt06ENyZWF0ZSBhIHN0YWJsZSBwb29sIHdpdGggYSBnaXZlbiBsaXN0IG9mIGFzc2V0cyBhbmQgcGVncy4AbQJUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgYSBuZXcgc3RhYmxlIHBvb2wgd2l0aCBzcGVjaWZpZWQgYXNzZXRzLCBhbXBsaWZpY2F0aW9uLCBmZWUsIGFuZCBwZWcgc291cmNlcy4gVGhlIHBvb2wgaXMgaWRlbnRpZmllZCBieSBhIHNoYXJlIGFzc2V0LgCNAlBlZyB0YXJnZXQgcHJpY2UgaXMgZGV0ZXJtaW5lZCBieSByZXRyaWV2aW5nIHRoZSB0YXJnZXQgcGVnIGZyb20gdGhlIG9yYWNsZSAtIGl0IGlzIHRoZSBwcmljZSBvZiB0aGUgYXNzZXQgZnJvbSB0aGUgcGVnIHNvdXJjZWRlbm9taW5hdGVkIGluIHRoZSBvdGhlciBwb29sIGFzc2V0cy4ALFBhcmFtZXRlcnM6pC0gYG9yaWdpbmA6IE11c3QgYmUgYFQ6OkF1dGhvcml0eU9yaWdpbmAu2C0gYHNoYXJlX2Fzc2V0YDogUHJlcmVnaXN0ZXJlZCBzaGFyZSBhc3NldCBpZGVudGlmaWVyLuQtIGBhc3NldHNgOiBMaXN0IG9mIGFzc2V0IElEcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcG9vbC7ALSBgYW1wbGlmaWNhdGlvbmA6IFBvb2wgYW1wbGlmaWNhdGlvbiBwYXJhbWV0ZXIu9C0gYGZlZWA6IEZlZSB0byBiZSBhcHBsaWVkIG9uIHRyYWRlIGFuZCBsaXF1aWRpdHkgb3BlcmF0aW9ucy49AS0gYHBlZ19zb3VyY2VgOiBCb3VuZGVkIHZlY3RvciBzcGVjaWZ5aW5nIHRoZSBzb3VyY2Ugb2YgdGhlIHBlZyBmb3IgZWFjaCBhc3NldC7kLSBgbWF4X3BlZ191cGRhdGVgOiBNYXhpbXVtIGFsbG93ZWQgcGVnIHVwZGF0ZSBwZXIgYmxvY2suAKBFbWl0cyBgUG9vbENyZWF0ZWRgIGV2ZW50IGlmIHN1Y2Nlc3NmdWwuyEVtaXRzIGBBbXBsaWZpY2F0aW9uQ2hhbmdpbmdgIGV2ZW50IGlmIHN1Y2Nlc3NmdWwuACAjIEVycm9yc00BLSBgSW5jb3JyZWN0QXNzZXRzYDogSWYgdGhlIGFzc2V0cyBhcmUgdGhlIHNhbWUgb3IgbGVzcyB0aGFuIDIgYXNzZXRzIGFyZSBwcm92aWRlZC4NAS0gYE1heEFzc2V0c0V4Y2VlZGVkYDogSWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIGFzc2V0cyBpcyBleGNlZWRlZC78LSBgUG9vbEV4aXN0c2A6IElmIGEgcG9vbCB3aXRoIHRoZSBnaXZlbiBhc3NldHMgYWxyZWFkeSBleGlzdHMuIQEtIGBTaGFyZUFzc2V0SW5Qb29sQXNzZXRzYDogSWYgdGhlIHNoYXJlIGFzc2V0IGlzIGFtb25nIHRoZSBwb29sIGFzc2V0cy5ZAS0gYEFzc2V0Tm90UmVnaXN0ZXJlZGA6IElmIG9uZSBvciBtb3JlIGFzc2V0cyBhcmUgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIEFzc2V0UmVnaXN0cnkuEQEtIGBJbnZhbGlkQW1wbGlmaWNhdGlvbmA6IElmIHRoZSBhbXBsaWZpY2F0aW9uIHBhcmFtZXRlciBpcyBpbnZhbGlkLvAtIGBJbmNvcnJlY3RJbml0aWFsUGVnc2A6IElmIHRoZSBpbml0aWFsIHBlZ3MgYXJlIGluY29ycmVjdC4ZAS0gYE1pc3NpbmdUYXJnZXRQZWdPcmFjbGVgOiBJZiB0aGUgdGFyZ2V0IHBlZyBvcmFjbGUgZW50cnkgaXMgbWlzc2luZy4JAS0gYEluY29ycmVjdEFzc2V0RGVjaW1hbHNgOiBJZiB0aGUgYXNzZXRzIGhhdmUgZGlmZmVyZW50IGRlY2ltYWxzLgBQYWRkX2Fzc2V0c19saXF1aWRpdHkMARxwb29sX2lkEAEoVDo6QXNzZXRJZAABGGFzc2V0c10DAQUBQm91bmRlZFZlYzxBc3NldEFtb3VudDxUOjpBc3NldElkPiwgQ29uc3RVMzI8TUFYX0FTU0VUU19JTl9QT09MPj4AAShtaW5fc2hhcmVzGAEcQmFsYW5jZQAMSHxBZGQgbGlxdWlkaXR5IHRvIHNlbGVjdGVkIHBvb2wuAFEBRmlyc3QgY2FsbCBvZiBgYWRkX2Fzc2V0c19saXF1aWRpdHlgIG11c3QgcHJvdmlkZSAiaW5pdGlhbCBsaXF1aWRpdHkiIG9mIGFsbCBhc3NldHMuAIUBSWYgdGhlcmUgaXMgbGlxdWlkaXR5IGFscmVhZHkgaW4gdGhlIHBvb2wsIExQIGNhbiBwcm92aWRlIGxpcXVpZGl0eSBvZiBhbnkgbnVtYmVyIG9mIHBvb2wgYXNzZXRzLgC0TFAgbXVzdCBoYXZlIHN1ZmZpY2llbnQgYW1vdW50IG9mIGVhY2ggYXNzZXQuALxPcmlnaW4gaXMgZ2l2ZW4gY29ycmVzcG9uZGluZyBhbW91bnQgb2Ygc2hhcmVzLgAsUGFyYW1ldGVyczp4LSBgb3JpZ2luYDogbGlxdWlkaXR5IHByb3ZpZGVyUC0gYHBvb2xfaWRgOiBQb29sIElkyC0gYGFzc2V0c2A6IGFzc2V0IGlkIGFuZCBsaXF1aWRpdHkgYW1vdW50IHByb3ZpZGVkzC0gYG1pbl9zaGFyZXNgOiBtaW5pbXVtIGFtb3VudCBvZiBzaGFyZXMgdG8gcmVjZWl2ZQC0RW1pdHMgYExpcXVpZGl0eUFkZGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwu4EVtaXRzIGBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuXHVwZGF0ZV9hc3NldF9wZWdfc291cmNlDAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAShwZWdfc291cmNlsQMBVFBlZ1NvdXJjZTxUOjpBc3NldElkPgANTNRVcGRhdGUgdGhlIHBlZyBzb3VyY2UgZm9yIGEgc3BlY2lmaWMgYXNzZXQgaW4gYSBwb29sLgAhAVRoaXMgZnVuY3Rpb24gYWxsb3dzIHVwZGF0aW5nIHRoZSBwZWcgc291cmNlIGZvciBhbiBhc3NldCB3aXRoaW4gYSBwb29sLkUBVGhlIHBvb2wgbXVzdCBleGlzdCBhbmQgaGF2ZSBwZWdzIGNvbmZpZ3VyZWQuIFRoZSBhc3NldCBtdXN0IGJlIHBhcnQgb2YgdGhlIHBvb2wuDQFUaGUgY3VycmVudCBwcmljZSBpcyBhbHdheXMgcHJlc2VydmVkIHdoZW4gdXBkYXRpbmcgdGhlIHBlZyBzb3VyY2UuACxQYXJhbWV0ZXJzOqQtIGBvcmlnaW5gOiBNdXN0IGJlIGBUOjpBdXRob3JpdHlPcmlnaW5gLtQtIGBwb29sX2lkYDogVGhlIElEIG9mIHRoZSBwb29sIGNvbnRhaW5pbmcgdGhlIGFzc2V0LhEBLSBgYXNzZXRfaWRgOiBUaGUgSUQgb2YgdGhlIGFzc2V0IHdob3NlIHBlZyBzb3VyY2UgaXMgdG8gYmUgdXBkYXRlZC7ELSBgcGVnX3NvdXJjZWA6IFRoZSBuZXcgcGVnIHNvdXJjZSBmb3IgdGhlIGFzc2V0LgDMRW1pdHMgYFBvb2xQZWdTb3VyY2VVcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuACAjIEVycm9yc9wtIGBQb29sTm90Rm91bmRgOiBJZiB0aGUgc3BlY2lmaWVkIHBvb2wgZG9lcyBub3QgZXhpc3Qu7C0gYE5vUGVnU291cmNlYDogSWYgdGhlIHBvb2wgZG9lcyBub3QgaGF2ZSBwZWdzIGNvbmZpZ3VyZWQuDQEtIGBBc3NldE5vdEluUG9vbGA6IElmIHRoZSBzcGVjaWZpZWQgYXNzZXQgaXMgbm90IHBhcnQgb2YgdGhlIHBvb2wuAGh1cGRhdGVfcG9vbF9tYXhfcGVnX3VwZGF0ZQgBHHBvb2xfaWQQAShUOjpBc3NldElkAAE4bWF4X3BlZ191cGRhdGXBAwEcUGVyYmlsbAAOQNBVcGRhdGUgdGhlIG1heGltdW0gcGVnIHVwZGF0ZSBwZXJjZW50YWdlIGZvciBhIHBvb2wuACEBVGhpcyBmdW5jdGlvbiBhbGxvd3MgdXBkYXRpbmcgdGhlIG1heGltdW0gcGVyY2VudGFnZSBieSB3aGljaCBwZWcgdmFsdWVzqGNhbiBjaGFuZ2UgaW4gYSBwb29sIHdpdGggcGVncyBjb25maWd1cmVkLgAsUGFyYW1ldGVyczqkLSBgb3JpZ2luYDogTXVzdCBiZSBgVDo6QXV0aG9yaXR5T3JpZ2luYC6oLSBgcG9vbF9pZGA6IFRoZSBJRCBvZiB0aGUgcG9vbCB0byB1cGRhdGUu6C0gYG1heF9wZWdfdXBkYXRlYDogVGhlIG5ldyBtYXhpbXVtIHBlZyB1cGRhdGUgcGVyY2VudGFnZS4A2EVtaXRzIGBQb29sTWF4UGVnVXBkYXRlVXBkYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgAgIyBFcnJvcnPcLSBgUG9vbE5vdEZvdW5kYDogSWYgdGhlIHNwZWNpZmllZCBwb29sIGRvZXMgbm90IGV4aXN0LuwtIGBOb1BlZ1NvdXJjZWA6IElmIHRoZSBwb29sIGRvZXMgbm90IGhhdmUgcGVncyBjb25maWd1cmVkLgAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMupQMMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEQBFMAAAQAWQMBGFZlYzxUPgAAqQMMRHBhbGxldF9zdGFibGVzd2FwFHR5cGVzLFRyYWRhYmlsaXR5AAAEARBiaXRzCAEIdTgAAK0DDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBsQMEUwAABAC9AwEYVmVjPFQ+AACxAwxEcGFsbGV0X3N0YWJsZXN3YXAUdHlwZXMkUGVnU291cmNlBBxBc3NldElkARABDBRWYWx1ZQQAKQMBHFBlZ1R5cGUAAAAYT3JhY2xlBAC1AwF8KFNvdXJjZSwgT3JhY2xlUGVyaW9kLCBBc3NldElkKQABACBNTU9yYWNsZQQAQQEBKEV2bUFkZHJlc3MAAgAAtQMAAAQM/QG5AxAAuQMMOGh5ZHJhZHhfdHJhaXRzGG9yYWNsZTBPcmFjbGVQZXJpb2QAARgkTGFzdEJsb2NrAAAAFFNob3J0AAEAKFRlbk1pbnV0ZXMAAgAQSG91cgADAAxEYXkABAAQV2VlawAFAAC9AwAAArEDAMEDDDRzcF9hcml0aG1ldGljKHBlcl90aGluZ3McUGVyYmlsbAAABAAQAQx1MzIAAMUDDDBwYWxsZXRfYm9uZHMYcGFsbGV0EENhbGwEBFQAAQgUaXNzdWUMASBhc3NldF9pZBABHEFzc2V0SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAEgbWF0dXJpdHkwARhNb21lbnQAAFRkSXNzdWUgbmV3IGZ1bmdpYmxlIGJvbmRzLtROZXcgYXNzZXQgaWQgaXMgcmVnaXN0ZXJlZCBhbmQgYXNzaWduZWQgdG8gdGhlIGJvbmRzLlkBVGhlIG51bWJlciBvZiBib25kcyB0aGUgaXNzdWVyIHJlY2VpdmVzIGlzIDE6MSB0byB0aGUgYGFtb3VudGAgb2YgdGhlIHVuZGVybHlpbmcgYXNzZXRcbWludXMgdGhlIHByb3RvY29sIGZlZS4ZAVRoZSBib25kIGFzc2V0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZW1wdHkgc3RyaW5nIGZvciB0aGUgYXNzZXQgbmFtZSwFAWFuZCB3aXRoIHRoZSBzYW1lIGV4aXN0ZW50aWFsIGRlcG9zaXQgYXMgb2YgdGhlIHVuZGVybHlpbmcgYXNzZXQu7EJvbmRzIGNhbiBiZSByZWRlZW1lZCBmb3IgdGhlIHVuZGVybHlpbmcgYXNzZXQgb25jZSBtYXR1cmUuLQFQcm90b2NvbCBmZWUgaXMgYXBwbGllZCB0byB0aGUgYW1vdW50LCBhbmQgdHJhbnNmZXJyZWQgdG8gYFQ6OkZlZVJlY2VpdmVyYC5pAVdoZW4gaXNzdWluZyBuZXcgYm9uZHMgd2l0aCB0aGUgdW5kZXJseWluZyBhc3NldCBhbmQgbWF0dXJpdHkgdGhhdCBtYXRjaGVzIGV4aXN0aW5nIGJvbmRzLD0BbmV3IGFtb3VudCBvZiB0aGVzZSBleGlzdGluZyBib25kcyBpcyBpc3N1ZWQsIGluc3RlYWQgb2YgcmVnaXN0ZXJpbmcgbmV3IGJvbmRzLg0BSXQncyBwb3NzaWJsZSB0byBpc3N1ZSBuZXcgYm9uZHMgZm9yIGJvbmRzIHRoYXQgYXJlIGFscmVhZHkgbWF0dXJlLgAsUGFyYW1ldGVyczr0LSBgb3JpZ2luYDogaXNzdWVyIG9mIG5ldyBib25kcywgbmVlZHMgdG8gYmUgYFQ6Oklzc3VlT3JpZ2luYIQtIGBhc3NldF9pZGA6IHVuZGVybHlpbmcgYXNzZXQgaWS4LSBgYW1vdW50YDogdGhlIGFtb3VudCBvZiB0aGUgdW5kZXJseWluZyBhc3NldB0BLSBgbWF0dXJpdHlgOiBVbml4IHRpbWUgaW4gbWlsbGlzZWNvbmRzLCB3aGVuIHRoZSBib25kcyB3aWxsIGJlIG1hdHVyZS4ANQFFbWl0cyBgQm9uZFRva2VuQ3JlYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsIGFuZCBuZXcgYm9uZHMgd2VyZSByZWdpc3RlcmVkLqhFbWl0cyBgQm9uZHNJc3N1ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AGHJlZGVlbQgBHGJvbmRfaWQQARxBc3NldElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQABMJhSZWRlZW0gYm9uZHMgZm9yIHRoZSB1bmRlcmx5aW5nIGFzc2V0LnUBVGhlIGFtb3VudCBvZiB0aGUgdW5kZXJseWluZyBhc3NldCB0aGUgYG9yaWdpbmAgcmVjZWl2ZXMgaXMgMToxIHRvIHRoZSBgYW1vdW50YCBvZiB0aGUgYm9uZHMuyEFueW9uZSB3aG8gaG9sZHMgdGhlIGJvbmRzIGlzIGFibGUgdG8gcmVkZWVtIHRoZW0uuEJvbmRzIGNhbiBiZSBib3RoIHBhcnRpYWxseSBvciBmdWxseSByZWRlZW1lZC4ALFBhcmFtZXRlcnM6WC0gYG9yaWdpbmA6IGFjY291bnQgaWRsLSBgYXNzZXRfaWRgOiBib25kIGFzc2V0IGlkGQEtIGBhbW91bnRgOiB0aGUgYW1vdW50IG9mIHRoZSBib25kcyB0byByZWRlZW0gZm9yIHRoZSB1bmRlcmx5aW5nIGFzc2V0ALBFbWl0cyBgQm9uZHNSZWRlZW1lZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLgAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuyQMMWHBhbGxldF9vdGNfc2V0dGxlbWVudHMYcGFsbGV0EENhbGwEBFQAAQRAc2V0dGxlX290Y19vcmRlcgwBGG90Y19pZBABHE9yZGVySWQAARhhbW91bnQYARxCYWxhbmNlAAEUcm91dGV9AwFMUm91dGU8QXNzZXRJZE9mPFQ+PgAAULBDbG9zZSBhbiBleGlzdGluZyBPVEMgYXJiaXRyYWdlIG9wcG9ydHVuaXR5LgDURXhlY3V0ZXMgYSB0cmFkZSBiZXR3ZWVuIGFuIE9UQyBvcmRlciBhbmQgc29tZSByb3V0ZS5VAUlmIHRoZSBPVEMgb3JkZXIgaXMgcGFydGlhbGx5IGZpbGxhYmxlLCB0aGUgZXh0cmluc2ljIGZhaWxzIGlmIHRoZSBleGlzdGluZyBhcmJpdHJhZ2XUb3Bwb3J0dW5pdHkgaXMgbm90IGNsb3NlZCBvciByZWR1Y2VkIGFmdGVyIHRoZSB0cmFkZS5hAUlmIHRoZSBPVEMgb3JkZXIgaXMgbm90IHBhcnRpYWxseSBmaWxsYWJsZSwgZmFpbHMgaWYgdGhlcmUgaXMgbm8gcHJvZml0IGFmdGVyIHRoZSB0cmFkZS4AEQFgT3JpZ2luYCBjYWxsaW5nIHRoaXMgZXh0cmluc2ljIGlzIG5vdCBwYXlpbmcgb3IgcmVjZWl2aW5nIGFueXRoaW5nLgAlAVRoZSBwcm9maXQgbWFkZSBieSBjbG9zaW5nIHRoZSBhcmJpdHJhZ2UgaXMgdHJhbnNmZXJyZWQgdG8gYEZlZVJlY2VpdmVyYC4ALFBhcmFtZXRlcnM6OQEtIGBvcmlnaW5gOiBTaWduZWQgb3IgdW5zaWduZWQgb3JpZ2luLiBVbnNpZ25lZCBvcmlnaW4gZG9lc24ndCBwYXkgdGhlIFRYIGZlZSysCQkJYnV0IGNhbiBiZSBzdWJtaXR0ZWQgb25seSBieSBhIGNvbGxhdG9yLhEBLSBgb3RjX2lkYDogSUQgb2YgdGhlIE9UQyBvcmRlciB3aXRoIGV4aXN0aW5nIGFyYml0cmFnZSBvcHBvcnR1bml0eS64LSBgYW1vdW50YDogQW1vdW50IG5lY2Vzc2FyeSB0byBjbG9zZSB0aGUgYXJiLiEBLSBgcm91dGVgOiBUaGUgcm91dGUgd2UgdHJhZGUgYWdhaW5zdC4gUmVxdWlyZWQgZm9yIHRoZSBmZWUgY2FsY3VsYXRpb24uAJxFbWl0cyBgRXhlY3V0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4ABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLs0DDChwYWxsZXRfbGJwGHBhbGxldBBDYWxsBARUAAEYLGNyZWF0ZV9wb29sLAEocG9vbF9vd25lcgABMFQ6OkFjY291bnRJZAABHGFzc2V0X2EQARxBc3NldElkAAE4YXNzZXRfYV9hbW91bnQYARxCYWxhbmNlAAEcYXNzZXRfYhABHEFzc2V0SWQAAThhc3NldF9iX2Ftb3VudBgBHEJhbGFuY2UAAThpbml0aWFsX3dlaWdodBABJExCUFdlaWdodAABMGZpbmFsX3dlaWdodBABJExCUFdlaWdodAABMHdlaWdodF9jdXJ2ZdEDATxXZWlnaHRDdXJ2ZVR5cGUAAQxmZWVNAwEoKHUzMiwgdTMyKQABNGZlZV9jb2xsZWN0b3IAATBUOjpBY2NvdW50SWQAATByZXBheV90YXJnZXQYARxCYWxhbmNlAACE/ENyZWF0ZSBhIG5ldyBsaXF1aWRpdHkgYm9vdHN0cmFwcGluZyBwb29sIGZvciBnaXZlbiBhc3NldCBwYWlyLgDYRm9yIGFueSBhc3NldCBwYWlyLCBvbmx5IG9uZSBwb29sIGNhbiBleGlzdCBhdCBhIHRpbWUuAAEBVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgYFQ6OkNyZWF0ZVBvb2xPcmlnaW5gLlUBVGhlIHBvb2wgaXMgY3JlYXRlZCB3aXRoIGluaXRpYWwgbGlxdWlkaXR5IHByb3ZpZGVkIGJ5IHRoZSBgcG9vbF9vd25lcmAgd2hvIG11c3QgaGF2ZVhzdWZmaWNpZW50IGZ1bmRzIGZyZWUuAKEBVGhlIHBvb2wgc3RhcnRzIHVuaW5pdGlhbGl6ZWQgYW5kIHVwZGF0ZV9wb29sIGNhbGwgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGNyZWF0ZWQgdG8gc2V0IHRoZSBzdGFydCBibG9jay4AOQFUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBkaXNwYXRjaGVkIGZyb20gZ292ZXJuaW5nIGVudGl0eSBgVDo6Q3JlYXRlUG9vbE9yaWdpbmAALFBhcmFtZXRlcnM6xC0gYHBvb2xfb3duZXJgOiB0aGUgZnV0dXJlIG93bmVyIG9mIHRoZSBuZXcgcG9vbC4hAS0gYGFzc2V0X2FgOiB7IGFzc2V0X2lkLCBhbW91bnQgfSBBc3NldCBJRCBhbmQgaW5pdGlhbCBsaXF1aWRpdHkgYW1vdW50LiEBLSBgYXNzZXRfYmA6IHsgYXNzZXRfaWQsIGFtb3VudCB9IEFzc2V0IElEIGFuZCBpbml0aWFsIGxpcXVpZGl0eSBhbW91bnQuoQEtIGBpbml0aWFsX3dlaWdodGA6IEluaXRpYWwgd2VpZ2h0IG9mIHRoZSBhc3NldF9hLiAxXzAwMF8wMDAgY29ycmVzcG9uZGluZyB0byAxJSBhbmQgMTAwXzAwMF8wMDAgdG8gMTAwJZx0aGlzIHNob3VsZCBiZSBoaWdoZXIgdGhhbiBmaW5hbCB3ZWlnaHSRAS0gYGZpbmFsX3dlaWdodGA6IEZpbmFsIHdlaWdodCBvZiB0aGUgYXNzZXRfYS4gMV8wMDBfMDAwIGNvcnJlc3BvbmRpbmcgdG8gMSUgYW5kIDEwMF8wMDBfMDAwIHRvIDEwMCWgdGhpcyBzaG91bGQgYmUgbG93ZXIgdGhhbiBpbml0aWFsIHdlaWdodEEBLSBgd2VpZ2h0X2N1cnZlYDogVGhlIHdlaWdodCBmdW5jdGlvbiB1c2VkIHRvIHVwZGF0ZSB0aGUgTEJQIHdlaWdodHMuIEN1cnJlbnRseSwNAXRoZXJlIGlzIG9ubHkgb25lIHdlaWdodCBmdW5jdGlvbiBpbXBsZW1lbnRlZCwgdGhlIGxpbmVhciBmdW5jdGlvbi49AS0gYGZlZWA6IFRoZSB0cmFkaW5nIGZlZSBjaGFyZ2VkIG9uIGV2ZXJ5IHRyYWRlIGRpc3RyaWJ1dGVkIHRvIGBmZWVfY29sbGVjdG9yYC4lAS0gYGZlZV9jb2xsZWN0b3JgOiBUaGUgYWNjb3VudCB0byB3aGljaCB0cmFkaW5nIGZlZXMgd2lsbCBiZSB0cmFuc2ZlcnJlZC6dAS0gYHJlcGF5X3RhcmdldGA6IFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIHJlcGF5IHRvIHNlcGFyYXRlIGZlZV9jb2xsZWN0b3IgYWNjb3VudC4gVW50aWwgdGhpcyBhbW91bnQgaXP0cmVhY2hlZCwgZmVlIHdpbGwgYmUgaW5jcmVhc2VkIHRvIDIwJSBhbmQgdGFrZW4gZnJvbSB0aGUgcG9vbACoRW1pdHMgYFBvb2xDcmVhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuAJ0BQkVXQVJFOiBXZSBhcmUgdGFraW5nIHRoZSBmZWUgZnJvbSB0aGUgYWNjdW11bGF0ZWQgYXNzZXQuIElmIHRoZSBhY2N1bXVsYXRlZCBhc3NldCBpcyBzb2xkIHRvIHRoZSBwb29sLHkBdGhlIGZlZSBjb3N0IGlzIHRyYW5zZmVycmVkIHRvIHRoZSBwb29sLiBJZiBpdHMgYm91Z2h0IGZyb20gdGhlIHBvb2wgdGhlIGJ1eWVyIGJlYXJzIHRoZSBjb3N0LmkBVGhpcyBpbmNyZWFzZXMgdGhlIHByaWNlIG9mIHRoZSBzb2xkIGFzc2V0IG9uIGV2ZXJ5IHRyYWRlLiBNYWtlIHN1cmUgdG8gb25seSBydW4gdGhpcyB3aXRobHByZXZpb3VzbHkgaWxsaXF1aWQgYXNzZXRzLkB1cGRhdGVfcG9vbF9kYXRhJAEccG9vbF9pZAABJFBvb2xJZDxUPgABKHBvb2xfb3duZXLsAVBPcHRpb248VDo6QWNjb3VudElkPgABFHN0YXJ0WQEBZE9wdGlvbjxCbG9ja051bWJlckZvcjxUPj4AAQxlbmRZAQFkT3B0aW9uPEJsb2NrTnVtYmVyRm9yPFQ+PgABOGluaXRpYWxfd2VpZ2h0WQEBRE9wdGlvbjxMQlBXZWlnaHQ+AAEwZmluYWxfd2VpZ2h0WQEBRE9wdGlvbjxMQlBXZWlnaHQ+AAEMZmVldQMBSE9wdGlvbjwodTMyLCB1MzIpPgABNGZlZV9jb2xsZWN0b3LsAVBPcHRpb248VDo6QWNjb3VudElkPgABMHJlcGF5X3RhcmdldOABPE9wdGlvbjxCYWxhbmNlPgABSGxVcGRhdGUgcG9vbCBkYXRhIG9mIGEgcG9vbC4ADQFUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBzaWduZWQgYnkgdGhlIHBvb2wgb3duZXIuAAUBVGhlIHBvb2wgY2FuIGJlIHVwZGF0ZWQgb25seSBpZiB0aGUgc2FsZSBoYXMgbm90IGFscmVhZHkgc3RhcnRlZC4AGQFBdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwYXJhbWV0ZXJzIGhhcyB0byBiZSBzcGVjaWZpZWQuACxQYXJhbWV0ZXJzOtgtIGBwb29sX2lkYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIHBvb2wgdG8gYmUgdXBkYXRlZC4lAS0gYHN0YXJ0YDogVGhlIG5ldyBzdGFydGluZyB0aW1lIG9mIHRoZSBzYWxlLiBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbC4VAS0gYGVuZGA6IFRoZSBuZXcgZW5kaW5nIHRpbWUgb2YgdGhlIHNhbGUuIFRoaXMgcGFyYW1ldGVyIGlzIG9wdGlvbmFsLh0BLSBgaW5pdGlhbF93ZWlnaHRgOiBUaGUgbmV3IGluaXRpYWwgd2VpZ2h0LiBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbC4NAS0gYGZpbmFsX3dlaWdodGA6IFRoZSBuZXcgZmluYWwgd2VpZ2h0LiBUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbC5BAS0gYGZlZWA6IFRoZSBuZXcgdHJhZGluZyBmZWUgY2hhcmdlZCBvbiBldmVyeSB0cmFkZS4gVGhpcyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuQQEtIGBmZWVfY29sbGVjdG9yYDogVGhlIG5ldyByZWNlaXZlciBvZiB0cmFkaW5nIGZlZXMuIFRoaXMgcGFyYW1ldGVyIGlzIG9wdGlvbmFsLgCoRW1pdHMgYFBvb2xVcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuNGFkZF9saXF1aWRpdHkIASBhbW91bnRfYdUDAVwoQXNzZXRJZCwgQmFsYW5jZU9mPFQ+KQABIGFtb3VudF9i1QMBXChBc3NldElkLCBCYWxhbmNlT2Y8VD4pAAIwYEFkZCBsaXF1aWRpdHkgdG8gYSBwb29sLgBNAUFzc2V0cyB0byBhZGQgaGFzIHRvIG1hdGNoIHRoZSBwb29sIGFzc2V0cy4gQXQgbGVhc3Qgb25lIGFtb3VudCBoYXMgdG8gYmUgbm9uLXplcm8uAA0BVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgc2lnbmVkIGJ5IHRoZSBwb29sIG93bmVyLgAsUGFyYW1ldGVyczqcLSBgcG9vbF9pZGA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBwb29sAQEtIGBhbW91bnRfYWA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBhc3NldCBhbmQgdGhlIGFtb3VudCB0byBhZGQuHQEtIGBhbW91bnRfYmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBzZWNvbmQgYXNzZXQgYW5kIHRoZSBhbW91bnQgdG8gYWRkLgC0RW1pdHMgYExpcXVpZGl0eUFkZGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuQHJlbW92ZV9saXF1aWRpdHkEARxwb29sX2lkAAEkUG9vbElkPFQ+AAMsTQFUcmFuc2ZlciBhbGwgdGhlIGxpcXVpZGl0eSBmcm9tIGEgcG9vbCBiYWNrIHRvIHRoZSBwb29sIG93bmVyIGFuZCBkZXN0cm95IHRoZSBwb29sLsBUaGUgcG9vbCBkYXRhIGFyZSBhbHNvIHJlbW92ZWQgZnJvbSB0aGUgc3RvcmFnZS4AsFRoZSBwb29sIGNhbid0IGJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIHNhbGUuAA0BVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgc2lnbmVkIGJ5IHRoZSBwb29sIG93bmVyLgAsUGFyYW1ldGVyczoBAS0gYGFtb3VudF9hYDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0IGFuZCB0aGUgYW1vdW50IHRvIGFkZC4ApEVtaXRzICdMaXF1aWRpdHlSZW1vdmVkJyB3aGVuIHN1Y2Nlc3NmdWwuEHNlbGwQASBhc3NldF9pbhABHEFzc2V0SWQAASRhc3NldF9vdXQQARxBc3NldElkAAEYYW1vdW50GAEwQmFsYW5jZU9mPFQ+AAEkbWF4X2xpbWl0GAEwQmFsYW5jZU9mPFQ+AAQ8hFRyYWRlIGBhc3NldF9pbmAgZm9yIGBhc3NldF9vdXRgLgBVAUV4ZWN1dGVzIGEgc3dhcCBvZiBgYXNzZXRfaW5gIGZvciBgYXNzZXRfb3V0YC4gUHJpY2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgcG9vbCBhbmQgaXMlAWFmZmVjdGVkIGJ5IHRoZSBhbW91bnQgYW5kIHByb3BvcnRpb24gb2YgdGhlIHBvb2wgYXNzZXRzIGFuZCB0aGUgd2VpZ2h0cy4A0FRyYWRpbmcgYGZlZWAgaXMgZGlzdHJpYnV0ZWQgdG8gdGhlIGBmZWVfY29sbGVjdG9yYC4ALFBhcmFtZXRlcnM6ZQEtIGBhc3NldF9pbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBhc3NldCBiZWluZyB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBhY2NvdW50IHRvIHRoZSBwb29sLmkBLSBgYXNzZXRfb3V0YDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0IGJlaW5nIHRyYW5zZmVycmVkIGZyb20gdGhlIHBvb2wgdG8gdGhlIGFjY291bnQukC0gYGFtb3VudGA6IFRoZSBhbW91bnQgb2YgYGFzc2V0X2luYO0BLSBgbWF4X2xpbWl0YDogbWluaW11bSBhbW91bnQgb2YgYGFzc2V0X291dGAgLyBhbW91bnQgb2YgYXNzZXRfb3V0IHRvIGJlIG9idGFpbmVkIGZyb20gdGhlIHBvb2wgaW4gZXhjaGFuZ2UgZm9yIGBhc3NldF9pbmAuAMRFbWl0cyBgU2VsbEV4ZWN1dGVkYCB3aGVuIHN1Y2Nlc3NmdWwuIERlcHJlY2F0ZWQuyEVtaXRzIGBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkYCB3aGVuIHN1Y2Nlc3NmdWwuDGJ1eRABJGFzc2V0X291dBABHEFzc2V0SWQAASBhc3NldF9pbhABHEFzc2V0SWQAARhhbW91bnQYATBCYWxhbmNlT2Y8VD4AASRtYXhfbGltaXQYATBCYWxhbmNlT2Y8VD4ABTyEVHJhZGUgYGFzc2V0X2luYCBmb3IgYGFzc2V0X291dGAuAFUBRXhlY3V0ZXMgYSBzd2FwIG9mIGBhc3NldF9pbmAgZm9yIGBhc3NldF9vdXRgLiBQcmljZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBwb29sIGFuZCBpczUBYWZmZWN0ZWQgYnkgdGhlIGFtb3VudCBhbmQgdGhlIHByb3BvcnRpb24gb2YgdGhlIHBvb2wgYXNzZXRzIGFuZCB0aGUgd2VpZ2h0cy4A0FRyYWRpbmcgYGZlZWAgaXMgZGlzdHJpYnV0ZWQgdG8gdGhlIGBmZWVfY29sbGVjdG9yYC4ALFBhcmFtZXRlcnM6ZQEtIGBhc3NldF9pbmA6IFRoZSBpZGVudGlmaWVyIG9mIHRoZSBhc3NldCBiZWluZyB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBhY2NvdW50IHRvIHRoZSBwb29sLmkBLSBgYXNzZXRfb3V0YDogVGhlIGlkZW50aWZpZXIgb2YgdGhlIGFzc2V0IGJlaW5nIHRyYW5zZmVycmVkIGZyb20gdGhlIHBvb2wgdG8gdGhlIGFjY291bnQumC0gYGFtb3VudGA6IFRoZSBhbW91bnQgb2YgYGFzc2V0X291dGAuTQEtIGBtYXhfbGltaXRgOiBtYXhpbXVtIGFtb3VudCBvZiBgYXNzZXRfaW5gIHRvIGJlIHNvbGQgaW4gZXhjaGFuZ2UgZm9yIGBhc3NldF9vdXRgLgDARW1pdHMgYEJ1eUV4ZWN1dGVkYCB3aGVuIHN1Y2Nlc3NmdWwuIERlcHJlY2F0ZWQuyEVtaXRzIGBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkYCB3aGVuIHN1Y2Nlc3NmdWwuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLtEDCChwYWxsZXRfbGJwPFdlaWdodEN1cnZlVHlwZQABBBhMaW5lYXIAAAAA1QMAAAQIEBgA2QMMKHBhbGxldF94eWsYcGFsbGV0EENhbGwEBFQAARwsY3JlYXRlX3Bvb2wQARxhc3NldF9hEAEcQXNzZXRJZAABIGFtb3VudF9hGAEcQmFsYW5jZQABHGFzc2V0X2IQARxBc3NldElkAAEgYW1vdW50X2IYARxCYWxhbmNlAAAklENyZWF0ZSBuZXcgcG9vbCBmb3IgZ2l2ZW4gYXNzZXQgcGFpci4AUQFSZWdpc3RlcnMgbmV3IHBvb2wgZm9yIGdpdmVuIGFzc2V0IHBhaXIgKGBhc3NldCBhYCBhbmQgYGFzc2V0IGJgKSBpbiBhc3NldCByZWdpc3RyeS5xAUFzc2V0IHJlZ2lzdHJ5IGNyZWF0ZXMgbmV3IGlkIG9yIHJldHVybnMgcHJldmlvdXNseSBjcmVhdGVkIG9uZSBpZiBzdWNoIHBvb2wgZXhpc3RlZCBiZWZvcmUuAPBQb29sIGlzIGNyZWF0ZWQgd2l0aCBpbml0aWFsIGxpcXVpZGl0eSBwcm92aWRlZCBieSBgb3JpZ2luYC55AVNoYXJlcyBhcmUgaXNzdWVkIHdpdGggc3BlY2lmaWVkIGluaXRpYWwgcHJpY2UgYW5kIHJlcHJlc2VudHMgcHJvcG9ydGlvbiBvZiBhc3NldCBpbiB0aGUgcG9vbC4AqEVtaXRzIGBQb29sQ3JlYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLjRhZGRfbGlxdWlkaXR5EAEcYXNzZXRfYRABHEFzc2V0SWQAARxhc3NldF9iEAEcQXNzZXRJZAABIGFtb3VudF9hGAEcQmFsYW5jZQABSGFtb3VudF9iX21heF9saW1pdBgBHEJhbGFuY2UAARTQQWRkIGxpcXVpZGl0eSB0byBwcmV2aW91c2x5IGNyZWF0ZWQgYXNzZXQgcGFpciBwb29sLgCUU2hhcmVzIGFyZSBpc3N1ZWQgd2l0aCBjdXJyZW50IHByaWNlLgC0RW1pdHMgYExpcXVpZGl0eUFkZGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuZGFkZF9saXF1aWRpdHlfd2l0aF9saW1pdHMUARxhc3NldF9hEAEcQXNzZXRJZAABHGFzc2V0X2IQARxBc3NldElkAAEgYW1vdW50X2EYARxCYWxhbmNlAAFIYW1vdW50X2JfbWF4X2xpbWl0GAEcQmFsYW5jZQABKG1pbl9zaGFyZXMYARxCYWxhbmNlAAUAQHJlbW92ZV9saXF1aWRpdHkMARxhc3NldF9hEAEcQXNzZXRJZAABHGFzc2V0X2IQARxBc3NldElkAAEwc2hhcmVfYW1vdW50GAEcQmFsYW5jZQACGDEBUmVtb3ZlIGxpcXVpZGl0eSBmcm9tIHNwZWNpZmljIGxpcXVpZGl0eSBwb29sIGluIHRoZSBmb3JtIG9mIGJ1cm5pbmcgc2hhcmVzLgDQSWYgbGlxdWlkaXR5IGluIHRoZSBwb29sIHJlYWNoZXMgMCwgaXQgaXMgZGVzdHJveWVkLgCkRW1pdHMgJ0xpcXVpZGl0eVJlbW92ZWQnIHdoZW4gc3VjY2Vzc2Z1bC60RW1pdHMgJ1Bvb2xEZXN0cm95ZWQnIHdoZW4gcG9vbCBpcyBkZXN0cm95ZWQucHJlbW92ZV9saXF1aWRpdHlfd2l0aF9saW1pdHMUARxhc3NldF9hEAEcQXNzZXRJZAABHGFzc2V0X2IQARxBc3NldElkAAEwc2hhcmVfYW1vdW50GAEcQmFsYW5jZQABMG1pbl9hbW91bnRfYRgBHEJhbGFuY2UAATBtaW5fYW1vdW50X2IYARxCYWxhbmNlAAYAEHNlbGwUASBhc3NldF9pbhABHEFzc2V0SWQAASRhc3NldF9vdXQQARxBc3NldElkAAEYYW1vdW50GAEcQmFsYW5jZQABJG1heF9saW1pdBgBHEJhbGFuY2UAASBkaXNjb3VudCABEGJvb2wAAyB0VHJhZGUgYXNzZXQgaW4gZm9yIGFzc2V0IG91dC4AZQFFeGVjdXRlcyBhIHN3YXAgb2YgYGFzc2V0X2luYCBmb3IgYGFzc2V0X291dGAuIFByaWNlIGlzIGRldGVybWluZWQgYnkgdGhlIGxpcXVpZGl0eSBwb29sLgDpAWBtYXhfbGltaXRgIC0gbWluaW11bSBhbW91bnQgb2YgYGFzc2V0X291dGAgLyBhbW91bnQgb2YgYXNzZXRfb3V0IHRvIGJlIG9idGFpbmVkIGZyb20gdGhlIHBvb2wgaW4gZXhjaGFuZ2UgZm9yIGBhc3NldF9pbmAuAMRFbWl0cyBgU2VsbEV4ZWN1dGVkYCB3aGVuIHN1Y2Nlc3NmdWwuIERlcHJlY2F0ZWQuyEVtaXRzIGBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkYCB3aGVuIHN1Y2Nlc3NmdWwuDGJ1eRQBJGFzc2V0X291dBABHEFzc2V0SWQAASBhc3NldF9pbhABHEFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAEkbWF4X2xpbWl0GAEcQmFsYW5jZQABIGRpc2NvdW50IAEQYm9vbAAEHHRUcmFkZSBhc3NldCBpbiBmb3IgYXNzZXQgb3V0LgBlAUV4ZWN1dGVzIGEgc3dhcCBvZiBgYXNzZXRfaW5gIGZvciBgYXNzZXRfb3V0YC4gUHJpY2UgaXMgZGV0ZXJtaW5lZCBieSB0aGUgbGlxdWlkaXR5IHBvb2wuAEkBYG1heF9saW1pdGAgLSBtYXhpbXVtIGFtb3VudCBvZiBgYXNzZXRfaW5gIHRvIGJlIHNvbGQgaW4gZXhjaGFuZ2UgZm9yIGBhc3NldF9vdXRgLsBFbWl0cyBgQnV5RXhlY3V0ZWRgIHdoZW4gc3VjY2Vzc2Z1bC4gRGVwcmVjYXRlZC7IRW1pdHMgYHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWRgIHdoZW4gc3VjY2Vzc2Z1bC4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMu3QMMQHBhbGxldF9yZWZlcnJhbHMYcGFsbGV0EENhbGwEBFQAARQ0cmVnaXN0ZXJfY29kZQQBEGNvZGXhAwFsUmVmZXJyYWxDb2RlPFQ6OkNvZGVMZW5ndGg+AAA0bFJlZ2lzdGVyIG5ldyByZWZlcnJhbCBjb2RlLgCMYG9yaWdpbmAgcGF5cyB0aGUgcmVnaXN0cmF0aW9uIGZlZS6oYGNvZGVgIGlzIGFzc2lnbmVkIHRvIHRoZSBnaXZlbiBgYWNjb3VudGAuAORMZW5ndGggb2YgdGhlIGBjb2RlYCBtdXN0IGJlIGF0IGxlYXN0IGBUOjpNaW5Db2RlTGVuZ3RoYC60TWF4aW11bSBsZW5ndGggaXMgbGltaXRlZCB0byBgVDo6Q29kZUxlbmd0aGAukQFgY29kZWAgbXVzdCBjb250YWluIG9ubHkgYWxmYS1udW1lcmljIGNoYXJhY3RlcnMgYW5kIGFsbCBjaGFyYWN0ZXJzIHdpbGwgYmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2UuACxQYXJhbWV0ZXJzOuQtIGBjb2RlYDogQ29kZSB0byByZWdpc3Rlci4gTXVzdCBmb2xsb3cgdGhlIHJlc3RyaWN0aW9ucy4AtEVtaXRzIGBDb2RlUmVnaXN0ZXJlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLiRsaW5rX2NvZGUEARBjb2Rl4QMBbFJlZmVycmFsQ29kZTxUOjpDb2RlTGVuZ3RoPgABKGhMaW5rIGEgY29kZSB0byBhbiBhY2NvdW50LgApAWBDb2RlYCBtdXN0IGJlIHZhbGlkIHJlZ2lzdGVyZWQgY29kZS4gT3RoZXJ3aXNlIGBJbnZhbGlkQ29kZWAgaXMgcmV0dXJuZWQuAPRTaWduZXIgYWNjb3VudCBpcyBsaW5rZWQgdG8gdGhlIHJlZmVycmFsIGFjY291bnQgb2YgdGhlIGNvZGUuACxQYXJhbWV0ZXJzOtAtIGBjb2RlYDogQ29kZSB0byB1c2UgdG8gbGluayB0aGUgc2lnbmVyIGFjY291bnQgdG8uAKRFbWl0cyBgQ29kZUxpbmtlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLhxjb252ZXJ0BAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAIYwENvbnZlcnQgYWNjcnVlZCBhc3NldCBhbW91bnQgdG8gcmV3YXJkIGN1cnJlbmN5LgAsUGFyYW1ldGVyczrcLSBgYXNzZXRfaWRgOiBJZCBvZiBhbiBhc3NldCB0byBjb252ZXJ0IHRvIFJld2FyZEFzc2V0LgCgRW1pdHMgYENvbnZlcnRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLjRjbGFpbV9yZXdhcmRzAAMkZENsYWltIGFjY3VtdWxhdGVkIHJld2FyZHMASQFJRiB0aGVyZSBpcyBhbnkgYXNzZXQgaW4gdGhlIHJld2FyZCBwb3QsIGFsbCBpcyBjb252ZXJ0ZWQgdG8gUmV3YXJkQ3VycmVuY3kgZmlyc3QuABkBUmV3YXJkIGFtb3VudCBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBzaGFyZXMgb2YgdGhlIHNpZ25lciBhY2NvdW50LgDVAWlmIHRoZSBzaWduZXIgYWNjb3VudCBpcyByZWZlcnJlciBhY2NvdW50LCB0b3RhbCBhY2N1bXVsYXRlZCByZXdhcmRzIGlzIHVwZGF0ZWQgYXMgd2VsbCBhcyByZWZlcnJlciBsZXZlbCBpZiByZWFjaGVkLgCYRW1pdHMgYENsYWltZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC5Uc2V0X3Jld2FyZF9wZXJjZW50YWdlDAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEUbGV2ZWzlAwEUTGV2ZWwAARxyZXdhcmRz6QMBPEZlZURpc3RyaWJ1dGlvbgAEIHBTZXQgYXNzZXQgcmV3YXJkIHBlcmNlbnRhZ2VzACxQYXJhbWV0ZXJzOlgtIGBhc3NldF9pZGA6IGFzc2V0IGlkQC0gYGxldmVsYDogbGV2ZWyMLSBgcmV3YXJkc2A6IHJld2FyZCBmZWUgcGVyY2VudGFnZXMAyEVtaXRzIGBBc3NldFJld2FyZHNVcGRhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLuEDDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAA5QMIQHBhbGxldF9yZWZlcnJhbHMUTGV2ZWwAARgQTm9uZQAAABRUaWVyMAABABRUaWVyMQACABRUaWVyMgADABRUaWVyMwAEABRUaWVyNAAFAADpAwhAcGFsbGV0X3JlZmVycmFsczxGZWVEaXN0cmlidXRpb24AAAwBIHJlZmVycmVyIQMBHFBlcm1pbGwAARh0cmFkZXIhAwEcUGVybWlsbAABIGV4dGVybmFsIQMBHFBlcm1pbGwAAO0DDEhwYWxsZXRfbGlxdWlkYXRpb24YcGFsbGV0EENhbGwEBFQAAQgkbGlxdWlkYXRlFAFAY29sbGF0ZXJhbF9hc3NldBABHEFzc2V0SWQAAShkZWJ0X2Fzc2V0EAEcQXNzZXRJZAABEHVzZXJBAQEoRXZtQWRkcmVzcwABNGRlYnRfdG9fY292ZXIYARxCYWxhbmNlAAEUcm91dGV9AwE4Um91dGU8QXNzZXRJZD4AAEC0TGlxdWlkYXRlcyBhbiBleGlzdGluZyBtb25leSBtYXJrZXQgcG9zaXRpb24ugENhbiBiZSBib3RoIHNpZ25lZCBhbmQgdW5zaWduZWQuANxQZXJmb3JtcyBhIGZsYXNoIGxvYW4gdG8gZ2V0IGZ1bmRzIHRvIHBheSBmb3IgdGhlIGRlYnQuOQFSZWNlaXZlZCBjb2xsYXRlcmFsIGlzIHN3YXBwZWQgYW5kIHRoZSBwcm9maXQgaXMgdHJhbnNmZXJyZWQgdG8gYEZlZVJlY2VpdmVyYC4ALFBhcmFtZXRlcnM6aC0gYG9yaWdpbmA6IFNpZ25lZCBvcmlnaW4uFQEtIGBjb2xsYXRlcmFsX2Fzc2V0YDogQXNzZXQgSUQgdXNlZCBhcyBjb2xsYXRlcmFsIGluIHRoZSBNTSBwb3NpdGlvbi7kLSBgZGVidF9hc3NldGA6IEFzc2V0IElEIHVzZWQgYXMgZGVidCBpbiB0aGUgTU0gcG9zaXRpb24uDQEtIGB1c2VyYDogRVZNIGFkZHJlc3Mgb2YgdGhlIE1NIHBvc2l0aW9uIHRoYXQgd2Ugd2FudCB0byBsaXF1aWRhdGUu3C0gYGRlYnRfdG9fY292ZXJgOiBBbW91bnQgb2YgZGVidCB3ZSB3YW50IHRvIGxpcXVpZGF0ZS4hAS0gYHJvdXRlYDogVGhlIHJvdXRlIHdlIHRyYWRlIGFnYWluc3QuIFJlcXVpcmVkIGZvciB0aGUgZmVlIGNhbGN1bGF0aW9uLgCkRW1pdHMgYExpcXVpZGF0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AWHNldF9ib3Jyb3dpbmdfY29udHJhY3QEASBjb250cmFjdEEBAShFdm1BZGRyZXNzAAEEqFNldCB0aGUgYm9ycm93aW5nIG1hcmtldCBjb250cmFjdCBhZGRyZXNzLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy7xAwwocGFsbGV0X2hzbRhwYWxsZXQQQ2FsbAQEVAABHFBhZGRfY29sbGF0ZXJhbF9hc3NldBwBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABHHBvb2xfaWQQAShUOjpBc3NldElkAAEwcHVyY2hhc2VfZmVlIQMBHFBlcm1pbGwAAWRtYXhfYnV5X3ByaWNlX2NvZWZmaWNpZW50PQEBQENvZWZmaWNpZW50UmF0aW8AATBidXlfYmFja19mZWUhAwEcUGVybWlsbAABMGJ1eWJhY2tfcmF0ZcEDARxQZXJiaWxsAAE4bWF4X2luX2hvbGRpbmfgATxPcHRpb248QmFsYW5jZT4AAGBoQWRkIGEgbmV3IGNvbGxhdGVyYWwgYXNzZXQAVQFUaGlzIGZ1bmN0aW9uIGFkZHMgYSBuZXcgYXNzZXQgYXMgYW4gYXBwcm92ZWQgY29sbGF0ZXJhbCBmb3IgSG9sbGFyLiBPbmx5IGNhbGxhYmxlIGJ5dHRoZSBnb3Zlcm5hbmNlIChyb290IG9yaWdpbikuACxQYXJhbWV0ZXJzOmAtIGBvcmlnaW5gOiBNdXN0IGJlIFJvb3TALSBgYXNzZXRfaWRgOiBBc3NldCBJRCB0byBiZSBhZGRlZCBhcyBjb2xsYXRlcmFsGQEtIGBwb29sX2lkYDogU3RhYmxlU3dhcCBwb29sIElEIHdoZXJlIHRoaXMgYXNzZXQgYW5kIEhvbGxhciBhcmUgcGFpcmVkaQEtIGBwdXJjaGFzZV9mZWVgOiBGZWUgYXBwbGllZCB3aGVuIGJ1eWluZyBIb2xsYXIgd2l0aCB0aGlzIGFzc2V0IChhZGRlZCB0byBwdXJjaGFzZSBwcmljZSldAS0gYG1heF9idXlfcHJpY2VfY29lZmZpY2llbnRgOiBNYXhpbXVtIGJ1eSBwcmljZSBjb2VmZmljaWVudCBmb3IgSFNNIHRvIGJ1eSBiYWNrIEhvbGxhckUBLSBgYnV5X2JhY2tfZmVlYDogRmVlIGFwcGxpZWQgd2hlbiBidXlpbmcgYmFjayBIb2xsYXIgKHN1YnRyYWN0ZWQgZnJvbSBidXkgcHJpY2UpYQEtIGBidXliYWNrX3JhdGVgOiBQYXJhbWV0ZXIgdGhhdCBjb250cm9scyBob3cgcXVpY2tseSBIU00gY2FuIGJ1eSBIb2xsYXIgd2l0aCB0aGlzIGFzc2V0GQEtIGBtYXhfaW5faG9sZGluZ2A6IE9wdGlvbmFsIG1heGltdW0gYW1vdW50IG9mIGNvbGxhdGVyYWwgSFNNIGNhbiBob2xkABhFbWl0czr0LSBgQ29sbGF0ZXJhbEFkZGVkYCB3aGVuIHRoZSBjb2xsYXRlcmFsIGlzIHN1Y2Nlc3NmdWxseSBhZGRlZAAcRXJyb3JzOi0BLSBgQXNzZXRBbHJlYWR5QXBwcm92ZWRgIGlmIHRoZSBhc3NldCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgYXMgYSBjb2xsYXRlcmFsUQEtIGBQb29sQWxyZWFkeUhhc0NvbGxhdGVyYWxgIGlmIGFub3RoZXIgYXNzZXQgZnJvbSB0aGUgc2FtZSBwb29sIGlzIGFscmVhZHkgYXBwcm92ZWQBAS0gYEhvbGxhck5vdEluUG9vbGAgaWYgSG9sbGFyIGlzIG5vdCBmb3VuZCBpbiB0aGUgc3BlY2lmaWVkIHBvb2w1AS0gYEFzc2V0Tm90SW5Qb29sYCBpZiB0aGUgY29sbGF0ZXJhbCBhc3NldCBpcyBub3QgZm91bmQgaW4gdGhlIHNwZWNpZmllZCBwb29skC0gT3RoZXIgZXJyb3JzIGZyb20gdW5kZXJseWluZyBjYWxsc1xyZW1vdmVfY29sbGF0ZXJhbF9hc3NldAQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABPGRSZW1vdmUgYSBjb2xsYXRlcmFsIGFzc2V0AI0BUmVtb3ZlcyBhbiBhc3NldCBmcm9tIHRoZSBhcHByb3ZlZCBjb2xsYXRlcmFscyBsaXN0LiBPbmx5IGNhbGxhYmxlIGJ5IHRoZSBnb3Zlcm5hbmNlIChyb290IG9yaWdpbikuUQFUaGUgY29sbGF0ZXJhbCBtdXN0IGhhdmUgYSB6ZXJvIGJhbGFuY2UgaW4gdGhlIEhTTSBhY2NvdW50IGJlZm9yZSBpdCBjYW4gYmUgcmVtb3ZlZC4ALFBhcmFtZXRlcnM6YC0gYG9yaWdpbmA6IE11c3QgYmUgUm9vdMQtIGBhc3NldF9pZGA6IEFzc2V0IElEIHRvIHJlbW92ZSBmcm9tIGNvbGxhdGVyYWxzABhFbWl0czoFAS0gYENvbGxhdGVyYWxSZW1vdmVkYCB3aGVuIHRoZSBjb2xsYXRlcmFsIGlzIHN1Y2Nlc3NmdWxseSByZW1vdmVkABxFcnJvcnM6AQEtIGBBc3NldE5vdEFwcHJvdmVkYCBpZiB0aGUgYXNzZXQgaXMgbm90IGEgcmVnaXN0ZXJlZCBjb2xsYXRlcmFsIQEtIGBDb2xsYXRlcmFsTm90RW1wdHlgIGlmIHRoZSBIU00gYWNjb3VudCBzdGlsbCBob2xkcyBzb21lIG9mIHRoaXMgYXNzZXRcdXBkYXRlX2NvbGxhdGVyYWxfYXNzZXQYASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAATBwdXJjaGFzZV9mZWX1AwE8T3B0aW9uPFBlcm1pbGw+AAFkbWF4X2J1eV9wcmljZV9jb2VmZmljaWVudPkDAWBPcHRpb248Q29lZmZpY2llbnRSYXRpbz4AATBidXlfYmFja19mZWX1AwE8T3B0aW9uPFBlcm1pbGw+AAEwYnV5YmFja19yYXRl/QMBPE9wdGlvbjxQZXJiaWxsPgABOG1heF9pbl9ob2xkaW5nAQQBXE9wdGlvbjxPcHRpb248QmFsYW5jZT4+AAJMiFVwZGF0ZSBjb2xsYXRlcmFsIGFzc2V0IHBhcmFtZXRlcnMAnQFVcGRhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvciBhbiBleGlzdGluZyBjb2xsYXRlcmFsIGFzc2V0LiBPbmx5IGNhbGxhYmxlIGJ5IHRoZSBnb3Zlcm5hbmNlIChyb290IG9yaWdpbikuIQFFYWNoIHBhcmFtZXRlciBpcyBvcHRpb25hbCBhbmQgb25seSBwcm92aWRlZCBwYXJhbWV0ZXJzIHdpbGwgYmUgdXBkYXRlZC4ALFBhcmFtZXRlcnM6YC0gYG9yaWdpbmA6IE11c3QgYmUgUm9vdIAtIGBhc3NldF9pZGA6IEFzc2V0IElEIHRvIHVwZGF0ZbQtIGBwdXJjaGFzZV9mZWVgOiBOZXcgcHVyY2hhc2UgZmVlIChvcHRpb25hbCkdAS0gYG1heF9idXlfcHJpY2VfY29lZmZpY2llbnRgOiBOZXcgbWF4IGJ1eSBwcmljZSBjb2VmZmljaWVudCAob3B0aW9uYWwptC0gYGJ1eV9iYWNrX2ZlZWA6IE5ldyBidXkgYmFjayBmZWUgKG9wdGlvbmFsKdwtIGBidXliYWNrX3JhdGVgOiBOZXcgYnV5YmFjayByYXRlIHBhcmFtZXRlciAob3B0aW9uYWwp5C0gYG1heF9pbl9ob2xkaW5nYDogTmV3IG1heGltdW0gaG9sZGluZyBhbW91bnQgKG9wdGlvbmFsKQAYRW1pdHM6BQEtIGBDb2xsYXRlcmFsVXBkYXRlZGAgd2hlbiB0aGUgY29sbGF0ZXJhbCBpcyBzdWNjZXNzZnVsbHkgdXBkYXRlZAAcRXJyb3JzOgEBLSBgQXNzZXROb3RBcHByb3ZlZGAgaWYgdGhlIGFzc2V0IGlzIG5vdCBhIHJlZ2lzdGVyZWQgY29sbGF0ZXJhbBBzZWxsEAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABJGFtb3VudF9pbhgBHEJhbGFuY2UAAThzbGlwcGFnZV9saW1pdBgBHEJhbGFuY2UAA2xEU2VsbCBhc3NldCB0byBIU00AeFRoaXMgZnVuY3Rpb24gYWxsb3dzIHVzZXJzIHRvOvAxLiBTZWxsIEhvbGxhciBiYWNrIHRvIEhTTSBpbiBleGNoYW5nZSBmb3IgY29sbGF0ZXJhbCBhc3NldHMRATIuIFNlbGwgY29sbGF0ZXJhbCBhc3NldHMgdG8gSFNNIGluIGV4Y2hhbmdlIGZvciBuZXdseSBtaW50ZWQgSG9sbGFyAHUBVGhlIHZhbGlkIHBhaXJzIG11c3QgaW5jbHVkZSBIb2xsYXIgYXMgb25lIHNpZGUgYW5kIGFuIGFwcHJvdmVkIGNvbGxhdGVyYWwgYXMgdGhlIG90aGVyIHNpZGUuACxQYXJhbWV0ZXJzOpQtIGBvcmlnaW5gOiBBY2NvdW50IHNlbGxpbmcgdGhlIGFzc2V0hC0gYGFzc2V0X2luYDogQXNzZXQgSUQgYmVpbmcgc29sZJAtIGBhc3NldF9vdXRgOiBBc3NldCBJRCBiZWluZyBib3VnaHSkLSBgYW1vdW50X2luYDogQW1vdW50IG9mIGFzc2V0X2luIHRvIHNlbGz4LSBgc2xpcHBhZ2VfbGltaXRgOiBNaW5pbXVtIGFtb3VudCBvdXQgZm9yIHNsaXBwYWdlIHByb3RlY3Rpb24AGEVtaXRzOqAtIGBTd2FwcGVkM2Agd2hlbiB0aGUgc2VsbCBpcyBzdWNjZXNzZnVsABxFcnJvcnM6JQEtIGBJbnZhbGlkQXNzZXRQYWlyYCBpZiB0aGUgcGFpciBpcyBub3QgSG9sbGFyIGFuZCBhbiBhcHByb3ZlZCBjb2xsYXRlcmFs9C0gYEFzc2V0Tm90QXBwcm92ZWRgIGlmIHRoZSBjb2xsYXRlcmFsIGFzc2V0IGlzbid0IHJlZ2lzdGVyZWRBAS0gYFNsaXBwYWdlTGltaXRFeGNlZWRlZGAgaWYgdGhlIGFtb3VudCByZWNlaXZlZCBpcyBsZXNzIHRoYW4gdGhlIHNsaXBwYWdlIGxpbWl0JQEtIGBNYXhCdXlCYWNrRXhjZWVkZWRgIGlmIHRoZSBzZWxsIHdvdWxkIGV4Y2VlZCB0aGUgbWF4aW11bSBidXkgYmFjayByYXRlGQEtIGBNYXhCdXlQcmljZUV4Y2VlZGVkYCBpZiB0aGUgc2VsbCB3b3VsZCBleGNlZWQgdGhlIG1heGltdW0gYnV5IHByaWNlHQEtIGBJbnN1ZmZpY2llbnRDb2xsYXRlcmFsQmFsYW5jZWAgaWYgSFNNIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggY29sbGF0ZXJhbGEBLSBgSW52YWxpZEVWTUludGVyYWN0aW9uYCBpZiB0aGVyZSdzIGFuIGVycm9yIGludGVyYWN0aW5nIHdpdGggdGhlIEhvbGxhciBFUkMyMCBjb250cmFjdJAtIE90aGVyIGVycm9ycyBmcm9tIHVuZGVybHlpbmcgY2FsbHMMYnV5EAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABKGFtb3VudF9vdXQYARxCYWxhbmNlAAE4c2xpcHBhZ2VfbGltaXQYARxCYWxhbmNlAARkSEJ1eSBhc3NldCBmcm9tIEhTTQB4VGhpcyBmdW5jdGlvbiBhbGxvd3MgdXNlcnMgdG86uDEuIEJ1eSBIb2xsYXIgZnJvbSBIU00gdXNpbmcgY29sbGF0ZXJhbCBhc3NldHO4Mi4gQnV5IGNvbGxhdGVyYWwgYXNzZXRzIGZyb20gSFNNIHVzaW5nIEhvbGxhcgB1AVRoZSB2YWxpZCBwYWlycyBtdXN0IGluY2x1ZGUgSG9sbGFyIGFzIG9uZSBzaWRlIGFuZCBhbiBhcHByb3ZlZCBjb2xsYXRlcmFsIGFzIHRoZSBvdGhlciBzaWRlLgAsUGFyYW1ldGVyczqQLSBgb3JpZ2luYDogQWNjb3VudCBidXlpbmcgdGhlIGFzc2V0tC0gYGFzc2V0X2luYDogQXNzZXQgSUQgYmVpbmcgc29sZCBieSB0aGUgdXNlcsAtIGBhc3NldF9vdXRgOiBBc3NldCBJRCBiZWluZyBib3VnaHQgYnkgdGhlIHVzZXKoLSBgYW1vdW50X291dGA6IEFtb3VudCBvZiBhc3NldF9vdXQgdG8gYnV59C0gYHNsaXBwYWdlX2xpbWl0YDogTWF4aW11bSBhbW91bnQgaW4gZm9yIHNsaXBwYWdlIHByb3RlY3Rpb24AGEVtaXRzOpwtIGBTd2FwcGVkM2Agd2hlbiB0aGUgYnV5IGlzIHN1Y2Nlc3NmdWwAHEVycm9yczolAS0gYEludmFsaWRBc3NldFBhaXJgIGlmIHRoZSBwYWlyIGlzIG5vdCBIb2xsYXIgYW5kIGFuIGFwcHJvdmVkIGNvbGxhdGVyYWz0LSBgQXNzZXROb3RBcHByb3ZlZGAgaWYgdGhlIGNvbGxhdGVyYWwgYXNzZXQgaXNuJ3QgcmVnaXN0ZXJlZCEBLSBgU2xpcHBhZ2VMaW1pdEV4Y2VlZGVkYCBpZiB0aGUgYW1vdW50IGlucHV0IGV4Y2VlZHMgdGhlIHNsaXBwYWdlIGxpbWl0PQEtIGBNYXhIb2xkaW5nRXhjZWVkZWRgIGlmIHRoZSBidXkgd291bGQgY2F1c2UgSFNNIHRvIGV4Y2VlZCBpdHMgbWF4aW11bSBob2xkaW5nYQEtIGBJbnZhbGlkRVZNSW50ZXJhY3Rpb25gIGlmIHRoZXJlJ3MgYW4gZXJyb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgSG9sbGFyIEVSQzIwIGNvbnRyYWN0kC0gT3RoZXIgZXJyb3JzIGZyb20gdW5kZXJseWluZyBjYWxsc0RleGVjdXRlX2FyYml0cmFnZQgBTGNvbGxhdGVyYWxfYXNzZXRfaWQQAShUOjpBc3NldElkAAEkYXJiaXRyYWdlBQQBRE9wdGlvbjxBcmJpdHJhZ2U+AAWIWQFFeGVjdXRlIGFyYml0cmFnZSBvcHBvcnR1bml0eSBiZXR3ZWVuIEhTTSBhbmQgY29sbGF0ZXJhbCBzdGFibGUgcG9vbCB1c2luZyBmbGFzaCBsb2FucwBRAVRoaXMgY2FsbCBpcyBkZXNpZ25lZCB0byBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSBieSBvZmZjaGFpbiB3b3JrZXJzLiBJdCBleGVjdXRlc1kBYXJiaXRyYWdlIGJ5IHRha2luZyBhIGZsYXNoIGxvYW4gZnJvbSB0aGUgR0hPIGNvbnRyYWN0IGFuZCBwZXJmb3JtaW5nIHRyYWRlcyB0byBwcm9maXToZnJvbSBwcmljZSBpbWJhbGFuY2VzIGJldHdlZW4gSFNNIGFuZCB0aGUgU3RhYmxlU3dhcCBwb29sLgB0VGhlIGFyYml0cmFnZSBleGVjdXRpb24gZmxvdzrUMS4gVGFrZXMgYSBmbGFzaCBsb2FuIG9mIEhvbGxhciBmcm9tIHRoZSBHSE8gY29udHJhY3RBATIuIEV4ZWN1dGVzIHRyYWRlcyBiZXR3ZWVuIEhTTSBhbmQgU3RhYmxlU3dhcCBwb29sIGJhc2VkIG9uIGFyYml0cmFnZSBkaXJlY3Rpb246yQEgICAtIEZvciBIb2xsYXJJbiAoYnV5IGRpcmVjdGlvbik6IFNlbGwgSG9sbGFyIHRvIEhTTSBmb3IgY29sbGF0ZXJhbCwgdGhlbiBzZWxsIGNvbGxhdGVyYWwgYmFjayBmb3IgSG9sbGFyIGluIHBvb2yZASAgIC0gRm9yIEhvbGxhck91dCAoc2VsbCBkaXJlY3Rpb24pOiBTZWxsIEhvbGxhciBmb3IgY29sbGF0ZXJhbCBpbiBwb29sLCB0aGVuIGJ1eSBIb2xsYXIgYmFjayBmcm9tIEhTTWAzLiBSZXBheXMgdGhlIGZsYXNoIGxvYW5VATQuIEFueSByZW1haW5pbmcgcHJvZml0IChpbiBjb2xsYXRlcmFsKSBpcyB0cmFuc2ZlcnJlZCB0byB0aGUgQXJiaXRyYWdlUHJvZml0UmVjZWl2ZXIAYQFUaGlzIGhlbHBzIG1haW50YWluIHRoZSBwZWcgb2YgSG9sbGFyIGJ5IHByb2ZpdGluZyBmcm9tIGFuZCBjb3JyZWN0aW5nIHByaWNlIGltYmFsYW5jZXMuFQFUaGUgY2FsbCBpcyB1bnNpZ25lZCBhbmQgc2hvdWxkIG9ubHkgYmUgZXhlY3V0ZWQgYnkgb2ZmY2hhaW4gd29ya2Vycy4ALFBhcmFtZXRlcnM6jC0gYG9yaWdpbmA6IE11c3QgYmUgTm9uZSAodW5zaWduZWQpMQEtIGBjb2xsYXRlcmFsX2Fzc2V0X2lkYDogVGhlIElEIG9mIHRoZSBjb2xsYXRlcmFsIGFzc2V0IHRvIHVzZSBmb3IgYXJiaXRyYWdlaQEtIGBhcmJpdHJhZ2VgOiBPcHRpb25hbCBhcmJpdHJhZ2UgcGFyYW1ldGVycyAoZGlyZWN0aW9uIGFuZCBhbW91bnQpLiBJZiBOb25lLCB0aGUgZnVuY3Rpb24pASAgd2lsbCBhdXRvbWF0aWNhbGx5IGZpbmQgYW5kIGNhbGN1bGF0ZSB0aGUgb3B0aW1hbCBhcmJpdHJhZ2Ugb3Bwb3J0dW5pdHkuABhFbWl0czrYLSBgQXJiaXRyYWdlRXhlY3V0ZWRgIHdoZW4gdGhlIGFyYml0cmFnZSBpcyBzdWNjZXNzZnVsABxFcnJvcnM6SQEtIGBGbGFzaE1pbnRlck5vdFNldGAgaWYgdGhlIGZsYXNoIG1pbnRlciBjb250cmFjdCBhZGRyZXNzIGhhcyBub3QgYmVlbiBjb25maWd1cmVkAQEtIGBBc3NldE5vdEFwcHJvdmVkYCBpZiB0aGUgYXNzZXQgaXMgbm90IGEgcmVnaXN0ZXJlZCBjb2xsYXRlcmFsJQEtIGBOb0FyYml0cmFnZU9wcG9ydHVuaXR5YCBpZiB0aGVyZSdzIG5vIHByb2ZpdGFibGUgYXJiaXRyYWdlIG9wcG9ydHVuaXR5LQEtIGBNYXhCdXlQcmljZUV4Y2VlZGVkYCBpZiB0aGUgYXJiaXRyYWdlIHdvdWxkIGV4Y2VlZCB0aGUgbWF4aW11bSBidXkgcHJpY2UZAS0gYE1heEJ1eUJhY2tFeGNlZWRlZGAgaWYgdGhlIGFyYml0cmFnZSB3b3VsZCBleGNlZWQgdGhlIGJ1eWJhY2sgbGltaXRhAS0gYEludmFsaWRFVk1JbnRlcmFjdGlvbmAgaWYgdGhlcmUncyBhbiBlcnJvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBIb2xsYXIgRVJDMjAgY29udHJhY3SQLSBPdGhlciBlcnJvcnMgZnJvbSB1bmRlcmx5aW5nIGNhbGxzQHNldF9mbGFzaF9taW50ZXIEAURmbGFzaF9taW50ZXJfYWRkckEBAShFdm1BZGRyZXNzAAY8lFNldCB0aGUgZmxhc2ggbWludGVyIGNvbnRyYWN0IGFkZHJlc3MAVQFDb25maWd1cmVzIHRoZSBFVk0gYWRkcmVzcyBvZiB0aGUgZmxhc2ggbG9hbiBjb250cmFjdCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYXJiaXRyYWdlWQFvcGVyYXRpb25zLiBUaGlzIGNvbnRyYWN0IG11c3Qgc3VwcG9ydCB0aGUgRVJDLTMxNTYgZmxhc2ggbG9hbiBzdGFuZGFyZCBhbmQgYmUgdHJ1c3RlZJx0byBoYW5kbGUgZmxhc2ggbG9hbnMgb2YgSG9sbGFyIHRva2Vucy4ALFBhcmFtZXRlcnM6wC0gYG9yaWdpbmA6IE11c3QgYmUgYXV0aG9yaXplZCAoZ292ZXJuYW5jZS9yb290KQ0BLSBgZmxhc2hfbWludGVyX2FkZHJgOiBUaGUgRVZNIGFkZHJlc3Mgb2YgdGhlIGZsYXNoIG1pbnRlciBjb250cmFjdAAYRW1pdHM6+C0gYEZsYXNoTWludGVyU2V0YCB3aGVuIHRoZSBhZGRyZXNzIGlzIHN1Y2Nlc3NmdWxseSBjb25maWd1cmVkABxFcnJvcnM6yC0gQXV0aG9yaXphdGlvbiBlcnJvcnMgaWYgb3JpZ2luIGlzIG5vdCBhdXRob3JpemVkBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLvUDBBhPcHRpb24EBFQBIQMBCBBOb25lAAAAEFNvbWUEACEDAAABAAD5AwQYT3B0aW9uBARUAT0BAQgQTm9uZQAAABBTb21lBAA9AQAAAQAA/QMEGE9wdGlvbgQEVAHBAwEIEE5vbmUAAAAQU29tZQQAwQMAAAEAAAEEBBhPcHRpb24EBFQB4AEIEE5vbmUAAAAQU29tZQQA4AAAAQAABQQEGE9wdGlvbgQEVAEJBAEIEE5vbmUAAAAQU29tZQQACQQAAAEAAAkEDChwYWxsZXRfaHNtFHR5cGVzJEFyYml0cmFnZQABCCRIb2xsYXJPdXQEABgBHEJhbGFuY2UAAAAgSG9sbGFySW4EABgBHEJhbGFuY2UAAQAADQQMLG9ybWxfdG9rZW5zGG1vZHVsZRBDYWxsBARUAAEUIHRyYW5zZmVyDAEQZGVzdAABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEYYW1vdW50LQEBKFQ6OkJhbGFuY2UAADTUVHJhbnNmZXIgc29tZSBsaXF1aWQgZnJlZSBiYWxhbmNlIHRvIGFub3RoZXIgYWNjb3VudC4ABQFgdHJhbnNmZXJgIHdpbGwgc2V0IHRoZSBgRnJlZUJhbGFuY2VgIG9mIHRoZSBzZW5kZXIgYW5kIHJlY2VpdmVyLuBJdCB3aWxsIGRlY3JlYXNlIHRoZSB0b3RhbCBpc3N1YW5jZSBvZiB0aGUgc3lzdGVtIGJ5IHRoZfxgVHJhbnNmZXJGZWVgLiBJZiB0aGUgc2VuZGVyJ3MgYWNjb3VudCBpcyBiZWxvdyB0aGUgZXhpc3RlbnRpYWwBAWRlcG9zaXQgYXMgYSByZXN1bHQgb2YgdGhlIHRyYW5zZmVyLCB0aGUgYWNjb3VudCB3aWxsIGJlIHJlYXBlZC4A5FRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIGBTaWduZWRgIGJ5IHRoZSx0cmFuc2FjdG9yLgCgLSBgZGVzdGA6IFRoZSByZWNpcGllbnQgb2YgdGhlIHRyYW5zZmVyLnwtIGBjdXJyZW5jeV9pZGA6IGN1cnJlbmN5IHR5cGUurC0gYGFtb3VudGA6IGZyZWUgYmFsYW5jZSBhbW91bnQgdG8gdHJhbmZlci4wdHJhbnNmZXJfYWxsDAEQZGVzdAABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEoa2VlcF9hbGl2ZSABEGJvb2wAAUzQVHJhbnNmZXIgYWxsIHJlbWFpbmluZyBiYWxhbmNlIHRvIHRoZSBnaXZlbiBhY2NvdW50LgDwTk9URTogVGhpcyBmdW5jdGlvbiBvbmx5IGF0dGVtcHRzIHRvIHRyYW5zZmVyIF90cmFuc2ZlcmFibGVf+GJhbGFuY2VzLiBUaGlzIG1lYW5zIHRoYXQgYW55IGxvY2tlZCwgcmVzZXJ2ZWQsIG9yIGV4aXN0ZW50aWFsCQFkZXBvc2l0cyAod2hlbiBga2VlcF9hbGl2ZWAgaXMgYHRydWVgKSwgd2lsbCBub3QgYmUgdHJhbnNmZXJyZWQgYnn8dGhpcyBmdW5jdGlvbi4gVG8gZW5zdXJlIHRoYXQgdGhpcyBmdW5jdGlvbiByZXN1bHRzIGluIGEga2lsbGVk+GFjY291bnQsIHlvdSBtaWdodCBuZWVkIHRvIHByZXBhcmUgdGhlIGFjY291bnQgYnkgcmVtb3ZpbmcgYW55sHJlZmVyZW5jZSBjb3VudGVycywgc3RvcmFnZSBkZXBvc2l0cywgZXRjLi4uAORUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSBgU2lnbmVkYCBieSB0aGUsdHJhbnNhY3Rvci4AoC0gYGRlc3RgOiBUaGUgcmVjaXBpZW50IG9mIHRoZSB0cmFuc2Zlci58LSBgY3VycmVuY3lfaWRgOiBjdXJyZW5jeSB0eXBlLvAtIGBrZWVwX2FsaXZlYDogQSBib29sZWFuIHRvIGRldGVybWluZSBpZiB0aGUgYHRyYW5zZmVyX2FsbGAFASAgb3BlcmF0aW9uIHNob3VsZCBzZW5kIGFsbCBvZiB0aGUgZnVuZHMgdGhlIGFjY291bnQgaGFzLCBjYXVzaW5nBQEgIHRoZSBzZW5kZXIgYWNjb3VudCB0byBiZSBraWxsZWQgKGZhbHNlKSwgb3IgdHJhbnNmZXIgZXZlcnl0aGluZwkBICBleGNlcHQgYXQgbGVhc3QgdGhlIGV4aXN0ZW50aWFsIGRlcG9zaXQsIHdoaWNoIHdpbGwgZ3VhcmFudGVlIHRvnCAga2VlcCB0aGUgc2VuZGVyIGFjY291bnQgYWxpdmUgKHRydWUpLkx0cmFuc2Zlcl9rZWVwX2FsaXZlDAEQZGVzdAABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEYYW1vdW50LQEBKFQ6OkJhbGFuY2UAAiwFAVNhbWUgYXMgdGhlIFtgdHJhbnNmZXJgXSBjYWxsLCBidXQgd2l0aCBhIGNoZWNrIHRoYXQgdGhlIHRyYW5zZmVyhHdpbGwgbm90IGtpbGwgdGhlIG9yaWdpbiBhY2NvdW50LgC4OTklIG9mIHRoZSB0aW1lIHlvdSB3YW50IFtgdHJhbnNmZXJgXSBpbnN0ZWFkLgDkVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgYFNpZ25lZGAgYnkgdGhlLHRyYW5zYWN0b3IuAKAtIGBkZXN0YDogVGhlIHJlY2lwaWVudCBvZiB0aGUgdHJhbnNmZXIufC0gYGN1cnJlbmN5X2lkYDogY3VycmVuY3kgdHlwZS6sLSBgYW1vdW50YDogZnJlZSBiYWxhbmNlIGFtb3VudCB0byB0cmFuZmVyLjhmb3JjZV90cmFuc2ZlchABGHNvdXJjZQABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEQZGVzdAABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEYYW1vdW50LQEBKFQ6OkJhbGFuY2UAAyQRAUV4YWN0bHkgYXMgYHRyYW5zZmVyYCwgZXhjZXB0IHRoZSBvcmlnaW4gbXVzdCBiZSByb290IGFuZCB0aGUgc291cmNlZGFjY291bnQgbWF5IGJlIHNwZWNpZmllZC4AxFRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIF9Sb290Xy4AnC0gYHNvdXJjZWA6IFRoZSBzZW5kZXIgb2YgdGhlIHRyYW5zZmVyLqAtIGBkZXN0YDogVGhlIHJlY2lwaWVudCBvZiB0aGUgdHJhbnNmZXIufC0gYGN1cnJlbmN5X2lkYDogY3VycmVuY3kgdHlwZS6sLSBgYW1vdW50YDogZnJlZSBiYWxhbmNlIGFtb3VudCB0byB0cmFuZmVyLixzZXRfYmFsYW5jZRABDHdobwABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEgbmV3X2ZyZWUtAQEoVDo6QmFsYW5jZQABMG5ld19yZXNlcnZlZC0BAShUOjpCYWxhbmNlAAQgkFNldCB0aGUgYmFsYW5jZXMgb2YgYSBnaXZlbiBhY2NvdW50LgAJAVRoaXMgd2lsbCBhbHRlciBgRnJlZUJhbGFuY2VgIGFuZCBgUmVzZXJ2ZWRCYWxhbmNlYCBpbiBzdG9yYWdlLiBpdMx3aWxsIGFsc28gZGVjcmVhc2UgdGhlIHRvdGFsIGlzc3VhbmNlIG9mIHRoZSBzeXN0ZW0NAShgVG90YWxJc3N1YW5jZWApLiBJZiB0aGUgbmV3IGZyZWUgb3IgcmVzZXJ2ZWQgYmFsYW5jZSBpcyBiZWxvdyB0aGXQZXhpc3RlbnRpYWwgZGVwb3NpdCwgaXQgd2lsbCByZWFwIHRoZSBgQWNjb3VudEluZm9gLgCwVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIGlzIGByb290YC4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuEQQMRHBhbGxldF9jdXJyZW5jaWVzGG1vZHVsZRBDYWxsBARUAAEMIHRyYW5zZmVyDAEQZGVzdAABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATxDdXJyZW5jeUlkT2Y8VD4AARhhbW91bnQtAQEwQmFsYW5jZU9mPFQ+AAAQ9FRyYW5zZmVyIHNvbWUgYmFsYW5jZSB0byBhbm90aGVyIGFjY291bnQgdW5kZXIgYGN1cnJlbmN5X2lkYC4A5FRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIGBTaWduZWRgIGJ5IHRoZSx0cmFuc2FjdG9yLmB0cmFuc2Zlcl9uYXRpdmVfY3VycmVuY3kIARBkZXN0AAGMPFQ6Okxvb2t1cCBhcyBTdGF0aWNMb29rdXA+OjpTb3VyY2UAARhhbW91bnQtAQEwQmFsYW5jZU9mPFQ+AAEQxFRyYW5zZmVyIHNvbWUgbmF0aXZlIGN1cnJlbmN5IHRvIGFub3RoZXIgYWNjb3VudC4A5FRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIGBTaWduZWRgIGJ5IHRoZSx0cmFuc2FjdG9yLjh1cGRhdGVfYmFsYW5jZQwBDHdobwABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEsY3VycmVuY3lfaWQQATxDdXJyZW5jeUlkT2Y8VD4AARhhbW91bnQVBAEsQW1vdW50T2Y8VD4AAgzMdXBkYXRlIGFtb3VudCBvZiBhY2NvdW50IGB3aG9gIHVuZGVyIGBjdXJyZW5jeV9pZGAuAMBUaGUgZGlzcGF0Y2ggb3JpZ2luIG9mIHRoaXMgY2FsbCBtdXN0IGJlIF9Sb290Xy4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuFQQAAAUNABkEDDBvcm1sX3Zlc3RpbmcYbW9kdWxlEENhbGwEBFQAARAUY2xhaW0AAAA8dmVzdGVkX3RyYW5zZmVyCAEQZGVzdAABjDxUOjpMb29rdXAgYXMgU3RhdGljTG9va3VwPjo6U291cmNlAAEgc2NoZWR1bGUdBAFQVmVzdGluZ1NjaGVkdWxlT2Y8VD4AAQBgdXBkYXRlX3Zlc3Rpbmdfc2NoZWR1bGVzCAEMd2hvAAGMPFQ6Okxvb2t1cCBhcyBTdGF0aWNMb29rdXA+OjpTb3VyY2UAAUR2ZXN0aW5nX3NjaGVkdWxlcyEEAWRWZWM8VmVzdGluZ1NjaGVkdWxlT2Y8VD4+AAIAJGNsYWltX2ZvcgQBEGRlc3QAAYw8VDo6TG9va3VwIGFzIFN0YXRpY0xvb2t1cD46OlNvdXJjZQADAAQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy4dBAgwb3JtbF92ZXN0aW5nPFZlc3RpbmdTY2hlZHVsZQgsQmxvY2tOdW1iZXIBEBxCYWxhbmNlARgAEAEUc3RhcnQQASxCbG9ja051bWJlcgABGHBlcmlvZBABLEJsb2NrTnVtYmVyAAEwcGVyaW9kX2NvdW50EAEMdTMyAAEocGVyX3BlcmlvZC0BARxCYWxhbmNlAAAhBAAAAh0EACUEDChwYWxsZXRfZXZtGHBhbGxldBBDYWxsBARUAAEQIHdpdGhkcmF3CAEcYWRkcmVzc0EBARBIMTYwAAEUdmFsdWUYATBCYWxhbmNlT2Y8VD4AAATgV2l0aGRyYXcgYmFsYW5jZSBmcm9tIEVWTSBpbnRvIGN1cnJlbmN5L2JhbGFuY2VzIHBhbGxldC4QY2FsbCQBGHNvdXJjZUEBARBIMTYwAAEYdGFyZ2V0QQEBEEgxNjAAARRpbnB1dDgBHFZlYzx1OD4AARR2YWx1ZUkBARBVMjU2AAEkZ2FzX2xpbWl0MAEMdTY0AAE8bWF4X2ZlZV9wZXJfZ2FzSQEBEFUyNTYAAWBtYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXMpBAEwT3B0aW9uPFUyNTY+AAEUbm9uY2UpBAEwT3B0aW9uPFUyNTY+AAEsYWNjZXNzX2xpc3QtBAFYVmVjPChIMTYwLCBWZWM8SDI1Nj4pPgABBF0BSXNzdWUgYW4gRVZNIGNhbGwgb3BlcmF0aW9uLiBUaGlzIGlzIHNpbWlsYXIgdG8gYSBtZXNzYWdlIGNhbGwgdHJhbnNhY3Rpb24gaW4gRXRoZXJldW0uGGNyZWF0ZSABGHNvdXJjZUEBARBIMTYwAAEQaW5pdDgBHFZlYzx1OD4AARR2YWx1ZUkBARBVMjU2AAEkZ2FzX2xpbWl0MAEMdTY0AAE8bWF4X2ZlZV9wZXJfZ2FzSQEBEFUyNTYAAWBtYXhfcHJpb3JpdHlfZmVlX3Blcl9nYXMpBAEwT3B0aW9uPFUyNTY+AAEUbm9uY2UpBAEwT3B0aW9uPFUyNTY+AAEsYWNjZXNzX2xpc3QtBAFYVmVjPChIMTYwLCBWZWM8SDI1Nj4pPgACCFEBSXNzdWUgYW4gRVZNIGNyZWF0ZSBvcGVyYXRpb24uIFRoaXMgaXMgc2ltaWxhciB0byBhIGNvbnRyYWN0IGNyZWF0aW9uIHRyYW5zYWN0aW9uIGluJEV0aGVyZXVtLhxjcmVhdGUyJAEYc291cmNlQQEBEEgxNjAAARBpbml0OAEcVmVjPHU4PgABEHNhbHQ0ARBIMjU2AAEUdmFsdWVJAQEQVTI1NgABJGdhc19saW1pdDABDHU2NAABPG1heF9mZWVfcGVyX2dhc0kBARBVMjU2AAFgbWF4X3ByaW9yaXR5X2ZlZV9wZXJfZ2FzKQQBME9wdGlvbjxVMjU2PgABFG5vbmNlKQQBME9wdGlvbjxVMjU2PgABLGFjY2Vzc19saXN0LQQBWFZlYzwoSDE2MCwgVmVjPEgyNTY+KT4AAwR8SXNzdWUgYW4gRVZNIGNyZWF0ZTIgb3BlcmF0aW9uLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy4pBAQYT3B0aW9uBARUAUkBAQgQTm9uZQAAABBTb21lBABJAQAAAQAALQQAAAIxBAAxBAAABAhBAckBADUEDDxwYWxsZXRfZXRoZXJldW0YcGFsbGV0EENhbGwEBFQAAQQgdHJhbnNhY3QEASx0cmFuc2FjdGlvbjkEASxUcmFuc2FjdGlvbgAABIRUcmFuc2FjdCBhbiBFdGhlcmV1bSB0cmFuc2FjdGlvbi4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuOQQMIGV0aGVyZXVtLHRyYW5zYWN0aW9uNFRyYW5zYWN0aW9uVjIAAQwYTGVnYWN5BAA9BAFETGVnYWN5VHJhbnNhY3Rpb24AAAAcRUlQMjkzMAQATQQBSEVJUDI5MzBUcmFuc2FjdGlvbgABABxFSVAxNTU5BABZBAFIRUlQMTU1OVRyYW5zYWN0aW9uAAIAAD0EDCBldGhlcmV1bSx0cmFuc2FjdGlvbkRMZWdhY3lUcmFuc2FjdGlvbgAAHAEUbm9uY2VJAQEQVTI1NgABJGdhc19wcmljZUkBARBVMjU2AAEkZ2FzX2xpbWl0SQEBEFUyNTYAARhhY3Rpb25BBAFEVHJhbnNhY3Rpb25BY3Rpb24AARR2YWx1ZUkBARBVMjU2AAEUaW5wdXQ4ARRCeXRlcwABJHNpZ25hdHVyZUUEAVBUcmFuc2FjdGlvblNpZ25hdHVyZQAAQQQMIGV0aGVyZXVtLHRyYW5zYWN0aW9uRFRyYW5zYWN0aW9uQWN0aW9uAAEIEENhbGwEAEEBARBIMTYwAAAAGENyZWF0ZQABAABFBAwgZXRoZXJldW0sdHJhbnNhY3Rpb25QVHJhbnNhY3Rpb25TaWduYXR1cmUAAAwBBHZJBAFUVHJhbnNhY3Rpb25SZWNvdmVyeUlkAAEEcjQBEEgyNTYAAQRzNAEQSDI1NgAASQQMIGV0aGVyZXVtLHRyYW5zYWN0aW9uVFRyYW5zYWN0aW9uUmVjb3ZlcnlJZAAABAAwAQx1NjQAAE0EDCBldGhlcmV1bSx0cmFuc2FjdGlvbkhFSVAyOTMwVHJhbnNhY3Rpb24AACwBIGNoYWluX2lkMAEMdTY0AAEUbm9uY2VJAQEQVTI1NgABJGdhc19wcmljZUkBARBVMjU2AAEkZ2FzX2xpbWl0SQEBEFUyNTYAARhhY3Rpb25BBAFEVHJhbnNhY3Rpb25BY3Rpb24AARR2YWx1ZUkBARBVMjU2AAEUaW5wdXQ4ARRCeXRlcwABLGFjY2Vzc19saXN0UQQBKEFjY2Vzc0xpc3QAATBvZGRfeV9wYXJpdHkgARBib29sAAEEcjQBEEgyNTYAAQRzNAEQSDI1NgAAUQQAAAJVBABVBAwgZXRoZXJldW0sdHJhbnNhY3Rpb244QWNjZXNzTGlzdEl0ZW0AAAgBHGFkZHJlc3NBAQEcQWRkcmVzcwABMHN0b3JhZ2Vfa2V5c8kBASRWZWM8SDI1Nj4AAFkEDCBldGhlcmV1bSx0cmFuc2FjdGlvbkhFSVAxNTU5VHJhbnNhY3Rpb24AADABIGNoYWluX2lkMAEMdTY0AAEUbm9uY2VJAQEQVTI1NgABYG1heF9wcmlvcml0eV9mZWVfcGVyX2dhc0kBARBVMjU2AAE8bWF4X2ZlZV9wZXJfZ2FzSQEBEFUyNTYAASRnYXNfbGltaXRJAQEQVTI1NgABGGFjdGlvbkEEAURUcmFuc2FjdGlvbkFjdGlvbgABFHZhbHVlSQEBEFUyNTYAARRpbnB1dDgBFEJ5dGVzAAEsYWNjZXNzX2xpc3RRBAEoQWNjZXNzTGlzdAABMG9kZF95X3Bhcml0eSABEGJvb2wAAQRyNAEQSDI1NgABBHM0ARBIMjU2AABdBAxMcGFsbGV0X2V2bV9hY2NvdW50cxhwYWxsZXQQQ2FsbAQEVAABGEBiaW5kX2V2bV9hZGRyZXNzAAAspEJpbmRzIGEgU3Vic3RyYXRlIGFkZHJlc3MgdG8gRVZNIGFkZHJlc3MubQFBZnRlciBiaW5kaW5nLCB0aGUgRVZNIGlzIGFibGUgdG8gY29udmVydCBhbiBFVk0gYWRkcmVzcyB0byB0aGUgb3JpZ2luYWwgU3Vic3RyYXRlIGFkZHJlc3MurQFXaXRob3V0IGJpbmRpbmcsIHRoZSBFVk0gY29udmVydHMgYW4gRVZNIGFkZHJlc3MgdG8gYSB0cnVuY2F0ZWQgU3Vic3RyYXRlIGFkZHJlc3MsIHdoaWNoIGRvZXNuJ3QgY29ycmVzcG9uZFh0byB0aGUgb3JpZ2luIGFkZHJlc3MuAAUBQmluZGluZyBhbiBhZGRyZXNzIGlzIG5vdCBuZWNlc3NhcnkgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIEVWTS4ALFBhcmFtZXRlcnM6wC0gYG9yaWdpbmA6IFN1YnN0cmF0ZSBhY2NvdW50IGJpbmRpbmcgYW4gYWRkcmVzcwC4RW1pdHMgYEV2bUFjY291bnRCb3VuZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLlRhZGRfY29udHJhY3RfZGVwbG95ZXIEARxhZGRyZXNzQQEBKEV2bUFkZHJlc3MAARxhAUFkZHMgYW4gRVZNIGFkZHJlc3MgdG8gdGhlIGxpc3Qgb2YgYWRkcmVzc2VzIHRoYXQgYXJlIGFsbG93ZWQgdG8gZGVwbG95IHNtYXJ0IGNvbnRyYWN0cy4ALFBhcmFtZXRlcnM6SQEtIGBvcmlnaW5gOiBTdWJzdHJhdGUgYWNjb3VudCB3aGl0ZWxpc3RpbmcgYW4gYWRkcmVzcy4gTXVzdCBiZSBgQ29udHJvbGxlck9yaWdpbmAusC0gYGFkZHJlc3NgOiBFVk0gYWRkcmVzcyB0aGF0IGlzIHdoaXRlbGlzdGVkALBFbWl0cyBgRGVwbG95ZXJBZGRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLmByZW1vdmVfY29udHJhY3RfZGVwbG95ZXIEARxhZGRyZXNzQQEBKEV2bUFkZHJlc3MAAhx1AVJlbW92ZXMgYW4gRVZNIGFkZHJlc3MgZnJvbSB0aGUgbGlzdCBvZiBhZGRyZXNzZXMgdGhhdCBhcmUgYWxsb3dlZCB0byBkZXBsb3kgc21hcnQgY29udHJhY3RzLgAsUGFyYW1ldGVyczqZAS0gYG9yaWdpbmA6IFN1YnN0cmF0ZSBhY2NvdW50IHJlbW92aW5nIHRoZSBFVk0gYWRkcmVzcyBmcm9tIHRoZSB3aGl0ZWxpc3QuIE11c3QgYmUgYENvbnRyb2xsZXJPcmlnaW5gLuwtIGBhZGRyZXNzYDogRVZNIGFkZHJlc3MgdGhhdCBpcyByZW1vdmVkIGZyb20gdGhlIHdoaXRlbGlzdAC4RW1pdHMgYERlcGxveWVyUmVtb3ZlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLmhyZW5vdW5jZV9jb250cmFjdF9kZXBsb3llcgADHKEBUmVtb3ZlcyB0aGUgYWNjb3VudCdzIEVWTSBhZGRyZXNzIGZyb20gdGhlIGxpc3Qgb2YgYWRkcmVzc2VzIHRoYXQgYXJlIGFsbG93ZWQgdG8gZGVwbG95IHNtYXJ0IGNvbnRyYWN0cy7ZAUJhc2VkIG9uIHRoZSBiZXN0IHByYWN0aWNlcywgdGhpcyBleHRyaW5zaWMgY2FuIGJlIGNhbGxlZCBieSBhbnkgd2hpdGVsaXN0ZWQgYWNjb3VudCB0byByZW5vdW5jZSB0aGVpciBvd24gcGVybWlzc2lvbi4ALFBhcmFtZXRlcnM6MQEtIGBvcmlnaW5gOiBTdWJzdHJhdGUgYWNjb3VudCByZW1vdmluZyB0aGVpciBFVk0gYWRkcmVzcyBmcm9tIHRoZSB3aGl0ZWxpc3QuALhFbWl0cyBgRGVwbG95ZXJSZW1vdmVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuQGFwcHJvdmVfY29udHJhY3QEARxhZGRyZXNzQQEBKEV2bUFkZHJlc3MABCRJAUFkZHMgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdG8gdGhlIGxpc3Qgb2YgYXBwcm92ZWQgY29udHJhY3RzIHRvIG1hbmFnZSBiYWxhbmNlcy4A/EVmZmVjdGl2ZWx5IGdpdmluZyBpdCBhbGxvd2FuY2UgdG8gZm9yIGFueSBiYWxhbmNlcyBhbmQgdG9rZW5zLgAsUGFyYW1ldGVyczqgLSBgb3JpZ2luYDogIE11c3QgYmUgYENvbnRyb2xsZXJPcmlnaW5gLswtIGBhZGRyZXNzYDogQ29udHJhY3QgYWRkcmVzcyB0aGF0IHdpbGwgYmUgYXBwcm92ZWQAvEVtaXRzIGBDb250cmFjdEFwcHJvdmVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuTGRpc2FwcHJvdmVfY29udHJhY3QEARxhZGRyZXNzQQEBKEV2bUFkZHJlc3MABRxdAVJlbW92ZXMgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgZnJvbSB0aGUgbGlzdCBvZiBhcHByb3ZlZCBjb250cmFjdHMgdG8gbWFuYWdlIGJhbGFuY2VzLgAsUGFyYW1ldGVyczqgLSBgb3JpZ2luYDogIE11c3QgYmUgYENvbnRyb2xsZXJPcmlnaW5gLtgtIGBhZGRyZXNzYDogQ29udHJhY3QgYWRkcmVzcyB0aGF0IHdpbGwgYmUgZGlzYXBwcm92ZWQAyEVtaXRzIGBDb250cmFjdERpc2FwcHJvdmVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLmEEDGxwYWxsZXRfeHlrX2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0EENhbGwEBFQAATxIY3JlYXRlX2dsb2JhbF9mYXJtJAE0dG90YWxfcmV3YXJkcxgBHEJhbGFuY2UAAWBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMQASxQZXJpb2RPZjxUPgABRGJsb2Nrc19wZXJfcGVyaW9kEAFEQmxvY2tOdW1iZXJGb3I8VD4AAUhpbmNlbnRpdml6ZWRfYXNzZXQQARxBc3NldElkAAE8cmV3YXJkX2N1cnJlbmN5EAEcQXNzZXRJZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAFAeWllbGRfcGVyX3BlcmlvZD0DASxQZXJxdWludGlsbAABLG1pbl9kZXBvc2l0GAEcQmFsYW5jZQABQHByaWNlX2FkanVzdG1lbnQ9AQEkRml4ZWRVMTI4AAB09ENyZWF0ZSBuZXcgbGlxdWlkaXR5IG1pbmluZyBwcm9ncmFtIHdpdGggcHJvdmlkZWQgcGFyYW1ldGVycy4APQFgb3duZXJgIGFjY291bnQgaGFzIHRvIGhhdmUgYXQgbGVhc3QgYHRvdGFsX3Jld2FyZHNgIGJhbGFuY2UuIFRoaXMgZnVuZCB3aWxsIGJlpHRyYW5zZmVycmVkIGZyb20gYG93bmVyYCB0byBmYXJtIGFjY291bnQuZQFJbiBjYXNlIG9mIGByZXdhcmRfY3VycmVuY3lgIGlzIGluc3VmZmljaWVudCBhc3NldCwgZmFybSdzIGBvd25lcmAgaGFzIHRvIHBheSBleGlzdGVudGlhbB0BZGVwb3NpdCBmb3IgZ2xvYmFsIGZhcm0gYWNjb3VudCBhbmQgZm9yIGxpcXVpZGl0eSBtaW5pbmcgYHBvdGAgYWNjb3VudC4A8FRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIGBUOjpDcmVhdGVPcmlnaW5gLlUBISEhV0FSTjogYFQ6OkNyZWF0ZU9yaWdpbmAgaGFzIHBvd2VyIG92ZXIgZnVuZHMgb2YgYG93bmVyYCdzIGFjY291bnQgYW5kIGl0IHNob3VsZCBiZdBjb25maWd1cmVkIHRvIHRydXN0ZWQgb3JpZ2luIGUuZyBTdWRvIG9yIEdvdmVybmFuY2UuACxQYXJhbWV0ZXJzOoAtIGBvcmlnaW5gOiBnbG9iYWwgZmFybSdzIG93bmVyLjEBLSBgdG90YWxfcmV3YXJkc2A6IHRvdGFsIHJld2FyZHMgcGxhbm5lZCB0byBkaXN0cmlidXRlLiBUaGlzIHJld2FyZHMgd2lsbCBiZdxkaXN0cmlidXRlZCBiZXR3ZWVuIGFsbCB5aWVsZCBmYXJtcyBpbiB0aGUgZ2xvYmFsIGZhcm0uWQEtIGBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHNgOiBwbGFubmVkIG51bWJlciBvZiBwZXJpb2RzIHRvIGRpc3RyaWJ1dGUgYHRvdGFsX3Jld2FyZHNgLikBV0FSTjogVEhJUyBJUyBOT1QgSEFSRCBERUFETElORS4gTm90IGFsbCByZXdhcmRzIGhhdmUgdG8gYmUgZGlzdHJpYnV0ZWQgaW5dAWBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHNgLiBSZXdhcmRzIGFyZSBkaXN0cmlidXRlZCBiYXNlZCBvbiB0aGUgc2l0dWF0aW9uIGluIHRoZSB5aWVsZGEBZmFybXMgYW5kIGNhbiBiZSBkaXN0cmlidXRlZCBpbiBhIGxvbmdlciB0aW1lIGZyYW1lIGJ1dCBuZXZlciBpbiB0aGUgc2hvcnRlciB0aW1lIGZyYW1lLlkBLSBgYmxvY2tzX3Blcl9wZXJpb2RgOiAgbnVtYmVyIG9mIGJsb2NrcyBpbiBhIHNpbmdsZSBwZXJpb2QuIE1pbi4gbnVtYmVyIG9mIGJsb2NrcyBwZXIwcGVyaW9kIGlzIDEuZQEtIGBpbmNlbnRpdml6ZWRfYXNzZXRgOiBhc3NldCB0byBiZSBpbmNlbnRpdml6ZWQgaW4gWFlLIHBvb2xzLiBBbGwgeWllbGQgZmFybXMgYWRkZWQgaW50bxEBbGlxLiBtaW5pbmcgcHJvZ3JhbSBoYXZlIHRvIGhhdmUgYGluY2VudGl2aXplZF9hc3NldGAgaW4gdGhlaXIgcGFpci7ALSBgcmV3YXJkX2N1cnJlbmN5YDogcGF5b2ZmIGN1cnJlbmN5IG9mIHJld2FyZHMulC0gYG93bmVyYDogbGlxLiBtaW5pbmcgcHJvZ3JhbSBvd25lci45AS0gYHlpZWxkX3Blcl9wZXJpb2RgOiBwZXJjZW50YWdlIHJldHVybiBvbiBgcmV3YXJkX2N1cnJlbmN5YCBvZiBhbGwgZmFybXMgcC5hLgkBLSBgbWluX2RlcG9zaXRgOiBtaW5pbXVtIGFtb3VudCB3aGljaCBjYW4gYmUgZGVwb3NpdGVkIHRvIHRoZSBmYXJtVC0gYHByaWNlX2FkanVzdG1lbnRgOsBFbWl0cyBgR2xvYmFsRmFybUNyZWF0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC5IdXBkYXRlX2dsb2JhbF9mYXJtCAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAAUBwcmljZV9hZGp1c3RtZW50PQEBJEZpeGVkVTEyOAABKJxVcGRhdGUgZ2xvYmFsIGZhcm0ncyBwcmljZXMgYWRqdXN0bWVudC4AqE9ubHkgZmFybSdzIG93bmVyIGNhbiBwZXJmb3JtIHRoaXMgYWN0aW9uLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci7MLSBgZ2xvYmFsX2Zhcm1faWRgOiBpZCBvZiB0aGUgZ2xvYmFsIGZhcm0gdG8gdXBkYXRl0C0gYHByaWNlX2FkanVzdG1lbnRgOiBuZXcgdmFsdWUgZm9yIHByaWNlIGFkanVzdG1lbnQAwEVtaXRzIGBHbG9iYWxGYXJtVXBkYXRlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLlR0ZXJtaW5hdGVfZ2xvYmFsX2Zhcm0EAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAACLJxUZXJtaW5hdGUgZXhpc3RpbmcgbGlxLiBtaW5pbmcgcHJvZ3JhbS4AoE9ubHkgZmFybSBvd25lciBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4A0QFXQVJOOiBUbyBzdWNjZXNzZnVsbHkgdGVybWluYXRlIGEgZmFybSwgZmFybSBoYXZlIHRvIGJlIGVtcHR5KGFsbCB5aWVsZCBmYXJtcyBpbiBoZSBnbG9iYWwgZmFybSBtdXN0IGJlIHRlcm1pbmF0ZWQpLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci7cLSBgZ2xvYmFsX2Zhcm1faWRgOiBpZCBvZiBnbG9iYWwgZmFybSB0byBiZSB0ZXJtaW5hdGVkLgDMRW1pdHMgYEdsb2JhbEZhcm1UZXJtaW5hdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuRGNyZWF0ZV95aWVsZF9mYXJtEAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIAATRsb3lhbHR5X2N1cnZlQQMBUE9wdGlvbjxMb3lhbHR5Q3VydmU+AANIvEFkZCB5aWVsZCBmYXJtIGZvciBnaXZlbiBgYXNzZXRfcGFpcmAgWFlLIHBvb2wuBCCgT25seSBmYXJtIG93bmVyIGNhbiBwZXJmb3JtIHRoaXMgYWN0aW9uLgBVAU9ubHkgWFlLcyB3aXRoIGBhc3NldF9wYWlyYCB3aXRoIGBpbmNlbnRpdml6ZWRfYXNzZXRgIGNhbiBiZSBhZGRlZCBpbnRvIHRoZSBmYXJtLiBYWUsVAXBvb2wgZm9yIGBhc3NldF9wYWlyYCBoYXMgdG8gZXhpc3QgdG8gc3VjY2Vzc2Z1bGx5IGNyZWF0ZSB5aWVsZCBmYXJtLiEBWWllbGQgZmFybSBmb3Igc2FtZSBgYXNzZXRfcGFpcmAgY2FuIGV4aXN0IG9ubHkgb25jZSBpbiB0aGUgZ2xvYmFsIGZhcm0uACxQYXJhbWV0ZXJzOoAtIGBvcmlnaW5gOiBnbG9iYWwgZmFybSdzIG93bmVyLgEBLSBgZmFybV9pZGA6IGdsb2JhbCBmYXJtIGlkIHRvIHdoaWNoIGEgeWllbGQgZmFybSB3aWxsIGJlIGFkZGVkLl0BLSBgYXNzZXRfcGFpcmA6IGFzc2V0IHBhaXIgaWRlbnRpZnlpbmcgeWllbGQgZmFybS4gTGlxLiBtaW5pbmcgd2lsbCBiZSBhbGxvd2VkIGZvciB0aGlzMQFgYXNzZXRfcGFpcmAgYW5kIG9uZSBvZiB0aGUgYXNzZXRzIGluIHRoZSBwYWlyIG11c3QgYmUgYGluY2VudGl2aXplZF9hc3NldGAumC0gYG11bHRpcGxpZXJgOiB5aWVsZCBmYXJtIG11bHRpcGxpZXIuXQEtIGBsb3lhbHR5X2N1cnZlYDogY3VydmUgdG8gY2FsY3VsYXRlIGxveWFsdHkgbXVsdGlwbGllciB0byBkaXN0cmlidXRlIHJld2FyZHMgdG8gdXNlcnPgd2l0aCB0aW1lIGluY2VudGl2ZS4gYE5vbmVgIG1lYW5zIG5vIGxveWFsdHkgbXVsdGlwbGllci4AvEVtaXRzIGBZaWVsZEZhcm1DcmVhdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuRHVwZGF0ZV95aWVsZF9mYXJtDAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIABCx0VXBkYXRlIHlpZWxkIGZhcm0gbXVsdGlwbGllci4EIKBPbmx5IGZhcm0gb3duZXIgY2FuIHBlcmZvcm0gdGhpcyBhY3Rpb24uACxQYXJhbWV0ZXJzOoAtIGBvcmlnaW5gOiBnbG9iYWwgZmFybSdzIG93bmVyLh0BLSBgZ2xvYmFsX2Zhcm1faWRgOiBnbG9iYWwgZmFybSBpZCBpbiB3aGljaCB5aWVsZCBmYXJtIHdpbGwgYmUgdXBkYXRlZC4FAS0gYGFzc2V0X3BhaXJgOiBhc3NldCBwYWlyIGlkZW50aWZ5aW5nIHlpZWxkIGZhcm0gaW4gZ2xvYmFsIGZhcm0uqC0gYG11bHRpcGxpZXJgOiBuZXcgeWllbGQgZmFybSBtdWx0aXBsaWVyLgC8RW1pdHMgYFlpZWxkRmFybVVwZGF0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC48c3RvcF95aWVsZF9mYXJtCAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgAFPKRTdG9wIGxpcS4gbWltaW5nIGZvciBzcGVjaWZpYyB5aWVsZCBmYXJtLgA1AVRoaXMgZnVuY3Rpb24gY2xhaW1zIHJld2FyZHMgZnJvbSBgR2xvYmFsRmFybWAgbGFzdCB0aW1lIGFuZCBzdG9wcyB5aWVsZCBmYXJtIQFpbmNlbnRpdml6YXRpb24gZnJvbSBhIGBHbG9iYWxGYXJtYC4gVXNlcnMgd2lsbCBiZSBhYmxlIHRvIG9ubHkgd2l0aGRyYXfIc2hhcmVzKHdpdGggY2xhaW1pbmcpIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5BAWBkZXBvc2l0X3NoYXJlcygpYCBhbmQgYGNsYWltX3Jld2FyZHMoKWAgYXJlIG5vdCBhbGxvd2VkIG9uIGNhbmNlbGVkIHlpZWxkIGZhcm0uBCCgT25seSBmYXJtIG93bmVyIGNhbiBwZXJmb3JtIHRoaXMgYWN0aW9uLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci4FAS0gYGdsb2JhbF9mYXJtX2lkYDogZmFybSBpZCBpbiB3aGljaCB5aWVsZCBmYXJtIHdpbGwgYmUgY2FuY2VsZWQu+C0gYGFzc2V0X3BhaXJgOiBhc3NldCBwYWlyIGlkZW50aWZ5aW5nIHlpZWxkIGZhcm0gaW4gdGhlIGZhcm0uALxFbWl0cyBgWWllbGRGYXJtU3RvcHBlZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLkRyZXN1bWVfeWllbGRfZmFybRABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEoYXNzZXRfcGFpcmUEASRBc3NldFBhaXIAAShtdWx0aXBsaWVyPQEBOEZhcm1NdWx0aXBsaWVyAAZEpFJlc3VtZSB5aWVsZCBmYXJtIGZvciBzdG9wcGVkIHlpZWxkIGZhcm0uAFUBVGhpcyBmdW5jdGlvbiByZXN1bWUgaW5jZW50aXZpemF0aW9uIGZyb20gYEdsb2JhbEZhcm1gIGFuZCByZXN0b3JlIGZ1bGwgZnVuY3Rpb25hbGl0eSEBZm9yIHlpZWxkIGZhcm0uIFVzZXJzIHdpbGwgYmUgYWJsZSB0byBkZXBvc2l0LCBjbGFpbSBhbmQgd2l0aGRyYXcgYWdhaW4uAORXQVJOOiBZaWVsZCBmYXJtIGlzIE5PVCByZXdhcmRlZCBmb3IgdGltZSBpdCB3YXMgc3RvcHBlZC4AoE9ubHkgZmFybSBvd25lciBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4ALFBhcmFtZXRlcnM6gC0gYG9yaWdpbmA6IGdsb2JhbCBmYXJtJ3Mgb3duZXIuHQEtIGBnbG9iYWxfZmFybV9pZGA6IGdsb2JhbCBmYXJtIGlkIGluIHdoaWNoIHlpZWxkIGZhcm0gd2lsbCBiZSByZXN1bWVkLsgtIGB5aWVsZF9mYXJtX2lkYDogaWQgb2YgeWllbGQgZmFybSB0byBiZSByZXN1bWVkLgUBLSBgYXNzZXRfcGFpcmA6IGFzc2V0IHBhaXIgaWRlbnRpZnlpbmcgeWllbGQgZmFybSBpbiBnbG9iYWwgZmFybS7ILSBgbXVsdGlwbGllcmA6IHlpZWxkIGZhcm0gbXVsdGlwbGllciBpbiB0aGUgZmFybS4AvEVtaXRzIGBZaWVsZEZhcm1SZXN1bWVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuUHRlcm1pbmF0ZV95aWVsZF9mYXJtDAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgAHTERSZW1vdmUgeWllbGQgZmFybQCBAVRoaXMgZnVuY3Rpb24gbWFya3MgYSB5aWVsZCBmYXJtIGFzIHJlYWR5IHRvIGJlIHJlbW92ZWQgZnJvbSBzdG9yYWdlIHdoZW4gaXQncyBlbXB0eS4gVXNlcnMgd2lsbGUBYmUgYWJsZSB0byBvbmx5IHdpdGhkcmF3IHNoYXJlcyh3aXRob3V0IGNsYWltaW5nIHJld2FyZHMgZnJvbSB5aWVsZCBmYXJtKS4gVW5wYWlkIHJld2FyZHNxAXdpbGwgYmUgdHJhbnNmZXJyZWQgYmFjayB0byBnbG9iYWwgZmFybSBhbmQgd2lsbCBiZSB1c2VkIHRvIGRpc3RyaWJ1dGUgdG8gb3RoZXIgeWllbGQgZmFybXMuAOBZaWVsZCBmYXJtIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLgBxAU9ubHkgZ2xvYmFsIGZhcm0ncyBvd25lciBjYW4gcGVyZm9ybSB0aGlzIGFjdGlvbi4gWWllbGQgZmFybSBzdGF5cyBpbiB0aGUgc3RvcmFnZSB1bnRpbCBpdCdzbQFlbXB0eShhbGwgZmFybSBlbnRyaWVzIGFyZSB3aXRoZHJhd24pLiBMYXN0IHdpdGhkcmF3biBmcm9tIHlpZWxkIGZhcm0gdHJpZ2dlciByZW1vdmluZyBmcm9tMHRoZSBzdG9yYWdlLgAsUGFyYW1ldGVyczqALSBgb3JpZ2luYDogZ2xvYmFsIGZhcm0ncyBvd25lci4dAS0gYGdsb2JhbF9mYXJtX2lkYDogZmFybSBpZCBmcm9tIHdoaWNoIHlpZWxkIGZhcm0gc2hvdWxkIGJlIHRlcm1pbmF0ZWQu1C0gYHlpZWxkX2Zhcm1faWRgOiBpZCBvZiB5aWVsZCBmYXJtIHRvIGJlIHRlcm1pbmF0ZWQuFQEtIGBhc3NldF9wYWlyYDogYXNzZXQgcGFpciBpZGVudGlmeWluZyB5aWVsZCBmYXJtIGluIHRoZSBnbG9iYWwgZmFybS4AyEVtaXRzIGBZaWVsZEZhcm1UZXJtaW5hdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuOGRlcG9zaXRfc2hhcmVzEAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgABNHNoYXJlc19hbW91bnQYARxCYWxhbmNlAAg4jERlcG9zaXQgTFAgc2hhcmVzIHRvIGEgbGlxLiBtaW5pbmcuAFEBVGhpcyBmdW5jdGlvbiB0cmFuc2ZlcnMgTFAgc2hhcmVzIGZyb20gYG9yaWdpbmAgdG8gcGFsbGV0J3MgYWNjb3VudCBhbmQgbWludCBuZnQgZm9yDQFgb3JpZ2luYCBhY2NvdW50LiBNaW50ZWQgbmZ0IHJlcHJlc2VudHMgZGVwb3NpdCBpbiB0aGUgbGlxLiBtaW5pbmcuACxQYXJhbWV0ZXJzOi0BLSBgb3JpZ2luYDogYWNjb3VudCBkZXBvc2l0aW5nIExQIHNoYXJlcy4gVGhpcyBhY2NvdW50IGhhcyB0byBoYXZlIGF0IGxlYXN0dGBzaGFyZXNfYW1vdW50YCBvZiBMUCBzaGFyZXMuPQEtIGBnbG9iYWxfZmFybV9pZGA6IGlkIG9mIGdsb2JhbCBmYXJtIHRvIHdoaWNoIHVzZXIgd2FudHMgdG8gZGVwb3NpdCBMUCBzaGFyZXMuyC0gYHlpZWxkX2Zhcm1faWRgOiBpZCBvZiB5aWVsZCBmYXJtIHRvIGRlcG9zaXQgdG8uHQEtIGBhc3NldF9wYWlyYDogYXNzZXQgcGFpciBpZGVudGlmeWluZyBMUCBzaGFyZXMgdXNlciB3YW50cyB0byBkZXBvc2l0LvQtIGBzaGFyZXNfYW1vdW50YDogYW1vdW50IG9mIExQIHNoYXJlcyB1c2VyIHdhbnRzIHRvIGRlcG9zaXQuALhFbWl0cyBgU2hhcmVzRGVwb3NpdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuKGpvaW5fZmFybXMMATBmYXJtX2VudHJpZXNpBAERAUJvdW5kZWRWZWM8KEdsb2JhbEZhcm1JZCwgWWllbGRGYXJtSWQpLCBUOjpNYXhGYXJtRW50cmllc1BlckRlcG9zaXQ+AAEoYXNzZXRfcGFpcmUEASRBc3NldFBhaXIAATRzaGFyZXNfYW1vdW50GAEcQmFsYW5jZQAMNLRKb2luIG11bHRpcGxlIGZhcm1zIHdpdGggYSBnaXZlbiBzaGFyZSBhbW91bnQA/FRoZSBzaGFyZSBpcyBkZXBvc2l0ZWQgdG8gdGhlIGZpcnN0IGZhcm0gb2YgdGhlIHNwZWNpZmllZCBmYW1zLNBhbmQgdGhlbiByZWRlcG9zaXQgdGhlIHNoYXJlcyB0byB0aGUgcmVtYWluaW5nIGZhcm1zACxQYXJhbWV0ZXJzOi0BLSBgb3JpZ2luYDogYWNjb3VudCBkZXBvc2l0aW5nIExQIHNoYXJlcy4gVGhpcyBhY2NvdW50IGhhcyB0byBoYXZlIGF0IGxlYXN0IQEtIGBmYXJtX2VudHJpZXNgOiBsaXN0IG9mIGdsb2JhbCBmYXJtIGlkIGFuZCB5aWVsZCBmYXJtIGlkIHBhaXJzIHRvIGpvaW4dAS0gYGFzc2V0X3BhaXJgOiBhc3NldCBwYWlyIGlkZW50aWZ5aW5nIExQIHNoYXJlcyB1c2VyIHdhbnRzIHRvIGRlcG9zaXQu9C0gYHNoYXJlc19hbW91bnRgOiBhbW91bnQgb2YgTFAgc2hhcmVzIHVzZXIgd2FudHMgdG8gZGVwb3NpdC4A2EVtaXRzIGBTaGFyZXNEZXBvc2l0ZWRgIGV2ZW50IGZvciB0aGUgZmlyc3QgZmFybSBlbnRyeR0BRW1pdHMgYFNoYXJlc1JlZGVwb3NpdGVkYCBldmVudCBmb3IgZWFjaCBmYXJtIGVudHJ5IGFmdGVyIHRoZSBmaXJzdCBvbmVwYWRkX2xpcXVpZGl0eV9hbmRfam9pbl9mYXJtcxQBHGFzc2V0X2EQARxBc3NldElkAAEcYXNzZXRfYhABHEFzc2V0SWQAASBhbW91bnRfYRgBHEJhbGFuY2UAAUhhbW91bnRfYl9tYXhfbGltaXQYARxCYWxhbmNlAAEwZmFybV9lbnRyaWVzaQQBEQFCb3VuZGVkVmVjPChHbG9iYWxGYXJtSWQsIFlpZWxkRmFybUlkKSwgVDo6TWF4RmFybUVudHJpZXNQZXJEZXBvc2l0PgANPC0BQWRkIGxpcXVpZGl0eSB0byBYWUsgcG9vbCBhbmQgam9pbiBtdWx0aXBsZSBmYXJtcyB3aXRoIGEgZ2l2ZW4gc2hhcmUgYW1vdW50AAkBVGhlIHNoYXJlIGlzIGRlcG9zaXRlZCB0byB0aGUgZmlyc3QgZmFybSBvZiB0aGUgc3BlY2lmaWVkIGVudHJpZXMs0GFuZCB0aGVuIHJlZGVwb3NpdCB0aGUgc2hhcmVzIHRvIHRoZSByZW1haW5pbmcgZmFybXMALFBhcmFtZXRlcnM6LQEtIGBvcmlnaW5gOiBhY2NvdW50IGRlcG9zaXRpbmcgTFAgc2hhcmVzLiBUaGlzIGFjY291bnQgaGFzIHRvIGhhdmUgYXQgbGVhc3TQLSBgYXNzZXRfYWA6IGFzc2V0IGlkIG9mIHRoZSBmaXJzdCBhc3NldCBpbiB0aGUgcGFpctQtIGBhc3NldF9iYDogYXNzZXQgaWQgb2YgdGhlIHNlY29uZCBhc3NldCBpbiB0aGUgcGFpcsgtIGBhbW91bnRfYWA6IGFtb3VudCBvZiB0aGUgZmlyc3QgYXNzZXQgdG8gZGVwb3NpdBUBLSBgYW1vdW50X2JfbWF4X2xpbWl0YDogbWF4aW11bSBhbW91bnQgb2YgdGhlIHNlY29uZCBhc3NldCB0byBkZXBvc2l0IQEtIGBmYXJtX2VudHJpZXNgOiBsaXN0IG9mIGdsb2JhbCBmYXJtIGlkIGFuZCB5aWVsZCBmYXJtIGlkIHBhaXJzIHRvIGpvaW4A2EVtaXRzIGBTaGFyZXNEZXBvc2l0ZWRgIGV2ZW50IGZvciB0aGUgZmlyc3QgZmFybSBlbnRyeR0BRW1pdHMgYFNoYXJlc1JlZGVwb3NpdGVkYCBldmVudCBmb3IgZWFjaCBmYXJtIGVudHJ5IGFmdGVyIHRoZSBmaXJzdCBvbmVAcmVkZXBvc2l0X3NoYXJlcxABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEoYXNzZXRfcGFpcmUEASRBc3NldFBhaXIAAShkZXBvc2l0X2lkGAEkRGVwb3NpdElkAAk85FJlZGVwb3NpdCBhbHJlYWR5IGxvY2tlZCBMUCBzaGFyZXMgdG8gYW5vdGhlciB5aWVsZCBmYXJtLgBlAVRoaXMgZnVuY3Rpb24gY3JlYXRlIHlpZWxkIGZhcm0gZW50cnkgZm9yIGV4aXN0aW5nIGRlcG9zaXQuIExQIHNoYXJlcyBhcmUgbm90IHRyYW5zZmVycmVk1GFuZCBhbW91bnQgb2YgTFAgc2hhcmVzIGlzIGJhc2VkIG9uIGV4aXN0aW5nIGRlcG9zaXQuAKRUaGlzIGZ1bmN0aW9uIERPRVNOJ1QgY3JlYXRlIG5ldyBkZXBvc2l0LgAsUGFyYW1ldGVyczoxAS0gYG9yaWdpbmA6IGFjY291bnQgZGVwb3NpdGluZyBMUCBzaGFyZXMuIFRoaXMgYWNjb3VudCBoYXZlIHRvIGhhdmUgYXQgbGVhc3SsLSBgZ2xvYmFsX2Zhcm1faWRgOiBnbG9iYWwgZmFybSBpZGVudGlmaWVyLuQtIGB5aWVsZF9mYXJtX2lkYDogeWllbGQgZmFybSBpZGVudGlmaWVyIHJlZGVwb3NpdGluZyB0by4ZAS0gYGFzc2V0X3BhaXJgOiBhc3NldCBwYWlyIGlkZW50aWZ5aW5nIExQIHNoYXJlcyB1c2VyIHdhbnQgdG8gZGVwb3NpdC6oLSBgZGVwb3NpdF9pZGA6IGlkZW50aWZpZXIgb2YgdGhlIGRlcG9zaXQuAMBFbWl0cyBgU2hhcmVzUmVkZXBvc2l0ZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC40Y2xhaW1fcmV3YXJkcwgBKGRlcG9zaXRfaWQYASREZXBvc2l0SWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQACiwNAUNsYWltIHJld2FyZHMgZnJvbSBsaXEuIG1pbmluZyBmb3IgZGVwb3NpdCByZXByZXNlbnRlZCBieSBgbmZ0X2lkYC4AWQFUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZSB1c2VyIHJld2FyZHMgZnJvbSBsaXEuIG1pbmluZyBhbmQgdHJhbnNmZXIgcmV3YXJkcyB0byBgb3JpZ2luYOhhY2NvdW50LiBDbGFpbWluZyBpbiB0aGUgc2FtZSBwZXJpb2QgaXMgYWxsb3dlZCBvbmx5IG9uY2UuACxQYXJhbWV0ZXJzOqgtIGBvcmlnaW5gOiBhY2NvdW50IG93bmVyIG9mIGRlcG9zaXQobmZ0KS74LSBgZGVwb3NpdF9pZGA6IG5mdCBpZCByZXByZXNlbnRpbmcgZGVwb3NpdCBpbiB0aGUgeWllbGQgZmFybS78LSBgeWllbGRfZmFybV9pZGA6IHlpZWxkIGZhcm0gaWRlbnRpZmllciB0byBjbGFpbSByZXdhcmRzIGZyb20uALBFbWl0cyBgUmV3YXJkQ2xhaW1lZGAgZXZlbnQgd2hlbiBzdWNjZXNzZnVsLjx3aXRoZHJhd19zaGFyZXMMAShkZXBvc2l0X2lkGAEkRGVwb3NpdElkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEoYXNzZXRfcGFpcmUEASRBc3NldFBhaXIAC1gVAVdpdGhkcmF3IExQIHNoYXJlcyBmcm9tIGxpcS4gbWluaW5nIHdpdGggcmV3YXJkIGNsYWltaW5nIGlmIHBvc3NpYmxlLgAVAUxpc3Qgb2YgcG9zc2libGUgY2FzZXMgb2YgdHJhbnNmZXJzIG9mIExQIHNoYXJlcyBhbmQgY2xhaW1lZCByZXdhcmRzOgBRASogeWllbGQgZmFybSBpcyBhY3RpdmUoeWllbGQgZmFybSBpcyBub3Qgc3RvcHBlZCkgLSBjbGFpbSBhbmQgdHJhbnNmZXIgcmV3YXJkcyhpZiBpdNh3YXNuJ3QgY2xhaW1lZCBpbiB0aGlzIHBlcmlvZCkgYW5kIHRyYW5zZmVyIExQIHNoYXJlcy7sKiBsaXEuIG1pbmluZyBpcyBzdG9wcGVkIC0gY2xhaW0gYW5kIHRyYW5zZmVyIHJld2FyZHMoaWYgaXTYd2Fzbid0IGNsYWltZWQgaW4gdGhpcyBwZXJpb2QpIGFuZCB0cmFuc2ZlciBMUCBzaGFyZXMuBQEqIHlpZWxkIGZhcm0gd2FzIHRlcm1pbmF0ZWQgLSBvbmx5IExQIHNoYXJlcyB3aWxsIGJlIHRyYW5zZmVycmVkLuwqIGZhcm0gd2FzIHRlcm1pbmF0ZWQgLSBvbmx5IExQIHNoYXJlcyB3aWxsIGJlIHRyYW5zZmVycmVkLgA1AVVzZXIncyB1bmNsYWltYWJsZSByZXdhcmRzIHdpbGwgYmUgdHJhbnNmZXJyZWQgYmFjayB0byBnbG9iYWwgZmFybSdzIGFjY291bnQuACxQYXJhbWV0ZXJzOqgtIGBvcmlnaW5gOiBhY2NvdW50IG93bmVyIG9mIGRlcG9zaXQobmZ0KS74LSBgZGVwb3NpdF9pZGA6IG5mdCBpZCByZXByZXNlbnRpbmcgZGVwb3NpdCBpbiB0aGUgeWllbGQgZmFybS4FAS0gYHlpZWxkX2Zhcm1faWRgOiB5aWVsZCBmYXJtIGlkZW50aWZpZXIgdG8gZGl0aGRyYXcgc2hhcmVzIGZyb20uBQEtIGBhc3NldF9wYWlyYDogYXNzZXQgcGFpciBpZGVudGlmeWluZyB5aWVsZCBmYXJtIGluIGdsb2JhbCBmYXJtLgAYRW1pdHM6hCogYFJld2FyZENsYWltZWRgIGlmIGNsYWltIGhhcHBlbqQqIGBTaGFyZXNXaXRoZHJhd25gIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bChleGl0X2Zhcm1zDAEoZGVwb3NpdF9pZBgBJERlcG9zaXRJZAABKGFzc2V0X3BhaXJlBAEkQXNzZXRQYWlyAAEwZmFybV9lbnRyaWVzbQQB0EJvdW5kZWRWZWM8WWllbGRGYXJtSWQsIFQ6Ok1heEZhcm1FbnRyaWVzUGVyRGVwb3NpdD4ADkCMRXhpdCBmcm9tIGFsbCBzcGVjaWZpZWQgeWllbGQgZmFybXMAXQFUaGlzIGZ1bmN0aW9uIHdpbGwgYXR0ZW1wdCB0byB3aXRoZHJhdyBzaGFyZXMgYW5kIGNsYWltIHJld2FyZHMgKGlmIGF2YWlsYWJsZSkgZnJvbSBhbGyoc3BlY2lmaWVkIHlpZWxkIGZhcm1zIGZvciBhIGdpdmVuIGRlcG9zaXQuACxQYXJhbWV0ZXJzOqgtIGBvcmlnaW5gOiBhY2NvdW50IG93bmVyIG9mIGRlcG9zaXQobmZ0KS74LSBgZGVwb3NpdF9pZGA6IG5mdCBpZCByZXByZXNlbnRpbmcgZGVwb3NpdCBpbiB0aGUgeWllbGQgZmFybS4dAS0gYGFzc2V0X3BhaXJgOiBhc3NldCBwYWlyIGlkZW50aWZ5aW5nIHlpZWxkIGZhcm0ocykgaW4gZ2xvYmFsIGZhcm0ocyku2C0gYGZhcm1fZW50cmllc2A6IGlkKHMpIG9mIHlpZWxkIGZhcm0ocykgdG8gZXhpdCBmcm9tLgAYRW1pdHM6rCogYFJld2FyZENsYWltZWRgIGZvciBlYWNoIHN1Y2Nlc3NmdWwgY2xhaW3IKiBgU2hhcmVzV2l0aGRyYXduYCBmb3IgZWFjaCBzdWNjZXNzZnVsIHdpdGhkcmF3YWzYKiBgRGVwb3NpdERlc3Ryb3llZGAgaWYgdGhlIGRlcG9zaXQgaXMgZnVsbHkgd2l0aGRyYXduAAQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5lBAwocGFsbGV0X3h5axR0eXBlcyRBc3NldFBhaXIAAAgBIGFzc2V0X2luEAEcQXNzZXRJZAABJGFzc2V0X291dBABHEFzc2V0SWQAAGkEDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBTQMEUwAABABRAwEYVmVjPFQ+AABtBAxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUARAEUwAABABZAwEYVmVjPFQ+AABxBAxccGFsbGV0X2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0EENhbGwIBFQABEkAAQAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMudQQMWHBhbGxldF9yZWxheWNoYWluX2luZm8YcGFsbGV0EENhbGwEBFQAAQAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMueQQMKHBhbGxldF9kY2EYcGFsbGV0EENhbGwEBFQAAQwgc2NoZWR1bGUIASBzY2hlZHVsZX0EAdRTY2hlZHVsZTxUOjpBY2NvdW50SWQsIFQ6OkFzc2V0SWQsIEJsb2NrTnVtYmVyRm9yPFQ+PgABVHN0YXJ0X2V4ZWN1dGlvbl9ibG9ja1kBAWRPcHRpb248QmxvY2tOdW1iZXJGb3I8VD4+AABkPQFDcmVhdGVzIGEgbmV3IERDQSAoRG9sbGFyLUNvc3QgQXZlcmFnaW5nKSBzY2hlZHVsZSBhbmQgcGxhbnMgdGhlIG5leHQgZXhlY3V0aW9uYGZvciB0aGUgc3BlY2lmaWVkIGJsb2NrLgAtAUlmIHRoZSBibG9jayBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZXhlY3V0aW9uIGlzIHBsYW5uZWQgZm9yIHRoZSBuZXh0IGJsb2NrLkkBSWYgdGhlIGdpdmVuIGJsb2NrIGlzIGZ1bGwsIHRoZSBleGVjdXRpb24gd2lsbCBiZSBwbGFubmVkIGluIHRoZSBzdWJzZXF1ZW50IGJsb2NrLgBRAU9uY2UgdGhlIHNjaGVkdWxlIGlzIGNyZWF0ZWQsIHRoZSBzcGVjaWZpZWQgYHRvdGFsX2Ftb3VudGAgd2lsbCBiZSByZXNlcnZlZCBmb3IgRENBLh0BVGhlIHJlc2VydmF0aW9uIGN1cnJlbmN5IHdpbGwgYmUgdGhlIGBhbW91bnRfaW5gIGN1cnJlbmN5IG9mIHRoZSBvcmRlci4A4FRyYWRlcyBhcmUgZXhlY3V0ZWQgYXMgbG9uZyBhcyB0aGVyZSBpcyBidWRnZXQgcmVtYWluaW5nTQFmcm9tIHRoZSBpbml0aWFsIGB0b3RhbF9hbW91bnRgIGFsbG9jYXRpb24sIHVubGVzcyBgdG90YWxfYW1vdW50YCBpcyAwLCB0aGVuIHRyYWRlc6hhcmUgZXhlY3V0ZWQgdW50aWwgc2NoZWR1bGUgaXMgdGVybWluYXRlZC4AVQFJZiBhIHRyYWRlIGZhaWxzIGR1ZSB0byBzbGlwcGFnZSBsaW1pdCBvciBwcmljZSBzdGFiaWxpdHkgZXJyb3JzLCBpdCB3aWxsIGJlIHJldHJpZWQu1ElmIHRoZSBudW1iZXIgb2YgcmV0cmllcyByZWFjaGVzIHRoZSBtYXhpbXVtIGFsbG93ZWQssHRoZSBzY2hlZHVsZSB3aWxsIGJlIHRlcm1pbmF0ZWQgcGVybWFuZW50bHku+EluIHRoZSBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCB0cmFkZSwgdGhlIHJldHJ5IGNvdW50ZXIgaXMgcmVzZXQuACxQYXJhbWV0ZXJzOmgtIGBvcmlnaW5gOiBzY2hlZHVsZSBvd25lcngtIGBzY2hlZHVsZWA6IHNjaGVkdWxlIGRldGFpbHMpAS0gYHN0YXJ0X2V4ZWN1dGlvbl9ibG9ja2A6IGZpcnN0IHBvc3NpYmxlIGV4ZWN1dGlvbiBibG9jayBmb3IgdGhlIHNjaGVkdWxlAPxFbWl0cyBgU2NoZWR1bGVkYCBhbmQgYEV4ZWN1dGlvblBsYW5uZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4AJHRlcm1pbmF0ZQgBLHNjaGVkdWxlX2lkEAEoU2NoZWR1bGVJZAABUG5leHRfZXhlY3V0aW9uX2Jsb2NrWQEBZE9wdGlvbjxCbG9ja051bWJlckZvcjxUPj4AASwJAVRlcm1pbmF0ZXMgYSBEQ0Egc2NoZWR1bGUgYW5kIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGZyb20gdGhlIGNoYWluLgBBAVRoaXMgY2FuIGJlIGNhbGxlZCBieSBib3RoIHNjaGVkdWxlIG93bmVyIG9yIHRoZSBjb25maWd1cmVkIGBUOjpUZXJtaW5hdGVPcmlnaW5gACxQYXJhbWV0ZXJzOmgtIGBvcmlnaW5gOiBzY2hlZHVsZSBvd25lcnAtIGBzY2hlZHVsZV9pZGA6IHNjaGVkdWxlIGlkFQEtIGBuZXh0X2V4ZWN1dGlvbl9ibG9ja2A6IGJsb2NrIG51bWJlciB3aGVyZSB0aGUgc2NoZWR1bGUgaXMgcGxhbm5lZC4ApEVtaXRzIGBUZXJtaW5hdGVkYCBldmVudCB3aGVuIHN1Y2Nlc3NmdWwuADx1bmxvY2tfcmVzZXJ2ZXMIAQx3aG8AATBUOjpBY2NvdW50SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAjRdAVVubG9ja3MgRENBIHJlc2VydmVzIG9mIHByb3ZpZGVkIGFzc2V0IGZvciB0aGUgY2FsbGVyIGlmIHRoZXkgaGF2ZSBubyBhY3RpdmUgc2NoZWR1bGVzLgA1AVRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGhlbHAgdXNlcnMgcmVjb3ZlciB0aGVpciByZXNlcnZlZCBmdW5kcyBpbiBjYXNl9GEgRENBIHNjaGVkdWxlIHdhcyB0ZXJtaW5hdGVkIGJ1dCBsZWZ0IHNvbWUgcmVzZXJ2ZWQgYW1vdW50cy4ACQFUaGlzIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBubyBhY3RpdmUgRENBIHNjaGVkdWxlcy4ALFBhcmFtZXRlcnM6/C0gYG9yaWdpbmA6IFRoZSBhY2NvdW50IHRvIHVubG9jayByZXNlcnZlcyBmb3IgKG11c3QgYmUgc2lnbmVkKQUBLSBgYXNzZXRfaWRgOiBUaGUgYXNzZXQgSUQgZm9yIHdoaWNoIHJlc2VydmVzIHNob3VsZCBiZSB1bmxvY2tlZC4AuEVtaXRzIGBSZXNlcnZlVW5sb2NrZWRgIGV2ZW50IHdoZW4gc3VjY2Vzc2Z1bC4ABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLn0EDChwYWxsZXRfZGNhFHR5cGVzIFNjaGVkdWxlDCRBY2NvdW50SWQBABxBc3NldElkARAsQmxvY2tOdW1iZXIBEAAcARRvd25lcgABJEFjY291bnRJZAABGHBlcmlvZBABLEJsb2NrTnVtYmVyAAEwdG90YWxfYW1vdW50GAEcQmFsYW5jZQABLG1heF9yZXRyaWVz6QIBKE9wdGlvbjx1OD4AAUxzdGFiaWxpdHlfdGhyZXNob2xk9QMBPE9wdGlvbjxQZXJtaWxsPgABIHNsaXBwYWdl9QMBPE9wdGlvbjxQZXJtaWxsPgABFG9yZGVygQQBOE9yZGVyPEFzc2V0SWQ+AACBBAwocGFsbGV0X2RjYRR0eXBlcxRPcmRlcgQcQXNzZXRJZAEQAQgQU2VsbBQBIGFzc2V0X2luEAEcQXNzZXRJZAABJGFzc2V0X291dBABHEFzc2V0SWQAASRhbW91bnRfaW4YARxCYWxhbmNlAAE4bWluX2Ftb3VudF9vdXQYARxCYWxhbmNlAAEUcm91dGV9AwHoQm91bmRlZFZlYzxUcmFkZTxBc3NldElkPiwgQ29uc3RVMzI8TUFYX05VTUJFUl9PRl9UUkFERVM+PgAAAAxCdXkUASBhc3NldF9pbhABHEFzc2V0SWQAASRhc3NldF9vdXQQARxBc3NldElkAAEoYW1vdW50X291dBgBHEJhbGFuY2UAATRtYXhfYW1vdW50X2luGAEcQmFsYW5jZQABFHJvdXRlfQMB6EJvdW5kZWRWZWM8VHJhZGU8QXNzZXRJZD4sIENvbnN0VTMyPE1BWF9OVU1CRVJfT0ZfVFJBREVTPj4AAQAAhQQMQHBhbGxldF9zY2hlZHVsZXIYcGFsbGV0EENhbGwEBFQAASggc2NoZWR1bGUQARB3aGVuEAFEQmxvY2tOdW1iZXJGb3I8VD4AAThtYXliZV9wZXJpb2RpY3UDAaxPcHRpb248c2NoZWR1bGU6OlBlcmlvZDxCbG9ja051bWJlckZvcjxUPj4+AAEgcHJpb3JpdHkIAUhzY2hlZHVsZTo6UHJpb3JpdHkAARBjYWxsEQEBfEJveDw8VCBhcyBDb25maWc+OjpSdW50aW1lQ2FsbD4AAARwQW5vbnltb3VzbHkgc2NoZWR1bGUgYSB0YXNrLhhjYW5jZWwIARB3aGVuEAFEQmxvY2tOdW1iZXJGb3I8VD4AARRpbmRleBABDHUzMgABBJRDYW5jZWwgYW4gYW5vbnltb3VzbHkgc2NoZWR1bGVkIHRhc2suOHNjaGVkdWxlX25hbWVkFAEIaWQEASBUYXNrTmFtZQABEHdoZW4QAURCbG9ja051bWJlckZvcjxUPgABOG1heWJlX3BlcmlvZGljdQMBrE9wdGlvbjxzY2hlZHVsZTo6UGVyaW9kPEJsb2NrTnVtYmVyRm9yPFQ+Pj4AASBwcmlvcml0eQgBSHNjaGVkdWxlOjpQcmlvcml0eQABEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgACBFhTY2hlZHVsZSBhIG5hbWVkIHRhc2suMGNhbmNlbF9uYW1lZAQBCGlkBAEgVGFza05hbWUAAwR4Q2FuY2VsIGEgbmFtZWQgc2NoZWR1bGVkIHRhc2suOHNjaGVkdWxlX2FmdGVyEAEUYWZ0ZXIQAURCbG9ja051bWJlckZvcjxUPgABOG1heWJlX3BlcmlvZGljdQMBrE9wdGlvbjxzY2hlZHVsZTo6UGVyaW9kPEJsb2NrTnVtYmVyRm9yPFQ+Pj4AASBwcmlvcml0eQgBSHNjaGVkdWxlOjpQcmlvcml0eQABEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgAEBKhBbm9ueW1vdXNseSBzY2hlZHVsZSBhIHRhc2sgYWZ0ZXIgYSBkZWxheS5Qc2NoZWR1bGVfbmFtZWRfYWZ0ZXIUAQhpZAQBIFRhc2tOYW1lAAEUYWZ0ZXIQAURCbG9ja051bWJlckZvcjxUPgABOG1heWJlX3BlcmlvZGljdQMBrE9wdGlvbjxzY2hlZHVsZTo6UGVyaW9kPEJsb2NrTnVtYmVyRm9yPFQ+Pj4AASBwcmlvcml0eQgBSHNjaGVkdWxlOjpQcmlvcml0eQABEGNhbGwRAQF8Qm94PDxUIGFzIENvbmZpZz46OlJ1bnRpbWVDYWxsPgAFBJBTY2hlZHVsZSBhIG5hbWVkIHRhc2sgYWZ0ZXIgYSBkZWxheS4kc2V0X3JldHJ5DAEQdGFza00DAXhUYXNrQWRkcmVzczxCbG9ja051bWJlckZvcjxUPj4AARxyZXRyaWVzCAEIdTgAARhwZXJpb2QQAURCbG9ja051bWJlckZvcjxUPgAGMFkBU2V0IGEgcmV0cnkgY29uZmlndXJhdGlvbiBmb3IgYSB0YXNrIHNvIHRoYXQsIGluIGNhc2UgaXRzIHNjaGVkdWxlZCBydW4gZmFpbHMsIGl0IHdpbGxVAWJlIHJldHJpZWQgYWZ0ZXIgYHBlcmlvZGAgYmxvY2tzLCBmb3IgYSB0b3RhbCBhbW91bnQgb2YgYHJldHJpZXNgIHJldHJpZXMgb3IgdW50aWwgaXQkc3VjY2VlZHMuAFUBVGFza3Mgd2hpY2ggbmVlZCB0byBiZSBzY2hlZHVsZWQgZm9yIGEgcmV0cnkgYXJlIHN0aWxsIHN1YmplY3QgdG8gd2VpZ2h0IG1ldGVyaW5nIGFuZFEBYWdlbmRhIHNwYWNlLCBzYW1lIGFzIGEgcmVndWxhciB0YXNrLiBJZiBhIHBlcmlvZGljIHRhc2sgZmFpbHMsIGl0IHdpbGwgYmUgc2NoZWR1bGVkkG5vcm1hbGx5IHdoaWxlIHRoZSB0YXNrIGlzIHJldHJ5aW5nLgBRAVRhc2tzIHNjaGVkdWxlZCBhcyBhIHJlc3VsdCBvZiBhIHJldHJ5IGZvciBhIHBlcmlvZGljIHRhc2sgYXJlIHVubmFtZWQsIG5vbi1wZXJpb2RpYz0BY2xvbmVzIG9mIHRoZSBvcmlnaW5hbCB0YXNrLiBUaGVpciByZXRyeSBjb25maWd1cmF0aW9uIHdpbGwgYmUgZGVyaXZlZCBmcm9tIHRoZU0Bb3JpZ2luYWwgdGFzaydzIGNvbmZpZ3VyYXRpb24sIGJ1dCB3aWxsIGhhdmUgYSBsb3dlciB2YWx1ZSBmb3IgYHJlbWFpbmluZ2AgdGhhbiB0aGVkb3JpZ2luYWwgYHRvdGFsX3JldHJpZXNgLjxzZXRfcmV0cnlfbmFtZWQMAQhpZAQBIFRhc2tOYW1lAAEccmV0cmllcwgBCHU4AAEYcGVyaW9kEAFEQmxvY2tOdW1iZXJGb3I8VD4ABzBdAVNldCBhIHJldHJ5IGNvbmZpZ3VyYXRpb24gZm9yIGEgbmFtZWQgdGFzayBzbyB0aGF0LCBpbiBjYXNlIGl0cyBzY2hlZHVsZWQgcnVuIGZhaWxzLCBpdF0Bd2lsbCBiZSByZXRyaWVkIGFmdGVyIGBwZXJpb2RgIGJsb2NrcywgZm9yIGEgdG90YWwgYW1vdW50IG9mIGByZXRyaWVzYCByZXRyaWVzIG9yIHVudGlsMGl0IHN1Y2NlZWRzLgBVAVRhc2tzIHdoaWNoIG5lZWQgdG8gYmUgc2NoZWR1bGVkIGZvciBhIHJldHJ5IGFyZSBzdGlsbCBzdWJqZWN0IHRvIHdlaWdodCBtZXRlcmluZyBhbmRRAWFnZW5kYSBzcGFjZSwgc2FtZSBhcyBhIHJlZ3VsYXIgdGFzay4gSWYgYSBwZXJpb2RpYyB0YXNrIGZhaWxzLCBpdCB3aWxsIGJlIHNjaGVkdWxlZJBub3JtYWxseSB3aGlsZSB0aGUgdGFzayBpcyByZXRyeWluZy4AUQFUYXNrcyBzY2hlZHVsZWQgYXMgYSByZXN1bHQgb2YgYSByZXRyeSBmb3IgYSBwZXJpb2RpYyB0YXNrIGFyZSB1bm5hbWVkLCBub24tcGVyaW9kaWM9AWNsb25lcyBvZiB0aGUgb3JpZ2luYWwgdGFzay4gVGhlaXIgcmV0cnkgY29uZmlndXJhdGlvbiB3aWxsIGJlIGRlcml2ZWQgZnJvbSB0aGVNAW9yaWdpbmFsIHRhc2sncyBjb25maWd1cmF0aW9uLCBidXQgd2lsbCBoYXZlIGEgbG93ZXIgdmFsdWUgZm9yIGByZW1haW5pbmdgIHRoYW4gdGhlZG9yaWdpbmFsIGB0b3RhbF9yZXRyaWVzYC4wY2FuY2VsX3JldHJ5BAEQdGFza00DAXhUYXNrQWRkcmVzczxCbG9ja051bWJlckZvcjxUPj4ACASoUmVtb3ZlcyB0aGUgcmV0cnkgY29uZmlndXJhdGlvbiBvZiBhIHRhc2suSGNhbmNlbF9yZXRyeV9uYW1lZAQBCGlkBAEgVGFza05hbWUACQS8Q2FuY2VsIHRoZSByZXRyeSBjb25maWd1cmF0aW9uIG9mIGEgbmFtZWQgdGFzay4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuiQQMfGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW0YcGFsbGV0EENhbGwEBFQAAQhMc2V0X3ZhbGlkYXRpb25fZGF0YQQBEGRhdGGNBAFUUGFyYWNoYWluSW5oZXJlbnREYXRhAAAkgFNldCB0aGUgY3VycmVudCB2YWxpZGF0aW9uIGRhdGEuAEEBVGhpcyBzaG91bGQgYmUgaW52b2tlZCBleGFjdGx5IG9uY2UgcGVyIGJsb2NrLiBJdCB3aWxsIHBhbmljIGF0IHRoZSBmaW5hbGl6YXRpb26IcGhhc2UgaWYgdGhlIGNhbGwgd2FzIG5vdCBpbnZva2VkLgDQVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgYEluaGVyZW50YAAhAUFzIGEgc2lkZSBlZmZlY3QsIHRoaXMgZnVuY3Rpb24gdXBncmFkZXMgdGhlIGN1cnJlbnQgdmFsaWRhdGlvbiBmdW5jdGlvboRpZiB0aGUgYXBwcm9wcmlhdGUgdGltZSBoYXMgY29tZS5gc3Vkb19zZW5kX3Vwd2FyZF9tZXNzYWdlBAEcbWVzc2FnZTgBNFVwd2FyZE1lc3NhZ2UAAQAEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMujQQIlGN1bXVsdXNfcHJpbWl0aXZlc19wYXJhY2hhaW5faW5oZXJlbnRUUGFyYWNoYWluSW5oZXJlbnREYXRhAAAQATx2YWxpZGF0aW9uX2RhdGGRBAFcUGVyc2lzdGVkVmFsaWRhdGlvbkRhdGEAAURyZWxheV9jaGFpbl9zdGF0ZZkEAVRzcF90cmllOjpTdG9yYWdlUHJvb2YAAURkb3dud2FyZF9tZXNzYWdlc6EEAWxWZWM8SW5ib3VuZERvd253YXJkTWVzc2FnZT4AAUxob3Jpem9udGFsX21lc3NhZ2VzqQQBpEJUcmVlTWFwPFBhcmFJZCwgVmVjPEluYm91bmRIcm1wTWVzc2FnZT4+AACRBAxMcG9sa2Fkb3RfcHJpbWl0aXZlcwh2OFxQZXJzaXN0ZWRWYWxpZGF0aW9uRGF0YQgESAE0BE4BEAAQASxwYXJlbnRfaGVhZJUEASBIZWFkRGF0YQABTHJlbGF5X3BhcmVudF9udW1iZXIQAQROAAFkcmVsYXlfcGFyZW50X3N0b3JhZ2Vfcm9vdDQBBEgAATBtYXhfcG92X3NpemUQAQx1MzIAAJUEDHRwb2xrYWRvdF9wYXJhY2hhaW5fcHJpbWl0aXZlcyhwcmltaXRpdmVzIEhlYWREYXRhAAAEADgBHFZlYzx1OD4AAJkEDBxzcF90cmllNHN0b3JhZ2VfcHJvb2YwU3RvcmFnZVByb29mAAAEASh0cmllX25vZGVznQQBREJUcmVlU2V0PFZlYzx1OD4+AACdBAQgQlRyZWVTZXQEBFQBOAAEACEBAAAAoQQAAAKlBAClBAhgcG9sa2Fkb3RfY29yZV9wcmltaXRpdmVzWEluYm91bmREb3dud2FyZE1lc3NhZ2UELEJsb2NrTnVtYmVyARAACAEcc2VudF9hdBABLEJsb2NrTnVtYmVyAAEMbXNnOAE8RG93bndhcmRNZXNzYWdlAACpBAQgQlRyZWVNYXAIBEsBvQEEVgGtBAAEALUEAAAArQQAAAKxBACxBAhgcG9sa2Fkb3RfY29yZV9wcmltaXRpdmVzSEluYm91bmRIcm1wTWVzc2FnZQQsQmxvY2tOdW1iZXIBEAAIARxzZW50X2F0EAEsQmxvY2tOdW1iZXIAARBkYXRhOAFMYWxsb2M6OnZlYzo6VmVjPHU4PgAAtQQAAAK5BAC5BAAABAi9Aa0EAL0EDFhzdGFnaW5nX3BhcmFjaGFpbl9pbmZvGHBhbGxldBBDYWxsBARUAAEABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLsEEDChwYWxsZXRfeGNtGHBhbGxldBBDYWxsBARUAAE4EHNlbmQIARBkZXN0xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AARxtZXNzYWdl5QQBVEJveDxWZXJzaW9uZWRYY208KCk+PgAAADx0ZWxlcG9ydF9hc3NldHMQARBkZXN0xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AASxiZW5lZmljaWFyecUEAVhCb3g8VmVyc2lvbmVkTG9jYXRpb24+AAEYYXNzZXRz6QUBUEJveDxWZXJzaW9uZWRBc3NldHM+AAE4ZmVlX2Fzc2V0X2l0ZW0QAQx1MzIAAUgRAVRlbGVwb3J0IHNvbWUgYXNzZXRzIGZyb20gdGhlIGxvY2FsIGNoYWluIHRvIHNvbWUgZGVzdGluYXRpb24gY2hhaW4uAB0BKipUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ6IFVzZSBgbGltaXRlZF90ZWxlcG9ydF9hc3NldHNgIGluc3RlYWQuKioAUQFGZWUgcGF5bWVudCBvbiB0aGUgZGVzdGluYXRpb24gc2lkZSBpcyBtYWRlIGZyb20gdGhlIGFzc2V0IGluIHRoZSBgYXNzZXRzYCB2ZWN0b3Igb2ZhAWluZGV4IGBmZWVfYXNzZXRfaXRlbWAuIFRoZSB3ZWlnaHQgbGltaXQgZm9yIGZlZXMgaXMgbm90IHByb3ZpZGVkIGFuZCB0aHVzIGlzIHVubGltaXRlZCy0d2l0aCBhbGwgZmVlcyB0YWtlbiBhcyBuZWVkZWQgZnJvbSB0aGUgYXNzZXQuACkBLSBgb3JpZ2luYDogTXVzdCBiZSBjYXBhYmxlIG9mIHdpdGhkcmF3aW5nIHRoZSBgYXNzZXRzYCBhbmQgZXhlY3V0aW5nIFhDTS4lAS0gYGRlc3RgOiBEZXN0aW5hdGlvbiBjb250ZXh0IGZvciB0aGUgYXNzZXRzLiBXaWxsIHR5cGljYWxseSBiZSBgW1BhcmVudCxhASAgUGFyYWNoYWluKC4uKV1gIHRvIHNlbmQgZnJvbSBwYXJhY2hhaW4gdG8gcGFyYWNoYWluLCBvciBgW1BhcmFjaGFpbiguLildYCB0byBzZW5kIGZyb21UICByZWxheSB0byBwYXJhY2hhaW4uVQEtIGBiZW5lZmljaWFyeWA6IEEgYmVuZWZpY2lhcnkgbG9jYXRpb24gZm9yIHRoZSBhc3NldHMgaW4gdGhlIGNvbnRleHQgb2YgYGRlc3RgLiBXaWxsmCAgZ2VuZXJhbGx5IGJlIGFuIGBBY2NvdW50SWQzMmAgdmFsdWUuWQEtIGBhc3NldHNgOiBUaGUgYXNzZXRzIHRvIGJlIHdpdGhkcmF3bi4gVGhpcyBzaG91bGQgaW5jbHVkZSB0aGUgYXNzZXRzIHVzZWQgdG8gcGF5IHRoZWggIGZlZSBvbiB0aGUgYGRlc3RgIGNoYWluLk0BLSBgZmVlX2Fzc2V0X2l0ZW1gOiBUaGUgaW5kZXggaW50byBgYXNzZXRzYCBvZiB0aGUgaXRlbSB3aGljaCBzaG91bGQgYmUgdXNlZCB0byBwYXkcICBmZWVzLlxyZXNlcnZlX3RyYW5zZmVyX2Fzc2V0cxABEGRlc3TFBAFYQm94PFZlcnNpb25lZExvY2F0aW9uPgABLGJlbmVmaWNpYXJ5xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AARhhc3NldHPpBQFQQm94PFZlcnNpb25lZEFzc2V0cz4AAThmZWVfYXNzZXRfaXRlbRABDHUzMgACeF0BVHJhbnNmZXIgc29tZSBhc3NldHMgZnJvbSB0aGUgbG9jYWwgY2hhaW4gdG8gdGhlIGRlc3RpbmF0aW9uIGNoYWluIHRocm91Z2ggdGhlaXIgbG9jYWwseGRlc3RpbmF0aW9uIG9yIHJlbW90ZSByZXNlcnZlLgA9AWBhc3NldHNgIG11c3QgaGF2ZSBzYW1lIHJlc2VydmUgbG9jYXRpb24gYW5kIG1heSBub3QgYmUgdGVsZXBvcnRhYmxlIHRvIGBkZXN0YC5NASAtIGBhc3NldHNgIGhhdmUgbG9jYWwgcmVzZXJ2ZTogdHJhbnNmZXIgYXNzZXRzIHRvIHNvdmVyZWlnbiBhY2NvdW50IG9mIGRlc3RpbmF0aW9uTQEgICBjaGFpbiBhbmQgZm9yd2FyZCBhIG5vdGlmaWNhdGlvbiBYQ00gdG8gYGRlc3RgIHRvIG1pbnQgYW5kIGRlcG9zaXQgcmVzZXJ2ZS1iYXNlZGwgICBhc3NldHMgdG8gYGJlbmVmaWNpYXJ5YC5VASAtIGBhc3NldHNgIGhhdmUgZGVzdGluYXRpb24gcmVzZXJ2ZTogYnVybiBsb2NhbCBhc3NldHMgYW5kIGZvcndhcmQgYSBub3RpZmljYXRpb24gdG9ZASAgIGBkZXN0YCBjaGFpbiB0byB3aXRoZHJhdyB0aGUgcmVzZXJ2ZSBhc3NldHMgZnJvbSB0aGlzIGNoYWluJ3Mgc292ZXJlaWduIGFjY291bnQgYW5khCAgIGRlcG9zaXQgdGhlbSB0byBgYmVuZWZpY2lhcnlgLmEBIC0gYGFzc2V0c2AgaGF2ZSByZW1vdGUgcmVzZXJ2ZTogYnVybiBsb2NhbCBhc3NldHMsIGZvcndhcmQgWENNIHRvIHJlc2VydmUgY2hhaW4gdG8gbW92ZWEBICAgcmVzZXJ2ZXMgZnJvbSB0aGlzIGNoYWluJ3MgU0EgdG8gYGRlc3RgIGNoYWluJ3MgU0EsIGFuZCBmb3J3YXJkIGFub3RoZXIgWENNIHRvIGBkZXN0YPQgICB0byBtaW50IGFuZCBkZXBvc2l0IHJlc2VydmUtYmFzZWQgYXNzZXRzIHRvIGBiZW5lZmljaWFyeWAuAD0BKipUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ6IFVzZSBgbGltaXRlZF9yZXNlcnZlX3RyYW5zZmVyX2Fzc2V0c2AgaW5zdGVhZC4qKgBRAUZlZSBwYXltZW50IG9uIHRoZSBkZXN0aW5hdGlvbiBzaWRlIGlzIG1hZGUgZnJvbSB0aGUgYXNzZXQgaW4gdGhlIGBhc3NldHNgIHZlY3RvciBvZmEBaW5kZXggYGZlZV9hc3NldF9pdGVtYC4gVGhlIHdlaWdodCBsaW1pdCBmb3IgZmVlcyBpcyBub3QgcHJvdmlkZWQgYW5kIHRodXMgaXMgdW5saW1pdGVkLLR3aXRoIGFsbCBmZWVzIHRha2VuIGFzIG5lZWRlZCBmcm9tIHRoZSBhc3NldC4AKQEtIGBvcmlnaW5gOiBNdXN0IGJlIGNhcGFibGUgb2Ygd2l0aGRyYXdpbmcgdGhlIGBhc3NldHNgIGFuZCBleGVjdXRpbmcgWENNLiUBLSBgZGVzdGA6IERlc3RpbmF0aW9uIGNvbnRleHQgZm9yIHRoZSBhc3NldHMuIFdpbGwgdHlwaWNhbGx5IGJlIGBbUGFyZW50LGEBICBQYXJhY2hhaW4oLi4pXWAgdG8gc2VuZCBmcm9tIHBhcmFjaGFpbiB0byBwYXJhY2hhaW4sIG9yIGBbUGFyYWNoYWluKC4uKV1gIHRvIHNlbmQgZnJvbVQgIHJlbGF5IHRvIHBhcmFjaGFpbi5VAS0gYGJlbmVmaWNpYXJ5YDogQSBiZW5lZmljaWFyeSBsb2NhdGlvbiBmb3IgdGhlIGFzc2V0cyBpbiB0aGUgY29udGV4dCBvZiBgZGVzdGAuIFdpbGyYICBnZW5lcmFsbHkgYmUgYW4gYEFjY291bnRJZDMyYCB2YWx1ZS5ZAS0gYGFzc2V0c2A6IFRoZSBhc3NldHMgdG8gYmUgd2l0aGRyYXduLiBUaGlzIHNob3VsZCBpbmNsdWRlIHRoZSBhc3NldHMgdXNlZCB0byBwYXkgdGhlyCAgZmVlIG9uIHRoZSBgZGVzdGAgKGFuZCBwb3NzaWJseSByZXNlcnZlKSBjaGFpbnMuTQEtIGBmZWVfYXNzZXRfaXRlbWA6IFRoZSBpbmRleCBpbnRvIGBhc3NldHNgIG9mIHRoZSBpdGVtIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvIHBheRwgIGZlZXMuHGV4ZWN1dGUIARxtZXNzYWdl7QUBtEJveDxWZXJzaW9uZWRYY208PFQgYXMgQ29uZmlnPjo6UnVudGltZUNhbGw+PgABKG1heF93ZWlnaHQoARhXZWlnaHQAAyDQRXhlY3V0ZSBhbiBYQ00gbWVzc2FnZSBmcm9tIGEgbG9jYWwsIHNpZ25lZCwgb3JpZ2luLgBNAUFuIGV2ZW50IGlzIGRlcG9zaXRlZCBpbmRpY2F0aW5nIHdoZXRoZXIgYG1zZ2AgY291bGQgYmUgZXhlY3V0ZWQgY29tcGxldGVseSBvciBvbmx5KHBhcnRpYWxseS4AXQFObyBtb3JlIHRoYW4gYG1heF93ZWlnaHRgIHdpbGwgYmUgdXNlZCBpbiBpdHMgYXR0ZW1wdGVkIGV4ZWN1dGlvbi4gSWYgdGhpcyBpcyBsZXNzIHRoYW5BAXRoZSBtYXhpbXVtIGFtb3VudCBvZiB3ZWlnaHQgdGhhdCB0aGUgbWVzc2FnZSBjb3VsZCB0YWtlIHRvIGJlIGV4ZWN1dGVkLCB0aGVuIG5vfGV4ZWN1dGlvbiBhdHRlbXB0IHdpbGwgYmUgbWFkZS5EZm9yY2VfeGNtX3ZlcnNpb24IASBsb2NhdGlvbn0BATRCb3g8TG9jYXRpb24+AAEcdmVyc2lvbhABKFhjbVZlcnNpb24ABBhJAUV4dG9sbCB0aGF0IGEgcGFydGljdWxhciBkZXN0aW5hdGlvbiBjYW4gYmUgY29tbXVuaWNhdGVkIHdpdGggdGhyb3VnaCBhIHBhcnRpY3VsYXI8dmVyc2lvbiBvZiBYQ00uANwtIGBvcmlnaW5gOiBNdXN0IGJlIGFuIG9yaWdpbiBzcGVjaWZpZWQgYnkgQWRtaW5PcmlnaW4u2C0gYGxvY2F0aW9uYDogVGhlIGRlc3RpbmF0aW9uIHRoYXQgaXMgYmVpbmcgZGVzY3JpYmVkLhEBLSBgeGNtX3ZlcnNpb25gOiBUaGUgbGF0ZXN0IHZlcnNpb24gb2YgWENNIHRoYXQgYGxvY2F0aW9uYCBzdXBwb3J0cy5kZm9yY2VfZGVmYXVsdF94Y21fdmVyc2lvbgQBRG1heWJlX3hjbV92ZXJzaW9uWQEBSE9wdGlvbjxYY21WZXJzaW9uPgAFFFkBU2V0IGEgc2FmZSBYQ00gdmVyc2lvbiAodGhlIHZlcnNpb24gdGhhdCBYQ00gc2hvdWxkIGJlIGVuY29kZWQgd2l0aCBpZiB0aGUgbW9zdCByZWNlbnS0dmVyc2lvbiBhIGRlc3RpbmF0aW9uIGNhbiBhY2NlcHQgaXMgdW5rbm93bikuANwtIGBvcmlnaW5gOiBNdXN0IGJlIGFuIG9yaWdpbiBzcGVjaWZpZWQgYnkgQWRtaW5PcmlnaW4uOQEtIGBtYXliZV94Y21fdmVyc2lvbmA6IFRoZSBkZWZhdWx0IFhDTSBlbmNvZGluZyB2ZXJzaW9uLCBvciBgTm9uZWAgdG8gZGlzYWJsZS54Zm9yY2Vfc3Vic2NyaWJlX3ZlcnNpb25fbm90aWZ5BAEgbG9jYXRpb27FBAFYQm94PFZlcnNpb25lZExvY2F0aW9uPgAGEDkBQXNrIGEgbG9jYXRpb24gdG8gbm90aWZ5IHVzIHJlZ2FyZGluZyB0aGVpciBYQ00gdmVyc2lvbiBhbmQgYW55IGNoYW5nZXMgdG8gaXQuANwtIGBvcmlnaW5gOiBNdXN0IGJlIGFuIG9yaWdpbiBzcGVjaWZpZWQgYnkgQWRtaW5PcmlnaW4uWQEtIGBsb2NhdGlvbmA6IFRoZSBsb2NhdGlvbiB0byB3aGljaCB3ZSBzaG91bGQgc3Vic2NyaWJlIGZvciBYQ00gdmVyc2lvbiBub3RpZmljYXRpb25zLoBmb3JjZV91bnN1YnNjcmliZV92ZXJzaW9uX25vdGlmeQQBIGxvY2F0aW9uxQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4ABxhJAVJlcXVpcmUgdGhhdCBhIHBhcnRpY3VsYXIgZGVzdGluYXRpb24gc2hvdWxkIG5vIGxvbmdlciBub3RpZnkgdXMgcmVnYXJkaW5nIGFueSBYQ01AdmVyc2lvbiBjaGFuZ2VzLgDcLSBgb3JpZ2luYDogTXVzdCBiZSBhbiBvcmlnaW4gc3BlY2lmaWVkIGJ5IEFkbWluT3JpZ2luLj0BLSBgbG9jYXRpb25gOiBUaGUgbG9jYXRpb24gdG8gd2hpY2ggd2UgYXJlIGN1cnJlbnRseSBzdWJzY3JpYmVkIGZvciBYQ00gdmVyc2lvbqggIG5vdGlmaWNhdGlvbnMgd2hpY2ggd2Ugbm8gbG9uZ2VyIGRlc2lyZS58bGltaXRlZF9yZXNlcnZlX3RyYW5zZmVyX2Fzc2V0cxQBEGRlc3TFBAFYQm94PFZlcnNpb25lZExvY2F0aW9uPgABLGJlbmVmaWNpYXJ5xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AARhhc3NldHPpBQFQQm94PFZlcnNpb25lZEFzc2V0cz4AAThmZWVfYXNzZXRfaXRlbRABDHUzMgABMHdlaWdodF9saW1pdJkFASxXZWlnaHRMaW1pdAAIeF0BVHJhbnNmZXIgc29tZSBhc3NldHMgZnJvbSB0aGUgbG9jYWwgY2hhaW4gdG8gdGhlIGRlc3RpbmF0aW9uIGNoYWluIHRocm91Z2ggdGhlaXIgbG9jYWwseGRlc3RpbmF0aW9uIG9yIHJlbW90ZSByZXNlcnZlLgA9AWBhc3NldHNgIG11c3QgaGF2ZSBzYW1lIHJlc2VydmUgbG9jYXRpb24gYW5kIG1heSBub3QgYmUgdGVsZXBvcnRhYmxlIHRvIGBkZXN0YC5NASAtIGBhc3NldHNgIGhhdmUgbG9jYWwgcmVzZXJ2ZTogdHJhbnNmZXIgYXNzZXRzIHRvIHNvdmVyZWlnbiBhY2NvdW50IG9mIGRlc3RpbmF0aW9uTQEgICBjaGFpbiBhbmQgZm9yd2FyZCBhIG5vdGlmaWNhdGlvbiBYQ00gdG8gYGRlc3RgIHRvIG1pbnQgYW5kIGRlcG9zaXQgcmVzZXJ2ZS1iYXNlZGwgICBhc3NldHMgdG8gYGJlbmVmaWNpYXJ5YC5VASAtIGBhc3NldHNgIGhhdmUgZGVzdGluYXRpb24gcmVzZXJ2ZTogYnVybiBsb2NhbCBhc3NldHMgYW5kIGZvcndhcmQgYSBub3RpZmljYXRpb24gdG9ZASAgIGBkZXN0YCBjaGFpbiB0byB3aXRoZHJhdyB0aGUgcmVzZXJ2ZSBhc3NldHMgZnJvbSB0aGlzIGNoYWluJ3Mgc292ZXJlaWduIGFjY291bnQgYW5khCAgIGRlcG9zaXQgdGhlbSB0byBgYmVuZWZpY2lhcnlgLmEBIC0gYGFzc2V0c2AgaGF2ZSByZW1vdGUgcmVzZXJ2ZTogYnVybiBsb2NhbCBhc3NldHMsIGZvcndhcmQgWENNIHRvIHJlc2VydmUgY2hhaW4gdG8gbW92ZWEBICAgcmVzZXJ2ZXMgZnJvbSB0aGlzIGNoYWluJ3MgU0EgdG8gYGRlc3RgIGNoYWluJ3MgU0EsIGFuZCBmb3J3YXJkIGFub3RoZXIgWENNIHRvIGBkZXN0YPQgICB0byBtaW50IGFuZCBkZXBvc2l0IHJlc2VydmUtYmFzZWQgYXNzZXRzIHRvIGBiZW5lZmljaWFyeWAuAFEBRmVlIHBheW1lbnQgb24gdGhlIGRlc3RpbmF0aW9uIHNpZGUgaXMgbWFkZSBmcm9tIHRoZSBhc3NldCBpbiB0aGUgYGFzc2V0c2AgdmVjdG9yIG9mYQFpbmRleCBgZmVlX2Fzc2V0X2l0ZW1gLCB1cCB0byBlbm91Z2ggdG8gcGF5IGZvciBgd2VpZ2h0X2xpbWl0YCBvZiB3ZWlnaHQuIElmIG1vcmUgd2VpZ2h0WQFpcyBuZWVkZWQgdGhhbiBgd2VpZ2h0X2xpbWl0YCwgdGhlbiB0aGUgb3BlcmF0aW9uIHdpbGwgZmFpbCBhbmQgdGhlIHNlbnQgYXNzZXRzIG1heSBiZSBhdCByaXNrLgApAS0gYG9yaWdpbmA6IE11c3QgYmUgY2FwYWJsZSBvZiB3aXRoZHJhd2luZyB0aGUgYGFzc2V0c2AgYW5kIGV4ZWN1dGluZyBYQ00uJQEtIGBkZXN0YDogRGVzdGluYXRpb24gY29udGV4dCBmb3IgdGhlIGFzc2V0cy4gV2lsbCB0eXBpY2FsbHkgYmUgYFtQYXJlbnQsYQEgIFBhcmFjaGFpbiguLildYCB0byBzZW5kIGZyb20gcGFyYWNoYWluIHRvIHBhcmFjaGFpbiwgb3IgYFtQYXJhY2hhaW4oLi4pXWAgdG8gc2VuZCBmcm9tVCAgcmVsYXkgdG8gcGFyYWNoYWluLlUBLSBgYmVuZWZpY2lhcnlgOiBBIGJlbmVmaWNpYXJ5IGxvY2F0aW9uIGZvciB0aGUgYXNzZXRzIGluIHRoZSBjb250ZXh0IG9mIGBkZXN0YC4gV2lsbJggIGdlbmVyYWxseSBiZSBhbiBgQWNjb3VudElkMzJgIHZhbHVlLlkBLSBgYXNzZXRzYDogVGhlIGFzc2V0cyB0byBiZSB3aXRoZHJhd24uIFRoaXMgc2hvdWxkIGluY2x1ZGUgdGhlIGFzc2V0cyB1c2VkIHRvIHBheSB0aGXIICBmZWUgb24gdGhlIGBkZXN0YCAoYW5kIHBvc3NpYmx5IHJlc2VydmUpIGNoYWlucy5NAS0gYGZlZV9hc3NldF9pdGVtYDogVGhlIGluZGV4IGludG8gYGFzc2V0c2Agb2YgdGhlIGl0ZW0gd2hpY2ggc2hvdWxkIGJlIHVzZWQgdG8gcGF5HCAgZmVlcy5FAS0gYHdlaWdodF9saW1pdGA6IFRoZSByZW1vdGUtc2lkZSB3ZWlnaHQgbGltaXQsIGlmIGFueSwgZm9yIHRoZSBYQ00gZmVlIHB1cmNoYXNlLlxsaW1pdGVkX3RlbGVwb3J0X2Fzc2V0cxQBEGRlc3TFBAFYQm94PFZlcnNpb25lZExvY2F0aW9uPgABLGJlbmVmaWNpYXJ5xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AARhhc3NldHPpBQFQQm94PFZlcnNpb25lZEFzc2V0cz4AAThmZWVfYXNzZXRfaXRlbRABDHUzMgABMHdlaWdodF9saW1pdJkFASxXZWlnaHRMaW1pdAAJSBEBVGVsZXBvcnQgc29tZSBhc3NldHMgZnJvbSB0aGUgbG9jYWwgY2hhaW4gdG8gc29tZSBkZXN0aW5hdGlvbiBjaGFpbi4AUQFGZWUgcGF5bWVudCBvbiB0aGUgZGVzdGluYXRpb24gc2lkZSBpcyBtYWRlIGZyb20gdGhlIGFzc2V0IGluIHRoZSBgYXNzZXRzYCB2ZWN0b3Igb2ZhAWluZGV4IGBmZWVfYXNzZXRfaXRlbWAsIHVwIHRvIGVub3VnaCB0byBwYXkgZm9yIGB3ZWlnaHRfbGltaXRgIG9mIHdlaWdodC4gSWYgbW9yZSB3ZWlnaHRZAWlzIG5lZWRlZCB0aGFuIGB3ZWlnaHRfbGltaXRgLCB0aGVuIHRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIGFuZCB0aGUgc2VudCBhc3NldHMgbWF5IGJlIGF0IHJpc2suACkBLSBgb3JpZ2luYDogTXVzdCBiZSBjYXBhYmxlIG9mIHdpdGhkcmF3aW5nIHRoZSBgYXNzZXRzYCBhbmQgZXhlY3V0aW5nIFhDTS4lAS0gYGRlc3RgOiBEZXN0aW5hdGlvbiBjb250ZXh0IGZvciB0aGUgYXNzZXRzLiBXaWxsIHR5cGljYWxseSBiZSBgW1BhcmVudCxhASAgUGFyYWNoYWluKC4uKV1gIHRvIHNlbmQgZnJvbSBwYXJhY2hhaW4gdG8gcGFyYWNoYWluLCBvciBgW1BhcmFjaGFpbiguLildYCB0byBzZW5kIGZyb21UICByZWxheSB0byBwYXJhY2hhaW4uVQEtIGBiZW5lZmljaWFyeWA6IEEgYmVuZWZpY2lhcnkgbG9jYXRpb24gZm9yIHRoZSBhc3NldHMgaW4gdGhlIGNvbnRleHQgb2YgYGRlc3RgLiBXaWxsmCAgZ2VuZXJhbGx5IGJlIGFuIGBBY2NvdW50SWQzMmAgdmFsdWUuWQEtIGBhc3NldHNgOiBUaGUgYXNzZXRzIHRvIGJlIHdpdGhkcmF3bi4gVGhpcyBzaG91bGQgaW5jbHVkZSB0aGUgYXNzZXRzIHVzZWQgdG8gcGF5IHRoZWggIGZlZSBvbiB0aGUgYGRlc3RgIGNoYWluLk0BLSBgZmVlX2Fzc2V0X2l0ZW1gOiBUaGUgaW5kZXggaW50byBgYXNzZXRzYCBvZiB0aGUgaXRlbSB3aGljaCBzaG91bGQgYmUgdXNlZCB0byBwYXkcICBmZWVzLkUBLSBgd2VpZ2h0X2xpbWl0YDogVGhlIHJlbW90ZS1zaWRlIHdlaWdodCBsaW1pdCwgaWYgYW55LCBmb3IgdGhlIFhDTSBmZWUgcHVyY2hhc2UuQGZvcmNlX3N1c3BlbnNpb24EASRzdXNwZW5kZWQgARBib29sAAoQ9FNldCBvciB1bnNldCB0aGUgZ2xvYmFsIHN1c3BlbnNpb24gc3RhdGUgb2YgdGhlIFhDTSBleGVjdXRvci4A3C0gYG9yaWdpbmA6IE11c3QgYmUgYW4gb3JpZ2luIHNwZWNpZmllZCBieSBBZG1pbk9yaWdpbi7QLSBgc3VzcGVuZGVkYDogYHRydWVgIHRvIHN1c3BlbmQsIGBmYWxzZWAgdG8gcmVzdW1lLjx0cmFuc2Zlcl9hc3NldHMUARBkZXN0xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AASxiZW5lZmljaWFyecUEAVhCb3g8VmVyc2lvbmVkTG9jYXRpb24+AAEYYXNzZXRz6QUBUEJveDxWZXJzaW9uZWRBc3NldHM+AAE4ZmVlX2Fzc2V0X2l0ZW0QAQx1MzIAATB3ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAC4RdAVRyYW5zZmVyIHNvbWUgYXNzZXRzIGZyb20gdGhlIGxvY2FsIGNoYWluIHRvIHRoZSBkZXN0aW5hdGlvbiBjaGFpbiB0aHJvdWdoIHRoZWlyIGxvY2FsLNBkZXN0aW5hdGlvbiBvciByZW1vdGUgcmVzZXJ2ZSwgb3IgdGhyb3VnaCB0ZWxlcG9ydHMuAFEBRmVlIHBheW1lbnQgb24gdGhlIGRlc3RpbmF0aW9uIHNpZGUgaXMgbWFkZSBmcm9tIHRoZSBhc3NldCBpbiB0aGUgYGFzc2V0c2AgdmVjdG9yIG9mNQFpbmRleCBgZmVlX2Fzc2V0X2l0ZW1gIChoZW5jZSByZWZlcnJlZCB0byBhcyBgZmVlc2ApLCB1cCB0byBlbm91Z2ggdG8gcGF5IGZvckEBYHdlaWdodF9saW1pdGAgb2Ygd2VpZ2h0LiBJZiBtb3JlIHdlaWdodCBpcyBuZWVkZWQgdGhhbiBgd2VpZ2h0X2xpbWl0YCwgdGhlbiB0aGXcb3BlcmF0aW9uIHdpbGwgZmFpbCBhbmQgdGhlIHNlbnQgYXNzZXRzIG1heSBiZSBhdCByaXNrLgBhAWBhc3NldHNgIChleGNsdWRpbmcgYGZlZXNgKSBtdXN0IGhhdmUgc2FtZSByZXNlcnZlIGxvY2F0aW9uIG9yIG90aGVyd2lzZSBiZSB0ZWxlcG9ydGFibGWwdG8gYGRlc3RgLCBubyBsaW1pdGF0aW9ucyBpbXBvc2VkIG9uIGBmZWVzYC5NASAtIGZvciBsb2NhbCByZXNlcnZlOiB0cmFuc2ZlciBhc3NldHMgdG8gc292ZXJlaWduIGFjY291bnQgb2YgZGVzdGluYXRpb24gY2hhaW4gYW5kTQEgICBmb3J3YXJkIGEgbm90aWZpY2F0aW9uIFhDTSB0byBgZGVzdGAgdG8gbWludCBhbmQgZGVwb3NpdCByZXNlcnZlLWJhc2VkIGFzc2V0cyB0b0QgICBgYmVuZWZpY2lhcnlgLmEBIC0gZm9yIGRlc3RpbmF0aW9uIHJlc2VydmU6IGJ1cm4gbG9jYWwgYXNzZXRzIGFuZCBmb3J3YXJkIGEgbm90aWZpY2F0aW9uIHRvIGBkZXN0YCBjaGFpblkBICAgdG8gd2l0aGRyYXcgdGhlIHJlc2VydmUgYXNzZXRzIGZyb20gdGhpcyBjaGFpbidzIHNvdmVyZWlnbiBhY2NvdW50IGFuZCBkZXBvc2l0IHRoZW1QICAgdG8gYGJlbmVmaWNpYXJ5YC5dASAtIGZvciByZW1vdGUgcmVzZXJ2ZTogYnVybiBsb2NhbCBhc3NldHMsIGZvcndhcmQgWENNIHRvIHJlc2VydmUgY2hhaW4gdG8gbW92ZSByZXNlcnZlc10BICAgZnJvbSB0aGlzIGNoYWluJ3MgU0EgdG8gYGRlc3RgIGNoYWluJ3MgU0EsIGFuZCBmb3J3YXJkIGFub3RoZXIgWENNIHRvIGBkZXN0YCB0byBtaW501CAgIGFuZCBkZXBvc2l0IHJlc2VydmUtYmFzZWQgYXNzZXRzIHRvIGBiZW5lZmljaWFyeWAuUQEgLSBmb3IgdGVsZXBvcnRzOiBidXJuIGxvY2FsIGFzc2V0cyBhbmQgZm9yd2FyZCBYQ00gdG8gYGRlc3RgIGNoYWluIHRvIG1pbnQvdGVsZXBvcnSwICAgYXNzZXRzIGFuZCBkZXBvc2l0IHRoZW0gdG8gYGJlbmVmaWNpYXJ5YC4AKQEtIGBvcmlnaW5gOiBNdXN0IGJlIGNhcGFibGUgb2Ygd2l0aGRyYXdpbmcgdGhlIGBhc3NldHNgIGFuZCBleGVjdXRpbmcgWENNLi0BLSBgZGVzdGA6IERlc3RpbmF0aW9uIGNvbnRleHQgZm9yIHRoZSBhc3NldHMuIFdpbGwgdHlwaWNhbGx5IGJlIGBYMihQYXJlbnQsVQEgIFBhcmFjaGFpbiguLikpYCB0byBzZW5kIGZyb20gcGFyYWNoYWluIHRvIHBhcmFjaGFpbiwgb3IgYFgxKFBhcmFjaGFpbiguLikpYCB0byBzZW5kaCAgZnJvbSByZWxheSB0byBwYXJhY2hhaW4uVQEtIGBiZW5lZmljaWFyeWA6IEEgYmVuZWZpY2lhcnkgbG9jYXRpb24gZm9yIHRoZSBhc3NldHMgaW4gdGhlIGNvbnRleHQgb2YgYGRlc3RgLiBXaWxsmCAgZ2VuZXJhbGx5IGJlIGFuIGBBY2NvdW50SWQzMmAgdmFsdWUuWQEtIGBhc3NldHNgOiBUaGUgYXNzZXRzIHRvIGJlIHdpdGhkcmF3bi4gVGhpcyBzaG91bGQgaW5jbHVkZSB0aGUgYXNzZXRzIHVzZWQgdG8gcGF5IHRoZcggIGZlZSBvbiB0aGUgYGRlc3RgIChhbmQgcG9zc2libHkgcmVzZXJ2ZSkgY2hhaW5zLk0BLSBgZmVlX2Fzc2V0X2l0ZW1gOiBUaGUgaW5kZXggaW50byBgYXNzZXRzYCBvZiB0aGUgaXRlbSB3aGljaCBzaG91bGQgYmUgdXNlZCB0byBwYXkcICBmZWVzLkUBLSBgd2VpZ2h0X2xpbWl0YDogVGhlIHJlbW90ZS1zaWRlIHdlaWdodCBsaW1pdCwgaWYgYW55LCBmb3IgdGhlIFhDTSBmZWUgcHVyY2hhc2UuMGNsYWltX2Fzc2V0cwgBGGFzc2V0c+kFAVBCb3g8VmVyc2lvbmVkQXNzZXRzPgABLGJlbmVmaWNpYXJ5xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4ADBhVAUNsYWltcyBhc3NldHMgdHJhcHBlZCBvbiB0aGlzIHBhbGxldCBiZWNhdXNlIG9mIGxlZnRvdmVyIGFzc2V0cyBkdXJpbmcgWENNIGV4ZWN1dGlvbi4ArC0gYG9yaWdpbmA6IEFueW9uZSBjYW4gY2FsbCB0aGlzIGV4dHJpbnNpYy5dAS0gYGFzc2V0c2A6IFRoZSBleGFjdCBhc3NldHMgdGhhdCB3ZXJlIHRyYXBwZWQuIFVzZSB0aGUgdmVyc2lvbiB0byBzcGVjaWZ5IHdoYXQgdmVyc2lvbph3YXMgdGhlIGxhdGVzdCB3aGVuIHRoZXkgd2VyZSB0cmFwcGVkLkUBLSBgYmVuZWZpY2lhcnlgOiBUaGUgbG9jYXRpb24vYWNjb3VudCB3aGVyZSB0aGUgY2xhaW1lZCBhc3NldHMgd2lsbCBiZSBkZXBvc2l0ZWQujHRyYW5zZmVyX2Fzc2V0c191c2luZ190eXBlX2FuZF90aGVuHAEQZGVzdMUEAVhCb3g8VmVyc2lvbmVkTG9jYXRpb24+AAEYYXNzZXRz6QUBUEJveDxWZXJzaW9uZWRBc3NldHM+AAFQYXNzZXRzX3RyYW5zZmVyX3R5cGUZBgFEQm94PFRyYW5zZmVyVHlwZT4AAThyZW1vdGVfZmVlc19pZB0GAVRCb3g8VmVyc2lvbmVkQXNzZXRJZD4AAUhmZWVzX3RyYW5zZmVyX3R5cGUZBgFEQm94PFRyYW5zZmVyVHlwZT4AAUhjdXN0b21feGNtX29uX2Rlc3TlBAFUQm94PFZlcnNpb25lZFhjbTwoKT4+AAEwd2VpZ2h0X2xpbWl0mQUBLFdlaWdodExpbWl0AA3AVQFUcmFuc2ZlciBhc3NldHMgZnJvbSB0aGUgbG9jYWwgY2hhaW4gdG8gdGhlIGRlc3RpbmF0aW9uIGNoYWluIHVzaW5nIGV4cGxpY2l0IHRyYW5zZmVyaHR5cGVzIGZvciBhc3NldHMgYW5kIGZlZXMuAFkBYGFzc2V0c2AgbXVzdCBoYXZlIHNhbWUgcmVzZXJ2ZSBsb2NhdGlvbiBvciBtYXkgYmUgdGVsZXBvcnRhYmxlIHRvIGBkZXN0YC4gQ2FsbGVyIG11c3TscHJvdmlkZSB0aGUgYGFzc2V0c190cmFuc2Zlcl90eXBlYCB0byBiZSB1c2VkIGZvciBgYXNzZXRzYDpRASAtIGBUcmFuc2ZlclR5cGU6OkxvY2FsUmVzZXJ2ZWA6IHRyYW5zZmVyIGFzc2V0cyB0byBzb3ZlcmVpZ24gYWNjb3VudCBvZiBkZXN0aW5hdGlvbk0BICAgY2hhaW4gYW5kIGZvcndhcmQgYSBub3RpZmljYXRpb24gWENNIHRvIGBkZXN0YCB0byBtaW50IGFuZCBkZXBvc2l0IHJlc2VydmUtYmFzZWRsICAgYXNzZXRzIHRvIGBiZW5lZmljaWFyeWAuWQEgLSBgVHJhbnNmZXJUeXBlOjpEZXN0aW5hdGlvblJlc2VydmVgOiBidXJuIGxvY2FsIGFzc2V0cyBhbmQgZm9yd2FyZCBhIG5vdGlmaWNhdGlvbiB0b1kBICAgYGRlc3RgIGNoYWluIHRvIHdpdGhkcmF3IHRoZSByZXNlcnZlIGFzc2V0cyBmcm9tIHRoaXMgY2hhaW4ncyBzb3ZlcmVpZ24gYWNjb3VudCBhbmSEICAgZGVwb3NpdCB0aGVtIHRvIGBiZW5lZmljaWFyeWAuWQEgLSBgVHJhbnNmZXJUeXBlOjpSZW1vdGVSZXNlcnZlKHJlc2VydmUpYDogYnVybiBsb2NhbCBhc3NldHMsIGZvcndhcmQgWENNIHRvIGByZXNlcnZlYGEBICAgY2hhaW4gdG8gbW92ZSByZXNlcnZlcyBmcm9tIHRoaXMgY2hhaW4ncyBTQSB0byBgZGVzdGAgY2hhaW4ncyBTQSwgYW5kIGZvcndhcmQgYW5vdGhlclUBICAgWENNIHRvIGBkZXN0YCB0byBtaW50IGFuZCBkZXBvc2l0IHJlc2VydmUtYmFzZWQgYXNzZXRzIHRvIGBiZW5lZmljaWFyeWAuIFR5cGljYWxseZQgICB0aGUgcmVtb3RlIGByZXNlcnZlYCBpcyBBc3NldCBIdWIuRQEgLSBgVHJhbnNmZXJUeXBlOjpUZWxlcG9ydGA6IGJ1cm4gbG9jYWwgYXNzZXRzIGFuZCBmb3J3YXJkIFhDTSB0byBgZGVzdGAgY2hhaW4gdG/oICAgbWludC90ZWxlcG9ydCBhc3NldHMgYW5kIGRlcG9zaXQgdGhlbSB0byBgYmVuZWZpY2lhcnlgLgBVAU9uIHRoZSBkZXN0aW5hdGlvbiBjaGFpbiwgYXMgd2VsbCBhcyBhbnkgaW50ZXJtZWRpYXJ5IGhvcHMsIGBCdXlFeGVjdXRpb25gIGlzIHVzZWQgdG8hAWJ1eSBleGVjdXRpb24gdXNpbmcgdHJhbnNmZXJyZWQgYGFzc2V0c2AgaWRlbnRpZmllZCBieSBgcmVtb3RlX2ZlZXNfaWRgLlkBTWFrZSBzdXJlIGVub3VnaCBvZiB0aGUgc3BlY2lmaWVkIGByZW1vdGVfZmVlc19pZGAgYXNzZXQgaXMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGxpc3RhAW9mIGBhc3NldHNgLiBgcmVtb3RlX2ZlZXNfaWRgIHNob3VsZCBiZSBlbm91Z2ggdG8gcGF5IGZvciBgd2VpZ2h0X2xpbWl0YC4gSWYgbW9yZSB3ZWlnaHRZAWlzIG5lZWRlZCB0aGFuIGB3ZWlnaHRfbGltaXRgLCB0aGVuIHRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIGFuZCB0aGUgc2VudCBhc3NldHMgbWF5IGJlIGF0IHJpc2suAEUBYHJlbW90ZV9mZWVzX2lkYCBtYXkgdXNlIGRpZmZlcmVudCB0cmFuc2ZlciB0eXBlIHRoYW4gcmVzdCBvZiBgYXNzZXRzYCBhbmQgY2FuIGJlnHNwZWNpZmllZCB0aHJvdWdoIGBmZWVzX3RyYW5zZmVyX3R5cGVgLgBhAVRoZSBjYWxsZXIgbmVlZHMgdG8gc3BlY2lmeSB3aGF0IHNob3VsZCBoYXBwZW4gdG8gdGhlIHRyYW5zZmVycmVkIGFzc2V0cyBvbmNlIHRoZXkgcmVhY2hBAXRoZSBgZGVzdGAgY2hhaW4uIFRoaXMgaXMgZG9uZSB0aHJvdWdoIHRoZSBgY3VzdG9tX3hjbV9vbl9kZXN0YCBwYXJhbWV0ZXIsIHdoaWNo/GNvbnRhaW5zIHRoZSBpbnN0cnVjdGlvbnMgdG8gZXhlY3V0ZSBvbiBgZGVzdGAgYXMgYSBmaW5hbCBzdGVwLnwgIFRoaXMgaXMgdXN1YWxseSBhcyBzaW1wbGUgYXM6UQEgIGBYY20odmVjIVtEZXBvc2l0QXNzZXQgeyBhc3NldHM6IFdpbGQoQWxsQ291bnRlZChhc3NldHMubGVuKCkpKSwgYmVuZWZpY2lhcnkgfV0pYCwxASAgYnV0IGNvdWxkIGJlIHNvbWV0aGluZyBtb3JlIGV4b3RpYyBsaWtlIHNlbmRpbmcgdGhlIGBhc3NldHNgIGV2ZW4gZnVydGhlci4AKQEtIGBvcmlnaW5gOiBNdXN0IGJlIGNhcGFibGUgb2Ygd2l0aGRyYXdpbmcgdGhlIGBhc3NldHNgIGFuZCBleGVjdXRpbmcgWENNLiUBLSBgZGVzdGA6IERlc3RpbmF0aW9uIGNvbnRleHQgZm9yIHRoZSBhc3NldHMuIFdpbGwgdHlwaWNhbGx5IGJlIGBbUGFyZW50LGEBICBQYXJhY2hhaW4oLi4pXWAgdG8gc2VuZCBmcm9tIHBhcmFjaGFpbiB0byBwYXJhY2hhaW4sIG9yIGBbUGFyYWNoYWluKC4uKV1gIHRvIHNlbmQgZnJvbT0BICByZWxheSB0byBwYXJhY2hhaW4sIG9yIGAocGFyZW50czogMiwgKEdsb2JhbENvbnNlbnN1cyguLiksIC4uKSlgIHRvIHNlbmQgZnJvbfQgIHBhcmFjaGFpbiBhY3Jvc3MgYSBicmlkZ2UgdG8gYW5vdGhlciBlY29zeXN0ZW0gZGVzdGluYXRpb24uWQEtIGBhc3NldHNgOiBUaGUgYXNzZXRzIHRvIGJlIHdpdGhkcmF3bi4gVGhpcyBzaG91bGQgaW5jbHVkZSB0aGUgYXNzZXRzIHVzZWQgdG8gcGF5IHRoZcggIGZlZSBvbiB0aGUgYGRlc3RgIChhbmQgcG9zc2libHkgcmVzZXJ2ZSkgY2hhaW5zLj0BLSBgYXNzZXRzX3RyYW5zZmVyX3R5cGVgOiBUaGUgWENNIGBUcmFuc2ZlclR5cGVgIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGBhc3NldHNgLiEBLSBgcmVtb3RlX2ZlZXNfaWRgOiBPbmUgb2YgdGhlIGluY2x1ZGVkIGBhc3NldHNgIHRvIGJlIHVzZWQgdG8gcGF5IGZlZXMuSQEtIGBmZWVzX3RyYW5zZmVyX3R5cGVgOiBUaGUgWENNIGBUcmFuc2ZlclR5cGVgIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGBmZWVzYCBhc3NldHMuWQEtIGBjdXN0b21feGNtX29uX2Rlc3RgOiBUaGUgWENNIHRvIGJlIGV4ZWN1dGVkIG9uIGBkZXN0YCBjaGFpbiBhcyB0aGUgbGFzdCBzdGVwIG9mIHRoZVkBICB0cmFuc2Zlciwgd2hpY2ggYWxzbyBkZXRlcm1pbmVzIHdoYXQgaGFwcGVucyB0byB0aGUgYXNzZXRzIG9uIHRoZSBkZXN0aW5hdGlvbiBjaGFpbi5FAS0gYHdlaWdodF9saW1pdGA6IFRoZSByZW1vdGUtc2lkZSB3ZWlnaHQgbGltaXQsIGlmIGFueSwgZm9yIHRoZSBYQ00gZmVlIHB1cmNoYXNlLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy7FBAgMeGNtRFZlcnNpb25lZExvY2F0aW9uAAEMCFYyBADJBAFEdjI6Ok11bHRpTG9jYXRpb24AAQAIVjMEAPUCAUR2Mzo6TXVsdGlMb2NhdGlvbgADAAhWNAQAfQEBMHY0OjpMb2NhdGlvbgAEAADJBBAMeGNtCHYyNG11bHRpbG9jYXRpb240TXVsdGlMb2NhdGlvbgAACAEccGFyZW50cwgBCHU4AAEgaW50ZXJpb3LNBAEkSnVuY3Rpb25zAADNBBAMeGNtCHYyNG11bHRpbG9jYXRpb24kSnVuY3Rpb25zAAEkEEhlcmUAAAAIWDEEANEEASBKdW5jdGlvbgABAAhYMggA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AAgAIWDMMANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AAwAIWDQQANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAEAAhYNRQA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24ABQAIWDYYANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24ABgAIWDccANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAHAAhYOCAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24AANEEASBKdW5jdGlvbgAA0QQBIEp1bmN0aW9uAADRBAEgSnVuY3Rpb24ACAAA0QQQDHhjbQh2MiBqdW5jdGlvbiBKdW5jdGlvbgABJCRQYXJhY2hhaW4EAFUBAQx1MzIAAAAsQWNjb3VudElkMzIIARxuZXR3b3Jr1QQBJE5ldHdvcmtJZAABCGlkBAEgW3U4OyAzMl0AAQA4QWNjb3VudEluZGV4NjQIARxuZXR3b3Jr1QQBJE5ldHdvcmtJZAABFGluZGV4LAEMdTY0AAIAMEFjY291bnRLZXkyMAgBHG5ldHdvcmvVBAEkTmV0d29ya0lkAAEMa2V5RQEBIFt1ODsgMjBdAAMAOFBhbGxldEluc3RhbmNlBAAIAQh1OAAEADBHZW5lcmFsSW5kZXgEAC0BARB1MTI4AAUAKEdlbmVyYWxLZXkEANkEAYBXZWFrQm91bmRlZFZlYzx1OCwgQ29uc3RVMzI8MzI+PgAGACRPbmx5Q2hpbGQABwAkUGx1cmFsaXR5CAEIaWTdBAEYQm9keUlkAAEQcGFydOEEASBCb2R5UGFydAAIAADVBAwMeGNtCHYyJE5ldHdvcmtJZAABEAxBbnkAAAAUTmFtZWQEANkEAYBXZWFrQm91bmRlZFZlYzx1OCwgQ29uc3RVMzI8MzI+PgABACBQb2xrYWRvdAACABhLdXNhbWEAAwAA2QQMTGJvdW5kZWRfY29sbGVjdGlvbnNAd2Vha19ib3VuZGVkX3ZlYzhXZWFrQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AADdBAwMeGNtCHYyGEJvZHlJZAABKBBVbml0AAAAFE5hbWVkBADZBAGAV2Vha0JvdW5kZWRWZWM8dTgsIENvbnN0VTMyPDMyPj4AAQAUSW5kZXgEAFUBAQx1MzIAAgAkRXhlY3V0aXZlAAMAJFRlY2huaWNhbAAEACxMZWdpc2xhdGl2ZQAFACBKdWRpY2lhbAAGABxEZWZlbnNlAAcAOEFkbWluaXN0cmF0aW9uAAgAIFRyZWFzdXJ5AAkAAOEEDAx4Y20IdjIgQm9keVBhcnQAARQUVm9pY2UAAAAcTWVtYmVycwQBFGNvdW50VQEBDHUzMgABACBGcmFjdGlvbggBDG5vbVUBAQx1MzIAARRkZW5vbVUBAQx1MzIAAgBEQXRMZWFzdFByb3BvcnRpb24IAQxub21VAQEMdTMyAAEUZGVub21VAQEMdTMyAAMASE1vcmVUaGFuUHJvcG9ydGlvbggBDG5vbVUBAQx1MzIAARRkZW5vbVUBAQx1MzIABAAA5QQIDHhjbTBWZXJzaW9uZWRYY20ELFJ1bnRpbWVDYWxsAAEMCFYyBADpBAFQdjI6OlhjbTxSdW50aW1lQ2FsbD4AAgAIVjMEADUFAVB2Mzo6WGNtPFJ1bnRpbWVDYWxsPgADAAhWNAQAnQUBUHY0OjpYY208UnVudGltZUNhbGw+AAQAAOkEDAx4Y20IdjIMWGNtBCxSdW50aW1lQ2FsbAAABADtBAF0VmVjPEluc3RydWN0aW9uPFJ1bnRpbWVDYWxsPj4AAO0EAAAC8QQA8QQMDHhjbQh2MixJbnN0cnVjdGlvbgQsUnVudGltZUNhbGwAAXA0V2l0aGRyYXdBc3NldAQA9QQBLE11bHRpQXNzZXRzAAAAVFJlc2VydmVBc3NldERlcG9zaXRlZAQA9QQBLE11bHRpQXNzZXRzAAEAWFJlY2VpdmVUZWxlcG9ydGVkQXNzZXQEAPUEASxNdWx0aUFzc2V0cwACADRRdWVyeVJlc3BvbnNlDAEgcXVlcnlfaWQsARxRdWVyeUlkAAEgcmVzcG9uc2UNBQEgUmVzcG9uc2UAAShtYXhfd2VpZ2h0LAEMdTY0AAMANFRyYW5zZmVyQXNzZXQIARhhc3NldHP1BAEsTXVsdGlBc3NldHMAASxiZW5lZmljaWFyeckEATRNdWx0aUxvY2F0aW9uAAQAUFRyYW5zZmVyUmVzZXJ2ZUFzc2V0DAEYYXNzZXRz9QQBLE11bHRpQXNzZXRzAAEQZGVzdMkEATRNdWx0aUxvY2F0aW9uAAEMeGNt6QQBHFhjbTwoKT4ABQAgVHJhbnNhY3QMASxvcmlnaW5fdHlwZR0FAShPcmlnaW5LaW5kAAFYcmVxdWlyZV93ZWlnaHRfYXRfbW9zdCwBDHU2NAABEGNhbGwhBQFoRG91YmxlRW5jb2RlZDxSdW50aW1lQ2FsbD4ABgBkSHJtcE5ld0NoYW5uZWxPcGVuUmVxdWVzdAwBGHNlbmRlclUBAQx1MzIAAUBtYXhfbWVzc2FnZV9zaXplVQEBDHUzMgABMG1heF9jYXBhY2l0eVUBAQx1MzIABwBMSHJtcENoYW5uZWxBY2NlcHRlZAQBJHJlY2lwaWVudFUBAQx1MzIACABISHJtcENoYW5uZWxDbG9zaW5nDAEkaW5pdGlhdG9yVQEBDHUzMgABGHNlbmRlclUBAQx1MzIAASRyZWNpcGllbnRVAQEMdTMyAAkALENsZWFyT3JpZ2luAAoANERlc2NlbmRPcmlnaW4EAM0EAVRJbnRlcmlvck11bHRpTG9jYXRpb24ACwAsUmVwb3J0RXJyb3IMASBxdWVyeV9pZCwBHFF1ZXJ5SWQAARBkZXN0yQQBNE11bHRpTG9jYXRpb24AAUxtYXhfcmVzcG9uc2Vfd2VpZ2h0LAEMdTY0AAwAMERlcG9zaXRBc3NldAwBGGFzc2V0cyUFAUBNdWx0aUFzc2V0RmlsdGVyAAEobWF4X2Fzc2V0c1UBAQx1MzIAASxiZW5lZmljaWFyeckEATRNdWx0aUxvY2F0aW9uAA0ATERlcG9zaXRSZXNlcnZlQXNzZXQQARhhc3NldHMlBQFATXVsdGlBc3NldEZpbHRlcgABKG1heF9hc3NldHNVAQEMdTMyAAEQZGVzdMkEATRNdWx0aUxvY2F0aW9uAAEMeGNt6QQBHFhjbTwoKT4ADgA0RXhjaGFuZ2VBc3NldAgBEGdpdmUlBQFATXVsdGlBc3NldEZpbHRlcgABHHJlY2VpdmX1BAEsTXVsdGlBc3NldHMADwBcSW5pdGlhdGVSZXNlcnZlV2l0aGRyYXcMARhhc3NldHMlBQFATXVsdGlBc3NldEZpbHRlcgABHHJlc2VydmXJBAE0TXVsdGlMb2NhdGlvbgABDHhjbekEARxYY208KCk+ABAAQEluaXRpYXRlVGVsZXBvcnQMARhhc3NldHMlBQFATXVsdGlBc3NldEZpbHRlcgABEGRlc3TJBAE0TXVsdGlMb2NhdGlvbgABDHhjbekEARxYY208KCk+ABEAMFF1ZXJ5SG9sZGluZxABIHF1ZXJ5X2lkLAEcUXVlcnlJZAABEGRlc3TJBAE0TXVsdGlMb2NhdGlvbgABGGFzc2V0cyUFAUBNdWx0aUFzc2V0RmlsdGVyAAFMbWF4X3Jlc3BvbnNlX3dlaWdodCwBDHU2NAASADBCdXlFeGVjdXRpb24IARBmZWVz/QQBKE11bHRpQXNzZXQAATB3ZWlnaHRfbGltaXQxBQEsV2VpZ2h0TGltaXQAEwA0UmVmdW5kU3VycGx1cwAUADxTZXRFcnJvckhhbmRsZXIEAOkEAUBYY208UnVudGltZUNhbGw+ABUALFNldEFwcGVuZGl4BADpBAFAWGNtPFJ1bnRpbWVDYWxsPgAWAChDbGVhckVycm9yABcAKENsYWltQXNzZXQIARhhc3NldHP1BAEsTXVsdGlBc3NldHMAARh0aWNrZXTJBAE0TXVsdGlMb2NhdGlvbgAYABBUcmFwBAAsAQx1NjQAGQBAU3Vic2NyaWJlVmVyc2lvbggBIHF1ZXJ5X2lkLAEcUXVlcnlJZAABTG1heF9yZXNwb25zZV93ZWlnaHQsAQx1NjQAGgBIVW5zdWJzY3JpYmVWZXJzaW9uABsAAPUEEAx4Y20IdjIobXVsdGlhc3NldCxNdWx0aUFzc2V0cwAABAD5BAE8VmVjPE11bHRpQXNzZXQ+AAD5BAAAAv0EAP0EEAx4Y20IdjIobXVsdGlhc3NldChNdWx0aUFzc2V0AAAIAQhpZAEFARxBc3NldElkAAEMZnVuBQUBLEZ1bmdpYmlsaXR5AAABBRAMeGNtCHYyKG11bHRpYXNzZXQcQXNzZXRJZAABCCBDb25jcmV0ZQQAyQQBNE11bHRpTG9jYXRpb24AAAAgQWJzdHJhY3QEADgBHFZlYzx1OD4AAQAABQUQDHhjbQh2MihtdWx0aWFzc2V0LEZ1bmdpYmlsaXR5AAEIIEZ1bmdpYmxlBAAtAQEQdTEyOAAAACxOb25GdW5naWJsZQQACQUBNEFzc2V0SW5zdGFuY2UAAQAACQUQDHhjbQh2MihtdWx0aWFzc2V0NEFzc2V0SW5zdGFuY2UAARwkVW5kZWZpbmVkAAAAFEluZGV4BAAtAQEQdTEyOAABABhBcnJheTQEAEgBHFt1ODsgNF0AAgAYQXJyYXk4BAD9AQEcW3U4OyA4XQADABxBcnJheTE2BAAdAgEgW3U4OyAxNl0ABAAcQXJyYXkzMgQABAEgW3U4OyAzMl0ABQAQQmxvYgQAOAEcVmVjPHU4PgAGAAANBQwMeGNtCHYyIFJlc3BvbnNlAAEQEE51bGwAAAAYQXNzZXRzBAD1BAEsTXVsdGlBc3NldHMAAQA8RXhlY3V0aW9uUmVzdWx0BAARBQFQT3B0aW9uPCh1MzIsIEVycm9yKT4AAgAcVmVyc2lvbgQAEAE4c3VwZXI6OlZlcnNpb24AAwAAEQUEGE9wdGlvbgQEVAEVBQEIEE5vbmUAAAAQU29tZQQAFQUAAAEAABUFAAAECBAZBQAZBRAMeGNtCHYyGHRyYWl0cxRFcnJvcgABaCBPdmVyZmxvdwAAADRVbmltcGxlbWVudGVkAAEAYFVudHJ1c3RlZFJlc2VydmVMb2NhdGlvbgACAGRVbnRydXN0ZWRUZWxlcG9ydExvY2F0aW9uAAMARE11bHRpTG9jYXRpb25GdWxsAAQAaE11bHRpTG9jYXRpb25Ob3RJbnZlcnRpYmxlAAUAJEJhZE9yaWdpbgAGADxJbnZhbGlkTG9jYXRpb24ABwA0QXNzZXROb3RGb3VuZAAIAFRGYWlsZWRUb1RyYW5zYWN0QXNzZXQACQA8Tm90V2l0aGRyYXdhYmxlAAoASExvY2F0aW9uQ2Fubm90SG9sZAALAFRFeGNlZWRzTWF4TWVzc2FnZVNpemUADABYRGVzdGluYXRpb25VbnN1cHBvcnRlZAANACRUcmFuc3BvcnQADgAoVW5yb3V0YWJsZQAPADBVbmtub3duQ2xhaW0AEAA4RmFpbGVkVG9EZWNvZGUAEQBATWF4V2VpZ2h0SW52YWxpZAASADhOb3RIb2xkaW5nRmVlcwATADBUb29FeHBlbnNpdmUAFAAQVHJhcAQAMAEMdTY0ABUATFVuaGFuZGxlZFhjbVZlcnNpb24AFgBIV2VpZ2h0TGltaXRSZWFjaGVkBAAwARhXZWlnaHQAFwAcQmFycmllcgAYAExXZWlnaHROb3RDb21wdXRhYmxlABkAAB0FDAx4Y20IdjIoT3JpZ2luS2luZAABEBhOYXRpdmUAAABAU292ZXJlaWduQWNjb3VudAABACRTdXBlcnVzZXIAAgAMWGNtAAMAACEFDAx4Y204ZG91YmxlX2VuY29kZWQ0RG91YmxlRW5jb2RlZAQEVAAABAEcZW5jb2RlZDgBHFZlYzx1OD4AACUFEAx4Y20IdjIobXVsdGlhc3NldEBNdWx0aUFzc2V0RmlsdGVyAAEIIERlZmluaXRlBAD1BAEsTXVsdGlBc3NldHMAAAAQV2lsZAQAKQUBOFdpbGRNdWx0aUFzc2V0AAEAACkFEAx4Y20IdjIobXVsdGlhc3NldDhXaWxkTXVsdGlBc3NldAABCAxBbGwAAAAUQWxsT2YIAQhpZAEFARxBc3NldElkAAEMZnVuLQUBPFdpbGRGdW5naWJpbGl0eQABAAAtBRAMeGNtCHYyKG11bHRpYXNzZXQ8V2lsZEZ1bmdpYmlsaXR5AAEIIEZ1bmdpYmxlAAAALE5vbkZ1bmdpYmxlAAEAADEFDAx4Y20IdjIsV2VpZ2h0TGltaXQAAQgkVW5saW1pdGVkAAAAHExpbWl0ZWQEACwBDHU2NAABAAA1BQwMeGNtCHYzDFhjbQQQQ2FsbAAABAA5BQFYVmVjPEluc3RydWN0aW9uPENhbGw+PgAAOQUAAAI9BQA9BQwMeGNtCHYzLEluc3RydWN0aW9uBBBDYWxsAAHANFdpdGhkcmF3QXNzZXQEAEEFASxNdWx0aUFzc2V0cwAAAFRSZXNlcnZlQXNzZXREZXBvc2l0ZWQEAEEFASxNdWx0aUFzc2V0cwABAFhSZWNlaXZlVGVsZXBvcnRlZEFzc2V0BABBBQEsTXVsdGlBc3NldHMAAgA0UXVlcnlSZXNwb25zZRABIHF1ZXJ5X2lkLAEcUXVlcnlJZAABIHJlc3BvbnNlWQUBIFJlc3BvbnNlAAEobWF4X3dlaWdodCgBGFdlaWdodAABHHF1ZXJpZXKBBQFUT3B0aW9uPE11bHRpTG9jYXRpb24+AAMANFRyYW5zZmVyQXNzZXQIARhhc3NldHNBBQEsTXVsdGlBc3NldHMAASxiZW5lZmljaWFyefUCATRNdWx0aUxvY2F0aW9uAAQAUFRyYW5zZmVyUmVzZXJ2ZUFzc2V0DAEYYXNzZXRzQQUBLE11bHRpQXNzZXRzAAEQZGVzdPUCATRNdWx0aUxvY2F0aW9uAAEMeGNtNQUBHFhjbTwoKT4ABQAgVHJhbnNhY3QMASxvcmlnaW5fa2luZIUFAShPcmlnaW5LaW5kAAFYcmVxdWlyZV93ZWlnaHRfYXRfbW9zdCgBGFdlaWdodAABEGNhbGwhBQFMRG91YmxlRW5jb2RlZDxDYWxsPgAGAGRIcm1wTmV3Q2hhbm5lbE9wZW5SZXF1ZXN0DAEYc2VuZGVyVQEBDHUzMgABQG1heF9tZXNzYWdlX3NpemVVAQEMdTMyAAEwbWF4X2NhcGFjaXR5VQEBDHUzMgAHAExIcm1wQ2hhbm5lbEFjY2VwdGVkBAEkcmVjaXBpZW50VQEBDHUzMgAIAEhIcm1wQ2hhbm5lbENsb3NpbmcMASRpbml0aWF0b3JVAQEMdTMyAAEYc2VuZGVyVQEBDHUzMgABJHJlY2lwaWVudFUBAQx1MzIACQAsQ2xlYXJPcmlnaW4ACgA0RGVzY2VuZE9yaWdpbgQA+QIBVEludGVyaW9yTXVsdGlMb2NhdGlvbgALACxSZXBvcnRFcnJvcgQAiQUBRFF1ZXJ5UmVzcG9uc2VJbmZvAAwAMERlcG9zaXRBc3NldAgBGGFzc2V0c40FAUBNdWx0aUFzc2V0RmlsdGVyAAEsYmVuZWZpY2lhcnn1AgE0TXVsdGlMb2NhdGlvbgANAExEZXBvc2l0UmVzZXJ2ZUFzc2V0DAEYYXNzZXRzjQUBQE11bHRpQXNzZXRGaWx0ZXIAARBkZXN09QIBNE11bHRpTG9jYXRpb24AAQx4Y201BQEcWGNtPCgpPgAOADRFeGNoYW5nZUFzc2V0DAEQZ2l2ZY0FAUBNdWx0aUFzc2V0RmlsdGVyAAEQd2FudEEFASxNdWx0aUFzc2V0cwABHG1heGltYWwgARBib29sAA8AXEluaXRpYXRlUmVzZXJ2ZVdpdGhkcmF3DAEYYXNzZXRzjQUBQE11bHRpQXNzZXRGaWx0ZXIAARxyZXNlcnZl9QIBNE11bHRpTG9jYXRpb24AAQx4Y201BQEcWGNtPCgpPgAQAEBJbml0aWF0ZVRlbGVwb3J0DAEYYXNzZXRzjQUBQE11bHRpQXNzZXRGaWx0ZXIAARBkZXN09QIBNE11bHRpTG9jYXRpb24AAQx4Y201BQEcWGNtPCgpPgARADRSZXBvcnRIb2xkaW5nCAE0cmVzcG9uc2VfaW5mb4kFAURRdWVyeVJlc3BvbnNlSW5mbwABGGFzc2V0c40FAUBNdWx0aUFzc2V0RmlsdGVyABIAMEJ1eUV4ZWN1dGlvbggBEGZlZXNJBQEoTXVsdGlBc3NldAABMHdlaWdodF9saW1pdJkFASxXZWlnaHRMaW1pdAATADRSZWZ1bmRTdXJwbHVzABQAPFNldEVycm9ySGFuZGxlcgQANQUBJFhjbTxDYWxsPgAVACxTZXRBcHBlbmRpeAQANQUBJFhjbTxDYWxsPgAWAChDbGVhckVycm9yABcAKENsYWltQXNzZXQIARhhc3NldHNBBQEsTXVsdGlBc3NldHMAARh0aWNrZXT1AgE0TXVsdGlMb2NhdGlvbgAYABBUcmFwBAAsAQx1NjQAGQBAU3Vic2NyaWJlVmVyc2lvbggBIHF1ZXJ5X2lkLAEcUXVlcnlJZAABTG1heF9yZXNwb25zZV93ZWlnaHQoARhXZWlnaHQAGgBIVW5zdWJzY3JpYmVWZXJzaW9uABsAJEJ1cm5Bc3NldAQAQQUBLE11bHRpQXNzZXRzABwALEV4cGVjdEFzc2V0BABBBQEsTXVsdGlBc3NldHMAHQAwRXhwZWN0T3JpZ2luBACBBQFUT3B0aW9uPE11bHRpTG9jYXRpb24+AB4ALEV4cGVjdEVycm9yBABdBQFQT3B0aW9uPCh1MzIsIEVycm9yKT4AHwBQRXhwZWN0VHJhbnNhY3RTdGF0dXMEAHkFAThNYXliZUVycm9yQ29kZQAgACxRdWVyeVBhbGxldAgBLG1vZHVsZV9uYW1lOAEcVmVjPHU4PgABNHJlc3BvbnNlX2luZm+JBQFEUXVlcnlSZXNwb25zZUluZm8AIQAwRXhwZWN0UGFsbGV0FAEUaW5kZXhVAQEMdTMyAAEQbmFtZTgBHFZlYzx1OD4AASxtb2R1bGVfbmFtZTgBHFZlYzx1OD4AASxjcmF0ZV9tYWpvclUBAQx1MzIAATxtaW5fY3JhdGVfbWlub3JVAQEMdTMyACIAUFJlcG9ydFRyYW5zYWN0U3RhdHVzBACJBQFEUXVlcnlSZXNwb25zZUluZm8AIwBMQ2xlYXJUcmFuc2FjdFN0YXR1cwAkADxVbml2ZXJzYWxPcmlnaW4EAP0CASBKdW5jdGlvbgAlADRFeHBvcnRNZXNzYWdlDAEcbmV0d29yawUDASROZXR3b3JrSWQAASxkZXN0aW5hdGlvbvkCAVRJbnRlcmlvck11bHRpTG9jYXRpb24AAQx4Y201BQEcWGNtPCgpPgAmACRMb2NrQXNzZXQIARRhc3NldEkFAShNdWx0aUFzc2V0AAEgdW5sb2NrZXL1AgE0TXVsdGlMb2NhdGlvbgAnACxVbmxvY2tBc3NldAgBFGFzc2V0SQUBKE11bHRpQXNzZXQAARh0YXJnZXT1AgE0TXVsdGlMb2NhdGlvbgAoADhOb3RlVW5sb2NrYWJsZQgBFGFzc2V0SQUBKE11bHRpQXNzZXQAARRvd25lcvUCATRNdWx0aUxvY2F0aW9uACkANFJlcXVlc3RVbmxvY2sIARRhc3NldEkFAShNdWx0aUFzc2V0AAEYbG9ja2Vy9QIBNE11bHRpTG9jYXRpb24AKgAsU2V0RmVlc01vZGUEATBqaXRfd2l0aGRyYXcgARBib29sACsAIFNldFRvcGljBAAEASBbdTg7IDMyXQAsAChDbGVhclRvcGljAC0ALEFsaWFzT3JpZ2luBAD1AgE0TXVsdGlMb2NhdGlvbgAuADxVbnBhaWRFeGVjdXRpb24IATB3ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAATBjaGVja19vcmlnaW6BBQFUT3B0aW9uPE11bHRpTG9jYXRpb24+AC8AAEEFEAx4Y20IdjMobXVsdGlhc3NldCxNdWx0aUFzc2V0cwAABABFBQE8VmVjPE11bHRpQXNzZXQ+AABFBQAAAkkFAEkFEAx4Y20IdjMobXVsdGlhc3NldChNdWx0aUFzc2V0AAAIAQhpZE0FARxBc3NldElkAAEMZnVuUQUBLEZ1bmdpYmlsaXR5AABNBRAMeGNtCHYzKG11bHRpYXNzZXQcQXNzZXRJZAABCCBDb25jcmV0ZQQA9QIBNE11bHRpTG9jYXRpb24AAAAgQWJzdHJhY3QEAAQBIFt1ODsgMzJdAAEAAFEFEAx4Y20IdjMobXVsdGlhc3NldCxGdW5naWJpbGl0eQABCCBGdW5naWJsZQQALQEBEHUxMjgAAAAsTm9uRnVuZ2libGUEAFUFATRBc3NldEluc3RhbmNlAAEAAFUFEAx4Y20IdjMobXVsdGlhc3NldDRBc3NldEluc3RhbmNlAAEYJFVuZGVmaW5lZAAAABRJbmRleAQALQEBEHUxMjgAAQAYQXJyYXk0BABIARxbdTg7IDRdAAIAGEFycmF5OAQA/QEBHFt1ODsgOF0AAwAcQXJyYXkxNgQAHQIBIFt1ODsgMTZdAAQAHEFycmF5MzIEAAQBIFt1ODsgMzJdAAUAAFkFDAx4Y20IdjMgUmVzcG9uc2UAARgQTnVsbAAAABhBc3NldHMEAEEFASxNdWx0aUFzc2V0cwABADxFeGVjdXRpb25SZXN1bHQEAF0FAVBPcHRpb248KHUzMiwgRXJyb3IpPgACABxWZXJzaW9uBAAQAThzdXBlcjo6VmVyc2lvbgADACxQYWxsZXRzSW5mbwQAaQUBmEJvdW5kZWRWZWM8UGFsbGV0SW5mbywgTWF4UGFsbGV0c0luZm8+AAQAOERpc3BhdGNoUmVzdWx0BAB5BQE4TWF5YmVFcnJvckNvZGUABQAAXQUEGE9wdGlvbgQEVAFhBQEIEE5vbmUAAAAQU29tZQQAYQUAAAEAAGEFAAAECBBlBQBlBRAMeGNtCHYzGHRyYWl0cxRFcnJvcgABoCBPdmVyZmxvdwAAADRVbmltcGxlbWVudGVkAAEAYFVudHJ1c3RlZFJlc2VydmVMb2NhdGlvbgACAGRVbnRydXN0ZWRUZWxlcG9ydExvY2F0aW9uAAMAMExvY2F0aW9uRnVsbAAEAFRMb2NhdGlvbk5vdEludmVydGlibGUABQAkQmFkT3JpZ2luAAYAPEludmFsaWRMb2NhdGlvbgAHADRBc3NldE5vdEZvdW5kAAgAVEZhaWxlZFRvVHJhbnNhY3RBc3NldAAJADxOb3RXaXRoZHJhd2FibGUACgBITG9jYXRpb25DYW5ub3RIb2xkAAsAVEV4Y2VlZHNNYXhNZXNzYWdlU2l6ZQAMAFhEZXN0aW5hdGlvblVuc3VwcG9ydGVkAA0AJFRyYW5zcG9ydAAOAChVbnJvdXRhYmxlAA8AMFVua25vd25DbGFpbQAQADhGYWlsZWRUb0RlY29kZQARAEBNYXhXZWlnaHRJbnZhbGlkABIAOE5vdEhvbGRpbmdGZWVzABMAMFRvb0V4cGVuc2l2ZQAUABBUcmFwBAAwAQx1NjQAFQBARXhwZWN0YXRpb25GYWxzZQAWADhQYWxsZXROb3RGb3VuZAAXADBOYW1lTWlzbWF0Y2gAGABMVmVyc2lvbkluY29tcGF0aWJsZQAZAFBIb2xkaW5nV291bGRPdmVyZmxvdwAaACxFeHBvcnRFcnJvcgAbADhSZWFuY2hvckZhaWxlZAAcABhOb0RlYWwAHQAoRmVlc05vdE1ldAAeACRMb2NrRXJyb3IAHwAwTm9QZXJtaXNzaW9uACAAKFVuYW5jaG9yZWQAIQA4Tm90RGVwb3NpdGFibGUAIgBMVW5oYW5kbGVkWGNtVmVyc2lvbgAjAEhXZWlnaHRMaW1pdFJlYWNoZWQEACgBGFdlaWdodAAkABxCYXJyaWVyACUATFdlaWdodE5vdENvbXB1dGFibGUAJgBERXhjZWVkc1N0YWNrTGltaXQAJwAAaQUMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAFtBQRTAAAEAHUFARhWZWM8VD4AAG0FDAx4Y20IdjMoUGFsbGV0SW5mbwAAGAEUaW5kZXhVAQEMdTMyAAEQbmFtZXEFAYBCb3VuZGVkVmVjPHU4LCBNYXhQYWxsZXROYW1lTGVuPgABLG1vZHVsZV9uYW1lcQUBgEJvdW5kZWRWZWM8dTgsIE1heFBhbGxldE5hbWVMZW4+AAEUbWFqb3JVAQEMdTMyAAEUbWlub3JVAQEMdTMyAAEUcGF0Y2hVAQEMdTMyAABxBQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQgEUwAABAA4ARhWZWM8VD4AAHUFAAACbQUAeQUMDHhjbQh2MzhNYXliZUVycm9yQ29kZQABDBxTdWNjZXNzAAAAFEVycm9yBAB9BQGMQm91bmRlZFZlYzx1OCwgTWF4RGlzcGF0Y2hFcnJvckxlbj4AAQA4VHJ1bmNhdGVkRXJyb3IEAH0FAYxCb3VuZGVkVmVjPHU4LCBNYXhEaXNwYXRjaEVycm9yTGVuPgACAAB9BQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQgEUwAABAA4ARhWZWM8VD4AAIEFBBhPcHRpb24EBFQB9QIBCBBOb25lAAAAEFNvbWUEAPUCAAABAACFBQwMeGNtCHYzKE9yaWdpbktpbmQAARAYTmF0aXZlAAAAQFNvdmVyZWlnbkFjY291bnQAAQAkU3VwZXJ1c2VyAAIADFhjbQADAACJBQwMeGNtCHYzRFF1ZXJ5UmVzcG9uc2VJbmZvAAAMASxkZXN0aW5hdGlvbvUCATRNdWx0aUxvY2F0aW9uAAEgcXVlcnlfaWQsARxRdWVyeUlkAAEobWF4X3dlaWdodCgBGFdlaWdodAAAjQUQDHhjbQh2MyhtdWx0aWFzc2V0QE11bHRpQXNzZXRGaWx0ZXIAAQggRGVmaW5pdGUEAEEFASxNdWx0aUFzc2V0cwAAABBXaWxkBACRBQE4V2lsZE11bHRpQXNzZXQAAQAAkQUQDHhjbQh2MyhtdWx0aWFzc2V0OFdpbGRNdWx0aUFzc2V0AAEQDEFsbAAAABRBbGxPZggBCGlkTQUBHEFzc2V0SWQAAQxmdW6VBQE8V2lsZEZ1bmdpYmlsaXR5AAEAKEFsbENvdW50ZWQEAFUBAQx1MzIAAgAwQWxsT2ZDb3VudGVkDAEIaWRNBQEcQXNzZXRJZAABDGZ1bpUFATxXaWxkRnVuZ2liaWxpdHkAARRjb3VudFUBAQx1MzIAAwAAlQUQDHhjbQh2MyhtdWx0aWFzc2V0PFdpbGRGdW5naWJpbGl0eQABCCBGdW5naWJsZQAAACxOb25GdW5naWJsZQABAACZBQwMeGNtCHYzLFdlaWdodExpbWl0AAEIJFVubGltaXRlZAAAABxMaW1pdGVkBAAoARhXZWlnaHQAAQAAnQUMLHN0YWdpbmdfeGNtCHY0DFhjbQQQQ2FsbAAABAChBQFYVmVjPEluc3RydWN0aW9uPENhbGw+PgAAoQUAAAKlBQClBQwsc3RhZ2luZ194Y20IdjQsSW5zdHJ1Y3Rpb24EEENhbGwAAcA0V2l0aGRyYXdBc3NldAQAqQUBGEFzc2V0cwAAAFRSZXNlcnZlQXNzZXREZXBvc2l0ZWQEAKkFARhBc3NldHMAAQBYUmVjZWl2ZVRlbGVwb3J0ZWRBc3NldAQAqQUBGEFzc2V0cwACADRRdWVyeVJlc3BvbnNlEAEgcXVlcnlfaWQsARxRdWVyeUlkAAEgcmVzcG9uc2XBBQEgUmVzcG9uc2UAAShtYXhfd2VpZ2h0KAEYV2VpZ2h0AAEccXVlcmllctUFAUBPcHRpb248TG9jYXRpb24+AAMANFRyYW5zZmVyQXNzZXQIARhhc3NldHOpBQEYQXNzZXRzAAEsYmVuZWZpY2lhcnl9AQEgTG9jYXRpb24ABABQVHJhbnNmZXJSZXNlcnZlQXNzZXQMARhhc3NldHOpBQEYQXNzZXRzAAEQZGVzdH0BASBMb2NhdGlvbgABDHhjbZ0FARxYY208KCk+AAUAIFRyYW5zYWN0DAEsb3JpZ2luX2tpbmSFBQEoT3JpZ2luS2luZAABWHJlcXVpcmVfd2VpZ2h0X2F0X21vc3QoARhXZWlnaHQAARBjYWxsIQUBTERvdWJsZUVuY29kZWQ8Q2FsbD4ABgBkSHJtcE5ld0NoYW5uZWxPcGVuUmVxdWVzdAwBGHNlbmRlclUBAQx1MzIAAUBtYXhfbWVzc2FnZV9zaXplVQEBDHUzMgABMG1heF9jYXBhY2l0eVUBAQx1MzIABwBMSHJtcENoYW5uZWxBY2NlcHRlZAQBJHJlY2lwaWVudFUBAQx1MzIACABISHJtcENoYW5uZWxDbG9zaW5nDAEkaW5pdGlhdG9yVQEBDHUzMgABGHNlbmRlclUBAQx1MzIAASRyZWNpcGllbnRVAQEMdTMyAAkALENsZWFyT3JpZ2luAAoANERlc2NlbmRPcmlnaW4EAIEBAUBJbnRlcmlvckxvY2F0aW9uAAsALFJlcG9ydEVycm9yBADZBQFEUXVlcnlSZXNwb25zZUluZm8ADAAwRGVwb3NpdEFzc2V0CAEYYXNzZXRz3QUBLEFzc2V0RmlsdGVyAAEsYmVuZWZpY2lhcnl9AQEgTG9jYXRpb24ADQBMRGVwb3NpdFJlc2VydmVBc3NldAwBGGFzc2V0c90FASxBc3NldEZpbHRlcgABEGRlc3R9AQEgTG9jYXRpb24AAQx4Y22dBQEcWGNtPCgpPgAOADRFeGNoYW5nZUFzc2V0DAEQZ2l2Zd0FASxBc3NldEZpbHRlcgABEHdhbnSpBQEYQXNzZXRzAAEcbWF4aW1hbCABEGJvb2wADwBcSW5pdGlhdGVSZXNlcnZlV2l0aGRyYXcMARhhc3NldHPdBQEsQXNzZXRGaWx0ZXIAARxyZXNlcnZlfQEBIExvY2F0aW9uAAEMeGNtnQUBHFhjbTwoKT4AEABASW5pdGlhdGVUZWxlcG9ydAwBGGFzc2V0c90FASxBc3NldEZpbHRlcgABEGRlc3R9AQEgTG9jYXRpb24AAQx4Y22dBQEcWGNtPCgpPgARADRSZXBvcnRIb2xkaW5nCAE0cmVzcG9uc2VfaW5mb9kFAURRdWVyeVJlc3BvbnNlSW5mbwABGGFzc2V0c90FASxBc3NldEZpbHRlcgASADBCdXlFeGVjdXRpb24IARBmZWVzsQUBFEFzc2V0AAEwd2VpZ2h0X2xpbWl0mQUBLFdlaWdodExpbWl0ABMANFJlZnVuZFN1cnBsdXMAFAA8U2V0RXJyb3JIYW5kbGVyBACdBQEkWGNtPENhbGw+ABUALFNldEFwcGVuZGl4BACdBQEkWGNtPENhbGw+ABYAKENsZWFyRXJyb3IAFwAoQ2xhaW1Bc3NldAgBGGFzc2V0c6kFARhBc3NldHMAARh0aWNrZXR9AQEgTG9jYXRpb24AGAAQVHJhcAQALAEMdTY0ABkAQFN1YnNjcmliZVZlcnNpb24IASBxdWVyeV9pZCwBHFF1ZXJ5SWQAAUxtYXhfcmVzcG9uc2Vfd2VpZ2h0KAEYV2VpZ2h0ABoASFVuc3Vic2NyaWJlVmVyc2lvbgAbACRCdXJuQXNzZXQEAKkFARhBc3NldHMAHAAsRXhwZWN0QXNzZXQEAKkFARhBc3NldHMAHQAwRXhwZWN0T3JpZ2luBADVBQFAT3B0aW9uPExvY2F0aW9uPgAeACxFeHBlY3RFcnJvcgQAXQUBUE9wdGlvbjwodTMyLCBFcnJvcik+AB8AUEV4cGVjdFRyYW5zYWN0U3RhdHVzBAB5BQE4TWF5YmVFcnJvckNvZGUAIAAsUXVlcnlQYWxsZXQIASxtb2R1bGVfbmFtZTgBHFZlYzx1OD4AATRyZXNwb25zZV9pbmZv2QUBRFF1ZXJ5UmVzcG9uc2VJbmZvACEAMEV4cGVjdFBhbGxldBQBFGluZGV4VQEBDHUzMgABEG5hbWU4ARxWZWM8dTg+AAEsbW9kdWxlX25hbWU4ARxWZWM8dTg+AAEsY3JhdGVfbWFqb3JVAQEMdTMyAAE8bWluX2NyYXRlX21pbm9yVQEBDHUzMgAiAFBSZXBvcnRUcmFuc2FjdFN0YXR1cwQA2QUBRFF1ZXJ5UmVzcG9uc2VJbmZvACMATENsZWFyVHJhbnNhY3RTdGF0dXMAJAA8VW5pdmVyc2FsT3JpZ2luBACJAQEgSnVuY3Rpb24AJQA0RXhwb3J0TWVzc2FnZQwBHG5ldHdvcmuRAQEkTmV0d29ya0lkAAEsZGVzdGluYXRpb26BAQFASW50ZXJpb3JMb2NhdGlvbgABDHhjbZ0FARxYY208KCk+ACYAJExvY2tBc3NldAgBFGFzc2V0sQUBFEFzc2V0AAEgdW5sb2NrZXJ9AQEgTG9jYXRpb24AJwAsVW5sb2NrQXNzZXQIARRhc3NldLEFARRBc3NldAABGHRhcmdldH0BASBMb2NhdGlvbgAoADhOb3RlVW5sb2NrYWJsZQgBFGFzc2V0sQUBFEFzc2V0AAEUb3duZXJ9AQEgTG9jYXRpb24AKQA0UmVxdWVzdFVubG9jawgBFGFzc2V0sQUBFEFzc2V0AAEYbG9ja2VyfQEBIExvY2F0aW9uACoALFNldEZlZXNNb2RlBAEwaml0X3dpdGhkcmF3IAEQYm9vbAArACBTZXRUb3BpYwQABAEgW3U4OyAzMl0ALAAoQ2xlYXJUb3BpYwAtACxBbGlhc09yaWdpbgQAfQEBIExvY2F0aW9uAC4APFVucGFpZEV4ZWN1dGlvbggBMHdlaWdodF9saW1pdJkFASxXZWlnaHRMaW1pdAABMGNoZWNrX29yaWdpbtUFAUBPcHRpb248TG9jYXRpb24+AC8AAKkFECxzdGFnaW5nX3hjbQh2NBRhc3NldBhBc3NldHMAAAQArQUBKFZlYzxBc3NldD4AAK0FAAACsQUAsQUQLHN0YWdpbmdfeGNtCHY0FGFzc2V0FEFzc2V0AAAIAQhpZLUFARxBc3NldElkAAEMZnVuuQUBLEZ1bmdpYmlsaXR5AAC1BRAsc3RhZ2luZ194Y20IdjQUYXNzZXQcQXNzZXRJZAAABAB9AQEgTG9jYXRpb24AALkFECxzdGFnaW5nX3hjbQh2NBRhc3NldCxGdW5naWJpbGl0eQABCCBGdW5naWJsZQQALQEBEHUxMjgAAAAsTm9uRnVuZ2libGUEAL0FATRBc3NldEluc3RhbmNlAAEAAL0FECxzdGFnaW5nX3hjbQh2NBRhc3NldDRBc3NldEluc3RhbmNlAAEYJFVuZGVmaW5lZAAAABRJbmRleAQALQEBEHUxMjgAAQAYQXJyYXk0BABIARxbdTg7IDRdAAIAGEFycmF5OAQA/QEBHFt1ODsgOF0AAwAcQXJyYXkxNgQAHQIBIFt1ODsgMTZdAAQAHEFycmF5MzIEAAQBIFt1ODsgMzJdAAUAAMEFDCxzdGFnaW5nX3hjbQh2NCBSZXNwb25zZQABGBBOdWxsAAAAGEFzc2V0cwQAqQUBGEFzc2V0cwABADxFeGVjdXRpb25SZXN1bHQEAF0FAVBPcHRpb248KHUzMiwgRXJyb3IpPgACABxWZXJzaW9uBAAQAThzdXBlcjo6VmVyc2lvbgADACxQYWxsZXRzSW5mbwQAxQUBmEJvdW5kZWRWZWM8UGFsbGV0SW5mbywgTWF4UGFsbGV0c0luZm8+AAQAOERpc3BhdGNoUmVzdWx0BAB5BQE4TWF5YmVFcnJvckNvZGUABQAAxQUMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAHJBQRTAAAEANEFARhWZWM8VD4AAMkFDCxzdGFnaW5nX3hjbQh2NChQYWxsZXRJbmZvAAAYARRpbmRleFUBAQx1MzIAARBuYW1lzQUBgEJvdW5kZWRWZWM8dTgsIE1heFBhbGxldE5hbWVMZW4+AAEsbW9kdWxlX25hbWXNBQGAQm91bmRlZFZlYzx1OCwgTWF4UGFsbGV0TmFtZUxlbj4AARRtYWpvclUBAQx1MzIAARRtaW5vclUBAQx1MzIAARRwYXRjaFUBAQx1MzIAAM0FDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAA0QUAAALJBQDVBQQYT3B0aW9uBARUAX0BAQgQTm9uZQAAABBTb21lBAB9AQAAAQAA2QUMLHN0YWdpbmdfeGNtCHY0RFF1ZXJ5UmVzcG9uc2VJbmZvAAAMASxkZXN0aW5hdGlvbn0BASBMb2NhdGlvbgABIHF1ZXJ5X2lkLAEcUXVlcnlJZAABKG1heF93ZWlnaHQoARhXZWlnaHQAAN0FECxzdGFnaW5nX3hjbQh2NBRhc3NldCxBc3NldEZpbHRlcgABCCBEZWZpbml0ZQQAqQUBGEFzc2V0cwAAABBXaWxkBADhBQEkV2lsZEFzc2V0AAEAAOEFECxzdGFnaW5nX3hjbQh2NBRhc3NldCRXaWxkQXNzZXQAARAMQWxsAAAAFEFsbE9mCAEIaWS1BQEcQXNzZXRJZAABDGZ1buUFATxXaWxkRnVuZ2liaWxpdHkAAQAoQWxsQ291bnRlZAQAVQEBDHUzMgACADBBbGxPZkNvdW50ZWQMAQhpZLUFARxBc3NldElkAAEMZnVu5QUBPFdpbGRGdW5naWJpbGl0eQABFGNvdW50VQEBDHUzMgADAADlBRAsc3RhZ2luZ194Y20IdjQUYXNzZXQ8V2lsZEZ1bmdpYmlsaXR5AAEIIEZ1bmdpYmxlAAAALE5vbkZ1bmdpYmxlAAEAAOkFCAx4Y208VmVyc2lvbmVkQXNzZXRzAAEMCFYyBAD1BAE8djI6Ok11bHRpQXNzZXRzAAEACFYzBABBBQE8djM6Ok11bHRpQXNzZXRzAAMACFY0BACpBQEodjQ6OkFzc2V0cwAEAADtBQgMeGNtMFZlcnNpb25lZFhjbQQsUnVudGltZUNhbGwAAQwIVjIEAPEFAVB2Mjo6WGNtPFJ1bnRpbWVDYWxsPgACAAhWMwQAAQYBUHYzOjpYY208UnVudGltZUNhbGw+AAMACFY0BAANBgFQdjQ6OlhjbTxSdW50aW1lQ2FsbD4ABAAA8QUMDHhjbQh2MgxYY20ELFJ1bnRpbWVDYWxsAAAEAPUFAXRWZWM8SW5zdHJ1Y3Rpb248UnVudGltZUNhbGw+PgAA9QUAAAL5BQD5BQwMeGNtCHYyLEluc3RydWN0aW9uBCxSdW50aW1lQ2FsbAABcDRXaXRoZHJhd0Fzc2V0BAD1BAEsTXVsdGlBc3NldHMAAABUUmVzZXJ2ZUFzc2V0RGVwb3NpdGVkBAD1BAEsTXVsdGlBc3NldHMAAQBYUmVjZWl2ZVRlbGVwb3J0ZWRBc3NldAQA9QQBLE11bHRpQXNzZXRzAAIANFF1ZXJ5UmVzcG9uc2UMASBxdWVyeV9pZCwBHFF1ZXJ5SWQAASByZXNwb25zZQ0FASBSZXNwb25zZQABKG1heF93ZWlnaHQsAQx1NjQAAwA0VHJhbnNmZXJBc3NldAgBGGFzc2V0c/UEASxNdWx0aUFzc2V0cwABLGJlbmVmaWNpYXJ5yQQBNE11bHRpTG9jYXRpb24ABABQVHJhbnNmZXJSZXNlcnZlQXNzZXQMARhhc3NldHP1BAEsTXVsdGlBc3NldHMAARBkZXN0yQQBNE11bHRpTG9jYXRpb24AAQx4Y23pBAEcWGNtPCgpPgAFACBUcmFuc2FjdAwBLG9yaWdpbl90eXBlHQUBKE9yaWdpbktpbmQAAVhyZXF1aXJlX3dlaWdodF9hdF9tb3N0LAEMdTY0AAEQY2FsbP0FAWhEb3VibGVFbmNvZGVkPFJ1bnRpbWVDYWxsPgAGAGRIcm1wTmV3Q2hhbm5lbE9wZW5SZXF1ZXN0DAEYc2VuZGVyVQEBDHUzMgABQG1heF9tZXNzYWdlX3NpemVVAQEMdTMyAAEwbWF4X2NhcGFjaXR5VQEBDHUzMgAHAExIcm1wQ2hhbm5lbEFjY2VwdGVkBAEkcmVjaXBpZW50VQEBDHUzMgAIAEhIcm1wQ2hhbm5lbENsb3NpbmcMASRpbml0aWF0b3JVAQEMdTMyAAEYc2VuZGVyVQEBDHUzMgABJHJlY2lwaWVudFUBAQx1MzIACQAsQ2xlYXJPcmlnaW4ACgA0RGVzY2VuZE9yaWdpbgQAzQQBVEludGVyaW9yTXVsdGlMb2NhdGlvbgALACxSZXBvcnRFcnJvcgwBIHF1ZXJ5X2lkLAEcUXVlcnlJZAABEGRlc3TJBAE0TXVsdGlMb2NhdGlvbgABTG1heF9yZXNwb25zZV93ZWlnaHQsAQx1NjQADAAwRGVwb3NpdEFzc2V0DAEYYXNzZXRzJQUBQE11bHRpQXNzZXRGaWx0ZXIAAShtYXhfYXNzZXRzVQEBDHUzMgABLGJlbmVmaWNpYXJ5yQQBNE11bHRpTG9jYXRpb24ADQBMRGVwb3NpdFJlc2VydmVBc3NldBABGGFzc2V0cyUFAUBNdWx0aUFzc2V0RmlsdGVyAAEobWF4X2Fzc2V0c1UBAQx1MzIAARBkZXN0yQQBNE11bHRpTG9jYXRpb24AAQx4Y23pBAEcWGNtPCgpPgAOADRFeGNoYW5nZUFzc2V0CAEQZ2l2ZSUFAUBNdWx0aUFzc2V0RmlsdGVyAAEccmVjZWl2ZfUEASxNdWx0aUFzc2V0cwAPAFxJbml0aWF0ZVJlc2VydmVXaXRoZHJhdwwBGGFzc2V0cyUFAUBNdWx0aUFzc2V0RmlsdGVyAAEccmVzZXJ2ZckEATRNdWx0aUxvY2F0aW9uAAEMeGNt6QQBHFhjbTwoKT4AEABASW5pdGlhdGVUZWxlcG9ydAwBGGFzc2V0cyUFAUBNdWx0aUFzc2V0RmlsdGVyAAEQZGVzdMkEATRNdWx0aUxvY2F0aW9uAAEMeGNt6QQBHFhjbTwoKT4AEQAwUXVlcnlIb2xkaW5nEAEgcXVlcnlfaWQsARxRdWVyeUlkAAEQZGVzdMkEATRNdWx0aUxvY2F0aW9uAAEYYXNzZXRzJQUBQE11bHRpQXNzZXRGaWx0ZXIAAUxtYXhfcmVzcG9uc2Vfd2VpZ2h0LAEMdTY0ABIAMEJ1eUV4ZWN1dGlvbggBEGZlZXP9BAEoTXVsdGlBc3NldAABMHdlaWdodF9saW1pdDEFASxXZWlnaHRMaW1pdAATADRSZWZ1bmRTdXJwbHVzABQAPFNldEVycm9ySGFuZGxlcgQA8QUBQFhjbTxSdW50aW1lQ2FsbD4AFQAsU2V0QXBwZW5kaXgEAPEFAUBYY208UnVudGltZUNhbGw+ABYAKENsZWFyRXJyb3IAFwAoQ2xhaW1Bc3NldAgBGGFzc2V0c/UEASxNdWx0aUFzc2V0cwABGHRpY2tldMkEATRNdWx0aUxvY2F0aW9uABgAEFRyYXAEACwBDHU2NAAZAEBTdWJzY3JpYmVWZXJzaW9uCAEgcXVlcnlfaWQsARxRdWVyeUlkAAFMbWF4X3Jlc3BvbnNlX3dlaWdodCwBDHU2NAAaAEhVbnN1YnNjcmliZVZlcnNpb24AGwAA/QUMDHhjbThkb3VibGVfZW5jb2RlZDREb3VibGVFbmNvZGVkBARUAAAEARxlbmNvZGVkOAEcVmVjPHU4PgAAAQYMDHhjbQh2MwxYY20EEENhbGwAAAQABQYBWFZlYzxJbnN0cnVjdGlvbjxDYWxsPj4AAAUGAAACCQYACQYMDHhjbQh2MyxJbnN0cnVjdGlvbgQQQ2FsbAABwDRXaXRoZHJhd0Fzc2V0BABBBQEsTXVsdGlBc3NldHMAAABUUmVzZXJ2ZUFzc2V0RGVwb3NpdGVkBABBBQEsTXVsdGlBc3NldHMAAQBYUmVjZWl2ZVRlbGVwb3J0ZWRBc3NldAQAQQUBLE11bHRpQXNzZXRzAAIANFF1ZXJ5UmVzcG9uc2UQASBxdWVyeV9pZCwBHFF1ZXJ5SWQAASByZXNwb25zZVkFASBSZXNwb25zZQABKG1heF93ZWlnaHQoARhXZWlnaHQAARxxdWVyaWVygQUBVE9wdGlvbjxNdWx0aUxvY2F0aW9uPgADADRUcmFuc2ZlckFzc2V0CAEYYXNzZXRzQQUBLE11bHRpQXNzZXRzAAEsYmVuZWZpY2lhcnn1AgE0TXVsdGlMb2NhdGlvbgAEAFBUcmFuc2ZlclJlc2VydmVBc3NldAwBGGFzc2V0c0EFASxNdWx0aUFzc2V0cwABEGRlc3T1AgE0TXVsdGlMb2NhdGlvbgABDHhjbTUFARxYY208KCk+AAUAIFRyYW5zYWN0DAEsb3JpZ2luX2tpbmSFBQEoT3JpZ2luS2luZAABWHJlcXVpcmVfd2VpZ2h0X2F0X21vc3QoARhXZWlnaHQAARBjYWxs/QUBTERvdWJsZUVuY29kZWQ8Q2FsbD4ABgBkSHJtcE5ld0NoYW5uZWxPcGVuUmVxdWVzdAwBGHNlbmRlclUBAQx1MzIAAUBtYXhfbWVzc2FnZV9zaXplVQEBDHUzMgABMG1heF9jYXBhY2l0eVUBAQx1MzIABwBMSHJtcENoYW5uZWxBY2NlcHRlZAQBJHJlY2lwaWVudFUBAQx1MzIACABISHJtcENoYW5uZWxDbG9zaW5nDAEkaW5pdGlhdG9yVQEBDHUzMgABGHNlbmRlclUBAQx1MzIAASRyZWNpcGllbnRVAQEMdTMyAAkALENsZWFyT3JpZ2luAAoANERlc2NlbmRPcmlnaW4EAPkCAVRJbnRlcmlvck11bHRpTG9jYXRpb24ACwAsUmVwb3J0RXJyb3IEAIkFAURRdWVyeVJlc3BvbnNlSW5mbwAMADBEZXBvc2l0QXNzZXQIARhhc3NldHONBQFATXVsdGlBc3NldEZpbHRlcgABLGJlbmVmaWNpYXJ59QIBNE11bHRpTG9jYXRpb24ADQBMRGVwb3NpdFJlc2VydmVBc3NldAwBGGFzc2V0c40FAUBNdWx0aUFzc2V0RmlsdGVyAAEQZGVzdPUCATRNdWx0aUxvY2F0aW9uAAEMeGNtNQUBHFhjbTwoKT4ADgA0RXhjaGFuZ2VBc3NldAwBEGdpdmWNBQFATXVsdGlBc3NldEZpbHRlcgABEHdhbnRBBQEsTXVsdGlBc3NldHMAARxtYXhpbWFsIAEQYm9vbAAPAFxJbml0aWF0ZVJlc2VydmVXaXRoZHJhdwwBGGFzc2V0c40FAUBNdWx0aUFzc2V0RmlsdGVyAAEccmVzZXJ2ZfUCATRNdWx0aUxvY2F0aW9uAAEMeGNtNQUBHFhjbTwoKT4AEABASW5pdGlhdGVUZWxlcG9ydAwBGGFzc2V0c40FAUBNdWx0aUFzc2V0RmlsdGVyAAEQZGVzdPUCATRNdWx0aUxvY2F0aW9uAAEMeGNtNQUBHFhjbTwoKT4AEQA0UmVwb3J0SG9sZGluZwgBNHJlc3BvbnNlX2luZm+JBQFEUXVlcnlSZXNwb25zZUluZm8AARhhc3NldHONBQFATXVsdGlBc3NldEZpbHRlcgASADBCdXlFeGVjdXRpb24IARBmZWVzSQUBKE11bHRpQXNzZXQAATB3ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAEwA0UmVmdW5kU3VycGx1cwAUADxTZXRFcnJvckhhbmRsZXIEAAEGASRYY208Q2FsbD4AFQAsU2V0QXBwZW5kaXgEAAEGASRYY208Q2FsbD4AFgAoQ2xlYXJFcnJvcgAXAChDbGFpbUFzc2V0CAEYYXNzZXRzQQUBLE11bHRpQXNzZXRzAAEYdGlja2V09QIBNE11bHRpTG9jYXRpb24AGAAQVHJhcAQALAEMdTY0ABkAQFN1YnNjcmliZVZlcnNpb24IASBxdWVyeV9pZCwBHFF1ZXJ5SWQAAUxtYXhfcmVzcG9uc2Vfd2VpZ2h0KAEYV2VpZ2h0ABoASFVuc3Vic2NyaWJlVmVyc2lvbgAbACRCdXJuQXNzZXQEAEEFASxNdWx0aUFzc2V0cwAcACxFeHBlY3RBc3NldAQAQQUBLE11bHRpQXNzZXRzAB0AMEV4cGVjdE9yaWdpbgQAgQUBVE9wdGlvbjxNdWx0aUxvY2F0aW9uPgAeACxFeHBlY3RFcnJvcgQAXQUBUE9wdGlvbjwodTMyLCBFcnJvcik+AB8AUEV4cGVjdFRyYW5zYWN0U3RhdHVzBAB5BQE4TWF5YmVFcnJvckNvZGUAIAAsUXVlcnlQYWxsZXQIASxtb2R1bGVfbmFtZTgBHFZlYzx1OD4AATRyZXNwb25zZV9pbmZviQUBRFF1ZXJ5UmVzcG9uc2VJbmZvACEAMEV4cGVjdFBhbGxldBQBFGluZGV4VQEBDHUzMgABEG5hbWU4ARxWZWM8dTg+AAEsbW9kdWxlX25hbWU4ARxWZWM8dTg+AAEsY3JhdGVfbWFqb3JVAQEMdTMyAAE8bWluX2NyYXRlX21pbm9yVQEBDHUzMgAiAFBSZXBvcnRUcmFuc2FjdFN0YXR1cwQAiQUBRFF1ZXJ5UmVzcG9uc2VJbmZvACMATENsZWFyVHJhbnNhY3RTdGF0dXMAJAA8VW5pdmVyc2FsT3JpZ2luBAD9AgEgSnVuY3Rpb24AJQA0RXhwb3J0TWVzc2FnZQwBHG5ldHdvcmsFAwEkTmV0d29ya0lkAAEsZGVzdGluYXRpb275AgFUSW50ZXJpb3JNdWx0aUxvY2F0aW9uAAEMeGNtNQUBHFhjbTwoKT4AJgAkTG9ja0Fzc2V0CAEUYXNzZXRJBQEoTXVsdGlBc3NldAABIHVubG9ja2Vy9QIBNE11bHRpTG9jYXRpb24AJwAsVW5sb2NrQXNzZXQIARRhc3NldEkFAShNdWx0aUFzc2V0AAEYdGFyZ2V09QIBNE11bHRpTG9jYXRpb24AKAA4Tm90ZVVubG9ja2FibGUIARRhc3NldEkFAShNdWx0aUFzc2V0AAEUb3duZXL1AgE0TXVsdGlMb2NhdGlvbgApADRSZXF1ZXN0VW5sb2NrCAEUYXNzZXRJBQEoTXVsdGlBc3NldAABGGxvY2tlcvUCATRNdWx0aUxvY2F0aW9uACoALFNldEZlZXNNb2RlBAEwaml0X3dpdGhkcmF3IAEQYm9vbAArACBTZXRUb3BpYwQABAEgW3U4OyAzMl0ALAAoQ2xlYXJUb3BpYwAtACxBbGlhc09yaWdpbgQA9QIBNE11bHRpTG9jYXRpb24ALgA8VW5wYWlkRXhlY3V0aW9uCAEwd2VpZ2h0X2xpbWl0mQUBLFdlaWdodExpbWl0AAEwY2hlY2tfb3JpZ2lugQUBVE9wdGlvbjxNdWx0aUxvY2F0aW9uPgAvAAANBgwsc3RhZ2luZ194Y20IdjQMWGNtBBBDYWxsAAAEABEGAVhWZWM8SW5zdHJ1Y3Rpb248Q2FsbD4+AAARBgAAAhUGABUGDCxzdGFnaW5nX3hjbQh2NCxJbnN0cnVjdGlvbgQQQ2FsbAABwDRXaXRoZHJhd0Fzc2V0BACpBQEYQXNzZXRzAAAAVFJlc2VydmVBc3NldERlcG9zaXRlZAQAqQUBGEFzc2V0cwABAFhSZWNlaXZlVGVsZXBvcnRlZEFzc2V0BACpBQEYQXNzZXRzAAIANFF1ZXJ5UmVzcG9uc2UQASBxdWVyeV9pZCwBHFF1ZXJ5SWQAASByZXNwb25zZcEFASBSZXNwb25zZQABKG1heF93ZWlnaHQoARhXZWlnaHQAARxxdWVyaWVy1QUBQE9wdGlvbjxMb2NhdGlvbj4AAwA0VHJhbnNmZXJBc3NldAgBGGFzc2V0c6kFARhBc3NldHMAASxiZW5lZmljaWFyeX0BASBMb2NhdGlvbgAEAFBUcmFuc2ZlclJlc2VydmVBc3NldAwBGGFzc2V0c6kFARhBc3NldHMAARBkZXN0fQEBIExvY2F0aW9uAAEMeGNtnQUBHFhjbTwoKT4ABQAgVHJhbnNhY3QMASxvcmlnaW5fa2luZIUFAShPcmlnaW5LaW5kAAFYcmVxdWlyZV93ZWlnaHRfYXRfbW9zdCgBGFdlaWdodAABEGNhbGz9BQFMRG91YmxlRW5jb2RlZDxDYWxsPgAGAGRIcm1wTmV3Q2hhbm5lbE9wZW5SZXF1ZXN0DAEYc2VuZGVyVQEBDHUzMgABQG1heF9tZXNzYWdlX3NpemVVAQEMdTMyAAEwbWF4X2NhcGFjaXR5VQEBDHUzMgAHAExIcm1wQ2hhbm5lbEFjY2VwdGVkBAEkcmVjaXBpZW50VQEBDHUzMgAIAEhIcm1wQ2hhbm5lbENsb3NpbmcMASRpbml0aWF0b3JVAQEMdTMyAAEYc2VuZGVyVQEBDHUzMgABJHJlY2lwaWVudFUBAQx1MzIACQAsQ2xlYXJPcmlnaW4ACgA0RGVzY2VuZE9yaWdpbgQAgQEBQEludGVyaW9yTG9jYXRpb24ACwAsUmVwb3J0RXJyb3IEANkFAURRdWVyeVJlc3BvbnNlSW5mbwAMADBEZXBvc2l0QXNzZXQIARhhc3NldHPdBQEsQXNzZXRGaWx0ZXIAASxiZW5lZmljaWFyeX0BASBMb2NhdGlvbgANAExEZXBvc2l0UmVzZXJ2ZUFzc2V0DAEYYXNzZXRz3QUBLEFzc2V0RmlsdGVyAAEQZGVzdH0BASBMb2NhdGlvbgABDHhjbZ0FARxYY208KCk+AA4ANEV4Y2hhbmdlQXNzZXQMARBnaXZl3QUBLEFzc2V0RmlsdGVyAAEQd2FudKkFARhBc3NldHMAARxtYXhpbWFsIAEQYm9vbAAPAFxJbml0aWF0ZVJlc2VydmVXaXRoZHJhdwwBGGFzc2V0c90FASxBc3NldEZpbHRlcgABHHJlc2VydmV9AQEgTG9jYXRpb24AAQx4Y22dBQEcWGNtPCgpPgAQAEBJbml0aWF0ZVRlbGVwb3J0DAEYYXNzZXRz3QUBLEFzc2V0RmlsdGVyAAEQZGVzdH0BASBMb2NhdGlvbgABDHhjbZ0FARxYY208KCk+ABEANFJlcG9ydEhvbGRpbmcIATRyZXNwb25zZV9pbmZv2QUBRFF1ZXJ5UmVzcG9uc2VJbmZvAAEYYXNzZXRz3QUBLEFzc2V0RmlsdGVyABIAMEJ1eUV4ZWN1dGlvbggBEGZlZXOxBQEUQXNzZXQAATB3ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAEwA0UmVmdW5kU3VycGx1cwAUADxTZXRFcnJvckhhbmRsZXIEAA0GASRYY208Q2FsbD4AFQAsU2V0QXBwZW5kaXgEAA0GASRYY208Q2FsbD4AFgAoQ2xlYXJFcnJvcgAXAChDbGFpbUFzc2V0CAEYYXNzZXRzqQUBGEFzc2V0cwABGHRpY2tldH0BASBMb2NhdGlvbgAYABBUcmFwBAAsAQx1NjQAGQBAU3Vic2NyaWJlVmVyc2lvbggBIHF1ZXJ5X2lkLAEcUXVlcnlJZAABTG1heF9yZXNwb25zZV93ZWlnaHQoARhXZWlnaHQAGgBIVW5zdWJzY3JpYmVWZXJzaW9uABsAJEJ1cm5Bc3NldAQAqQUBGEFzc2V0cwAcACxFeHBlY3RBc3NldAQAqQUBGEFzc2V0cwAdADBFeHBlY3RPcmlnaW4EANUFAUBPcHRpb248TG9jYXRpb24+AB4ALEV4cGVjdEVycm9yBABdBQFQT3B0aW9uPCh1MzIsIEVycm9yKT4AHwBQRXhwZWN0VHJhbnNhY3RTdGF0dXMEAHkFAThNYXliZUVycm9yQ29kZQAgACxRdWVyeVBhbGxldAgBLG1vZHVsZV9uYW1lOAEcVmVjPHU4PgABNHJlc3BvbnNlX2luZm/ZBQFEUXVlcnlSZXNwb25zZUluZm8AIQAwRXhwZWN0UGFsbGV0FAEUaW5kZXhVAQEMdTMyAAEQbmFtZTgBHFZlYzx1OD4AASxtb2R1bGVfbmFtZTgBHFZlYzx1OD4AASxjcmF0ZV9tYWpvclUBAQx1MzIAATxtaW5fY3JhdGVfbWlub3JVAQEMdTMyACIAUFJlcG9ydFRyYW5zYWN0U3RhdHVzBADZBQFEUXVlcnlSZXNwb25zZUluZm8AIwBMQ2xlYXJUcmFuc2FjdFN0YXR1cwAkADxVbml2ZXJzYWxPcmlnaW4EAIkBASBKdW5jdGlvbgAlADRFeHBvcnRNZXNzYWdlDAEcbmV0d29ya5EBASROZXR3b3JrSWQAASxkZXN0aW5hdGlvboEBAUBJbnRlcmlvckxvY2F0aW9uAAEMeGNtnQUBHFhjbTwoKT4AJgAkTG9ja0Fzc2V0CAEUYXNzZXSxBQEUQXNzZXQAASB1bmxvY2tlcn0BASBMb2NhdGlvbgAnACxVbmxvY2tBc3NldAgBFGFzc2V0sQUBFEFzc2V0AAEYdGFyZ2V0fQEBIExvY2F0aW9uACgAOE5vdGVVbmxvY2thYmxlCAEUYXNzZXSxBQEUQXNzZXQAARRvd25lcn0BASBMb2NhdGlvbgApADRSZXF1ZXN0VW5sb2NrCAEUYXNzZXSxBQEUQXNzZXQAARhsb2NrZXJ9AQEgTG9jYXRpb24AKgAsU2V0RmVlc01vZGUEATBqaXRfd2l0aGRyYXcgARBib29sACsAIFNldFRvcGljBAAEASBbdTg7IDMyXQAsAChDbGVhclRvcGljAC0ALEFsaWFzT3JpZ2luBAB9AQEgTG9jYXRpb24ALgA8VW5wYWlkRXhlY3V0aW9uCAEwd2VpZ2h0X2xpbWl0mQUBLFdlaWdodExpbWl0AAEwY2hlY2tfb3JpZ2lu1QUBQE9wdGlvbjxMb2NhdGlvbj4ALwAAGQYQUHN0YWdpbmdfeGNtX2V4ZWN1dG9yGHRyYWl0czhhc3NldF90cmFuc2ZlcjBUcmFuc2ZlclR5cGUAARAgVGVsZXBvcnQAAAAwTG9jYWxSZXNlcnZlAAEASERlc3RpbmF0aW9uUmVzZXJ2ZQACADRSZW1vdGVSZXNlcnZlBADFBAFEVmVyc2lvbmVkTG9jYXRpb24AAwAAHQYIDHhjbUBWZXJzaW9uZWRBc3NldElkAAEICFYzBABNBQEsdjM6OkFzc2V0SWQAAwAIVjQEALUFASx2NDo6QXNzZXRJZAAEAAAhBgxIY3VtdWx1c19wYWxsZXRfeGNtGHBhbGxldBBDYWxsBARUAAEABA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLiUGDFBwYWxsZXRfbWVzc2FnZV9xdWV1ZRhwYWxsZXQQQ2FsbAQEVAABCCRyZWFwX3BhZ2UIAThtZXNzYWdlX29yaWdpbikGAUhNZXNzYWdlT3JpZ2luT2Y8VD4AAShwYWdlX2luZGV4EAEkUGFnZUluZGV4AAAEPQFSZW1vdmUgYSBwYWdlIHdoaWNoIGhhcyBubyBtb3JlIG1lc3NhZ2VzIHJlbWFpbmluZyB0byBiZSBwcm9jZXNzZWQgb3IgaXMgc3RhbGUuSGV4ZWN1dGVfb3ZlcndlaWdodBABOG1lc3NhZ2Vfb3JpZ2luKQYBSE1lc3NhZ2VPcmlnaW5PZjxUPgABEHBhZ2UQASRQYWdlSW5kZXgAARRpbmRleBABHFQ6OlNpemUAATB3ZWlnaHRfbGltaXQoARhXZWlnaHQAATR4RXhlY3V0ZSBhbiBvdmVyd2VpZ2h0IG1lc3NhZ2UuAE0BVGVtcG9yYXJ5IHByb2Nlc3NpbmcgZXJyb3JzIHdpbGwgYmUgcHJvcGFnYXRlZCB3aGVyZWFzIHBlcm1hbmVudCBlcnJvcnMgYXJlIHRyZWF0ZWRUYXMgc3VjY2VzcyBjb25kaXRpb24uAHQtIGBvcmlnaW5gOiBNdXN0IGJlIGBTaWduZWRgLjUBLSBgbWVzc2FnZV9vcmlnaW5gOiBUaGUgb3JpZ2luIGZyb20gd2hpY2ggdGhlIG1lc3NhZ2UgdG8gYmUgZXhlY3V0ZWQgYXJyaXZlZC49AS0gYHBhZ2VgOiBUaGUgcGFnZSBpbiB0aGUgcXVldWUgaW4gd2hpY2ggdGhlIG1lc3NhZ2UgdG8gYmUgZXhlY3V0ZWQgaXMgc2l0dGluZy4JAS0gYGluZGV4YDogVGhlIGluZGV4IGludG8gdGhlIHF1ZXVlIG9mIHRoZSBtZXNzYWdlIHRvIGJlIGV4ZWN1dGVkLlkBLSBgd2VpZ2h0X2xpbWl0YDogVGhlIG1heGltdW0gYW1vdW50IG9mIHdlaWdodCBhbGxvd2VkIHRvIGJlIGNvbnN1bWVkIGluIHRoZSBleGVjdXRpb25EICBvZiB0aGUgbWVzc2FnZS4A9EJlbmNobWFyayBjb21wbGV4aXR5IGNvbnNpZGVyYXRpb25zOiBPKGluZGV4ICsgd2VpZ2h0X2xpbWl0KS4EDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMuKQYIXGN1bXVsdXNfcHJpbWl0aXZlc19jb3JlWEFnZ3JlZ2F0ZU1lc3NhZ2VPcmlnaW4AAQwQSGVyZQAAABhQYXJlbnQAAQAcU2libGluZwQAvQEBGFBhcmFJZAACAAAtBgwgb3JtbF94Y20YbW9kdWxlEENhbGwEBFQAAQREc2VuZF9hc19zb3ZlcmVpZ24IARBkZXN0xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AARxtZXNzYWdl5QQBVEJveDxWZXJzaW9uZWRYY208KCk+PgAABKxTZW5kIGFuIFhDTSBtZXNzYWdlIGFzIHBhcmFjaGFpbiBzb3ZlcmVpZ24uBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLjEGDDBvcm1sX3h0b2tlbnMYbW9kdWxlEENhbGwEBFQAARggdHJhbnNmZXIQASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAEQZGVzdMUEAVhCb3g8VmVyc2lvbmVkTG9jYXRpb24+AAFEZGVzdF93ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAADBsVHJhbnNmZXIgbmF0aXZlIGN1cnJlbmNpZXMuAPxgZGVzdF93ZWlnaHRfbGltaXRgIGlzIHRoZSB3ZWlnaHQgZm9yIFhDTSBleGVjdXRpb24gb24gdGhlIGRlc3QJAWNoYWluLCBhbmQgaXQgd291bGQgYmUgY2hhcmdlZCBmcm9tIHRoZSB0cmFuc2ZlcnJlZCBhc3NldHMuIElmIHNldAUBYmVsb3cgcmVxdWlyZW1lbnRzLCB0aGUgZXhlY3V0aW9uIG1heSBmYWlsIGFuZCBhc3NldHMgd291bGRuJ3QgYmUkcmVjZWl2ZWQuABEBSXQncyBhIG5vLW9wIGlmIGFueSBlcnJvciBvbiBsb2NhbCBYQ00gZXhlY3V0aW9uIG9yIG1lc3NhZ2Ugc2VuZGluZy74Tm90ZSBzZW5kaW5nIGFzc2V0cyBvdXQgcGVyIHNlIGRvZXNuJ3QgZ3VhcmFudGVlIHRoZXkgd291bGQgYmURAXJlY2VpdmVkLiBSZWNlaXZpbmcgZGVwZW5kcyBvbiBpZiB0aGUgWENNIG1lc3NhZ2UgY291bGQgYmUgZGVsaXZlcmVk3GJ5IHRoZSBuZXR3b3JrLCBhbmQgaWYgdGhlIHJlY2VpdmluZyBjaGFpbiB3b3VsZCBoYW5kbGVMbWVzc2FnZXMgY29ycmVjdGx5Lkx0cmFuc2Zlcl9tdWx0aWFzc2V0DAEUYXNzZXQ1BgFMQm94PFZlcnNpb25lZEFzc2V0PgABEGRlc3TFBAFYQm94PFZlcnNpb25lZExvY2F0aW9uPgABRGRlc3Rfd2VpZ2h0X2xpbWl0mQUBLFdlaWdodExpbWl0AAEwRFRyYW5zZmVyIGBBc3NldGAuAPxgZGVzdF93ZWlnaHRfbGltaXRgIGlzIHRoZSB3ZWlnaHQgZm9yIFhDTSBleGVjdXRpb24gb24gdGhlIGRlc3QJAWNoYWluLCBhbmQgaXQgd291bGQgYmUgY2hhcmdlZCBmcm9tIHRoZSB0cmFuc2ZlcnJlZCBhc3NldHMuIElmIHNldAUBYmVsb3cgcmVxdWlyZW1lbnRzLCB0aGUgZXhlY3V0aW9uIG1heSBmYWlsIGFuZCBhc3NldHMgd291bGRuJ3QgYmUkcmVjZWl2ZWQuABEBSXQncyBhIG5vLW9wIGlmIGFueSBlcnJvciBvbiBsb2NhbCBYQ00gZXhlY3V0aW9uIG9yIG1lc3NhZ2Ugc2VuZGluZy74Tm90ZSBzZW5kaW5nIGFzc2V0cyBvdXQgcGVyIHNlIGRvZXNuJ3QgZ3VhcmFudGVlIHRoZXkgd291bGQgYmURAXJlY2VpdmVkLiBSZWNlaXZpbmcgZGVwZW5kcyBvbiBpZiB0aGUgWENNIG1lc3NhZ2UgY291bGQgYmUgZGVsaXZlcmVk3GJ5IHRoZSBuZXR3b3JrLCBhbmQgaWYgdGhlIHJlY2VpdmluZyBjaGFpbiB3b3VsZCBoYW5kbGVMbWVzc2FnZXMgY29ycmVjdGx5LkR0cmFuc2Zlcl93aXRoX2ZlZRQBLGN1cnJlbmN5X2lkEAE0VDo6Q3VycmVuY3lJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UAAQxmZWUYAShUOjpCYWxhbmNlAAEQZGVzdMUEAVhCb3g8VmVyc2lvbmVkTG9jYXRpb24+AAFEZGVzdF93ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAAlTsVHJhbnNmZXIgbmF0aXZlIGN1cnJlbmNpZXMgc3BlY2lmeWluZyB0aGUgZmVlIGFuZCBhbW91bnQgYXMkc2VwYXJhdGUuAPxgZGVzdF93ZWlnaHRfbGltaXRgIGlzIHRoZSB3ZWlnaHQgZm9yIFhDTSBleGVjdXRpb24gb24gdGhlIGRlc3QJAWNoYWluLCBhbmQgaXQgd291bGQgYmUgY2hhcmdlZCBmcm9tIHRoZSB0cmFuc2ZlcnJlZCBhc3NldHMuIElmIHNldAUBYmVsb3cgcmVxdWlyZW1lbnRzLCB0aGUgZXhlY3V0aW9uIG1heSBmYWlsIGFuZCBhc3NldHMgd291bGRuJ3QgYmUkcmVjZWl2ZWQuAA0BYGZlZWAgaXMgdGhlIGFtb3VudCB0byBiZSBzcGVudCB0byBwYXkgZm9yIGV4ZWN1dGlvbiBpbiBkZXN0aW5hdGlvbvhjaGFpbi4gQm90aCBmZWUgYW5kIGFtb3VudCB3aWxsIGJlIHN1YnRyYWN0ZWQgZm9ybSB0aGUgY2FsbGVycyBiYWxhbmNlLgANAUlmIGBmZWVgIGlzIG5vdCBoaWdoIGVub3VnaCB0byBjb3ZlciBmb3IgdGhlIGV4ZWN1dGlvbiBjb3N0cyBpbiB0aGXkZGVzdGluYXRpb24gY2hhaW4sIHRoZW4gdGhlIGFzc2V0cyB3aWxsIGJlIHRyYXBwZWQgaW4gdGhlRGRlc3RpbmF0aW9uIGNoYWluABEBSXQncyBhIG5vLW9wIGlmIGFueSBlcnJvciBvbiBsb2NhbCBYQ00gZXhlY3V0aW9uIG9yIG1lc3NhZ2Ugc2VuZGluZy74Tm90ZSBzZW5kaW5nIGFzc2V0cyBvdXQgcGVyIHNlIGRvZXNuJ3QgZ3VhcmFudGVlIHRoZXkgd291bGQgYmURAXJlY2VpdmVkLiBSZWNlaXZpbmcgZGVwZW5kcyBvbiBpZiB0aGUgWENNIG1lc3NhZ2UgY291bGQgYmUgZGVsaXZlcmVk3GJ5IHRoZSBuZXR3b3JrLCBhbmQgaWYgdGhlIHJlY2VpdmluZyBjaGFpbiB3b3VsZCBoYW5kbGVMbWVzc2FnZXMgY29ycmVjdGx5LnB0cmFuc2Zlcl9tdWx0aWFzc2V0X3dpdGhfZmVlEAEUYXNzZXQ1BgFMQm94PFZlcnNpb25lZEFzc2V0PgABDGZlZTUGAUxCb3g8VmVyc2lvbmVkQXNzZXQ+AAEQZGVzdMUEAVhCb3g8VmVyc2lvbmVkTG9jYXRpb24+AAFEZGVzdF93ZWlnaHRfbGltaXSZBQEsV2VpZ2h0TGltaXQAA1TsVHJhbnNmZXIgYEFzc2V0YCBzcGVjaWZ5aW5nIHRoZSBmZWUgYW5kIGFtb3VudCBhcyBzZXBhcmF0ZS4A/GBkZXN0X3dlaWdodF9saW1pdGAgaXMgdGhlIHdlaWdodCBmb3IgWENNIGV4ZWN1dGlvbiBvbiB0aGUgZGVzdAkBY2hhaW4sIGFuZCBpdCB3b3VsZCBiZSBjaGFyZ2VkIGZyb20gdGhlIHRyYW5zZmVycmVkIGFzc2V0cy4gSWYgc2V0BQFiZWxvdyByZXF1aXJlbWVudHMsIHRoZSBleGVjdXRpb24gbWF5IGZhaWwgYW5kIGFzc2V0cyB3b3VsZG4ndCBiZSRyZWNlaXZlZC4A2GBmZWVgIGlzIHRoZSBBc3NldCB0byBiZSBzcGVudCB0byBwYXkgZm9yIGV4ZWN1dGlvbiBpbgkBZGVzdGluYXRpb24gY2hhaW4uIEJvdGggZmVlIGFuZCBhbW91bnQgd2lsbCBiZSBzdWJ0cmFjdGVkIGZvcm0gdGhlEQFjYWxsZXJzIGJhbGFuY2UgRm9yIG5vdyB3ZSBvbmx5IGFjY2VwdCBmZWUgYW5kIGFzc2V0IGhhdmluZyB0aGUgc2FtZThgTG9jYXRpb25gIGlkLgANAUlmIGBmZWVgIGlzIG5vdCBoaWdoIGVub3VnaCB0byBjb3ZlciBmb3IgdGhlIGV4ZWN1dGlvbiBjb3N0cyBpbiB0aGXkZGVzdGluYXRpb24gY2hhaW4sIHRoZW4gdGhlIGFzc2V0cyB3aWxsIGJlIHRyYXBwZWQgaW4gdGhlRGRlc3RpbmF0aW9uIGNoYWluABEBSXQncyBhIG5vLW9wIGlmIGFueSBlcnJvciBvbiBsb2NhbCBYQ00gZXhlY3V0aW9uIG9yIG1lc3NhZ2Ugc2VuZGluZy74Tm90ZSBzZW5kaW5nIGFzc2V0cyBvdXQgcGVyIHNlIGRvZXNuJ3QgZ3VhcmFudGVlIHRoZXkgd291bGQgYmURAXJlY2VpdmVkLiBSZWNlaXZpbmcgZGVwZW5kcyBvbiBpZiB0aGUgWENNIG1lc3NhZ2UgY291bGQgYmUgZGVsaXZlcmVk3GJ5IHRoZSBuZXR3b3JrLCBhbmQgaWYgdGhlIHJlY2VpdmluZyBjaGFpbiB3b3VsZCBoYW5kbGVMbWVzc2FnZXMgY29ycmVjdGx5LmB0cmFuc2Zlcl9tdWx0aWN1cnJlbmNpZXMQAShjdXJyZW5jaWVzOQYBgFZlYzwoVDo6Q3VycmVuY3lJZCwgVDo6QmFsYW5jZSk+AAEgZmVlX2l0ZW0QAQx1MzIAARBkZXN0xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AAURkZXN0X3dlaWdodF9saW1pdJkFASxXZWlnaHRMaW1pdAAEPAUBVHJhbnNmZXIgc2V2ZXJhbCBjdXJyZW5jaWVzIHNwZWNpZnlpbmcgdGhlIGl0ZW0gdG8gYmUgdXNlZCBhcyBmZWUA/GBkZXN0X3dlaWdodF9saW1pdGAgaXMgdGhlIHdlaWdodCBmb3IgWENNIGV4ZWN1dGlvbiBvbiB0aGUgZGVzdAkBY2hhaW4sIGFuZCBpdCB3b3VsZCBiZSBjaGFyZ2VkIGZyb20gdGhlIHRyYW5zZmVycmVkIGFzc2V0cy4gSWYgc2V0BQFiZWxvdyByZXF1aXJlbWVudHMsIHRoZSBleGVjdXRpb24gbWF5IGZhaWwgYW5kIGFzc2V0cyB3b3VsZG4ndCBiZSRyZWNlaXZlZC4ADQFgZmVlX2l0ZW1gIGlzIGluZGV4IG9mIHRoZSBjdXJyZW5jaWVzIHR1cGxlIHRoYXQgd2Ugd2FudCB0byB1c2UgZm9yHHBheW1lbnQAEQFJdCdzIGEgbm8tb3AgaWYgYW55IGVycm9yIG9uIGxvY2FsIFhDTSBleGVjdXRpb24gb3IgbWVzc2FnZSBzZW5kaW5nLvhOb3RlIHNlbmRpbmcgYXNzZXRzIG91dCBwZXIgc2UgZG9lc24ndCBndWFyYW50ZWUgdGhleSB3b3VsZCBiZREBcmVjZWl2ZWQuIFJlY2VpdmluZyBkZXBlbmRzIG9uIGlmIHRoZSBYQ00gbWVzc2FnZSBjb3VsZCBiZSBkZWxpdmVyZWTcYnkgdGhlIG5ldHdvcmssIGFuZCBpZiB0aGUgcmVjZWl2aW5nIGNoYWluIHdvdWxkIGhhbmRsZUxtZXNzYWdlcyBjb3JyZWN0bHkuUHRyYW5zZmVyX211bHRpYXNzZXRzEAEYYXNzZXRz6QUBUEJveDxWZXJzaW9uZWRBc3NldHM+AAEgZmVlX2l0ZW0QAQx1MzIAARBkZXN0xQQBWEJveDxWZXJzaW9uZWRMb2NhdGlvbj4AAURkZXN0X3dlaWdodF9saW1pdJkFASxXZWlnaHRMaW1pdAAFPPhUcmFuc2ZlciBzZXZlcmFsIGBBc3NldGAgc3BlY2lmeWluZyB0aGUgaXRlbSB0byBiZSB1c2VkIGFzIGZlZQD8YGRlc3Rfd2VpZ2h0X2xpbWl0YCBpcyB0aGUgd2VpZ2h0IGZvciBYQ00gZXhlY3V0aW9uIG9uIHRoZSBkZXN0CQFjaGFpbiwgYW5kIGl0IHdvdWxkIGJlIGNoYXJnZWQgZnJvbSB0aGUgdHJhbnNmZXJyZWQgYXNzZXRzLiBJZiBzZXQFAWJlbG93IHJlcXVpcmVtZW50cywgdGhlIGV4ZWN1dGlvbiBtYXkgZmFpbCBhbmQgYXNzZXRzIHdvdWxkbid0IGJlJHJlY2VpdmVkLgDkYGZlZV9pdGVtYCBpcyBpbmRleCBvZiB0aGUgQXNzZXRzIHRoYXQgd2Ugd2FudCB0byB1c2UgZm9yHHBheW1lbnQAEQFJdCdzIGEgbm8tb3AgaWYgYW55IGVycm9yIG9uIGxvY2FsIFhDTSBleGVjdXRpb24gb3IgbWVzc2FnZSBzZW5kaW5nLvhOb3RlIHNlbmRpbmcgYXNzZXRzIG91dCBwZXIgc2UgZG9lc24ndCBndWFyYW50ZWUgdGhleSB3b3VsZCBiZREBcmVjZWl2ZWQuIFJlY2VpdmluZyBkZXBlbmRzIG9uIGlmIHRoZSBYQ00gbWVzc2FnZSBjb3VsZCBiZSBkZWxpdmVyZWTcYnkgdGhlIG5ldHdvcmssIGFuZCBpZiB0aGUgcmVjZWl2aW5nIGNoYWluIHdvdWxkIGhhbmRsZUxtZXNzYWdlcyBjb3JyZWN0bHkuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLjUGCAx4Y204VmVyc2lvbmVkQXNzZXQAAQwIVjIEAP0EATh2Mjo6TXVsdGlBc3NldAABAAhWMwQASQUBOHYzOjpNdWx0aUFzc2V0AAMACFY0BACxBQEkdjQ6OkFzc2V0AAQAADkGAAAC1QMAPQYMZHBhbGxldF9jb2xsYXRvcl9zZWxlY3Rpb24YcGFsbGV0EENhbGwEBFQAASREc2V0X2ludnVsbmVyYWJsZXMEAQxuZXcxAQFEVmVjPFQ6OkFjY291bnRJZD4AADQxAVNldCB0aGUgbGlzdCBvZiBpbnZ1bG5lcmFibGUgKGZpeGVkKSBjb2xsYXRvcnMuIFRoZXNlIGNvbGxhdG9ycyBtdXN0IGRvIHNvbWXQcHJlcGFyYXRpb24sIG5hbWVseSB0byBoYXZlIHJlZ2lzdGVyZWQgc2Vzc2lvbiBrZXlzLgBZAVRoZSBjYWxsIHdpbGwgcmVtb3ZlIGFueSBhY2NvdW50cyB0aGF0IGhhdmUgbm90IHJlZ2lzdGVyZWQga2V5cyBmcm9tIHRoZSBzZXQuIFRoYXQgaXMsXQFpdCBpcyBub24tYXRvbWljOyB0aGUgY2FsbGVyIGFjY2VwdHMgYWxsIGBBY2NvdW50SWRgcyBwYXNzZWQgaW4gYG5ld2AgX2luZGl2aWR1YWxseV8gYXMxAWFjY2VwdGFibGUgSW52dWxuZXJhYmxlcywgYW5kIGlzIG5vdCBwcm9wb3NpbmcgYSBfc2V0XyBvZiBuZXcgSW52dWxuZXJhYmxlcy4AWQFUaGlzIGNhbGwgZG9lcyBub3QgbWFpbnRhaW4gbXV0dWFsIGV4Y2x1c2l2aXR5IG9mIGBJbnZ1bG5lcmFibGVzYCBhbmQgYENhbmRpZGF0ZXNgLiBJdGEBaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgYmF0Y2ggb2YgYGFkZF9pbnZ1bG5lcmFibGVgIGFuZCBgcmVtb3ZlX2ludnVsbmVyYWJsZWAgaW5zdGVhZC4gQVEBYGJhdGNoX2FsbGAgY2FuIGFsc28gYmUgdXNlZCB0byBlbmZvcmNlIGF0b21pY2l0eS4gSWYgYW55IGNhbmRpZGF0ZXMgYXJlIGluY2x1ZGVkIGluTQFgbmV3YCwgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCB3aXRoIGByZW1vdmVfaW52dWxuZXJhYmxlX2NhbmRpZGF0ZWAgYWZ0ZXIgZXhlY3V0aW9uLgCUTXVzdCBiZSBjYWxsZWQgYnkgdGhlIGBVcGRhdGVPcmlnaW5gLlhzZXRfZGVzaXJlZF9jYW5kaWRhdGVzBAEMbWF4EAEMdTMyAAEUVQFTZXQgdGhlIGlkZWFsIG51bWJlciBvZiBub24taW52dWxuZXJhYmxlIGNvbGxhdG9ycy4gSWYgbG93ZXJpbmcgdGhpcyBudW1iZXIsIHRoZW4gdGhlYQFudW1iZXIgb2YgcnVubmluZyBjb2xsYXRvcnMgY291bGQgYmUgaGlnaGVyIHRoYW4gdGhpcyBmaWd1cmUuIEFzaWRlIGZyb20gdGhhdCBlZGdlIGNhc2UsNQF0aGVyZSBzaG91bGQgYmUgbm8gb3RoZXIgd2F5IHRvIGhhdmUgbW9yZSBjYW5kaWRhdGVzIHRoYW4gdGhlIGRlc2lyZWQgbnVtYmVyLgDQVGhlIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgdGhlIGBVcGRhdGVPcmlnaW5gLkhzZXRfY2FuZGlkYWN5X2JvbmQEARBib25kGAEwQmFsYW5jZU9mPFQ+AAIceFNldCB0aGUgY2FuZGlkYWN5IGJvbmQgYW1vdW50LgBRAUlmIHRoZSBjYW5kaWRhY3kgYm9uZCBpcyBpbmNyZWFzZWQgYnkgdGhpcyBjYWxsLCBhbGwgY3VycmVudCBjYW5kaWRhdGVzIHdoaWNoIGhhdmUgYU0BZGVwb3NpdCBsb3dlciB0aGFuIHRoZSBuZXcgYm9uZCB3aWxsIGJlIGtpY2tlZCBmcm9tIHRoZSBsaXN0IGFuZCBnZXQgdGhlaXIgZGVwb3NpdHMUYmFjay4A0FRoZSBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIHRoZSBgVXBkYXRlT3JpZ2luYC5UcmVnaXN0ZXJfYXNfY2FuZGlkYXRlAAMQQQFSZWdpc3RlciB0aGlzIGFjY291bnQgYXMgYSBjb2xsYXRvciBjYW5kaWRhdGUuIFRoZSBhY2NvdW50IG11c3QgKGEpIGFscmVhZHkgaGF2ZR0BcmVnaXN0ZXJlZCBzZXNzaW9uIGtleXMgYW5kIChiKSBiZSBhYmxlIHRvIHJlc2VydmUgdGhlIGBDYW5kaWRhY3lCb25kYC4A3FRoaXMgY2FsbCBpcyBub3QgYXZhaWxhYmxlIHRvIGBJbnZ1bG5lcmFibGVgIGNvbGxhdG9ycy4wbGVhdmVfaW50ZW50AAQUVQFEZXJlZ2lzdGVyIGBvcmlnaW5gIGFzIGEgY29sbGF0b3IgY2FuZGlkYXRlLiBOb3RlIHRoYXQgdGhlIGNvbGxhdG9yIGNhbiBvbmx5IGxlYXZlIG9uDQFzZXNzaW9uIGNoYW5nZS4gVGhlIGBDYW5kaWRhY3lCb25kYCB3aWxsIGJlIHVucmVzZXJ2ZWQgaW1tZWRpYXRlbHkuABkBVGhpcyBjYWxsIHdpbGwgZmFpbCBpZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNhbmRpZGF0ZXMgd291bGQgZHJvcCBiZWxvd1xgTWluRWxpZ2libGVDb2xsYXRvcnNgLkBhZGRfaW52dWxuZXJhYmxlBAEMd2hvAAEwVDo6QWNjb3VudElkAAUQRQFBZGQgYSBuZXcgYWNjb3VudCBgd2hvYCB0byB0aGUgbGlzdCBvZiBgSW52dWxuZXJhYmxlc2AgY29sbGF0b3JzLiBgd2hvYCBtdXN0IGhhdmUdAXJlZ2lzdGVyZWQgc2Vzc2lvbiBrZXlzLiBJZiBgd2hvYCBpcyBhIGNhbmRpZGF0ZSwgdGhleSB3aWxsIGJlIHJlbW92ZWQuANBUaGUgb3JpZ2luIGZvciB0aGlzIGNhbGwgbXVzdCBiZSB0aGUgYFVwZGF0ZU9yaWdpbmAuTHJlbW92ZV9pbnZ1bG5lcmFibGUEAQx3aG8AATBUOjpBY2NvdW50SWQABhBhAVJlbW92ZSBhbiBhY2NvdW50IGB3aG9gIGZyb20gdGhlIGxpc3Qgb2YgYEludnVsbmVyYWJsZXNgIGNvbGxhdG9ycy4gYEludnVsbmVyYWJsZXNgIG11c3QoYmUgc29ydGVkLgDQVGhlIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgdGhlIGBVcGRhdGVPcmlnaW5gLix1cGRhdGVfYm9uZAQBLG5ld19kZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAccXQFVcGRhdGUgdGhlIGNhbmRpZGFjeSBib25kIG9mIGNvbGxhdG9yIGNhbmRpZGF0ZSBgb3JpZ2luYCB0byBhIG5ldyBhbW91bnQgYG5ld19kZXBvc2l0YC4AQQFTZXR0aW5nIGEgYG5ld19kZXBvc2l0YCB0aGF0IGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnQgZGVwb3NpdCB3aGlsZSBgb3JpZ2luYCBpc+BvY2N1cHlpbmcgYSB0b3AtYERlc2lyZWRDYW5kaWRhdGVzYCBzbG90IGlzIG5vdCBhbGxvd2VkLgBZAVRoaXMgY2FsbCB3aWxsIGZhaWwgaWYgYG9yaWdpbmAgaXMgbm90IGEgY29sbGF0b3IgY2FuZGlkYXRlLCB0aGUgdXBkYXRlZCBib25kIGlzIGxvd2VyGQF0aGFuIHRoZSBtaW5pbXVtIGNhbmRpZGFjeSBib25kLCBhbmQvb3IgdGhlIGFtb3VudCBjYW5ub3QgYmUgcmVzZXJ2ZWQuTHRha2VfY2FuZGlkYXRlX3Nsb3QIARxkZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAEYdGFyZ2V0AAEwVDo6QWNjb3VudElkAAgcTQFUaGUgY2FsbGVyIGBvcmlnaW5gIHJlcGxhY2VzIGEgY2FuZGlkYXRlIGB0YXJnZXRgIGluIHRoZSBjb2xsYXRvciBjYW5kaWRhdGUgbGlzdCBieVUBcmVzZXJ2aW5nIGBkZXBvc2l0YC4gVGhlIGFtb3VudCBgZGVwb3NpdGAgcmVzZXJ2ZWQgYnkgdGhlIGNhbGxlciBtdXN0IGJlIGdyZWF0ZXIgdGhhbuB0aGUgZXhpc3RpbmcgYm9uZCBvZiB0aGUgdGFyZ2V0IGl0IGlzIHRyeWluZyB0byByZXBsYWNlLgBZAVRoaXMgY2FsbCB3aWxsIGZhaWwgaWYgdGhlIGNhbGxlciBpcyBhbHJlYWR5IGEgY29sbGF0b3IgY2FuZGlkYXRlIG9yIGludnVsbmVyYWJsZSwgdGhlVQFjYWxsZXIgZG9lcyBub3QgaGF2ZSByZWdpc3RlcmVkIHNlc3Npb24ga2V5cywgdGhlIHRhcmdldCBpcyBub3QgYSBjb2xsYXRvciBjYW5kaWRhdGUsvGFuZC9vciB0aGUgYGRlcG9zaXRgIGFtb3VudCBjYW5ub3QgYmUgcmVzZXJ2ZWQuBA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLkEGDDhwYWxsZXRfc2Vzc2lvbhhwYWxsZXQQQ2FsbAQEVAABCCBzZXRfa2V5cwgBEGtleXNFBgEcVDo6S2V5cwABFHByb29mOAEcVmVjPHU4PgAAJORTZXRzIHRoZSBzZXNzaW9uIGtleShzKSBvZiB0aGUgZnVuY3Rpb24gY2FsbGVyIHRvIGBrZXlzYC4dAUFsbG93cyBhbiBhY2NvdW50IHRvIHNldCBpdHMgc2Vzc2lvbiBrZXkgcHJpb3IgdG8gYmVjb21pbmcgYSB2YWxpZGF0b3IuwFRoaXMgZG9lc24ndCB0YWtlIGVmZmVjdCB1bnRpbCB0aGUgbmV4dCBzZXNzaW9uLgDQVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgc2lnbmVkLgA0IyMgQ29tcGxleGl0eVkBLSBgTygxKWAuIEFjdHVhbCBjb3N0IGRlcGVuZHMgb24gdGhlIG51bWJlciBvZiBsZW5ndGggb2YgYFQ6OktleXM6OmtleV9pZHMoKWAgd2hpY2ggaXMgICBmaXhlZC4ocHVyZ2Vfa2V5cwABMMhSZW1vdmVzIGFueSBzZXNzaW9uIGtleShzKSBvZiB0aGUgZnVuY3Rpb24gY2FsbGVyLgDAVGhpcyBkb2Vzbid0IHRha2UgZWZmZWN0IHVudGlsIHRoZSBuZXh0IHNlc3Npb24uAFUBVGhlIGRpc3BhdGNoIG9yaWdpbiBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgU2lnbmVkIGFuZCB0aGUgYWNjb3VudCBtdXN0IGJlIGVpdGhlciBiZV0BY29udmVydGlibGUgdG8gYSB2YWxpZGF0b3IgSUQgdXNpbmcgdGhlIGNoYWluJ3MgdHlwaWNhbCBhZGRyZXNzaW5nIHN5c3RlbSAodGhpcyB1c3VhbGx5UQFtZWFucyBiZWluZyBhIGNvbnRyb2xsZXIgYWNjb3VudCkgb3IgZGlyZWN0bHkgY29udmVydGlibGUgaW50byBhIHZhbGlkYXRvciBJRCAod2hpY2iUdXN1YWxseSBtZWFucyBiZWluZyBhIHN0YXNoIGFjY291bnQpLgA0IyMgQ29tcGxleGl0eT0BLSBgTygxKWAgaW4gbnVtYmVyIG9mIGtleSB0eXBlcy4gQWN0dWFsIGNvc3QgZGVwZW5kcyBvbiB0aGUgbnVtYmVyIG9mIGxlbmd0aCBvZpggIGBUOjpLZXlzOjprZXlfaWRzKClgIHdoaWNoIGlzIGZpeGVkLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5FBgw8aHlkcmFkeF9ydW50aW1lGG9wYXF1ZSxTZXNzaW9uS2V5cwAABAEQYXVyYUkGAcQ8QXVyYSBhcyAkY3JhdGU6OkJvdW5kVG9SdW50aW1lQXBwUHVibGljPjo6UHVibGljAABJBhBEc3BfY29uc2Vuc3VzX2F1cmEcc3IyNTUxOSxhcHBfc3IyNTUxORhQdWJsaWMAAAQABAE8c3IyNTUxOTo6UHVibGljAABNBgwscGFsbGV0X2lzbXAYcGFsbGV0EENhbGwEBFQAARA8aGFuZGxlX3Vuc2lnbmVkBAEgbWVzc2FnZXNRBgEwVmVjPE1lc3NhZ2U+AAAoWQFFeGVjdXRlIHRoZSBwcm92aWRlZCBiYXRjaCBvZiBJU01QIG1lc3NhZ2VzLCB0aGlzIHdpbGwgc2hvcnQtY2lyY3VpdCBhbmQgcmV2ZXJ0IGlmIGFueV0Bb2YgdGhlIHByb3ZpZGVkIG1lc3NhZ2VzIGFyZSBpbnZhbGlkLiBUaGlzIGlzIGFuIHVuc2lnbmVkIGV4dHJpbnNpYyB0aGF0IHBlcm1pdHMgYW55b25lVQFleGVjdXRlIElTTVAgbWVzc2FnZXMgZm9yIGZyZWUsIHByb3ZpZGVkIHRoZXkgaGF2ZSB2YWxpZCBwcm9vZnMgYW5kIHRoZSBtZXNzYWdlcyBoYXZleG5vdCBiZWVuIHByZXZpb3VzbHkgcHJvY2Vzc2VkLgDoVGhlIGRpc3BhdGNoIG9yaWdpbiBmb3IgdGhpcyBjYWxsIG11c3QgYmUgYW4gdW5zaWduZWQgb25lLgDALSBgbWVzc2FnZXNgOiB0aGUgbWVzc2FnZXMgdG8gaGFuZGxlIG9yIHByb2Nlc3MuAC0BRW1pdHMgZGlmZmVyZW50IG1lc3NhZ2UgZXZlbnRzIGJhc2VkIG9uIHRoZSBNZXNzYWdlIHJlY2VpdmVkIGlmIHN1Y2Nlc3NmdWwuXGNyZWF0ZV9jb25zZW5zdXNfY2xpZW50BAEcbWVzc2FnZbUGAVBDcmVhdGVDb25zZW5zdXNTdGF0ZQACHFUBQ3JlYXRlIGEgY29uc2Vuc3VzIGNsaWVudCwgdXNpbmcgYSBzdWJqZWN0aXZlbHkgY2hvc2VuIGNvbnNlbnN1cyBzdGF0ZS4gVGhpcyBjYW4gYWxzbzkBYmUgdXNlZCB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgY29uc2Vuc3VzIHN0YXRlLiBUaGUgZGlzcGF0Y2ggb3JpZ2luIGZvciB0aGlzeGNhbGwgbXVzdCBiZSBgVDo6QWRtaW5PcmlnaW5gLgC0LSBgbWVzc2FnZWA6IFtgQ3JlYXRlQ29uc2Vuc3VzU3RhdGVgXSBzdHJ1Y3QuANhFbWl0cyBbYEV2ZW50OjpDb25zZW5zdXNDbGllbnRDcmVhdGVkYF0gaWYgc3VjY2Vzc2Z1bC5YdXBkYXRlX2NvbnNlbnN1c19zdGF0ZQQBHG1lc3NhZ2XVBgFQVXBkYXRlQ29uc2Vuc3VzU3RhdGUAAxAdAU1vZGlmeSB0aGUgdW5ib25kaW5nIHBlcmlvZCBhbmQgY2hhbGxlbmdlIHBlcmlvZCBmb3IgYSBjb25zZW5zdXMgc3RhdGUu7FRoZSBkaXNwYXRjaCBvcmlnaW4gZm9yIHRoaXMgY2FsbCBtdXN0IGJlIGBUOjpBZG1pbk9yaWdpbmAuAKwtIGBtZXNzYWdlYDogYFVwZGF0ZUNvbnNlbnN1c1N0YXRlYCBzdHJ1Y3QuMGZ1bmRfbWVzc2FnZQQBHG1lc3NhZ2XdBgF0RnVuZE1lc3NhZ2VQYXJhbXM8VDo6QmFsYW5jZT4ABBBhAUFkZCBtb3JlIGZ1bmRzIHRvIGEgbWVzc2FnZSAocmVxdWVzdCBvciByZXNwb25zZSkgdG8gYmUgdXNlZCBmb3IgZGVsaXZlcnkgYW5kIGV4ZWN1dGlvbi4AVQFTaG91bGQgbm90IGJlIGNhbGxlZCBvbiBhIG1lc3NhZ2UgdGhhdCBoYXMgYmVlbiBjb21wbGV0ZWQgKGRlbGl2ZXJlZCBvciB0aW1lZC1vdXQpIGFzhHRob3NlIGZ1bmRzIHdpbGwgYmUgbG9zdCBmb3JldmVyLgQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5RBgAAAlUGAFUGDBBpc21wJG1lc3NhZ2luZxxNZXNzYWdlAAEUJENvbnNlbnN1cwQAWQYBQENvbnNlbnN1c01lc3NhZ2UAAAAoRnJhdWRQcm9vZgQAXQYBREZyYXVkUHJvb2ZNZXNzYWdlAAEAHFJlcXVlc3QEAGEGAThSZXF1ZXN0TWVzc2FnZQACACBSZXNwb25zZQQAfQYBPFJlc3BvbnNlTWVzc2FnZQADABxUaW1lb3V0BACtBgE4VGltZW91dE1lc3NhZ2UABAAAWQYMEGlzbXAkbWVzc2FnaW5nQENvbnNlbnN1c01lc3NhZ2UAAAwBPGNvbnNlbnN1c19wcm9vZjgBHFZlYzx1OD4AAUhjb25zZW5zdXNfc3RhdGVfaWRIAUBDb25zZW5zdXNTdGF0ZUlkAAEYc2lnbmVyOAEcVmVjPHU4PgAAXQYMEGlzbXAkbWVzc2FnaW5nREZyYXVkUHJvb2ZNZXNzYWdlAAAMARxwcm9vZl8xOAEcVmVjPHU4PgABHHByb29mXzI4ARxWZWM8dTg+AAFIY29uc2Vuc3VzX3N0YXRlX2lkSAFAQ29uc2Vuc3VzU3RhdGVJZAAAYQYMEGlzbXAkbWVzc2FnaW5nOFJlcXVlc3RNZXNzYWdlAAAMASByZXF1ZXN0c2UGAUBWZWM8UG9zdFJlcXVlc3Q+AAEUcHJvb2ZxBgEUUHJvb2YAARhzaWduZXI4ARxWZWM8dTg+AABlBgAAAmkGAGkGDBBpc21wGHJvdXRlcixQb3N0UmVxdWVzdAAAHAEYc291cmNlbQYBMFN0YXRlTWFjaGluZQABEGRlc3RtBgEwU3RhdGVNYWNoaW5lAAEUbm9uY2UwAQx1NjQAARBmcm9tOAEcVmVjPHU4PgABCHRvOAEcVmVjPHU4PgABRHRpbWVvdXRfdGltZXN0YW1wMAEMdTY0AAEQYm9keTgBHFZlYzx1OD4AAG0GDBBpc21wEGhvc3QwU3RhdGVNYWNoaW5lAAEUDEV2bQQAEAEMdTMyAAAAIFBvbGthZG90BAAQAQx1MzIAAQAYS3VzYW1hBAAQAQx1MzIAAgAkU3Vic3RyYXRlBABIAUBDb25zZW5zdXNTdGF0ZUlkAAMAKFRlbmRlcm1pbnQEAEgBQENvbnNlbnN1c1N0YXRlSWQABAAAcQYMEGlzbXAkbWVzc2FnaW5nFFByb29mAAAIARhoZWlnaHR1BgFIU3RhdGVNYWNoaW5lSGVpZ2h0AAEUcHJvb2Y4ARxWZWM8dTg+AAB1BgwQaXNtcCRjb25zZW5zdXNIU3RhdGVNYWNoaW5lSGVpZ2h0AAAIAQhpZHkGAThTdGF0ZU1hY2hpbmVJZAABGGhlaWdodDABDHU2NAAAeQYMEGlzbXAkY29uc2Vuc3VzOFN0YXRlTWFjaGluZUlkAAAIASBzdGF0ZV9pZG0GATBTdGF0ZU1hY2hpbmUAAUhjb25zZW5zdXNfc3RhdGVfaWRIAUBDb25zZW5zdXNTdGF0ZUlkAAB9BgwQaXNtcCRtZXNzYWdpbmc8UmVzcG9uc2VNZXNzYWdlAAAMASBkYXRhZ3JhbYEGATxSZXF1ZXN0UmVzcG9uc2UAARRwcm9vZnEGARRQcm9vZgABGHNpZ25lcjgBHFZlYzx1OD4AAIEGDBBpc21wGHJvdXRlcjxSZXF1ZXN0UmVzcG9uc2UAAQgcUmVxdWVzdAQAhQYBMFZlYzxSZXF1ZXN0PgAAACBSZXNwb25zZQQAkQYBNFZlYzxSZXNwb25zZT4AAQAAhQYAAAKJBgCJBgwQaXNtcBhyb3V0ZXIcUmVxdWVzdAABCBBQb3N0BABpBgEsUG9zdFJlcXVlc3QAAAAMR2V0BACNBgEoR2V0UmVxdWVzdAABAACNBgwQaXNtcBhyb3V0ZXIoR2V0UmVxdWVzdAAAIAEYc291cmNlbQYBMFN0YXRlTWFjaGluZQABEGRlc3RtBgEwU3RhdGVNYWNoaW5lAAEUbm9uY2UwAQx1NjQAARBmcm9tOAEcVmVjPHU4PgABEGtleXMhAQEwVmVjPFZlYzx1OD4+AAEYaGVpZ2h0MAEMdTY0AAEcY29udGV4dDgBHFZlYzx1OD4AAUR0aW1lb3V0X3RpbWVzdGFtcDABDHU2NAAAkQYAAAKVBgCVBgwQaXNtcBhyb3V0ZXIgUmVzcG9uc2UAAQgQUG9zdAQAmQYBMFBvc3RSZXNwb25zZQAAAAxHZXQEAJ0GASxHZXRSZXNwb25zZQABAACZBgwQaXNtcBhyb3V0ZXIwUG9zdFJlc3BvbnNlAAAMARBwb3N0aQYBLFBvc3RSZXF1ZXN0AAEgcmVzcG9uc2U4ARxWZWM8dTg+AAFEdGltZW91dF90aW1lc3RhbXAwAQx1NjQAAJ0GDBBpc21wGHJvdXRlcixHZXRSZXNwb25zZQAACAEMZ2V0jQYBKEdldFJlcXVlc3QAARh2YWx1ZXOhBgFEVmVjPFN0b3JhZ2VWYWx1ZT4AAKEGAAACpQYApQYMEGlzbXAYcm91dGVyMFN0b3JhZ2VWYWx1ZQAACAEMa2V5OAEcVmVjPHU4PgABFHZhbHVlqQYBPE9wdGlvbjxWZWM8dTg+PgAAqQYEGE9wdGlvbgQEVAE4AQgQTm9uZQAAABBTb21lBAA4AAABAACtBgwQaXNtcCRtZXNzYWdpbmc4VGltZW91dE1lc3NhZ2UAAQwQUG9zdAgBIHJlcXVlc3RzhQYBMFZlYzxSZXF1ZXN0PgABNHRpbWVvdXRfcHJvb2ZxBgEUUHJvb2YAAAAwUG9zdFJlc3BvbnNlCAEkcmVzcG9uc2VzsQYBRFZlYzxQb3N0UmVzcG9uc2U+AAE0dGltZW91dF9wcm9vZnEGARRQcm9vZgABAAxHZXQEASByZXF1ZXN0c4UGATBWZWM8UmVxdWVzdD4AAgAAsQYAAAKZBgC1BgwQaXNtcCRtZXNzYWdpbmdQQ3JlYXRlQ29uc2Vuc3VzU3RhdGUAABgBPGNvbnNlbnN1c19zdGF0ZTgBHFZlYzx1OD4AAUxjb25zZW5zdXNfY2xpZW50X2lkSAFEQ29uc2Vuc3VzQ2xpZW50SWQAAUhjb25zZW5zdXNfc3RhdGVfaWRIAUBDb25zZW5zdXNTdGF0ZUlkAAFAdW5ib25kaW5nX3BlcmlvZDABDHU2NAABRGNoYWxsZW5nZV9wZXJpb2RzuQYBbEJUcmVlTWFwPFN0YXRlTWFjaGluZSwgdTY0PgABZHN0YXRlX21hY2hpbmVfY29tbWl0bWVudHPFBgGwVmVjPChTdGF0ZU1hY2hpbmVJZCwgU3RhdGVDb21taXRtZW50SGVpZ2h0KT4AALkGBCBCVHJlZU1hcAgESwFtBgRWATAABAC9BgAAAL0GAAACwQYAwQYAAAQIbQYwAMUGAAACyQYAyQYAAAQIeQbNBgDNBgwQaXNtcCRtZXNzYWdpbmdUU3RhdGVDb21taXRtZW50SGVpZ2h0AAAIAShjb21taXRtZW500QYBPFN0YXRlQ29tbWl0bWVudAABGGhlaWdodDABDHU2NAAA0QYMEGlzbXAkY29uc2Vuc3VzPFN0YXRlQ29tbWl0bWVudAAADAEkdGltZXN0YW1wMAEMdTY0AAEwb3ZlcmxheV9yb290hQIBME9wdGlvbjxIMjU2PgABKHN0YXRlX3Jvb3Q0ARBIMjU2AADVBgwscGFsbGV0X2lzbXAUdXRpbHNQVXBkYXRlQ29uc2Vuc3VzU3RhdGUAAAwBSGNvbnNlbnN1c19zdGF0ZV9pZEgBQENvbnNlbnN1c1N0YXRlSWQAAUB1bmJvbmRpbmdfcGVyaW9k2QYBLE9wdGlvbjx1NjQ+AAFEY2hhbGxlbmdlX3BlcmlvZHO5BgFsQlRyZWVNYXA8U3RhdGVNYWNoaW5lLCB1NjQ+AADZBgQYT3B0aW9uBARUATABCBBOb25lAAAAEFNvbWUEADAAAAEAAN0GDCxwYWxsZXRfaXNtcBR1dGlsc0RGdW5kTWVzc2FnZVBhcmFtcwQcQmFsYW5jZQEYAAgBKGNvbW1pdG1lbnThBgFETWVzc2FnZUNvbW1pdG1lbnQAARhhbW91bnQYARxCYWxhbmNlAADhBgwscGFsbGV0X2lzbXAUdXRpbHNETWVzc2FnZUNvbW1pdG1lbnQAAQgcUmVxdWVzdAQANAEQSDI1NgAAACBSZXNwb25zZQQANAEQSDI1NgABAADlBgw4aXNtcF9wYXJhY2hhaW4YcGFsbGV0EENhbGwEBFQAAQxodXBkYXRlX3BhcmFjaGFpbl9jb25zZW5zdXMEARBkYXRhWQYBQENvbnNlbnN1c01lc3NhZ2UAAAhFAVRoaXMgYWxsb3dzIGJsb2NrIGJ1aWxkZXJzIHN1Ym1pdCBwYXJhY2hhaW4gY29uc2Vuc3VzIHByb29mcyBhcyBpbmhlcmVudHMuIElmIHRoZSkBcHJvdmlkZWQgW2BDb25zZW5zdXNNZXNzYWdlYF0gaXMgbm90IGZvciBhIHBhcmFjaGFpbiwgdGhpcyBjYWxsIHdpbGwgZmFpbC40YWRkX3BhcmFjaGFpbgQBIHBhcmFfaWRz6QYBSFZlYzxQYXJhY2hhaW5EYXRhPgABBMxBZGQgc29tZSBuZXcgcGFyYWNoYWlucyB0byB0aGUgcGFyYWNoYWlucyB3aGl0ZWxpc3RAcmVtb3ZlX3BhcmFjaGFpbgQBIHBhcmFfaWRzWQMBIFZlYzx1MzI+AAIE1FJlbW92ZXMgc29tZSBwYXJhY2hhaW5zIGZyb20gdGhlIHBhcmFjaGFpbnMgd2hpdGVsaXN0BA0BQ29udGFpbnMgYSB2YXJpYW50IHBlciBkaXNwYXRjaGFibGUgZXh0cmluc2ljIHRoYXQgdGhpcyBwYWxsZXQgaGFzLukGAAAC7QYA7QYIOGlzbXBfcGFyYWNoYWluNFBhcmFjaGFpbkRhdGEAAAgBCGlkEAEMdTMyAAE0c2xvdF9kdXJhdGlvbjABDHU2NAAA8QYMUHBhbGxldF90b2tlbl9nYXRld2F5GHBhbGxldBBDYWxsBARUAAEUIHRlbGVwb3J0BAEYcGFyYW1z9QYBeQFUZWxlcG9ydFBhcmFtczxBc3NldElkPFQ+LDw8VCBhcyBDb25maWc+OjpOYXRpdmVDdXJyZW5jeSBhcwpDdXJyZW5jeTxUOjpBY2NvdW50SWQ+Pjo6QmFsYW5jZSw+AAAIcFRlbGVwb3J0cyBhIHJlZ2lzdGVyZWQgYXNzZXQxAWxvY2tzIHRoZSBhc3NldCBhbmQgZGlzcGF0Y2hlcyBhIHJlcXVlc3QgdG8gdG9rZW4gZ2F0ZXdheSBvbiB0aGUgZGVzdGluYXRpb25sc2V0X3Rva2VuX2dhdGV3YXlfYWRkcmVzc2VzBAEkYWRkcmVzc2Vz+QYBfEJUcmVlTWFwPFN0YXRlTWFjaGluZSwgVmVjPHU4Pj4AAQTIU2V0IHRoZSB0b2tlbiBnYXRld2F5IGFkZHJlc3MgZm9yIHNwZWNpZmllZCBjaGFpbnNQY3JlYXRlX2VyYzYxNjBfYXNzZXQEARRhc3NldAUHAXRBc3NldFJlZ2lzdHJhdGlvbjxBc3NldElkPFQ+PgACFCkBUmVnaXN0ZXJzIGEgbXVsdGktY2hhaW4gRVJDNjE2MCBhc3NldC4gVGhlIGFzc2V0IHNob3VsZCBub3QgYWxyZWFkeSBleGlzdC4AWQFUaGlzIHdvcmtzIGJ5IGRpc3BhdGNoaW5nIGEgcmVxdWVzdCB0byB0aGUgVG9rZW5HYXRld2F5IG1vZHVsZSBvbiBlYWNoIHJlcXVlc3RlZCBjaGFpblB0byBjcmVhdGUgdGhlIGFzc2V0LgEBYG5hdGl2ZWAgc2hvdWxkIGJlIHRydWUgaWYgdGhpcyBhc3NldCBvcmlnaW5hdGVzIGZyb20gdGhpcyBjaGFpblB1cGRhdGVfZXJjNjE2MF9hc3NldAQBFGFzc2V0JQcBSEdhdGV3YXlBc3NldFVwZGF0ZQADECkBUmVnaXN0ZXJzIGEgbXVsdGktY2hhaW4gRVJDNjE2MCBhc3NldC4gVGhlIGFzc2V0IHNob3VsZCBub3QgYWxyZWFkeSBleGlzdC4AWQFUaGlzIHdvcmtzIGJ5IGRpc3BhdGNoaW5nIGEgcmVxdWVzdCB0byB0aGUgVG9rZW5HYXRld2F5IG1vZHVsZSBvbiBlYWNoIHJlcXVlc3RlZCBjaGFpblB0byBjcmVhdGUgdGhlIGFzc2V0Llh1cGRhdGVfYXNzZXRfcHJlY2lzaW9uBAEYdXBkYXRlOQcBbFByZWNpc2lvblVwZGF0ZTxBc3NldElkPFQ+PgAEBKhVcGRhdGUgdGhlIHByZWNpc2lvbiBmb3IgYW4gZXhpc3RpbmcgYXNzZXQEDQFDb250YWlucyBhIHZhcmlhbnQgcGVyIGRpc3BhdGNoYWJsZSBleHRyaW5zaWMgdGhhdCB0aGlzIHBhbGxldCBoYXMu9QYMUHBhbGxldF90b2tlbl9nYXRld2F5FHR5cGVzOFRlbGVwb3J0UGFyYW1zCBxBc3NldElkARAcQmFsYW5jZQEYACQBIGFzc2V0X2lkEAEcQXNzZXRJZAABLGRlc3RpbmF0aW9ubQYBMFN0YXRlTWFjaGluZQABJHJlY2VwaWVudDQBEEgyNTYAARhhbW91bnQYARxCYWxhbmNlAAEcdGltZW91dDABDHU2NAABNHRva2VuX2dhdGV3YXk4ARxWZWM8dTg+AAEscmVsYXllcl9mZWUYARxCYWxhbmNlAAEkY2FsbF9kYXRhqQYBPE9wdGlvbjxWZWM8dTg+PgABGHJlZGVlbSABEGJvb2wAAPkGBCBCVHJlZU1hcAgESwFtBgRWATgABAD9BgAAAP0GAAACAQcAAQcAAAQIbQY4AAUHDFBwYWxsZXRfdG9rZW5fZ2F0ZXdheRR0eXBlc0RBc3NldFJlZ2lzdHJhdGlvbgQcQXNzZXRJZAEQABABIGxvY2FsX2lkEAEcQXNzZXRJZAABDHJlZwkHAch0b2tlbl9nYXRld2F5X3ByaW1pdGl2ZXM6OkdhdGV3YXlBc3NldFJlZ2lzdHJhdGlvbgABGG5hdGl2ZSABEGJvb2wAASRwcmVjaXNpb24ZBwFoQlRyZWVNYXA8U3RhdGVNYWNoaW5lLCB1OD4AAAkHCGB0b2tlbl9nYXRld2F5X3ByaW1pdGl2ZXNgR2F0ZXdheUFzc2V0UmVnaXN0cmF0aW9uAAAQARBuYW1lDQcBcEJvdW5kZWRWZWM8dTgsIENvbnN0VTMyPDUwPj4AARhzeW1ib2wRBwFwQm91bmRlZFZlYzx1OCwgQ29uc3RVMzI8MjA+PgABGGNoYWlucxUHAURWZWM8U3RhdGVNYWNoaW5lPgABPG1pbmltdW1fYmFsYW5jZeABME9wdGlvbjx1MTI4PgAADQcMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AAARBwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQgEUwAABAA4ARhWZWM8VD4AABUHAAACbQYAGQcEIEJUcmVlTWFwCARLAW0GBFYBCAAEAB0HAAAAHQcAAAIhBwAhBwAABAhtBggAJQcIYHRva2VuX2dhdGV3YXlfcHJpbWl0aXZlc0hHYXRld2F5QXNzZXRVcGRhdGUAABABIGFzc2V0X2lkNAEQSDI1NgABKGFkZF9jaGFpbnMpBwGcQm91bmRlZFZlYzxTdGF0ZU1hY2hpbmUsIENvbnN0VTMyPDEwMD4+AAE0cmVtb3ZlX2NoYWlucykHAZxCb3VuZGVkVmVjPFN0YXRlTWFjaGluZSwgQ29uc3RVMzI8MTAwPj4AAShuZXdfYWRtaW5zLQcBvEJvdW5kZWRWZWM8KFN0YXRlTWFjaGluZSwgSDE2MCksIENvbnN0VTMyPDEwMD4+AAApBwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAW0GBFMAAAQAFQcBGFZlYzxUPgAALQcMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAExBwRTAAAEADUHARhWZWM8VD4AADEHAAAECG0GQQEANQcAAAIxBwA5BwxQcGFsbGV0X3Rva2VuX2dhdGV3YXkUdHlwZXM8UHJlY2lzaW9uVXBkYXRlBBxBc3NldElkARAACAEgYXNzZXRfaWQQARxBc3NldElkAAEocHJlY2lzaW9ucxkHAWhCVHJlZU1hcDxTdGF0ZU1hY2hpbmUsIHU4PgAAPQcMRHBhbGxldF9lbWFfb3JhY2xlGHBhbGxldBBDYWxsBARUAAEMKGFkZF9vcmFjbGUIARhzb3VyY2X9AQEYU291cmNlAAEYYXNzZXRzTQMBSChBc3NldElkLCBBc3NldElkKQAAADRyZW1vdmVfb3JhY2xlCAEYc291cmNl/QEBGFNvdXJjZQABGGFzc2V0c00DAUgoQXNzZXRJZCwgQXNzZXRJZCkAAQBUdXBkYXRlX2JpZnJvc3Rfb3JhY2xlDAEcYXNzZXRfYcUEAZBCb3g8cG9sa2Fkb3RfeGNtOjpWZXJzaW9uZWRMb2NhdGlvbj4AARxhc3NldF9ixQQBkEJveDxwb2xrYWRvdF94Y206OlZlcnNpb25lZExvY2F0aW9uPgABFHByaWNlKQMBSChCYWxhbmNlLCBCYWxhbmNlKQACAAQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5BBwxAcGFsbGV0X2Jyb2FkY2FzdBhwYWxsZXQQQ2FsbAQEVAABAAQNAUNvbnRhaW5zIGEgdmFyaWFudCBwZXIgZGlzcGF0Y2hhYmxlIGV4dHJpbnNpYyB0aGF0IHRoaXMgcGFsbGV0IGhhcy5FBwwoc3BfcnVudGltZRh0cmFpdHMsQmxha2VUd28yNTYAAAAASQcMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AABNBwxgcGFsbGV0X2NvbnZpY3Rpb25fdm90aW5nFHR5cGVzFFRhbGx5CBRWb3RlcwEYFFRvdGFsAAAMARBheWVzGAEUVm90ZXMAARBuYXlzGAEUVm90ZXMAARxzdXBwb3J0GAEUVm90ZXMAAFEHDEBwYWxsZXRfd2hpdGVsaXN0GHBhbGxldBRFdmVudAQEVAABDDxDYWxsV2hpdGVsaXN0ZWQEASRjYWxsX2hhc2g0ARxUOjpIYXNoAAAAWFdoaXRlbGlzdGVkQ2FsbFJlbW92ZWQEASRjYWxsX2hhc2g0ARxUOjpIYXNoAAEAZFdoaXRlbGlzdGVkQ2FsbERpc3BhdGNoZWQIASRjYWxsX2hhc2g0ARxUOjpIYXNoAAEYcmVzdWx0VQcBaERpc3BhdGNoUmVzdWx0V2l0aFBvc3RJbmZvAAIABHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0VQcEGFJlc3VsdAgEVAFZBwRFAWEHAQgIT2sEAFkHAAAAAAxFcnIEAGEHAAABAABZBww0ZnJhbWVfc3VwcG9ydCBkaXNwYXRjaEBQb3N0RGlzcGF0Y2hJbmZvAAAIATRhY3R1YWxfd2VpZ2h0XQcBOE9wdGlvbjxXZWlnaHQ+AAEgcGF5c19mZWVkARBQYXlzAABdBwQYT3B0aW9uBARUASgBCBBOb25lAAAAEFNvbWUEACgAAAEAAGEHCChzcF9ydW50aW1lZERpc3BhdGNoRXJyb3JXaXRoUG9zdEluZm8EEEluZm8BWQcACAEkcG9zdF9pbmZvWQcBEEluZm8AARRlcnJvcmgBNERpc3BhdGNoRXJyb3IAAGUHDERwYWxsZXRfZGlzcGF0Y2hlchhwYWxsZXQURXZlbnQEBFQAAQh0VHJlYXN1cnlNYW5hZ2VyQ2FsbERpc3BhdGNoZWQIASRjYWxsX2hhc2g0ARxUOjpIYXNoAAEYcmVzdWx0VQcBaERpc3BhdGNoUmVzdWx0V2l0aFBvc3RJbmZvAAAAZEFhdmVNYW5hZ2VyQ2FsbERpc3BhdGNoZWQIASRjYWxsX2hhc2g0ARxUOjpIYXNoAAEYcmVzdWx0VQcBaERpc3BhdGNoUmVzdWx0V2l0aFBvc3RJbmZvAAEABHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0aQcMVHBhbGxldF9hc3NldF9yZWdpc3RyeRhwYWxsZXQURXZlbnQEBFQAARhYRXhpc3RlbnRpYWxEZXBvc2l0UGFpZAwBDHdobwABMFQ6OkFjY291bnRJZAABJGZlZV9hc3NldBABKFQ6OkFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAAI0EV4aXN0ZW50aWFsIGRlcG9zaXQgZm9yIGluc3VmZmljaW5ldCBhc3NldCB3YXMgcGFpZC6cYFN1ZmZpY2llbmN5Q2hlY2tgIHRyaWdnZXJzIHRoaXMgZXZlbnQuKFJlZ2lzdGVyZWQgASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAShhc3NldF9uYW1l3QIBmE9wdGlvbjxCb3VuZGVkVmVjPHU4LCBUOjpTdHJpbmdMaW1pdD4+AAEoYXNzZXRfdHlwZeUCASRBc3NldFR5cGUAAUxleGlzdGVudGlhbF9kZXBvc2l0GAEcQmFsYW5jZQABOHhjbV9yYXRlX2xpbWl04AE8T3B0aW9uPEJhbGFuY2U+AAEYc3ltYm9s3QIBmE9wdGlvbjxCb3VuZGVkVmVjPHU4LCBUOjpTdHJpbmdMaW1pdD4+AAEgZGVjaW1hbHPpAgEoT3B0aW9uPHU4PgABNGlzX3N1ZmZpY2llbnQgARBib29sAAEEVEFzc2V0IHdhcyByZWdpc3RlcmVkLhxVcGRhdGVkIAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEoYXNzZXRfbmFtZd0CAZhPcHRpb248Qm91bmRlZFZlYzx1OCwgVDo6U3RyaW5nTGltaXQ+PgABKGFzc2V0X3R5cGXlAgEkQXNzZXRUeXBlAAFMZXhpc3RlbnRpYWxfZGVwb3NpdBgBHEJhbGFuY2UAATh4Y21fcmF0ZV9saW1pdOABPE9wdGlvbjxCYWxhbmNlPgABGHN5bWJvbN0CAZhPcHRpb248Qm91bmRlZFZlYzx1OCwgVDo6U3RyaW5nTGltaXQ+PgABIGRlY2ltYWxz6QIBKE9wdGlvbjx1OD4AATRpc19zdWZmaWNpZW50IAEQYm9vbAACBEhBc3NldCB3YXMgdXBkYXRlZC4sTG9jYXRpb25TZXQIASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAASBsb2NhdGlvbvECAVhUOjpBc3NldE5hdGl2ZUxvY2F0aW9uAAMEhE5hdGl2ZSBsb2NhdGlvbiBzZXQgZm9yIGFuIGFzc2V0LixBc3NldEJhbm5lZAQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAEBERBc3NldCB3YXMgYmFubmVkLjRBc3NldFVuYmFubmVkBAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAUEYEFzc2V0J3MgYmFuIHdhcyByZW1vdmVkLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldG0HDDRwYWxsZXRfY2xhaW1zGHBhbGxldBRFdmVudAQEVAABBBRDbGFpbQwAAAEwVDo6QWNjb3VudElkAABxBwE8RXRoZXJldW1BZGRyZXNzAAAYATBCYWxhbmNlT2Y8VD4AAAAEfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXRxBww0cGFsbGV0X2NsYWltcxh0cmFpdHM8RXRoZXJldW1BZGRyZXNzAAAEAEUBASBbdTg7IDIwXQAAdQcMXHBhbGxldF9jb2xsYXRvcl9yZXdhcmRzGHBhbGxldBRFdmVudAQEVAABBEBDb2xsYXRvclJld2FyZGVkDAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQABIGN1cnJlbmN5EAE0VDo6Q3VycmVuY3lJZAAABFhDb2xsYXRvciB3YXMgcmV3YXJkZWQuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0eQcMPHBhbGxldF9vbW5pcG9vbBhwYWxsZXQURXZlbnQEBFQAATQoVG9rZW5BZGRlZAwBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABOGluaXRpYWxfYW1vdW50GAEcQmFsYW5jZQABNGluaXRpYWxfcHJpY2U9AQEUUHJpY2UAAAR4QW4gYXNzZXQgd2FzIGFkZGVkIHRvIE9tbmlwb29sMFRva2VuUmVtb3ZlZAwBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAATRodWJfd2l0aGRyYXduGAEcQmFsYW5jZQABBIhBbiBhc3NldCB3YXMgcmVtb3ZlZCBmcm9tIE9tbmlwb29sOExpcXVpZGl0eUFkZGVkEAEMd2hvAAEwVDo6QWNjb3VudElkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEYYW1vdW50GAEcQmFsYW5jZQABLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQAAgSwTGlxdWlkaXR5IG9mIGFuIGFzc2V0IHdhcyBhZGRlZCB0byBPbW5pcG9vbC5ATGlxdWlkaXR5UmVtb3ZlZBQBDHdobwABMFQ6OkFjY291bnRJZAABLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAThzaGFyZXNfcmVtb3ZlZBgBHEJhbGFuY2UAAQxmZWU9AQEkRml4ZWRVMTI4AAMEwExpcXVpZGl0eSBvZiBhbiBhc3NldCB3YXMgcmVtb3ZlZCBmcm9tIE9tbmlwb29sLmBQcm90b2NvbExpcXVpZGl0eVJlbW92ZWQUAQx3aG8AATBUOjpBY2NvdW50SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAEoaHViX2Ftb3VudBgBHEJhbGFuY2UAAThzaGFyZXNfcmVtb3ZlZBgBHEJhbGFuY2UABAS0UFJvdG9jb2wgTGlxdWlkaXR5IHdhcyByZW1vdmVkIGZyb20gT21uaXBvb2wuMFNlbGxFeGVjdXRlZCQBDHdobwABMFQ6OkFjY291bnRJZAABIGFzc2V0X2luEAEoVDo6QXNzZXRJZAABJGFzc2V0X291dBABKFQ6OkFzc2V0SWQAASRhbW91bnRfaW4YARxCYWxhbmNlAAEoYW1vdW50X291dBgBHEJhbGFuY2UAATRodWJfYW1vdW50X2luGAEcQmFsYW5jZQABOGh1Yl9hbW91bnRfb3V0GAEcQmFsYW5jZQABQGFzc2V0X2ZlZV9hbW91bnQYARxCYWxhbmNlAAFMcHJvdG9jb2xfZmVlX2Ftb3VudBgBHEJhbGFuY2UABQhQU2VsbCB0cmFkZSBleGVjdXRlZC7ERGVwcmVjYXRlZC4gUmVwbGFjZWQgYnkgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZCxCdXlFeGVjdXRlZCQBDHdobwABMFQ6OkFjY291bnRJZAABIGFzc2V0X2luEAEoVDo6QXNzZXRJZAABJGFzc2V0X291dBABKFQ6OkFzc2V0SWQAASRhbW91bnRfaW4YARxCYWxhbmNlAAEoYW1vdW50X291dBgBHEJhbGFuY2UAATRodWJfYW1vdW50X2luGAEcQmFsYW5jZQABOGh1Yl9hbW91bnRfb3V0GAEcQmFsYW5jZQABQGFzc2V0X2ZlZV9hbW91bnQYARxCYWxhbmNlAAFMcHJvdG9jb2xfZmVlX2Ftb3VudBgBHEJhbGFuY2UABghMQnV5IHRyYWRlIGV4ZWN1dGVkLsREZXByZWNhdGVkLiBSZXBsYWNlZCBieSBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkPFBvc2l0aW9uQ3JlYXRlZBgBLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQAARRvd25lcgABMFQ6OkFjY291bnRJZAABFGFzc2V0EAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAARhzaGFyZXMYARxCYWxhbmNlAAEUcHJpY2U9AQEUUHJpY2UABwTATFAgUG9zaXRpb24gd2FzIGNyZWF0ZWQgYW5kIE5GVCBpbnN0YW5jZSBtaW50ZWQuRFBvc2l0aW9uRGVzdHJveWVkCAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAgEyExQIFBvc2l0aW9uIHdhcyBkZXN0cm95ZWQgYW5kIE5GVCBpbnN0YW5jZSBidXJuZWQuPFBvc2l0aW9uVXBkYXRlZBgBLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQAARRvd25lcgABMFQ6OkFjY291bnRJZAABFGFzc2V0EAEoVDo6QXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAARhzaGFyZXMYARxCYWxhbmNlAAEUcHJpY2U9AQEUUHJpY2UACQRgTFAgUG9zaXRpb24gd2FzIHVwZGF0ZWQuUFRyYWRhYmxlU3RhdGVVcGRhdGVkCAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEUc3RhdGUlAwEsVHJhZGFiaWxpdHkACgSgQXNzZXQncyB0cmFkYWJsZSBzdGF0ZSBoYXMgYmVlbiB1cGRhdGVkLjRBc3NldFJlZnVuZGVkDAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEYYW1vdW50GAEcQmFsYW5jZQABJHJlY2lwaWVudAABMFQ6OkFjY291bnRJZAALBEkBQW1vdW50IGhhcyBiZWVuIHJlZnVuZGVkIGZvciBhc3NldCB3aGljaCBoYXMgbm90IGJlZW4gYWNjZXB0ZWQgdG8gYWRkIHRvIG9tbmlwb29sLlRBc3NldFdlaWdodENhcFVwZGF0ZWQIASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAQxjYXAhAwEcUGVybWlsbAAMBJBBc3NldCdzIHdlaWdodCBjYXAgaGFzIGJlZW4gdXBkYXRlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXR9BwxgcGFsbGV0X3RyYW5zYWN0aW9uX3BhdXNlGHBhbGxldBRFdmVudAQEVAABCERUcmFuc2FjdGlvblBhdXNlZAgBRHBhbGxldF9uYW1lX2J5dGVzOAEcVmVjPHU4PgABTGZ1bmN0aW9uX25hbWVfYnl0ZXM4ARxWZWM8dTg+AAAESFBhdXNlZCB0cmFuc2FjdGlvbkxUcmFuc2FjdGlvblVucGF1c2VkCAFEcGFsbGV0X25hbWVfYnl0ZXM4ARxWZWM8dTg+AAFMZnVuY3Rpb25fbmFtZV9ieXRlczgBHFZlYzx1OD4AAQRQVW5wYXVzZWQgdHJhbnNhY3Rpb24EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSBBww0cGFsbGV0X2R1c3RlchhwYWxsZXQURXZlbnQEBFQAAQwYRHVzdGVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEcQmFsYW5jZQAABDxBY2NvdW50IGR1c3RlZC4UQWRkZWQEAQx3aG8AATBUOjpBY2NvdW50SWQAAQSMQWNjb3VudCBhZGRlZCB0byBub24tZHVzdGFibGUgbGlzdC4cUmVtb3ZlZAQBDHdobwABMFQ6OkFjY291bnRJZAACBJxBY2NvdW50IHJlbW92ZWQgZnJvbSBub24tZHVzdGFibGUgbGlzdC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSFBwxccGFsbGV0X2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0FEV2ZW50CARUAARJAAEMXEdsb2JhbEZhcm1BY2NSUFpVcGRhdGVkDAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATxhY2N1bXVsYXRlZF9ycHo9AQEkRml4ZWRVMTI4AAE4dG90YWxfc2hhcmVzX3oYARxCYWxhbmNlAAAE1Edsb2JhbCBmYXJtIGFjY3VtdWxhdGVkIHJld2FyZCBwZXIgc2hhcmUgd2FzIHVwZGF0ZWQuXFlpZWxkRmFybUFjY1JQVlNVcGRhdGVkEAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAUBhY2N1bXVsYXRlZF9ycHZzPQEBJEZpeGVkVTEyOAABTHRvdGFsX3ZhbHVlZF9zaGFyZXMYARxCYWxhbmNlAAEE7FlpZWxkIGZhcm0gYWNjdW11bGF0ZWQgcmV3YXJkIHBlciB2YWx1ZWQgc2hhcmUgd2FzIHVwZGF0ZWQuVEFsbFJld2FyZHNEaXN0cmlidXRlZAQBOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAIE8Edsb2JhbCBmYXJtIGhhcyBubyBtb3JlIHJld2FyZHMgdG8gZGlzdHJpYnV0ZSBpbiB0aGUgbW9tZW50LgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldIkHDIBwYWxsZXRfb21uaXBvb2xfbGlxdWlkaXR5X21pbmluZxhwYWxsZXQURXZlbnQEBFQAATRER2xvYmFsRmFybUNyZWF0ZWQoAQhpZBABMEdsb2JhbEZhcm1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAE0dG90YWxfcmV3YXJkcxgBHEJhbGFuY2UAATxyZXdhcmRfY3VycmVuY3kQAShUOjpBc3NldElkAAFAeWllbGRfcGVyX3BlcmlvZD0DASxQZXJxdWludGlsbAABYHBsYW5uZWRfeWllbGRpbmdfcGVyaW9kcxABLFBlcmlvZE9mPFQ+AAFEYmxvY2tzX3Blcl9wZXJpb2QQAURCbG9ja051bWJlckZvcjxUPgABVG1heF9yZXdhcmRfcGVyX3BlcmlvZBgBHEJhbGFuY2UAASxtaW5fZGVwb3NpdBgBHEJhbGFuY2UAAVRscm5hX3ByaWNlX2FkanVzdG1lbnQ9AQEkRml4ZWRVMTI4AAAEcE5ldyBnbG9iYWwgZmFybSB3YXMgY3JlYXRlZC5ER2xvYmFsRmFybVVwZGF0ZWQQAQhpZBABMEdsb2JhbEZhcm1JZAABYHBsYW5uZWRfeWllbGRpbmdfcGVyaW9kcxABLFBlcmlvZE9mPFQ+AAFAeWllbGRfcGVyX3BlcmlvZD0DASxQZXJxdWludGlsbAABLG1pbl9kZXBvc2l0GAEcQmFsYW5jZQABBFxHbG9iYWwgZmFybSB3YXMgdXBkYXRlZFBHbG9iYWxGYXJtVGVybWluYXRlZBABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAE8cmV3YXJkX2N1cnJlbmN5EAEoVDo6QXNzZXRJZAABVHVuZGlzdHJpYnV0ZWRfcmV3YXJkcxgBHEJhbGFuY2UAAgRsR2xvYmFsIGZhcm0gd2FzIHRlcm1pbmF0ZWQuQFlpZWxkRmFybUNyZWF0ZWQUAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIAATRsb3lhbHR5X2N1cnZlQQMBUE9wdGlvbjxMb3lhbHR5Q3VydmU+AAMElE5ldyB5aWVsZCBmYXJtIHdhcyBhZGRlZCB0byB0aGUgZmFybS5AWWllbGRGYXJtVXBkYXRlZBQBOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEobXVsdGlwbGllcj0BAThGYXJtTXVsdGlwbGllcgAEBIhZaWVsZCBmYXJtIG11bHRpcGxpZXIgd2FzIHVwZGF0ZWQuQFlpZWxkRmFybVN0b3BwZWQQAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABDHdobwABMFQ6OkFjY291bnRJZAAFBJhZaWVsZCBmYXJtIGZvciBgYXNzZXRfaWRgIHdhcyBzdG9wcGVkLkBZaWVsZEZhcm1SZXN1bWVkFAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAAShtdWx0aXBsaWVyPQEBOEZhcm1NdWx0aXBsaWVyAAYEmFlpZWxkIGZhcm0gZm9yIGBhc3NldF9pZGAgd2FzIHJlc3VtZWQuTFlpZWxkRmFybVRlcm1pbmF0ZWQQAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABDHdobwABMFQ6OkFjY291bnRJZAAHBLxZaWVsZCBmYXJtIHdhcyB0ZXJtaW5hdGVkIGZyb20gdGhlIGdsb2JhbCBmYXJtLjxTaGFyZXNEZXBvc2l0ZWQcAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABKGRlcG9zaXRfaWQYASREZXBvc2l0SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAATRzaGFyZXNfYW1vdW50GAEcQmFsYW5jZQABLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQACASoTmV3IExQIHNoYXJlcyhMUCBwb3NpdGlvbikgd2VyZSBkZXBvc2l0ZWQuRFNoYXJlc1JlZGVwb3NpdGVkHAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAShkZXBvc2l0X2lkGAEkRGVwb3NpdElkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEMd2hvAAEwVDo6QWNjb3VudElkAAE0c2hhcmVzX2Ftb3VudBgBHEJhbGFuY2UAASxwb3NpdGlvbl9pZBgBRFQ6OlBvc2l0aW9uSXRlbUlkAAkEAQFBbHJlYWR5IGxvY2tlZCBMUCBzaGFyZXMgd2VyZSByZWRlcG9zaXRlZCB0byBhbm90aGVyIHlpZWxkIGZhcm0uNFJld2FyZENsYWltZWQYAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABDHdobwABMFQ6OkFjY291bnRJZAABHGNsYWltZWQYARxCYWxhbmNlAAE8cmV3YXJkX2N1cnJlbmN5EAEoVDo6QXNzZXRJZAABKGRlcG9zaXRfaWQYASREZXBvc2l0SWQACgRUUmV3YXJkcyB3ZXJlIGNsYWltZWQuPFNoYXJlc1dpdGhkcmF3bhQBOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEcQmFsYW5jZQABKGRlcG9zaXRfaWQYASREZXBvc2l0SWQACwRkTFAgc2hhcmVzIHdlcmUgd2l0aGRyYXduLkBEZXBvc2l0RGVzdHJveWVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEoZGVwb3NpdF9pZBgBJERlcG9zaXRJZAAMBB0BQWxsIExQIHNoYXJlcyB3ZXJlIHVubG9ja2VkIGFuZCBORlQgcmVwcmVzZW50aW5nIGRlcG9zaXQgd2FzIGRlc3Ryb3llZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSNBwwocGFsbGV0X290YxhwYWxsZXQURXZlbnQEBFQAARAkQ2FuY2VsbGVkBAEgb3JkZXJfaWQQARxPcmRlcklkAAAEbEFuIE9yZGVyIGhhcyBiZWVuIGNhbmNlbGxlZBhGaWxsZWQUASBvcmRlcl9pZBABHE9yZGVySWQAAQx3aG8AATBUOjpBY2NvdW50SWQAASRhbW91bnRfaW4YARxCYWxhbmNlAAEoYW1vdW50X291dBgBHEJhbGFuY2UAAQxmZWUYARxCYWxhbmNlAAEIjEFuIE9yZGVyIGhhcyBiZWVuIGNvbXBsZXRlbHkgZmlsbGVkxERlcHJlY2F0ZWQuIFJlcGxhY2VkIGJ5IHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWQ8UGFydGlhbGx5RmlsbGVkFAEgb3JkZXJfaWQQARxPcmRlcklkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEkYW1vdW50X2luGAEcQmFsYW5jZQABKGFtb3VudF9vdXQYARxCYWxhbmNlAAEMZmVlGAEcQmFsYW5jZQACCIhBbiBPcmRlciBoYXMgYmVlbiBwYXJ0aWFsbHkgZmlsbGVkxERlcHJlY2F0ZWQuIFJlcGxhY2VkIGJ5IHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWQYUGxhY2VkGAEgb3JkZXJfaWQQARxPcmRlcklkAAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABJGFtb3VudF9pbhgBHEJhbGFuY2UAAShhbW91bnRfb3V0GAEcQmFsYW5jZQABSHBhcnRpYWxseV9maWxsYWJsZSABEGJvb2wAAwRgQW4gT3JkZXIgaGFzIGJlZW4gcGxhY2VkBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0kQcMWHBhbGxldF9jaXJjdWl0X2JyZWFrZXIYcGFsbGV0FEV2ZW50BARUAAEYXFRyYWRlVm9sdW1lTGltaXRDaGFuZ2VkCAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAFIdHJhZGVfdm9sdW1lX2xpbWl0TQMBKCh1MzIsIHUzMikAAASsVHJhZGUgdm9sdW1lIGxpbWl0IG9mIGFuIGFzc2V0IHdhcyBjaGFuZ2VkLmBBZGRMaXF1aWRpdHlMaW1pdENoYW5nZWQIASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAATxsaXF1aWRpdHlfbGltaXR1AwFIT3B0aW9uPCh1MzIsIHUzMik+AAEEsEFkZCBsaXF1aWRpdHkgbGltaXQgb2YgYW4gYXNzZXQgd2FzIGNoYW5nZWQubFJlbW92ZUxpcXVpZGl0eUxpbWl0Q2hhbmdlZAgBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABPGxpcXVpZGl0eV9saW1pdHUDAUhPcHRpb248KHUzMiwgdTMyKT4AAgS8UmVtb3ZlIGxpcXVpZGl0eSBsaW1pdCBvZiBhbiBhc3NldCB3YXMgY2hhbmdlZC40QXNzZXRMb2NrZG93bggBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABFHVudGlsEAFEQmxvY2tOdW1iZXJGb3I8VD4AAwRYQXNzZXQgd2VudCB0byBsb2NrZG93blBBc3NldExvY2tkb3duUmVtb3ZlZAQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAAEBGhBc3NldCBsb2NrZG93biB3YXMgcmVtb3ZlZDxEZXBvc2l0UmVsZWFzZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQABQSsQWxsIHJlc2VydmVkIGFtb3VudCBvZiBkZXBvc2l0IHdhcyByZWxlYXNlZAR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldJUHDFRwYWxsZXRfcm91dGVfZXhlY3V0b3IYcGFsbGV0FEV2ZW50BARUAAEIIEV4ZWN1dGVkFAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABJGFtb3VudF9pbhgBKFQ6OkJhbGFuY2UAAShhbW91bnRfb3V0GAEoVDo6QmFsYW5jZQABIGV2ZW50X2lkEAFESW5jcmVtZW50YWxJZFR5cGUAAATQVGhlIHJvdXRlIHdpdGggdHJhZGVzIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZDBSb3V0ZVVwZGF0ZWQEASRhc3NldF9pZHNZAwE8VmVjPFQ6OkFzc2V0SWQ+AAEE0FRoZSByb3V0ZSB3aXRoIHRyYWRlcyBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQEfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSZBwxMcGFsbGV0X2R5bmFtaWNfZmVlcxhwYWxsZXQURXZlbnQEBFQAAQhEQXNzZXRGZWVDb25maWdTZXQIASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAARhwYXJhbXOVAwFYQXNzZXRGZWVDb25maWc8VDo6RmVlPgAABJBBc3NldCBmZWUgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBzZXRUQXNzZXRGZWVDb25maWdSZW1vdmVkBAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEEoEFzc2V0IGZlZSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIHJlbW92ZWQEfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSdBww4cGFsbGV0X3N0YWtpbmcYcGFsbGV0FEV2ZW50BARUAAEYPFBvc2l0aW9uQ3JlYXRlZAwBDHdobwABMFQ6OkFjY291bnRJZAABLHBvc2l0aW9uX2lkGAFEVDo6UG9zaXRpb25JdGVtSWQAARRzdGFrZRgBHEJhbGFuY2UAAATQTmV3IHN0YWtpbmcgcG9zaXRpb24gd2FzIGNyZWF0ZWQgYW5kIE5GVCB3YXMgbWludGVkLihTdGFrZUFkZGVkHAEMd2hvAAEwVDo6QWNjb3VudElkAAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAABFHN0YWtlGAEcQmFsYW5jZQABLHRvdGFsX3N0YWtlGAEcQmFsYW5jZQABOGxvY2tlZF9yZXdhcmRzGAEcQmFsYW5jZQABOHNsYXNoZWRfcG9pbnRzGAEUUG9pbnQAAUhwYXlhYmxlX3BlcmNlbnRhZ2U9AQEkRml4ZWRVMTI4AAEEyFN0YWtlZCBhbW91bnQgZm9yIGV4aXN0aW5nIHBvc2l0aW9uIHdhcyBpbmNyZWFzZWQuOFJld2FyZHNDbGFpbWVkHAEMd2hvAAEwVDo6QWNjb3VudElkAAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAABMHBhaWRfcmV3YXJkcxgBHEJhbGFuY2UAAUB1bmxvY2tlZF9yZXdhcmRzGAEcQmFsYW5jZQABOHNsYXNoZWRfcG9pbnRzGAEUUG9pbnQAAVhzbGFzaGVkX3VucGFpZF9yZXdhcmRzGAEcQmFsYW5jZQABSHBheWFibGVfcGVyY2VudGFnZT0BASRGaXhlZFUxMjgAAgRUUmV3YXJkcyB3ZXJlIGNsYWltZWQuIFVuc3Rha2VkDAEMd2hvAAEwVDo6QWNjb3VudElkAAEscG9zaXRpb25faWQYAURUOjpQb3NpdGlvbkl0ZW1JZAABOHVubG9ja2VkX3N0YWtlGAEcQmFsYW5jZQADBLxTdGFrZWQgYW1vdW50IHdhcyB3aXRoZHJhd24gYW5kIE5GVCB3YXMgYnVybmVkLkhTdGFraW5nSW5pdGlhbGl6ZWQEAVBub25fZHVzdGFibGVfYmFsYW5jZRgBHEJhbGFuY2UABARgU3Rha2luZyB3YXMgaW5pdGlhbGl6ZWQuVEFjY3VtdWxhdGVkUnBzVXBkYXRlZAgBPGFjY3VtdWxhdGVkX3Jwcz0BASRGaXhlZFUxMjgAASx0b3RhbF9zdGFrZRgBHEJhbGFuY2UABQTUU3Rha2luZydzIGBhY2N1bXVsYXRlZF9yZXdhcmRfcGVyX3N0YWtlYCB3YXMgdXBkYXRlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXShBwxEcGFsbGV0X3N0YWJsZXN3YXAYcGFsbGV0FEV2ZW50BARUAAEsLFBvb2xDcmVhdGVkFAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAARhhc3NldHNZAwE8VmVjPFQ6OkFzc2V0SWQ+AAE0YW1wbGlmaWNhdGlvbqUHAShOb25aZXJvVTE2AAEMZmVlIQMBHFBlcm1pbGwAAQxwZWepBwF8T3B0aW9uPFBvb2xQZWdJbmZvPFQ6OkFzc2V0SWQ+PgAABExBIHBvb2wgd2FzIGNyZWF0ZWQuKEZlZVVwZGF0ZWQIARxwb29sX2lkEAEoVDo6QXNzZXRJZAABDGZlZSEDARxQZXJtaWxsAAEEaFBvb2wgZmVlIGhhcyBiZWVuIHVwZGF0ZWQuOExpcXVpZGl0eUFkZGVkEAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhzaGFyZXMYARxCYWxhbmNlAAEYYXNzZXRzZQMBcFZlYzxBc3NldEFtb3VudDxUOjpBc3NldElkPj4AAgSoTGlxdWlkaXR5IG9mIGFuIGFzc2V0IHdhcyBhZGRlZCB0byBhIHBvb2wuQExpcXVpZGl0eVJlbW92ZWQUARxwb29sX2lkEAEoVDo6QXNzZXRJZAABDHdobwABMFQ6OkFjY291bnRJZAABGHNoYXJlcxgBHEJhbGFuY2UAARxhbW91bnRzZQMBcFZlYzxBc3NldEFtb3VudDxUOjpBc3NldElkPj4AAQxmZWUYARxCYWxhbmNlAAMESExpcXVpZGl0eSByZW1vdmVkLjBTZWxsRXhlY3V0ZWQcAQx3aG8AATBUOjpBY2NvdW50SWQAARxwb29sX2lkEAEoVDo6QXNzZXRJZAABIGFzc2V0X2luEAEoVDo6QXNzZXRJZAABJGFzc2V0X291dBABKFQ6OkFzc2V0SWQAASRhbW91bnRfaW4YARxCYWxhbmNlAAEoYW1vdW50X291dBgBHEJhbGFuY2UAAQxmZWUYARxCYWxhbmNlAAQIjQFTZWxsIHRyYWRlIGV4ZWN1dGVkLiBUcmFkZSBmZWUgcGFpZCBpbiBhc3NldCBsZWF2aW5nIHRoZSBwb29sIChhbHJlYWR5IHN1YnRyYWN0ZWQgZnJvbSBhbW91bnRfb3V0KS7ERGVwcmVjYXRlZC4gUmVwbGFjZWQgYnkgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZCxCdXlFeGVjdXRlZBwBDHdobwABMFQ6OkFjY291bnRJZAABHHBvb2xfaWQQAShUOjpBc3NldElkAAEgYXNzZXRfaW4QAShUOjpBc3NldElkAAEkYXNzZXRfb3V0EAEoVDo6QXNzZXRJZAABJGFtb3VudF9pbhgBHEJhbGFuY2UAAShhbW91bnRfb3V0GAEcQmFsYW5jZQABDGZlZRgBHEJhbGFuY2UABQh5AUJ1eSB0cmFkZSBleGVjdXRlZC4gVHJhZGUgZmVlIHBhaWQgaW4gYXNzZXQgZW50ZXJpbmcgdGhlIHBvb2wgKGFscmVhZHkgaW5jbHVkZWQgaW4gYW1vdW50X2luKS7ERGVwcmVjYXRlZC4gUmVwbGFjZWQgYnkgcGFsbGV0X2Jyb2FkY2FzdDo6U3dhcHBlZFBUcmFkYWJsZVN0YXRlVXBkYXRlZAwBHHBvb2xfaWQQAShUOjpBc3NldElkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEUc3RhdGWpAwEsVHJhZGFiaWxpdHkABgSgQXNzZXQncyB0cmFkYWJsZSBzdGF0ZSBoYXMgYmVlbiB1cGRhdGVkLlRBbXBsaWZpY2F0aW9uQ2hhbmdpbmcUARxwb29sX2lkEAEoVDo6QXNzZXRJZAABVGN1cnJlbnRfYW1wbGlmaWNhdGlvbqUHAShOb25aZXJvVTE2AAFMZmluYWxfYW1wbGlmaWNhdGlvbqUHAShOb25aZXJvVTE2AAEsc3RhcnRfYmxvY2sQAURCbG9ja051bWJlckZvcjxUPgABJGVuZF9ibG9jaxABREJsb2NrTnVtYmVyRm9yPFQ+AAcE1EFtcGxpZmljYXRpb24gb2YgYSBwb29sIGhhcyBiZWVuIHNjaGVkdWxlZCB0byBjaGFuZ2UuNFBvb2xEZXN0cm95ZWQEARxwb29sX2lkEAEoVDo6QXNzZXRJZAAIBGhBIHBvb2wgaGFzIGJlZW4gZGVzdHJveWVkLlBQb29sUGVnU291cmNlVXBkYXRlZAwBHHBvb2xfaWQQAShUOjpBc3NldElkAAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEocGVnX3NvdXJjZbEDAVRQZWdTb3VyY2U8VDo6QXNzZXRJZD4ACQSEUG9vbCBwZWcgc291cmNlIGhhcyBiZWVuIHVwZGF0ZWQuXFBvb2xNYXhQZWdVcGRhdGVVcGRhdGVkCAEccG9vbF9pZBABKFQ6OkFzc2V0SWQAAThtYXhfcGVnX3VwZGF0ZcEDARxQZXJiaWxsAAoElFBvb2wgbWF4IHBlZyB1cGRhdGUgaGFzIGJlZW4gdXBkYXRlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSlBwQoTm9uWmVyb1UxNgAABADIAAAAqQcEGE9wdGlvbgQEVAGtBwEIEE5vbmUAAAAQU29tZQQArQcAAAEAAK0HDERwYWxsZXRfc3RhYmxlc3dhcBR0eXBlcyxQb29sUGVnSW5mbwQcQXNzZXRJZAEQAAwBGHNvdXJjZa0DAWhCb3VuZGVkUGVnU291cmNlczxBc3NldElkPgABOG1heF9wZWdfdXBkYXRlwQMBHFBlcmJpbGwAARxjdXJyZW50sQcBLEJvdW5kZWRQZWdzAACxBwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUASkDBFMAAAQAtQcBGFZlYzxUPgAAtQcAAAIpAwC5BwwwcGFsbGV0X2JvbmRzGHBhbGxldBRFdmVudAQEVAABDDBUb2tlbkNyZWF0ZWQQARhpc3N1ZXIAATBUOjpBY2NvdW50SWQAASBhc3NldF9pZBABHEFzc2V0SWQAARxib25kX2lkEAEcQXNzZXRJZAABIG1hdHVyaXR5MAEYTW9tZW50AAAEbEEgYm9uZCBhc3NldCB3YXMgcmVnaXN0ZXJlZBhJc3N1ZWQQARhpc3N1ZXIAATBUOjpBY2NvdW50SWQAARxib25kX2lkEAEcQXNzZXRJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UAAQxmZWUYAShUOjpCYWxhbmNlAAEEUE5ldyBib25kIHdlcmUgaXNzdWVkIFJlZGVlbWVkDAEMd2hvAAEwVDo6QWNjb3VudElkAAEcYm9uZF9pZBABHEFzc2V0SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAIETEJvbmRzIHdlcmUgcmVkZWVtZWQEfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXS9BwxYcGFsbGV0X290Y19zZXR0bGVtZW50cxhwYWxsZXQURXZlbnQEBFQAAQQgRXhlY3V0ZWQIASBhc3NldF9pZBABMEFzc2V0SWRPZjxUPgABGHByb2ZpdBgBHEJhbGFuY2UAAARkQSB0cmFkZSBoYXMgYmVlbiBleGVjdXRlZAR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldMEHDChwYWxsZXRfbGJwGHBhbGxldBRFdmVudAQEVAABGCxQb29sQ3JlYXRlZAgBEHBvb2wAASRQb29sSWQ8VD4AARBkYXRhxQcBlFBvb2w8VDo6QWNjb3VudElkLCBCbG9ja051bWJlckZvcjxUPj4AAASwUG9vbCB3YXMgY3JlYXRlZCBieSB0aGUgYENyZWF0ZVBvb2xgIG9yaWdpbi4sUG9vbFVwZGF0ZWQIARBwb29sAAEkUG9vbElkPFQ+AAEQZGF0YcUHAZRQb29sPFQ6OkFjY291bnRJZCwgQmxvY2tOdW1iZXJGb3I8VD4+AAEEXFBvb2wgZGF0YSB3ZXJlIHVwZGF0ZWQuOExpcXVpZGl0eUFkZGVkFAEMd2hvAAEwVDo6QWNjb3VudElkAAEcYXNzZXRfYRABHEFzc2V0SWQAARxhc3NldF9iEAEcQXNzZXRJZAABIGFtb3VudF9hGAEwQmFsYW5jZU9mPFQ+AAEgYW1vdW50X2IYATBCYWxhbmNlT2Y8VD4AAgScTmV3IGxpcXVpZGl0eSB3YXMgcHJvdmlkZWQgdG8gdGhlIHBvb2wuQExpcXVpZGl0eVJlbW92ZWQUAQx3aG8AATBUOjpBY2NvdW50SWQAARxhc3NldF9hEAEcQXNzZXRJZAABHGFzc2V0X2IQARxBc3NldElkAAEgYW1vdW50X2EYATBCYWxhbmNlT2Y8VD4AASBhbW91bnRfYhgBMEJhbGFuY2VPZjxUPgADBPxMaXF1aWRpdHkgd2FzIHJlbW92ZWQgZnJvbSB0aGUgcG9vbCBhbmQgdGhlIHBvb2wgd2FzIGRlc3Ryb3llZC4wU2VsbEV4ZWN1dGVkHAEMd2hvAAEwVDo6QWNjb3VudElkAAEgYXNzZXRfaW4QARxBc3NldElkAAEkYXNzZXRfb3V0EAEcQXNzZXRJZAABGGFtb3VudBgBMEJhbGFuY2VPZjxUPgABKHNhbGVfcHJpY2UYATBCYWxhbmNlT2Y8VD4AASRmZWVfYXNzZXQQARxBc3NldElkAAEoZmVlX2Ftb3VudBgBMEJhbGFuY2VPZjxUPgAECDhTYWxlIGV4ZWN1dGVkLsREZXByZWNhdGVkLiBSZXBsYWNlZCBieSBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkLEJ1eUV4ZWN1dGVkHAEMd2hvAAEwVDo6QWNjb3VudElkAAEkYXNzZXRfb3V0EAEcQXNzZXRJZAABIGFzc2V0X2luEAEcQXNzZXRJZAABGGFtb3VudBgBMEJhbGFuY2VPZjxUPgABJGJ1eV9wcmljZRgBMEJhbGFuY2VPZjxUPgABJGZlZV9hc3NldBABHEFzc2V0SWQAAShmZWVfYW1vdW50GAEwQmFsYW5jZU9mPFQ+AAUISFB1cmNoYXNlIGV4ZWN1dGVkLsREZXByZWNhdGVkLiBSZXBsYWNlZCBieSBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0xQcIKHBhbGxldF9sYnAQUG9vbAgkQWNjb3VudElkAQAsQmxvY2tOdW1iZXIBEAAoARRvd25lcgABJEFjY291bnRJZAABFHN0YXJ0WQEBTE9wdGlvbjxCbG9ja051bWJlcj4AAQxlbmRZAQFMT3B0aW9uPEJsb2NrTnVtYmVyPgABGGFzc2V0c00DAUgoQXNzZXRJZCwgQXNzZXRJZCkAAThpbml0aWFsX3dlaWdodBABJExCUFdlaWdodAABMGZpbmFsX3dlaWdodBABJExCUFdlaWdodAABMHdlaWdodF9jdXJ2ZdEDATxXZWlnaHRDdXJ2ZVR5cGUAAQxmZWVNAwEoKHUzMiwgdTMyKQABNGZlZV9jb2xsZWN0b3IAASRBY2NvdW50SWQAATByZXBheV90YXJnZXQYARxCYWxhbmNlAADJBwwocGFsbGV0X3h5axhwYWxsZXQURXZlbnQEBFQAARg4TGlxdWlkaXR5QWRkZWQUAQx3aG8AATBUOjpBY2NvdW50SWQAARxhc3NldF9hEAEcQXNzZXRJZAABHGFzc2V0X2IQARxBc3NldElkAAEgYW1vdW50X2EYARxCYWxhbmNlAAEgYW1vdW50X2IYARxCYWxhbmNlAAAEnE5ldyBsaXF1aWRpdHkgd2FzIHByb3ZpZGVkIHRvIHRoZSBwb29sLkBMaXF1aWRpdHlSZW1vdmVkEAEMd2hvAAEwVDo6QWNjb3VudElkAAEcYXNzZXRfYRABHEFzc2V0SWQAARxhc3NldF9iEAEcQXNzZXRJZAABGHNoYXJlcxgBHEJhbGFuY2UAAQSQTGlxdWlkaXR5IHdhcyByZW1vdmVkIGZyb20gdGhlIHBvb2wuLFBvb2xDcmVhdGVkGAEMd2hvAAEwVDo6QWNjb3VudElkAAEcYXNzZXRfYRABHEFzc2V0SWQAARxhc3NldF9iEAEcQXNzZXRJZAABVGluaXRpYWxfc2hhcmVzX2Ftb3VudBgBHEJhbGFuY2UAASxzaGFyZV90b2tlbhABHEFzc2V0SWQAARBwb29sAAEwVDo6QWNjb3VudElkAAIERFBvb2wgd2FzIGNyZWF0ZWQuNFBvb2xEZXN0cm95ZWQUAQx3aG8AATBUOjpBY2NvdW50SWQAARxhc3NldF9hEAEcQXNzZXRJZAABHGFzc2V0X2IQARxBc3NldElkAAEsc2hhcmVfdG9rZW4QARxBc3NldElkAAEQcG9vbAABMFQ6OkFjY291bnRJZAADBExQb29sIHdhcyBkZXN0cm95ZWQuMFNlbGxFeGVjdXRlZCABDHdobwABMFQ6OkFjY291bnRJZAABIGFzc2V0X2luEAEcQXNzZXRJZAABJGFzc2V0X291dBABHEFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAEoc2FsZV9wcmljZRgBHEJhbGFuY2UAASRmZWVfYXNzZXQQARxBc3NldElkAAEoZmVlX2Ftb3VudBgBHEJhbGFuY2UAARBwb29sAAEwVDo6QWNjb3VudElkAAQIUEFzc2V0IHNhbGUgZXhlY3V0ZWQuxERlcHJlY2F0ZWQuIFJlcGxhY2VkIGJ5IHBhbGxldF9icm9hZGNhc3Q6OlN3YXBwZWQsQnV5RXhlY3V0ZWQgAQx3aG8AATBUOjpBY2NvdW50SWQAASRhc3NldF9vdXQQARxBc3NldElkAAEgYXNzZXRfaW4QARxBc3NldElkAAEYYW1vdW50GAEcQmFsYW5jZQABJGJ1eV9wcmljZRgBHEJhbGFuY2UAASRmZWVfYXNzZXQQARxBc3NldElkAAEoZmVlX2Ftb3VudBgBHEJhbGFuY2UAARBwb29sAAEwVDo6QWNjb3VudElkAAUIYEFzc2V0IHB1cmNoYXNlIGV4ZWN1dGVkLsREZXByZWNhdGVkLiBSZXBsYWNlZCBieSBwYWxsZXRfYnJvYWRjYXN0OjpTd2FwcGVkBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0zQcMQHBhbGxldF9yZWZlcnJhbHMYcGFsbGV0FEV2ZW50BARUAAEYOENvZGVSZWdpc3RlcmVkCAEQY29kZeEDAWxSZWZlcnJhbENvZGU8VDo6Q29kZUxlbmd0aD4AARxhY2NvdW50AAEwVDo6QWNjb3VudElkAAAEiFJlZmVycmFsIGNvZGUgaGFzIGJlZW4gcmVnaXN0ZXJlZC4oQ29kZUxpbmtlZAwBHGFjY291bnQAATBUOjpBY2NvdW50SWQAARBjb2Rl4QMBbFJlZmVycmFsQ29kZTxUOjpDb2RlTGVuZ3RoPgABQHJlZmVycmFsX2FjY291bnQAATBUOjpBY2NvdW50SWQAAQSwUmVmZXJyYWwgY29kZSBoYXMgYmVlbiBsaW5rZWQgdG8gYW4gYWNjb3VudC4kQ29udmVydGVkCAEQZnJvbdEHAVxBc3NldEFtb3VudDxUOjpBc3NldElkPgABCHRv0QcBXEFzc2V0QW1vdW50PFQ6OkFzc2V0SWQ+AAIEoEFzc2V0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBSZXdhcmRBc3NldC4cQ2xhaW1lZAwBDHdobwABMFQ6OkFjY291bnRJZAABQHJlZmVycmVyX3Jld2FyZHMYARxCYWxhbmNlAAE0dHJhZGVfcmV3YXJkcxgBHEJhbGFuY2UAAwRAUmV3YXJkcyBjbGFpbWVkLkxBc3NldFJld2FyZHNVcGRhdGVkDAEgYXNzZXRfaWQQAShUOjpBc3NldElkAAEUbGV2ZWzlAwEUTGV2ZWwAARxyZXdhcmRz6QMBPEZlZURpc3RyaWJ1dGlvbgAEBHxOZXcgYXNzZXQgcmV3YXJkcyBoYXMgYmVlbiBzZXQuHExldmVsVXAIAQx3aG8AATBUOjpBY2NvdW50SWQAARRsZXZlbOUDARRMZXZlbAAFBGxSZWZlcnJlciByZWFjaGVkIG5ldyBsZXZlbC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXTRBwhAcGFsbGV0X3JlZmVycmFscyxBc3NldEFtb3VudAQcQXNzZXRJZAEQAAgBIGFzc2V0X2lkEAEcQXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAANUHDEhwYWxsZXRfbGlxdWlkYXRpb24YcGFsbGV0FEV2ZW50BARUAAEEKExpcXVpZGF0ZWQUARB1c2VyQQEBKEV2bUFkZHJlc3MAAUBjb2xsYXRlcmFsX2Fzc2V0EAEcQXNzZXRJZAABKGRlYnRfYXNzZXQQARxBc3NldElkAAE0ZGVidF90b19jb3ZlchgBHEJhbGFuY2UAARhwcm9maXQYARxCYWxhbmNlAAAEpE1vbmV5IG1hcmtldCBwb3NpdGlvbiBoYXMgYmVlbiBsaXF1aWRhdGVkBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV02QcMKHBhbGxldF9oc20YcGFsbGV0FEV2ZW50BARUAAEUPENvbGxhdGVyYWxBZGRlZBgBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABHHBvb2xfaWQQAShUOjpBc3NldElkAAEwcHVyY2hhc2VfZmVlIQMBHFBlcm1pbGwAAWRtYXhfYnV5X3ByaWNlX2NvZWZmaWNpZW50PQEBQENvZWZmaWNpZW50UmF0aW8AATBidXlfYmFja19mZWUhAwEcUGVybWlsbAABMGJ1eWJhY2tfcmF0ZcEDARxQZXJiaWxsAAAkgEEgbmV3IGNvbGxhdGVyYWwgYXNzZXQgd2FzIGFkZGVkACxQYXJhbWV0ZXJzOtQtIGBhc3NldF9pZGA6IFRoZSBJRCBvZiB0aGUgYXNzZXQgYWRkZWQgYXMgY29sbGF0ZXJhbPAtIGBwb29sX2lkYDogVGhlIFN0YWJsZVN3YXAgcG9vbCBJRCB3aGVyZSB0aGlzIGFzc2V0IGJlbG9uZ3MBAS0gYHB1cmNoYXNlX2ZlZWA6IEZlZSBhcHBsaWVkIHdoZW4gYnV5aW5nIEhvbGxhciB3aXRoIHRoaXMgYXNzZXRdAS0gYG1heF9idXlfcHJpY2VfY29lZmZpY2llbnRgOiBNYXhpbXVtIGJ1eSBwcmljZSBjb2VmZmljaWVudCBmb3IgSFNNIHRvIGJ1eSBiYWNrIEhvbGxhctQtIGBidXlfYmFja19mZWVgOiBGZWUgYXBwbGllZCB3aGVuIGJ1eWluZyBiYWNrIEhvbGxhcmEBLSBgYnV5YmFja19yYXRlYDogUGFyYW1ldGVyIHRoYXQgY29udHJvbHMgaG93IHF1aWNrbHkgSFNNIGNhbiBidXkgSG9sbGFyIHdpdGggdGhpcyBhc3NldERDb2xsYXRlcmFsUmVtb3ZlZAQBIGFzc2V0X2lkEAEoVDo6QXNzZXRJZAABEHhBIGNvbGxhdGVyYWwgYXNzZXQgd2FzIHJlbW92ZWQALFBhcmFtZXRlcnM66C0gYGFzc2V0X2lkYDogVGhlIElEIG9mIHRoZSBhc3NldCByZW1vdmVkIGZyb20gY29sbGF0ZXJhbHNEQ29sbGF0ZXJhbFVwZGF0ZWQYASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAATBwdXJjaGFzZV9mZWX1AwE8T3B0aW9uPFBlcm1pbGw+AAFkbWF4X2J1eV9wcmljZV9jb2VmZmljaWVudPkDAWBPcHRpb248Q29lZmZpY2llbnRSYXRpbz4AATBidXlfYmFja19mZWX1AwE8T3B0aW9uPFBlcm1pbGw+AAEwYnV5YmFja19yYXRl/QMBPE9wdGlvbjxQZXJiaWxsPgABOG1heF9pbl9ob2xkaW5nAQQBXE9wdGlvbjxPcHRpb248QmFsYW5jZT4+AAIkeEEgY29sbGF0ZXJhbCBhc3NldCB3YXMgdXBkYXRlZAAsUGFyYW1ldGVyczrQLSBgYXNzZXRfaWRgOiBUaGUgSUQgb2YgdGhlIHVwZGF0ZWQgY29sbGF0ZXJhbCBhc3NldA0BLSBgcHVyY2hhc2VfZmVlYDogTmV3IHB1cmNoYXNlIGZlZSBpZiB1cGRhdGVkIChOb25lIGlmIG5vdCBjaGFuZ2VkKXUBLSBgbWF4X2J1eV9wcmljZV9jb2VmZmljaWVudGA6IE5ldyBtYXggYnV5IHByaWNlIGNvZWZmaWNpZW50IGlmIHVwZGF0ZWQgKE5vbmUgaWYgbm90IGNoYW5nZWQpDQEtIGBidXlfYmFja19mZWVgOiBOZXcgYnV5IGJhY2sgZmVlIGlmIHVwZGF0ZWQgKE5vbmUgaWYgbm90IGNoYW5nZWQpDQEtIGBidXliYWNrX3JhdGVgOiBOZXcgYnV5YmFjayByYXRlIGlmIHVwZGF0ZWQgKE5vbmUgaWYgbm90IGNoYW5nZWQpPQEtIGBtYXhfaW5faG9sZGluZ2A6IE5ldyBtYXggY29sbGF0ZXJhbCBob2xkaW5nIGlmIHVwZGF0ZWQgKE5vbmUgaWYgbm90IGNoYW5nZWQpREFyYml0cmFnZUV4ZWN1dGVkEAEkYXJiaXRyYWdlCAEIdTgAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQAATRob2xsYXJfYW1vdW50GAEcQmFsYW5jZQABGHByb2ZpdBgBHEJhbGFuY2UAAxR8QXJiaXRyYWdlIGV4ZWN1dGVkIHN1Y2Nlc3NmdWxseQAsUGFyYW1ldGVyczrgLSBgYXNzZXRfaWRgOiBUaGUgY29sbGF0ZXJhbCBhc3NldCB1c2VkIGluIHRoZSBhcmJpdHJhZ2VBAS0gYGhvbGxhcl9hbW91bnRgOiBBbW91bnQgb2YgSG9sbGFyIHRoYXQgd2FzIGluY2x1ZGVkIGluIHRoZSBhcmJpdHJhZ2Ugb3BlcmF0aW9uOEZsYXNoTWludGVyU2V0BAEwZmxhc2hfbWludGVyQQEBKEV2bUFkZHJlc3MABBBgRmxhc2ggbWludGVyIGFkZHJlc3Mgc2V0ACxQYXJhbWV0ZXJzOvgtIGBmbGFzaF9taW50ZXJgOiBUaGUgRVZNIGFkZHJlc3Mgb2YgdGhlIGZsYXNoIG1pbnRlciBjb250cmFjdAR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldN0HDCxvcm1sX3Rva2Vucxhtb2R1bGUURXZlbnQEBFQAAUQcRW5kb3dlZAwBLGN1cnJlbmN5X2lkEAE0VDo6Q3VycmVuY3lJZAABDHdobwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UAAAS4QW4gYWNjb3VudCB3YXMgY3JlYXRlZCB3aXRoIHNvbWUgZnJlZSBiYWxhbmNlLiBEdXN0TG9zdAwBLGN1cnJlbmN5X2lkEAE0VDo6Q3VycmVuY3lJZAABDHdobwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UAAQjsQW4gYWNjb3VudCB3YXMgcmVtb3ZlZCB3aG9zZSBiYWxhbmNlIHdhcyBub24temVybyBidXQgYmVsb3fIRXhpc3RlbnRpYWxEZXBvc2l0LCByZXN1bHRpbmcgaW4gYW4gb3V0cmlnaHQgbG9zcy4gVHJhbnNmZXIQASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAARBmcm9tAAEwVDo6QWNjb3VudElkAAEIdG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAIETFRyYW5zZmVyIHN1Y2NlZWRlZC4gUmVzZXJ2ZWQMASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAME4FNvbWUgYmFsYW5jZSB3YXMgcmVzZXJ2ZWQgKG1vdmVkIGZyb20gZnJlZSB0byByZXNlcnZlZCkuKFVucmVzZXJ2ZWQMASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAQE6FNvbWUgYmFsYW5jZSB3YXMgdW5yZXNlcnZlZCAobW92ZWQgZnJvbSByZXNlcnZlZCB0byBmcmVlKS5IUmVzZXJ2ZVJlcGF0cmlhdGVkFAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEQZnJvbQABMFQ6OkFjY291bnRJZAABCHRvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQABGHN0YXR1c4ABNEJhbGFuY2VTdGF0dXMABQj0U29tZSByZXNlcnZlZCBiYWxhbmNlIHdhcyByZXBhdHJpYXRlZCAobW92ZWQgZnJvbSByZXNlcnZlZCB0b0Rhbm90aGVyIGFjY291bnQpLihCYWxhbmNlU2V0EAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEQZnJlZRgBKFQ6OkJhbGFuY2UAASByZXNlcnZlZBgBKFQ6OkJhbGFuY2UABgRoQSBiYWxhbmNlIHdhcyBzZXQgYnkgcm9vdC5AVG90YWxJc3N1YW5jZVNldAgBLGN1cnJlbmN5X2lkEAE0VDo6Q3VycmVuY3lJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UABwS4VGhlIHRvdGFsIGlzc3VhbmNlIG9mIGFuIGN1cnJlbmN5IGhhcyBiZWVuIHNldCRXaXRoZHJhd24MASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAgE7FNvbWUgYmFsYW5jZXMgd2VyZSB3aXRoZHJhd24gKGUuZy4gcGF5IGZvciB0cmFuc2FjdGlvbiBmZWUpHFNsYXNoZWQQASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAASxmcmVlX2Ftb3VudBgBKFQ6OkJhbGFuY2UAATxyZXNlcnZlZF9hbW91bnQYAShUOjpCYWxhbmNlAAkE1FNvbWUgYmFsYW5jZXMgd2VyZSBzbGFzaGVkIChlLmcuIGR1ZSB0byBtaXMtYmVoYXZpb3IpJERlcG9zaXRlZAwBLGN1cnJlbmN5X2lkEAE0VDo6Q3VycmVuY3lJZAABDHdobwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBKFQ6OkJhbGFuY2UACgSYRGVwb3NpdGVkIHNvbWUgYmFsYW5jZSBpbnRvIGFuIGFjY291bnQcTG9ja1NldBABHGxvY2tfaWT9AQE4TG9ja0lkZW50aWZpZXIAASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAAsEVFNvbWUgZnVuZHMgYXJlIGxvY2tlZCxMb2NrUmVtb3ZlZAwBHGxvY2tfaWT9AQE4TG9ja0lkZW50aWZpZXIAASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQADAR8U29tZSBsb2NrZWQgZnVuZHMgd2VyZSB1bmxvY2tlZBhMb2NrZWQMASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYAShUOjpCYWxhbmNlAA0EdFNvbWUgZnJlZSBiYWxhbmNlIHdhcyBsb2NrZWQuIFVubG9ja2VkDAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAOBHhTb21lIGxvY2tlZCBiYWxhbmNlIHdhcyBmcmVlZC4YSXNzdWVkCAEsY3VycmVuY3lfaWQQATRUOjpDdXJyZW5jeUlkAAEYYW1vdW50GAEoVDo6QmFsYW5jZQAPACRSZXNjaW5kZWQIASxjdXJyZW5jeV9pZBABNFQ6OkN1cnJlbmN5SWQAARhhbW91bnQYAShUOjpCYWxhbmNlABAABHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV04QcMRHBhbGxldF9jdXJyZW5jaWVzGG1vZHVsZRRFdmVudAQEVAABECxUcmFuc2ZlcnJlZBABLGN1cnJlbmN5X2lkEAE8Q3VycmVuY3lJZE9mPFQ+AAEQZnJvbQABMFQ6OkFjY291bnRJZAABCHRvAAEwVDo6QWNjb3VudElkAAEYYW1vdW50GAEwQmFsYW5jZU9mPFQ+AAAEaEN1cnJlbmN5IHRyYW5zZmVyIHN1Y2Nlc3MuOEJhbGFuY2VVcGRhdGVkDAEsY3VycmVuY3lfaWQQATxDdXJyZW5jeUlkT2Y8VD4AAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQVBAEsQW1vdW50T2Y8VD4AAQRcVXBkYXRlIGJhbGFuY2Ugc3VjY2Vzcy4kRGVwb3NpdGVkDAEsY3VycmVuY3lfaWQQATxDdXJyZW5jeUlkT2Y8VD4AAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYATBCYWxhbmNlT2Y8VD4AAgRARGVwb3NpdCBzdWNjZXNzLiRXaXRoZHJhd24MASxjdXJyZW5jeV9pZBABPEN1cnJlbmN5SWRPZjxUPgABDHdobwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBMEJhbGFuY2VPZjxUPgADBERXaXRoZHJhdyBzdWNjZXNzLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldOUHDDBvcm1sX3Zlc3RpbmcYbW9kdWxlFEV2ZW50BARUAAEMUFZlc3RpbmdTY2hlZHVsZUFkZGVkDAEQZnJvbQABMFQ6OkFjY291bnRJZAABCHRvAAEwVDo6QWNjb3VudElkAAFAdmVzdGluZ19zY2hlZHVsZR0EAVBWZXN0aW5nU2NoZWR1bGVPZjxUPgAABGxBZGRlZCBuZXcgdmVzdGluZyBzY2hlZHVsZS4cQ2xhaW1lZAgBDHdobwABMFQ6OkFjY291bnRJZAABGGFtb3VudBgBMEJhbGFuY2VPZjxUPgABBEBDbGFpbWVkIHZlc3RpbmcuXFZlc3RpbmdTY2hlZHVsZXNVcGRhdGVkBAEMd2hvAAEwVDo6QWNjb3VudElkAAIEaFVwZGF0ZWQgdmVzdGluZyBzY2hlZHVsZXMuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV06QcMKHBhbGxldF9ldm0YcGFsbGV0FEV2ZW50BARUAAEUDExvZwQBDGxvZ+0HAQxMb2cAAAR8RXRoZXJldW0gZXZlbnRzIGZyb20gY29udHJhY3RzLhxDcmVhdGVkBAEcYWRkcmVzc0EBARBIMTYwAAEEtEEgY29udHJhY3QgaGFzIGJlZW4gY3JlYXRlZCBhdCBnaXZlbiBhZGRyZXNzLjRDcmVhdGVkRmFpbGVkBAEcYWRkcmVzc0EBARBIMTYwAAIEBQFBIGNvbnRyYWN0IHdhcyBhdHRlbXB0ZWQgdG8gYmUgY3JlYXRlZCwgYnV0IHRoZSBleGVjdXRpb24gZmFpbGVkLiBFeGVjdXRlZAQBHGFkZHJlc3NBAQEQSDE2MAADBPhBIGNvbnRyYWN0IGhhcyBiZWVuIGV4ZWN1dGVkIHN1Y2Nlc3NmdWxseSB3aXRoIHN0YXRlcyBhcHBsaWVkLjhFeGVjdXRlZEZhaWxlZAQBHGFkZHJlc3NBAQEQSDE2MAAEBGUBQSBjb250cmFjdCBoYXMgYmVlbiBleGVjdXRlZCB3aXRoIGVycm9ycy4gU3RhdGVzIGFyZSByZXZlcnRlZCB3aXRoIG9ubHkgZ2FzIGZlZXMgYXBwbGllZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXTtBwwgZXRoZXJldW0MbG9nDExvZwAADAEcYWRkcmVzc0EBARBIMTYwAAEYdG9waWNzyQEBJFZlYzxIMjU2PgABEGRhdGE4ARRCeXRlcwAA8QcMPHBhbGxldF9ldGhlcmV1bRhwYWxsZXQURXZlbnQAAQQgRXhlY3V0ZWQUARBmcm9tQQEBEEgxNjAAAQh0b0EBARBIMTYwAAFAdHJhbnNhY3Rpb25faGFzaDQBEEgyNTYAASxleGl0X3JlYXNvbvUHAShFeGl0UmVhc29uAAEoZXh0cmFfZGF0YTgBHFZlYzx1OD4AAATIQW4gZXRoZXJldW0gdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXT1BwwgZXZtX2NvcmUUZXJyb3IoRXhpdFJlYXNvbgABEBxTdWNjZWVkBAD5BwEsRXhpdFN1Y2NlZWQAAAAURXJyb3IEAP0HASRFeGl0RXJyb3IAAQAYUmV2ZXJ0BAANCAEoRXhpdFJldmVydAACABRGYXRhbAQAEQgBJEV4aXRGYXRhbAADAAD5BwwgZXZtX2NvcmUUZXJyb3IsRXhpdFN1Y2NlZWQAAQwcU3RvcHBlZAAAACBSZXR1cm5lZAABACBTdWljaWRlZAACAAD9BwwgZXZtX2NvcmUUZXJyb3IkRXhpdEVycm9yAAFAOFN0YWNrVW5kZXJmbG93AAAANFN0YWNrT3ZlcmZsb3cAAQAsSW52YWxpZEp1bXAAAgAwSW52YWxpZFJhbmdlAAMARERlc2lnbmF0ZWRJbnZhbGlkAAQALENhbGxUb29EZWVwAAUAPENyZWF0ZUNvbGxpc2lvbgAGAExDcmVhdGVDb250cmFjdExpbWl0AAcALEludmFsaWRDb2RlBAABCAEYT3Bjb2RlAA8ALE91dE9mT2Zmc2V0AAgAIE91dE9mR2FzAAkAJE91dE9mRnVuZAAKACxQQ1VuZGVyZmxvdwALACxDcmVhdGVFbXB0eQAMABRPdGhlcgQABQgBRENvdzwnc3RhdGljLCBzdHI+AA0AIE1heE5vbmNlAA4AAAEIDCBldm1fY29yZRhvcGNvZGUYT3Bjb2RlAAAEAAgBCHU4AAAFCAQMQ293BARUAQkIAAQACQgAAAAJCAAABQIADQgMIGV2bV9jb3JlFGVycm9yKEV4aXRSZXZlcnQAAQQgUmV2ZXJ0ZWQAAAAAEQgMIGV2bV9jb3JlFGVycm9yJEV4aXRGYXRhbAABEDBOb3RTdXBwb3J0ZWQAAABIVW5oYW5kbGVkSW50ZXJydXB0AAEAQENhbGxFcnJvckFzRmF0YWwEAP0HASRFeGl0RXJyb3IAAgAUT3RoZXIEAAUIAURDb3c8J3N0YXRpYywgc3RyPgADAAAVCAxMcGFsbGV0X2V2bV9hY2NvdW50cxhwYWxsZXQURXZlbnQEBFQAARQUQm91bmQIARxhY2NvdW50AAEwVDo6QWNjb3VudElkAAEcYWRkcmVzc0EBAShFdm1BZGRyZXNzAAAEUEJpbmRpbmcgd2FzIGNyZWF0ZWQuNERlcGxveWVyQWRkZWQEAQx3aG9BAQEoRXZtQWRkcmVzcwABBExEZXBsb3llciB3YXMgYWRkZWQuPERlcGxveWVyUmVtb3ZlZAQBDHdob0EBAShFdm1BZGRyZXNzAAIEVERlcGxveWVyIHdhcyByZW1vdmVkLkBDb250cmFjdEFwcHJvdmVkBAEcYWRkcmVzc0EBAShFdm1BZGRyZXNzAAMEWENvbnRyYWN0IHdhcyBhcHByb3ZlZC5MQ29udHJhY3REaXNhcHByb3ZlZAQBHGFkZHJlc3NBAQEoRXZtQWRkcmVzcwAEBGRDb250cmFjdCB3YXMgZGlzYXBwcm92ZWQuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0GQgMbHBhbGxldF94eWtfbGlxdWlkaXR5X21pbmluZxhwYWxsZXQURXZlbnQEBFQAATRER2xvYmFsRmFybUNyZWF0ZWQsAQhpZBABMEdsb2JhbEZhcm1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAE0dG90YWxfcmV3YXJkcxgBHEJhbGFuY2UAATxyZXdhcmRfY3VycmVuY3kQARxBc3NldElkAAFAeWllbGRfcGVyX3BlcmlvZD0DASxQZXJxdWludGlsbAABYHBsYW5uZWRfeWllbGRpbmdfcGVyaW9kcxABLFBlcmlvZE9mPFQ+AAFEYmxvY2tzX3Blcl9wZXJpb2QQAURCbG9ja051bWJlckZvcjxUPgABSGluY2VudGl2aXplZF9hc3NldBABHEFzc2V0SWQAAVRtYXhfcmV3YXJkX3Blcl9wZXJpb2QYARxCYWxhbmNlAAEsbWluX2RlcG9zaXQYARxCYWxhbmNlAAFAcHJpY2VfYWRqdXN0bWVudD0BASRGaXhlZFUxMjgAAARwTmV3IGdsb2JhbCBmYXJtIHdhcyBjcmVhdGVkLkRHbG9iYWxGYXJtVXBkYXRlZAgBCGlkEAEwR2xvYmFsRmFybUlkAAFAcHJpY2VfYWRqdXN0bWVudD0BASRGaXhlZFUxMjgAAQS0R2xvYmFsIGZhcm0ncyBgcHJpY2VfYWRqdXN0bWVudGAgd2FzIHVwZGF0ZWQuQFlpZWxkRmFybUNyZWF0ZWQUAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgABNGxveWFsdHlfY3VydmVBAwFQT3B0aW9uPExveWFsdHlDdXJ2ZT4AAgScTmV3IHlpZWxkIGZhcm0gd2FzIGFkZGVkIGludG8gdGhlIGZhcm0uUEdsb2JhbEZhcm1UZXJtaW5hdGVkEAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAATxyZXdhcmRfY3VycmVuY3kQARxBc3NldElkAAFUdW5kaXN0cmlidXRlZF9yZXdhcmRzGAEcQmFsYW5jZQADBGxHbG9iYWwgZmFybSB3YXMgdGVybWluYXRlZC48U2hhcmVzRGVwb3NpdGVkGAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYARxCYWxhbmNlAAEgbHBfdG9rZW4QARxBc3NldElkAAEoZGVwb3NpdF9pZBgBJERlcG9zaXRJZAAEBHBOZXcgTFAgdG9rZW5zIHdhcyBkZXBvc2l0ZWQuRFNoYXJlc1JlZGVwb3NpdGVkGAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARhhbW91bnQYARxCYWxhbmNlAAEgbHBfdG9rZW4QARxBc3NldElkAAEoZGVwb3NpdF9pZBgBJERlcG9zaXRJZAAFBMxMUCB0b2tlbiB3YXMgcmVkZXBvc2l0ZWQgZm9yIGEgbmV3IHlpZWxkIGZhcm0gZW50cnk0UmV3YXJkQ2xhaW1lZBgBOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEcY2xhaW1lZBgBHEJhbGFuY2UAATxyZXdhcmRfY3VycmVuY3kQARxBc3NldElkAAEoZGVwb3NpdF9pZBgBJERlcG9zaXRJZAAGBFBSZXdhcmRzIHdhcyBjbGFpbWVkLjxTaGFyZXNXaXRoZHJhd24YAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAABNHlpZWxkX2Zhcm1faWQQASxZaWVsZEZhcm1JZAABDHdobwABMFQ6OkFjY291bnRJZAABIGxwX3Rva2VuEAEcQXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAAShkZXBvc2l0X2lkGAEkRGVwb3NpdElkAAcEYExQIHRva2VucyB3YXMgd2l0aGRyYXduLkBZaWVsZEZhcm1TdG9wcGVkEAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgAIBJhZaWVsZCBmYXJtIGZvciBhc3NldCBwYWlyIHdhcyBzdG9wcGVkLkBZaWVsZEZhcm1SZXN1bWVkFAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIACQSYWWllbGQgZmFybSBmb3IgYXNzZXQgcGFpciB3YXMgcmVzdW1lZC5MWWllbGRGYXJtVGVybWluYXRlZBABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEoYXNzZXRfcGFpcmUEASRBc3NldFBhaXIACgSsWWllbGQgZmFybSB3YXMgdGVybWluYXRlZCBmcm9tIGdsb2JhbCBmYXJtLkBZaWVsZEZhcm1VcGRhdGVkFAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAAShhc3NldF9wYWlyZQQBJEFzc2V0UGFpcgABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIACwSIWWllbGQgZmFybSBtdWx0aXBsaWVyIHdhcyB1cGRhdGVkLkBEZXBvc2l0RGVzdHJveWVkCAEMd2hvAAEwVDo6QWNjb3VudElkAAEoZGVwb3NpdF9pZBgBJERlcG9zaXRJZAAMBKxORlQgcmVwcmVzZW50aW5nIGRlcG9zaXQgaGFzIGJlZW4gZGVzdHJveWVkBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0HQgMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nGHBhbGxldBRFdmVudAgEVAAESQABDFxHbG9iYWxGYXJtQWNjUlBaVXBkYXRlZAwBOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE8YWNjdW11bGF0ZWRfcnB6PQEBJEZpeGVkVTEyOAABOHRvdGFsX3NoYXJlc196GAEcQmFsYW5jZQAABNRHbG9iYWwgZmFybSBhY2N1bXVsYXRlZCByZXdhcmQgcGVyIHNoYXJlIHdhcyB1cGRhdGVkLlxZaWVsZEZhcm1BY2NSUFZTVXBkYXRlZBABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAFAYWNjdW11bGF0ZWRfcnB2cz0BASRGaXhlZFUxMjgAAUx0b3RhbF92YWx1ZWRfc2hhcmVzGAEcQmFsYW5jZQABBOxZaWVsZCBmYXJtIGFjY3VtdWxhdGVkIHJld2FyZCBwZXIgdmFsdWVkIHNoYXJlIHdhcyB1cGRhdGVkLlRBbGxSZXdhcmRzRGlzdHJpYnV0ZWQEAThnbG9iYWxfZmFybV9pZBABMEdsb2JhbEZhcm1JZAACBPBHbG9iYWwgZmFybSBoYXMgbm8gbW9yZSByZXdhcmRzIHRvIGRpc3RyaWJ1dGUgaW4gdGhlIG1vbWVudC4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXQhCAxYcGFsbGV0X3JlbGF5Y2hhaW5faW5mbxhwYWxsZXQURXZlbnQEBFQAAQRMQ3VycmVudEJsb2NrTnVtYmVycwgBWHBhcmFjaGFpbl9ibG9ja19udW1iZXIQAURCbG9ja051bWJlckZvcjxUPgABXHJlbGF5Y2hhaW5fYmxvY2tfbnVtYmVyEAFEQmxvY2tOdW1iZXJGb3I8VD4AAAhUQ3VycmVudCBibG9jayBudW1iZXJzzFsgUGFyYWNoYWluIGJsb2NrIG51bWJlciwgUmVsYXljaGFpbiBCbG9jayBudW1iZXIgXQR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldCUIDChwYWxsZXRfZGNhGHBhbGxldBRFdmVudAQEVAABJEBFeGVjdXRpb25TdGFydGVkCAEIaWQQAShTY2hlZHVsZUlkAAEUYmxvY2sQAURCbG9ja051bWJlckZvcjxUPgAABHBUaGUgRENBIGV4ZWN1dGlvbiBpcyBzdGFydGVkJFNjaGVkdWxlZBQBCGlkEAEoU2NoZWR1bGVJZAABDHdobwABMFQ6OkFjY291bnRJZAABGHBlcmlvZBABREJsb2NrTnVtYmVyRm9yPFQ+AAEwdG90YWxfYW1vdW50GAEcQmFsYW5jZQABFG9yZGVygQQBRE9yZGVyPFQ6OkFzc2V0SWQ+AAEEnFRoZSBEQ0EgaXMgc2NoZWR1bGVkIGZvciBuZXh0IGV4ZWN1dGlvbkBFeGVjdXRpb25QbGFubmVkDAEIaWQQAShTY2hlZHVsZUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAEUYmxvY2sQAURCbG9ja051bWJlckZvcjxUPgACBIhUaGUgRENBIGlzIHBsYW5uZWQgZm9yIGJsb2NrbnVtYmVyNFRyYWRlRXhlY3V0ZWQQAQhpZBABKFNjaGVkdWxlSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAASRhbW91bnRfaW4YARxCYWxhbmNlAAEoYW1vdW50X291dBgBHEJhbGFuY2UAAwSYVGhlIERDQSB0cmFkZSBpcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQsVHJhZGVGYWlsZWQMAQhpZBABKFNjaGVkdWxlSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARRlcnJvcmgBNERpc3BhdGNoRXJyb3IABASEVGhlIERDQSB0cmFkZSBleGVjdXRpb24gaXMgZmFpbGVkKFRlcm1pbmF0ZWQMAQhpZBABKFNjaGVkdWxlSWQAAQx3aG8AATBUOjpBY2NvdW50SWQAARRlcnJvcmgBNERpc3BhdGNoRXJyb3IABQTsVGhlIERDQSBpcyB0ZXJtaW5hdGVkIGFuZCBjb21wbGV0ZWx5IHJlbW92ZWQgZnJvbSB0aGUgY2hhaW4kQ29tcGxldGVkCAEIaWQQAShTY2hlZHVsZUlkAAEMd2hvAAEwVDo6QWNjb3VudElkAAYE6FRoZSBEQ0EgaXMgY29tcGxldGVkIGFuZCBjb21wbGV0ZWx5IHJlbW92ZWQgZnJvbSB0aGUgY2hhaW5oUmFuZG9tbmVzc0dlbmVyYXRpb25GYWlsZWQIARRibG9jaxABREJsb2NrTnVtYmVyRm9yPFQ+AAEUZXJyb3JoATREaXNwYXRjaEVycm9yAAcEQQFSYW5kb21uZXNzIGdlbmVyYXRpb24gZmFpbGVkIHBvc3NpYmx5IGNvbWluZyBmcm9tIG1pc3NpbmcgZGF0YSBhYm91dCByZWxheSBjaGFpbjxSZXNlcnZlVW5sb2NrZWQIAQx3aG8AATBUOjpBY2NvdW50SWQAASBhc3NldF9pZBABKFQ6OkFzc2V0SWQACAT0RENBIHJlc2VydmUgZm9yIHRoZSBnaXZlbiBhc3NldCBoYXZlIGJlZW4gdW5sb2NrZWQgZm9yIGEgdXNlcgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldCkIDEBwYWxsZXRfc2NoZWR1bGVyGHBhbGxldBRFdmVudAQEVAABJCRTY2hlZHVsZWQIARB3aGVuEAFEQmxvY2tOdW1iZXJGb3I8VD4AARRpbmRleBABDHUzMgAABFBTY2hlZHVsZWQgc29tZSB0YXNrLiBDYW5jZWxlZAgBEHdoZW4QAURCbG9ja051bWJlckZvcjxUPgABFGluZGV4EAEMdTMyAAEETENhbmNlbGVkIHNvbWUgdGFzay4oRGlzcGF0Y2hlZAwBEHRhc2tNAwF4VGFza0FkZHJlc3M8QmxvY2tOdW1iZXJGb3I8VD4+AAEIaWQtCAFAT3B0aW9uPFRhc2tOYW1lPgABGHJlc3VsdJgBOERpc3BhdGNoUmVzdWx0AAIEVERpc3BhdGNoZWQgc29tZSB0YXNrLiBSZXRyeVNldBABEHRhc2tNAwF4VGFza0FkZHJlc3M8QmxvY2tOdW1iZXJGb3I8VD4+AAEIaWQtCAFAT3B0aW9uPFRhc2tOYW1lPgABGHBlcmlvZBABREJsb2NrTnVtYmVyRm9yPFQ+AAEccmV0cmllcwgBCHU4AAMEoFNldCBhIHJldHJ5IGNvbmZpZ3VyYXRpb24gZm9yIHNvbWUgdGFzay44UmV0cnlDYW5jZWxsZWQIARB0YXNrTQMBeFRhc2tBZGRyZXNzPEJsb2NrTnVtYmVyRm9yPFQ+PgABCGlkLQgBQE9wdGlvbjxUYXNrTmFtZT4ABASsQ2FuY2VsIGEgcmV0cnkgY29uZmlndXJhdGlvbiBmb3Igc29tZSB0YXNrLjxDYWxsVW5hdmFpbGFibGUIARB0YXNrTQMBeFRhc2tBZGRyZXNzPEJsb2NrTnVtYmVyRm9yPFQ+PgABCGlkLQgBQE9wdGlvbjxUYXNrTmFtZT4ABQQpAVRoZSBjYWxsIGZvciB0aGUgcHJvdmlkZWQgaGFzaCB3YXMgbm90IGZvdW5kIHNvIHRoZSB0YXNrIGhhcyBiZWVuIGFib3J0ZWQuOFBlcmlvZGljRmFpbGVkCAEQdGFza00DAXhUYXNrQWRkcmVzczxCbG9ja051bWJlckZvcjxUPj4AAQhpZC0IAUBPcHRpb248VGFza05hbWU+AAYEPQFUaGUgZ2l2ZW4gdGFzayB3YXMgdW5hYmxlIHRvIGJlIHJlbmV3ZWQgc2luY2UgdGhlIGFnZW5kYSBpcyBmdWxsIGF0IHRoYXQgYmxvY2suLFJldHJ5RmFpbGVkCAEQdGFza00DAXhUYXNrQWRkcmVzczxCbG9ja051bWJlckZvcjxUPj4AAQhpZC0IAUBPcHRpb248VGFza05hbWU+AAcIXQFUaGUgZ2l2ZW4gdGFzayB3YXMgdW5hYmxlIHRvIGJlIHJldHJpZWQgc2luY2UgdGhlIGFnZW5kYSBpcyBmdWxsIGF0IHRoYXQgYmxvY2sgb3IgdGhlcmWcd2FzIG5vdCBlbm91Z2ggd2VpZ2h0IHRvIHJlc2NoZWR1bGUgaXQuVFBlcm1hbmVudGx5T3ZlcndlaWdodAgBEHRhc2tNAwF4VGFza0FkZHJlc3M8QmxvY2tOdW1iZXJGb3I8VD4+AAEIaWQtCAFAT3B0aW9uPFRhc2tOYW1lPgAIBPBUaGUgZ2l2ZW4gdGFzayBjYW4gbmV2ZXIgYmUgZXhlY3V0ZWQgc2luY2UgaXQgaXMgb3ZlcndlaWdodC4EMEV2ZW50cyB0eXBlLi0IBBhPcHRpb24EBFQBBAEIEE5vbmUAAAAQU29tZQQABAAAAQAAMQgMfGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW0YcGFsbGV0FEV2ZW50BARUAAEYYFZhbGlkYXRpb25GdW5jdGlvblN0b3JlZAAABNBUaGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBoYXMgYmVlbiBzY2hlZHVsZWQgdG8gYXBwbHkuZFZhbGlkYXRpb25GdW5jdGlvbkFwcGxpZWQEAVRyZWxheV9jaGFpbl9ibG9ja19udW0QAVRSZWxheUNoYWluQmxvY2tOdW1iZXIAAQRFAVRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdhcyBhcHBsaWVkIGFzIG9mIHRoZSBjb250YWluZWQgcmVsYXkgY2hhaW4gYmxvY2sgbnVtYmVyLmxWYWxpZGF0aW9uRnVuY3Rpb25EaXNjYXJkZWQAAgSwVGhlIHJlbGF5LWNoYWluIGFib3J0ZWQgdGhlIHVwZ3JhZGUgcHJvY2Vzcy5gRG93bndhcmRNZXNzYWdlc1JlY2VpdmVkBAEUY291bnQQAQx1MzIAAwQBAVNvbWUgZG93bndhcmQgbWVzc2FnZXMgaGF2ZSBiZWVuIHJlY2VpdmVkIGFuZCB3aWxsIGJlIHByb2Nlc3NlZC5kRG93bndhcmRNZXNzYWdlc1Byb2Nlc3NlZAgBLHdlaWdodF91c2VkKAEYV2VpZ2h0AAEgZG1xX2hlYWQ0AURyZWxheV9jaGFpbjo6SGFzaAAEBOBEb3dud2FyZCBtZXNzYWdlcyB3ZXJlIHByb2Nlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gd2VpZ2h0LkRVcHdhcmRNZXNzYWdlU2VudAQBMG1lc3NhZ2VfaGFzaC0IATxPcHRpb248WGNtSGFzaD4ABQS4QW4gdXB3YXJkIG1lc3NhZ2Ugd2FzIHNlbnQgdG8gdGhlIHJlbGF5IGNoYWluLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldDUIDChwYWxsZXRfeGNtGHBhbGxldBRFdmVudAQEVAABYCRBdHRlbXB0ZWQEARxvdXRjb21lOQgBUHhjbTo6bGF0ZXN0OjpPdXRjb21lAAAEqEV4ZWN1dGlvbiBvZiBhbiBYQ00gbWVzc2FnZSB3YXMgYXR0ZW1wdGVkLhBTZW50EAEYb3JpZ2lufQEBIExvY2F0aW9uAAEsZGVzdGluYXRpb259AQEgTG9jYXRpb24AARxtZXNzYWdlnQUBHFhjbTwoKT4AAShtZXNzYWdlX2lkBAEcWGNtSGFzaAABBFxBIFhDTSBtZXNzYWdlIHdhcyBzZW50LkhVbmV4cGVjdGVkUmVzcG9uc2UIARhvcmlnaW59AQEgTG9jYXRpb24AASBxdWVyeV9pZDABHFF1ZXJ5SWQAAgxZAVF1ZXJ5IHJlc3BvbnNlIHJlY2VpdmVkIHdoaWNoIGRvZXMgbm90IG1hdGNoIGEgcmVnaXN0ZXJlZCBxdWVyeS4gVGhpcyBtYXkgYmUgYmVjYXVzZSBhVQFtYXRjaGluZyBxdWVyeSB3YXMgbmV2ZXIgcmVnaXN0ZXJlZCwgaXQgbWF5IGJlIGJlY2F1c2UgaXQgaXMgYSBkdXBsaWNhdGUgcmVzcG9uc2UsIG9ycGJlY2F1c2UgdGhlIHF1ZXJ5IHRpbWVkIG91dC40UmVzcG9uc2VSZWFkeQgBIHF1ZXJ5X2lkMAEcUXVlcnlJZAABIHJlc3BvbnNlwQUBIFJlc3BvbnNlAAMIXQFRdWVyeSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBhbmQgaXMgcmVhZHkgZm9yIHRha2luZyB3aXRoIGB0YWtlX3Jlc3BvbnNlYC4gVGhlcmUgaXOAbm8gcmVnaXN0ZXJlZCBub3RpZmljYXRpb24gY2FsbC4gTm90aWZpZWQMASBxdWVyeV9pZDABHFF1ZXJ5SWQAATBwYWxsZXRfaW5kZXgIAQh1OAABKGNhbGxfaW5kZXgIAQh1OAAECFkBUXVlcnkgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIHF1ZXJ5IGlzIHJlbW92ZWQuIFRoZSByZWdpc3RlcmVkIG5vdGlmaWNhdGlvbiBoYXOoYmVlbiBkaXNwYXRjaGVkIGFuZCBleGVjdXRlZCBzdWNjZXNzZnVsbHkuQE5vdGlmeU92ZXJ3ZWlnaHQUASBxdWVyeV9pZDABHFF1ZXJ5SWQAATBwYWxsZXRfaW5kZXgIAQh1OAABKGNhbGxfaW5kZXgIAQh1OAABNGFjdHVhbF93ZWlnaHQoARhXZWlnaHQAAUxtYXhfYnVkZ2V0ZWRfd2VpZ2h0KAEYV2VpZ2h0AAUMSQFRdWVyeSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBhbmQgcXVlcnkgaXMgcmVtb3ZlZC4gVGhlIHJlZ2lzdGVyZWQgbm90aWZpY2F0aW9uWQFjb3VsZCBub3QgYmUgZGlzcGF0Y2hlZCBiZWNhdXNlIHRoZSBkaXNwYXRjaCB3ZWlnaHQgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHdlaWdodORvcmlnaW5hbGx5IGJ1ZGdldGVkIGJ5IHRoaXMgcnVudGltZSBmb3IgdGhlIHF1ZXJ5IHJlc3VsdC5MTm90aWZ5RGlzcGF0Y2hFcnJvcgwBIHF1ZXJ5X2lkMAEcUXVlcnlJZAABMHBhbGxldF9pbmRleAgBCHU4AAEoY2FsbF9pbmRleAgBCHU4AAYIVQFRdWVyeSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBhbmQgcXVlcnkgaXMgcmVtb3ZlZC4gVGhlcmUgd2FzIGEgZ2VuZXJhbCBlcnJvciB3aXRoiGRpc3BhdGNoaW5nIHRoZSBub3RpZmljYXRpb24gY2FsbC5ITm90aWZ5RGVjb2RlRmFpbGVkDAEgcXVlcnlfaWQwARxRdWVyeUlkAAEwcGFsbGV0X2luZGV4CAEIdTgAAShjYWxsX2luZGV4CAEIdTgABwxRAVF1ZXJ5IHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBxdWVyeSBpcyByZW1vdmVkLiBUaGUgZGlzcGF0Y2ggd2FzIHVuYWJsZSB0byBiZVkBZGVjb2RlZCBpbnRvIGEgYENhbGxgOyB0aGlzIG1pZ2h0IGJlIGR1ZSB0byBkaXNwYXRjaCBmdW5jdGlvbiBoYXZpbmcgYSBzaWduYXR1cmUgd2hpY2iUaXMgbm90IGAob3JpZ2luLCBRdWVyeUlkLCBSZXNwb25zZSlgLkBJbnZhbGlkUmVzcG9uZGVyDAEYb3JpZ2lufQEBIExvY2F0aW9uAAEgcXVlcnlfaWQwARxRdWVyeUlkAAFEZXhwZWN0ZWRfbG9jYXRpb27VBQFAT3B0aW9uPExvY2F0aW9uPgAIDFkBRXhwZWN0ZWQgcXVlcnkgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQgYnV0IHRoZSBvcmlnaW4gbG9jYXRpb24gb2YgdGhlIHJlc3BvbnNlIGRvZXNVAW5vdCBtYXRjaCB0aGF0IGV4cGVjdGVkLiBUaGUgcXVlcnkgcmVtYWlucyByZWdpc3RlcmVkIGZvciBhIGxhdGVyLCB2YWxpZCwgcmVzcG9uc2UgdG9sYmUgcmVjZWl2ZWQgYW5kIGFjdGVkIHVwb24uXEludmFsaWRSZXNwb25kZXJWZXJzaW9uCAEYb3JpZ2lufQEBIExvY2F0aW9uAAEgcXVlcnlfaWQwARxRdWVyeUlkAAkcUQFFeHBlY3RlZCBxdWVyeSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBidXQgdGhlIGV4cGVjdGVkIG9yaWdpbiBsb2NhdGlvbiBwbGFjZWQgaW5NAXN0b3JhZ2UgYnkgdGhpcyBydW50aW1lIHByZXZpb3VzbHkgY2Fubm90IGJlIGRlY29kZWQuIFRoZSBxdWVyeSByZW1haW5zIHJlZ2lzdGVyZWQuAEEBVGhpcyBpcyB1bmV4cGVjdGVkIChzaW5jZSBhIGxvY2F0aW9uIHBsYWNlZCBpbiBzdG9yYWdlIGluIGEgcHJldmlvdXNseSBleGVjdXRpbmdNAXJ1bnRpbWUgc2hvdWxkIGJlIHJlYWRhYmxlIHByaW9yIHRvIHF1ZXJ5IHRpbWVvdXQpIGFuZCBkYW5nZXJvdXMgc2luY2UgdGhlIHBvc3NpYmx5WQF2YWxpZCByZXNwb25zZSB3aWxsIGJlIGRyb3BwZWQuIE1hbnVhbCBnb3Zlcm5hbmNlIGludGVydmVudGlvbiBpcyBwcm9iYWJseSBnb2luZyB0byBiZRxuZWVkZWQuNFJlc3BvbnNlVGFrZW4EASBxdWVyeV9pZDABHFF1ZXJ5SWQACgTIUmVjZWl2ZWQgcXVlcnkgcmVzcG9uc2UgaGFzIGJlZW4gcmVhZCBhbmQgcmVtb3ZlZC40QXNzZXRzVHJhcHBlZAwBEGhhc2g0ARBIMjU2AAEYb3JpZ2lufQEBIExvY2F0aW9uAAEYYXNzZXRz6QUBPFZlcnNpb25lZEFzc2V0cwALBLhTb21lIGFzc2V0cyBoYXZlIGJlZW4gcGxhY2VkIGluIGFuIGFzc2V0IHRyYXAuVFZlcnNpb25DaGFuZ2VOb3RpZmllZBABLGRlc3RpbmF0aW9ufQEBIExvY2F0aW9uAAEYcmVzdWx0EAEoWGNtVmVyc2lvbgABEGNvc3SpBQEYQXNzZXRzAAEobWVzc2FnZV9pZAQBHFhjbUhhc2gADAwlAUFuIFhDTSB2ZXJzaW9uIGNoYW5nZSBub3RpZmljYXRpb24gbWVzc2FnZSBoYXMgYmVlbiBhdHRlbXB0ZWQgdG8gYmUgc2VudC4A4FRoZSBjb3N0IG9mIHNlbmRpbmcgaXQgKGJvcm5lIGJ5IHRoZSBjaGFpbikgaXMgaW5jbHVkZWQuXFN1cHBvcnRlZFZlcnNpb25DaGFuZ2VkCAEgbG9jYXRpb259AQEgTG9jYXRpb24AARx2ZXJzaW9uEAEoWGNtVmVyc2lvbgANCDkBVGhlIHN1cHBvcnRlZCB2ZXJzaW9uIG9mIGEgbG9jYXRpb24gaGFzIGJlZW4gY2hhbmdlZC4gVGhpcyBtaWdodCBiZSB0aHJvdWdoIGFuwGF1dG9tYXRpYyBub3RpZmljYXRpb24gb3IgYSBtYW51YWwgaW50ZXJ2ZW50aW9uLlBOb3RpZnlUYXJnZXRTZW5kRmFpbAwBIGxvY2F0aW9ufQEBIExvY2F0aW9uAAEgcXVlcnlfaWQwARxRdWVyeUlkAAEUZXJyb3JlBQEgWGNtRXJyb3IADghZAUEgZ2l2ZW4gbG9jYXRpb24gd2hpY2ggaGFkIGEgdmVyc2lvbiBjaGFuZ2Ugc3Vic2NyaXB0aW9uIHdhcyBkcm9wcGVkIG93aW5nIHRvIGFuIGVycm9yfHNlbmRpbmcgdGhlIG5vdGlmaWNhdGlvbiB0byBpdC5kTm90aWZ5VGFyZ2V0TWlncmF0aW9uRmFpbAgBIGxvY2F0aW9uxQQBRFZlcnNpb25lZExvY2F0aW9uAAEgcXVlcnlfaWQwARxRdWVyeUlkAA8IWQFBIGdpdmVuIGxvY2F0aW9uIHdoaWNoIGhhZCBhIHZlcnNpb24gY2hhbmdlIHN1YnNjcmlwdGlvbiB3YXMgZHJvcHBlZCBvd2luZyB0byBhbiBlcnJvcrRtaWdyYXRpbmcgdGhlIGxvY2F0aW9uIHRvIG91ciBuZXcgWENNIGZvcm1hdC5USW52YWxpZFF1ZXJpZXJWZXJzaW9uCAEYb3JpZ2lufQEBIExvY2F0aW9uAAEgcXVlcnlfaWQwARxRdWVyeUlkABAcVQFFeHBlY3RlZCBxdWVyeSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBidXQgdGhlIGV4cGVjdGVkIHF1ZXJpZXIgbG9jYXRpb24gcGxhY2VkIGluTQFzdG9yYWdlIGJ5IHRoaXMgcnVudGltZSBwcmV2aW91c2x5IGNhbm5vdCBiZSBkZWNvZGVkLiBUaGUgcXVlcnkgcmVtYWlucyByZWdpc3RlcmVkLgBBAVRoaXMgaXMgdW5leHBlY3RlZCAoc2luY2UgYSBsb2NhdGlvbiBwbGFjZWQgaW4gc3RvcmFnZSBpbiBhIHByZXZpb3VzbHkgZXhlY3V0aW5nTQFydW50aW1lIHNob3VsZCBiZSByZWFkYWJsZSBwcmlvciB0byBxdWVyeSB0aW1lb3V0KSBhbmQgZGFuZ2Vyb3VzIHNpbmNlIHRoZSBwb3NzaWJseVkBdmFsaWQgcmVzcG9uc2Ugd2lsbCBiZSBkcm9wcGVkLiBNYW51YWwgZ292ZXJuYW5jZSBpbnRlcnZlbnRpb24gaXMgcHJvYmFibHkgZ29pbmcgdG8gYmUcbmVlZGVkLjhJbnZhbGlkUXVlcmllchABGG9yaWdpbn0BASBMb2NhdGlvbgABIHF1ZXJ5X2lkMAEcUXVlcnlJZAABQGV4cGVjdGVkX3F1ZXJpZXJ9AQEgTG9jYXRpb24AAVBtYXliZV9hY3R1YWxfcXVlcmllctUFAUBPcHRpb248TG9jYXRpb24+ABEMXQFFeHBlY3RlZCBxdWVyeSByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBidXQgdGhlIHF1ZXJpZXIgbG9jYXRpb24gb2YgdGhlIHJlc3BvbnNlIGRvZXNRAW5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQuIFRoZSBxdWVyeSByZW1haW5zIHJlZ2lzdGVyZWQgZm9yIGEgbGF0ZXIsIHZhbGlkLCByZXNwb25zZSB0b2xiZSByZWNlaXZlZCBhbmQgYWN0ZWQgdXBvbi5QVmVyc2lvbk5vdGlmeVN0YXJ0ZWQMASxkZXN0aW5hdGlvbn0BASBMb2NhdGlvbgABEGNvc3SpBQEYQXNzZXRzAAEobWVzc2FnZV9pZAQBHFhjbUhhc2gAEghZAUEgcmVtb3RlIGhhcyByZXF1ZXN0ZWQgWENNIHZlcnNpb24gY2hhbmdlIG5vdGlmaWNhdGlvbiBmcm9tIHVzIGFuZCB3ZSBoYXZlIGhvbm9yZWQgaXQuHQFBIHZlcnNpb24gaW5mb3JtYXRpb24gbWVzc2FnZSBpcyBzZW50IHRvIHRoZW0gYW5kIGl0cyBjb3N0IGlzIGluY2x1ZGVkLlhWZXJzaW9uTm90aWZ5UmVxdWVzdGVkDAEsZGVzdGluYXRpb259AQEgTG9jYXRpb24AARBjb3N0qQUBGEFzc2V0cwABKG1lc3NhZ2VfaWQEARxYY21IYXNoABMEPQFXZSBoYXZlIHJlcXVlc3RlZCB0aGF0IGEgcmVtb3RlIGNoYWluIHNlbmQgdXMgWENNIHZlcnNpb24gY2hhbmdlIG5vdGlmaWNhdGlvbnMuYFZlcnNpb25Ob3RpZnlVbnJlcXVlc3RlZAwBLGRlc3RpbmF0aW9ufQEBIExvY2F0aW9uAAEQY29zdKkFARhBc3NldHMAAShtZXNzYWdlX2lkBAEcWGNtSGFzaAAUCCUBV2UgaGF2ZSByZXF1ZXN0ZWQgdGhhdCBhIHJlbW90ZSBjaGFpbiBzdG9wcyBzZW5kaW5nIHVzIFhDTSB2ZXJzaW9uIGNoYW5nZThub3RpZmljYXRpb25zLiBGZWVzUGFpZAgBGHBheWluZ30BASBMb2NhdGlvbgABEGZlZXOpBQEYQXNzZXRzABUEMQFGZWVzIHdlcmUgcGFpZCBmcm9tIGEgbG9jYXRpb24gZm9yIGFuIG9wZXJhdGlvbiAob2Z0ZW4gZm9yIHVzaW5nIGBTZW5kWGNtYCkuNEFzc2V0c0NsYWltZWQMARBoYXNoNAEQSDI1NgABGG9yaWdpbn0BASBMb2NhdGlvbgABGGFzc2V0c+kFATxWZXJzaW9uZWRBc3NldHMAFgTAU29tZSBhc3NldHMgaGF2ZSBiZWVuIGNsYWltZWQgZnJvbSBhbiBhc3NldCB0cmFwYFZlcnNpb25NaWdyYXRpb25GaW5pc2hlZAQBHHZlcnNpb24QAShYY21WZXJzaW9uABcEhEEgWENNIHZlcnNpb24gbWlncmF0aW9uIGZpbmlzaGVkLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldDkIECxzdGFnaW5nX3hjbQh2NBh0cmFpdHMcT3V0Y29tZQABDCBDb21wbGV0ZQQBEHVzZWQoARhXZWlnaHQAAAAoSW5jb21wbGV0ZQgBEHVzZWQoARhXZWlnaHQAARRlcnJvcmUFARRFcnJvcgABABRFcnJvcgQBFGVycm9yZQUBFEVycm9yAAIAAD0IDEhjdW11bHVzX3BhbGxldF94Y20YcGFsbGV0FEV2ZW50BARUAAEMNEludmFsaWRGb3JtYXQEAAQBIFt1ODsgMzJdAAAIgERvd253YXJkIG1lc3NhZ2UgaXMgaW52YWxpZCBYQ00uIFxbIGlkIFxdSFVuc3VwcG9ydGVkVmVyc2lvbgQABAEgW3U4OyAzMl0AAQi8RG93bndhcmQgbWVzc2FnZSBpcyB1bnN1cHBvcnRlZCB2ZXJzaW9uIG9mIFhDTS4gXFsgaWQgXF1ARXhlY3V0ZWREb3dud2FyZAgABAEgW3U4OyAzMl0AADkIARxPdXRjb21lAAIIxERvd253YXJkIG1lc3NhZ2UgZXhlY3V0ZWQgd2l0aCB0aGUgZ2l2ZW4gb3V0Y29tZS5EXFsgaWQsIG91dGNvbWUgXF0EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXRBCAxkY3VtdWx1c19wYWxsZXRfeGNtcF9xdWV1ZRhwYWxsZXQURXZlbnQEBFQAAQQ8WGNtcE1lc3NhZ2VTZW50BAEwbWVzc2FnZV9oYXNoBAEcWGNtSGFzaAAABMBBbiBIUk1QIG1lc3NhZ2Ugd2FzIHNlbnQgdG8gYSBzaWJsaW5nIHBhcmFjaGFpbi4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXRFCAxQcGFsbGV0X21lc3NhZ2VfcXVldWUYcGFsbGV0FEV2ZW50BARUAAEQQFByb2Nlc3NpbmdGYWlsZWQMAQhpZDQBEEgyNTYElFRoZSBgYmxha2UyXzI1NmAgaGFzaCBvZiB0aGUgbWVzc2FnZS4BGG9yaWdpbikGAUhNZXNzYWdlT3JpZ2luT2Y8VD4EZFRoZSBxdWV1ZSBvZiB0aGUgbWVzc2FnZS4BFGVycm9ySQgBTFByb2Nlc3NNZXNzYWdlRXJyb3IQYFRoZSBlcnJvciB0aGF0IG9jY3VycmVkLgBJAVRoaXMgZXJyb3IgaXMgcHJldHR5IG9wYXF1ZS4gTW9yZSBmaW5lLWdyYWluZWQgZXJyb3JzIG5lZWQgdG8gYmUgZW1pdHRlZCBhcyBldmVudHNoYnkgdGhlIGBNZXNzYWdlUHJvY2Vzc29yYC4ABFUBTWVzc2FnZSBkaXNjYXJkZWQgZHVlIHRvIGFuIGVycm9yIGluIHRoZSBgTWVzc2FnZVByb2Nlc3NvcmAgKHVzdWFsbHkgYSBmb3JtYXQgZXJyb3IpLiRQcm9jZXNzZWQQAQhpZDQBEEgyNTYElFRoZSBgYmxha2UyXzI1NmAgaGFzaCBvZiB0aGUgbWVzc2FnZS4BGG9yaWdpbikGAUhNZXNzYWdlT3JpZ2luT2Y8VD4EZFRoZSBxdWV1ZSBvZiB0aGUgbWVzc2FnZS4BLHdlaWdodF91c2VkKAEYV2VpZ2h0BMBIb3cgbXVjaCB3ZWlnaHQgd2FzIHVzZWQgdG8gcHJvY2VzcyB0aGUgbWVzc2FnZS4BHHN1Y2Nlc3MgARBib29sGIhXaGV0aGVyIHRoZSBtZXNzYWdlIHdhcyBwcm9jZXNzZWQuAEkBTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IHRoZSB1bmRlcmx5aW5nIGBNZXNzYWdlUHJvY2Vzc29yYCB3YXMgaW50ZXJuYWxseTUBc3VjY2Vzc2Z1bC4gSXQgKnNvbGVseSogbWVhbnMgdGhhdCB0aGUgTVEgcGFsbGV0IHdpbGwgdHJlYXQgdGhpcyBhcyBhIHN1Y2Nlc3NNAWNvbmRpdGlvbiBhbmQgZGlzY2FyZCB0aGUgbWVzc2FnZS4gQW55IGludGVybmFsIGVycm9yIG5lZWRzIHRvIGJlIGVtaXR0ZWQgYXMgZXZlbnRzaGJ5IHRoZSBgTWVzc2FnZVByb2Nlc3NvcmAuAQRUTWVzc2FnZSBpcyBwcm9jZXNzZWQuSE92ZXJ3ZWlnaHRFbnF1ZXVlZBABCGlkBAEgW3U4OyAzMl0ElFRoZSBgYmxha2UyXzI1NmAgaGFzaCBvZiB0aGUgbWVzc2FnZS4BGG9yaWdpbikGAUhNZXNzYWdlT3JpZ2luT2Y8VD4EZFRoZSBxdWV1ZSBvZiB0aGUgbWVzc2FnZS4BKHBhZ2VfaW5kZXgQASRQYWdlSW5kZXgEYFRoZSBwYWdlIG9mIHRoZSBtZXNzYWdlLgE0bWVzc2FnZV9pbmRleBABHFQ6OlNpemUEpFRoZSBpbmRleCBvZiB0aGUgbWVzc2FnZSB3aXRoaW4gdGhlIHBhZ2UuAgSMTWVzc2FnZSBwbGFjZWQgaW4gb3ZlcndlaWdodCBxdWV1ZS4oUGFnZVJlYXBlZAgBGG9yaWdpbikGAUhNZXNzYWdlT3JpZ2luT2Y8VD4EWFRoZSBxdWV1ZSBvZiB0aGUgcGFnZS4BFGluZGV4EAEkUGFnZUluZGV4BFhUaGUgaW5kZXggb2YgdGhlIHBhZ2UuAwRUVGhpcyBwYWdlIHdhcyByZWFwZWQuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0SQgQNGZyYW1lX3N1cHBvcnQYdHJhaXRzIG1lc3NhZ2VzTFByb2Nlc3NNZXNzYWdlRXJyb3IAARgkQmFkRm9ybWF0AAAAHENvcnJ1cHQAAQAsVW5zdXBwb3J0ZWQAAgAoT3ZlcndlaWdodAQAKAEYV2VpZ2h0AAMAFFlpZWxkAAQARFN0YWNrTGltaXRSZWFjaGVkAAUAAE0IDCBvcm1sX3hjbRhtb2R1bGUURXZlbnQEBFQAAQQQU2VudAgBCHRvfQEBIExvY2F0aW9uAAEcbWVzc2FnZZ0FARxYY208KCk+AAAEhFhDTSBtZXNzYWdlIHNlbnQuIFxbdG8sIG1lc3NhZ2VcXQR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldFEIDDBvcm1sX3h0b2tlbnMYbW9kdWxlFEV2ZW50BARUAAEERFRyYW5zZmVycmVkQXNzZXRzEAEYc2VuZGVyAAEwVDo6QWNjb3VudElkAAEYYXNzZXRzqQUBGEFzc2V0cwABDGZlZbEFARRBc3NldAABEGRlc3R9AQEgTG9jYXRpb24AAAR0VHJhbnNmZXJyZWQgYEFzc2V0YCB3aXRoIGZlZS4EfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXRVCAxMb3JtbF91bmtub3duX3Rva2Vucxhtb2R1bGUURXZlbnQAAQgkRGVwb3NpdGVkCAEUYXNzZXSxBQEUQXNzZXQAAQx3aG99AQEgTG9jYXRpb24AAARARGVwb3NpdCBzdWNjZXNzLiRXaXRoZHJhd24IARRhc3NldLEFARRBc3NldAABDHdob30BASBMb2NhdGlvbgABBERXaXRoZHJhdyBzdWNjZXNzLgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldFkIDGRwYWxsZXRfY29sbGF0b3Jfc2VsZWN0aW9uGHBhbGxldBRFdmVudAQEVAABKEBOZXdJbnZ1bG5lcmFibGVzBAE0aW52dWxuZXJhYmxlczEBAURWZWM8VDo6QWNjb3VudElkPgAABGxOZXcgSW52dWxuZXJhYmxlcyB3ZXJlIHNldC5ESW52dWxuZXJhYmxlQWRkZWQEAShhY2NvdW50X2lkAAEwVDo6QWNjb3VudElkAAEEdEEgbmV3IEludnVsbmVyYWJsZSB3YXMgYWRkZWQuTEludnVsbmVyYWJsZVJlbW92ZWQEAShhY2NvdW50X2lkAAEwVDo6QWNjb3VudElkAAIEcEFuIEludnVsbmVyYWJsZSB3YXMgcmVtb3ZlZC5QTmV3RGVzaXJlZENhbmRpZGF0ZXMEAUhkZXNpcmVkX2NhbmRpZGF0ZXMQAQx1MzIAAwSkVGhlIG51bWJlciBvZiBkZXNpcmVkIGNhbmRpZGF0ZXMgd2FzIHNldC5ATmV3Q2FuZGlkYWN5Qm9uZAQBLGJvbmRfYW1vdW50GAEwQmFsYW5jZU9mPFQ+AAQEbFRoZSBjYW5kaWRhY3kgYm9uZCB3YXMgc2V0LjhDYW5kaWRhdGVBZGRlZAgBKGFjY291bnRfaWQAATBUOjpBY2NvdW50SWQAARxkZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAUEXEEgbmV3IGNhbmRpZGF0ZSBqb2luZWQuUENhbmRpZGF0ZUJvbmRVcGRhdGVkCAEoYWNjb3VudF9pZAABMFQ6OkFjY291bnRJZAABHGRlcG9zaXQYATBCYWxhbmNlT2Y8VD4ABgRwQm9uZCBvZiBhIGNhbmRpZGF0ZSB1cGRhdGVkLkBDYW5kaWRhdGVSZW1vdmVkBAEoYWNjb3VudF9pZAABMFQ6OkFjY291bnRJZAAHBGBBIGNhbmRpZGF0ZSB3YXMgcmVtb3ZlZC5EQ2FuZGlkYXRlUmVwbGFjZWQMAQxvbGQAATBUOjpBY2NvdW50SWQAAQxuZXcAATBUOjpBY2NvdW50SWQAARxkZXBvc2l0GAEwQmFsYW5jZU9mPFQ+AAgE9EFuIGFjY291bnQgd2FzIHJlcGxhY2VkIGluIHRoZSBjYW5kaWRhdGUgbGlzdCBieSBhbm90aGVyIG9uZS5oSW52YWxpZEludnVsbmVyYWJsZVNraXBwZWQEAShhY2NvdW50X2lkAAEwVDo6QWNjb3VudElkAAkIVQFBbiBhY2NvdW50IHdhcyB1bmFibGUgdG8gYmUgYWRkZWQgdG8gdGhlIEludnVsbmVyYWJsZXMgYmVjYXVzZSB0aGV5IGRpZCBub3QgaGF2ZSBrZXlzyHJlZ2lzdGVyZWQuIE90aGVyIEludnVsbmVyYWJsZXMgbWF5IGhhdmUgYmVlbiBzZXQuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0XQgMOHBhbGxldF9zZXNzaW9uGHBhbGxldBRFdmVudAABBChOZXdTZXNzaW9uBAE0c2Vzc2lvbl9pbmRleBABMFNlc3Npb25JbmRleAAACDkBTmV3IHNlc3Npb24gaGFzIGhhcHBlbmVkLiBOb3RlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIHRoZSBzZXNzaW9uIGluZGV4LCBub3QgdGhlnGJsb2NrIG51bWJlciBhcyB0aGUgdHlwZSBtaWdodCBzdWdnZXN0LgR8VGhlIGBFdmVudGAgZW51bSBvZiB0aGlzIHBhbGxldGEIDCxwYWxsZXRfaXNtcBhwYWxsZXQURXZlbnQEBFQAATRMU3RhdGVNYWNoaW5lVXBkYXRlZAgBQHN0YXRlX21hY2hpbmVfaWR5BgE4U3RhdGVNYWNoaW5lSWQEYFN0YXRlIG1hY2hpbmUgaWRlbnRpZmllcgE0bGF0ZXN0X2hlaWdodDABDHU2NARsU3RhdGUgbWFjaGluZSBsYXRlc3QgaGVpZ2h0AAQRAUVtaXR0ZWQgd2hlbiBhIHN0YXRlIG1hY2hpbmUgaXMgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgdG8gYSBuZXcgaGVpZ2h0VFN0YXRlQ29tbWl0bWVudFZldG9lZAgBGGhlaWdodHUGAUhTdGF0ZU1hY2hpbmVIZWlnaHQEUFN0YXRlIG1hY2hpbmUgaGVpZ2h0ASRmaXNoZXJtYW5lCAFwQm91bmRlZFZlYzx1OCwgQ29uc3RVMzI8MzI+PgRUcmVzcG9uc2libGUgZmlzaGVybWFuAQTgRW1pdHRlZCB3aGVuIGEgc3RhdGUgY29tbWl0bWVudCBpcyB2ZXRvZWQgYnkgYSBmaXNoZXJtYW5YQ29uc2Vuc3VzQ2xpZW50Q3JlYXRlZAQBTGNvbnNlbnN1c19jbGllbnRfaWRIAURDb25zZW5zdXNDbGllbnRJZARMQ29uc2Vuc3VzIGNsaWVudCBpZAIEyEluZGljYXRlcyB0aGF0IGEgY29uc2Vuc3VzIGNsaWVudCBoYXMgYmVlbiBjcmVhdGVkVENvbnNlbnN1c0NsaWVudEZyb3plbgQBTGNvbnNlbnN1c19jbGllbnRfaWRIAURDb25zZW5zdXNDbGllbnRJZARMQ29uc2Vuc3VzIGNsaWVudCBpZAMEyEluZGljYXRlcyB0aGF0IGEgY29uc2Vuc3VzIGNsaWVudCBoYXMgYmVlbiBjcmVhdGVkIFJlc3BvbnNlFAEoZGVzdF9jaGFpbm0GATBTdGF0ZU1hY2hpbmUEqENoYWluIHRoYXQgdGhpcyByZXNwb25zZSB3aWxsIGJlIHJvdXRlZCB0bwEwc291cmNlX2NoYWlubQYBMFN0YXRlTWFjaGluZQR4U291cmNlIENoYWluIGZvciB0aGlzIHJlc3BvbnNlATRyZXF1ZXN0X25vbmNlMAEMdTY0BMBOb25jZSBmb3IgdGhlIHJlcXVlc3Qgd2hpY2ggdGhpcyByZXNwb25zZSBpcyBmb3IBKGNvbW1pdG1lbnQ0ARBIMjU2BExSZXNwb25zZSBDb21taXRtZW50AThyZXFfY29tbWl0bWVudDQBEEgyNTYESFJlcXVlc3QgY29tbWl0bWVudAQEnEFuIE91dGdvaW5nIFJlc3BvbnNlIGhhcyBiZWVuIGRlcG9zaXRlZBxSZXF1ZXN0EAEoZGVzdF9jaGFpbm0GATBTdGF0ZU1hY2hpbmUEpENoYWluIHRoYXQgdGhpcyByZXF1ZXN0IHdpbGwgYmUgcm91dGVkIHRvATBzb3VyY2VfY2hhaW5tBgEwU3RhdGVNYWNoaW5lBGBTb3VyY2UgQ2hhaW4gZm9yIHJlcXVlc3QBNHJlcXVlc3Rfbm9uY2UwAQx1NjQENFJlcXVlc3Qgbm9uY2UBKGNvbW1pdG1lbnQ0ARBIMjU2BChDb21taXRtZW50BQSYQW4gT3V0Z29pbmcgUmVxdWVzdCBoYXMgYmVlbiBkZXBvc2l0ZWQYRXJyb3JzBAEYZXJyb3JzaQgBSFZlYzxIYW5kbGluZ0Vycm9yPgRcTWVzc2FnZSBoYW5kbGluZyBlcnJvcnMGBJxTb21lIGVycm9ycyBoYW5kbGluZyBzb21lIGlzbXAgbWVzc2FnZXNIUG9zdFJlcXVlc3RIYW5kbGVkBAB1CAFYUmVxdWVzdFJlc3BvbnNlSGFuZGxlZAAHBFBQb3N0IFJlcXVlc3QgSGFuZGxlZExQb3N0UmVzcG9uc2VIYW5kbGVkBAB1CAFYUmVxdWVzdFJlc3BvbnNlSGFuZGxlZAAIBFRQb3N0IFJlc3BvbnNlIEhhbmRsZWRER2V0UmVxdWVzdEhhbmRsZWQEAHUIAVhSZXF1ZXN0UmVzcG9uc2VIYW5kbGVkAAkEUEdldCBSZXNwb25zZSBIYW5kbGVkZFBvc3RSZXF1ZXN0VGltZW91dEhhbmRsZWQEAHkIAThUaW1lb3V0SGFuZGxlZAAKBHBQb3N0IHJlcXVlc3QgdGltZW91dCBoYW5kbGVkaFBvc3RSZXNwb25zZVRpbWVvdXRIYW5kbGVkBAB5CAE4VGltZW91dEhhbmRsZWQACwR0UG9zdCByZXNwb25zZSB0aW1lb3V0IGhhbmRsZWRgR2V0UmVxdWVzdFRpbWVvdXRIYW5kbGVkBAB5CAE4VGltZW91dEhhbmRsZWQADARsR2V0IHJlcXVlc3QgdGltZW91dCBoYW5kbGVkBDRQYWxsZXQgRXZlbnRzZQgMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AABpCAAAAm0IAG0IDCxwYWxsZXRfaXNtcBhlcnJvcnM0SGFuZGxpbmdFcnJvcgAABAEcbWVzc2FnZXEIAXhCb3VuZGVkVmVjPHU4LCBDb25zdFUzMjwxMDAwPj4AAHEIDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAAdQgMEGlzbXAYZXZlbnRzWFJlcXVlc3RSZXNwb25zZUhhbmRsZWQAAAgBKGNvbW1pdG1lbnQ0ARBIMjU2AAEccmVsYXllcjgBHFZlYzx1OD4AAHkIDBBpc21wGGV2ZW50czhUaW1lb3V0SGFuZGxlZAAADAEoY29tbWl0bWVudDQBEEgyNTYAARhzb3VyY2VtBgEwU3RhdGVNYWNoaW5lAAEQZGVzdG0GATBTdGF0ZU1hY2hpbmUAAH0IDDhpc21wX3BhcmFjaGFpbhhwYWxsZXQURXZlbnQEBFQAAQg8UGFyYWNoYWluc0FkZGVkBAEgcGFyYV9pZHPpBgFIVmVjPFBhcmFjaGFpbkRhdGE+BGhUaGUgcGFyYWNoYWlucyBpbiBxdWVzdGlvbgAE/FBhcmFjaGFpbnMgd2l0aCB0aGUgYHBhcmFfaWRzYCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIHdoaXRlbGlzdERQYXJhY2hhaW5zUmVtb3ZlZAQBIHBhcmFfaWRzWQMBIFZlYzx1MzI+BGhUaGUgcGFyYWNoYWlucyBpbiBxdWVzdGlvbgEEDQFQYXJhY2hhaW5zIHdpdGggdGhlIGBwYXJhX2lkc2AgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgd2hpdGVsaXN0BHRFdmVudHMgZW1pdHRlZCBieSB0aGlzIHBhbGxldIEIDEhwYWxsZXRfaHlwZXJicmlkZ2UYcGFsbGV0FEV2ZW50BARUAAEMREhvc3RQYXJhbXNVcGRhdGVkCAEMb2xkhQgB4FZlcnNpb25lZEhvc3RQYXJhbXM8PFQgYXMgcGFsbGV0X2lzbXA6OkNvbmZpZz46OkJhbGFuY2U+BExUaGUgb2xkIGhvc3QgcGFyYW1zAQxuZXeFCAHgVmVyc2lvbmVkSG9zdFBhcmFtczw8VCBhcyBwYWxsZXRfaXNtcDo6Q29uZmlnPjo6QmFsYW5jZT4ETFRoZSBuZXcgaG9zdCBwYXJhbXMABBkBSHlwZXJicmlkZ2UgZ292ZXJuYW5jZSBoYXMgbm93IHVwZGF0ZWQgaXQncyBob3N0IHBhcmFtcyBvbiB0aGlzIGNoYWluLkxSZWxheWVyRmVlV2l0aGRyYXduCAEYYW1vdW50GAGMPFQgYXMgcGFsbGV0X2lzbXA6OkNvbmZpZz46OkJhbGFuY2UEdFRoZSBhbW91bnQgdGhhdCB3YXMgd2l0aGRyYXduARxhY2NvdW50AAEwVDo6QWNjb3VudElkBGhUaGUgd2l0aGRyYXdhbCBiZW5lZmljaWFyeQEEhEEgcmVsYXllciBoYXMgd2l0aGRyYXduIHNvbWUgZmVlc2BQcm90b2NvbFJldmVudWVXaXRoZHJhd24IARhhbW91bnQYAYw8VCBhcyBwYWxsZXRfaXNtcDo6Q29uZmlnPjo6QmFsYW5jZQR0VGhlIGFtb3VudCB0aGF0IHdhcyB3aXRoZHJhd24BHGFjY291bnQAATBUOjpBY2NvdW50SWQEaFRoZSB3aXRoZHJhd2FsIGJlbmVmaWNpYXJ5AgS8SHlwZXJicmlkZ2UgaGFzIHdpdGhkcmF3biBpdCdzIHByb3RvY29sIHJldmVudWUEfFRoZSBgRXZlbnRgIGVudW0gb2YgdGhpcyBwYWxsZXSFCAhIcGFsbGV0X2h5cGVyYnJpZGdlTFZlcnNpb25lZEhvc3RQYXJhbXMEHEJhbGFuY2UBGAEECFYxBACJCAFwU3Vic3RyYXRlSG9zdFBhcmFtczxCYWxhbmNlPgAAAACJCAhIcGFsbGV0X2h5cGVyYnJpZGdlTFN1YnN0cmF0ZUhvc3RQYXJhbXMEBEIBGAAMAVBkZWZhdWx0X3Blcl9ieXRlX2ZlZRgBBEIAATRwZXJfYnl0ZV9mZWVzjQgBZEJUcmVlTWFwPFN0YXRlTWFjaGluZSwgQj4AAVhhc3NldF9yZWdpc3RyYXRpb25fZmVlGAEEQgAAjQgEIEJUcmVlTWFwCARLAW0GBFYBGAAEAJEIAAAAkQgAAAKVCACVCAAABAhtBhgAmQgMUHBhbGxldF90b2tlbl9nYXRld2F5GHBhbGxldBRFdmVudAQEVAABEDxBc3NldFRlbGVwb3J0ZWQUARBmcm9tAAEwVDo6QWNjb3VudElkBDhTb3VyY2UgYWNjb3VudAEIdG80ARBIMjU2BIhiZW5lZmljaWFyeSBhY2NvdW50IG9uIGRlc3RpbmF0aW9uARhhbW91bnQYAdg8VDo6TmF0aXZlQ3VycmVuY3kgYXMgQ3VycmVuY3k8VDo6QWNjb3VudElkPj46OkJhbGFuY2UESEFtb3VudCB0cmFuc2ZlcnJlZAEQZGVzdG0GATBTdGF0ZU1hY2hpbmUERERlc3RpbmF0aW9uIGNoYWluAShjb21taXRtZW50NAEQSDI1NgRIUmVxdWVzdCBjb21taXRtZW50AARwQW4gYXNzZXQgaGFzIGJlZW4gdGVsZXBvcnRlZDRBc3NldFJlY2VpdmVkDAEsYmVuZWZpY2lhcnkAATBUOjpBY2NvdW50SWQEhGJlbmVmaWNpYXJ5IGFjY291bnQgb24gcmVsYXljaGFpbgEYYW1vdW50GAENATw8VCBhcyBDb25maWc+OjpOYXRpdmVDdXJyZW5jeSBhcyBDdXJyZW5jeTxUOjpBY2NvdW50SWQ+Pjo6CkJhbGFuY2UESEFtb3VudCB0cmFuc2ZlcnJlZAEYc291cmNlbQYBMFN0YXRlTWFjaGluZQRERGVzdGluYXRpb24gY2hhaW4BBB0BQW4gYXNzZXQgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIHRyYW5zZmVycmVkIHRvIHRoZSBiZW5lZmljaWFyeSdzIGFjY291bnQ0QXNzZXRSZWZ1bmRlZAwBLGJlbmVmaWNpYXJ5AAEwVDo6QWNjb3VudElkBIRiZW5lZmljaWFyeSBhY2NvdW50IG9uIHJlbGF5Y2hhaW4BGGFtb3VudBgBDQE8PFQgYXMgQ29uZmlnPjo6TmF0aXZlQ3VycmVuY3kgYXMgQ3VycmVuY3k8VDo6QWNjb3VudElkPj46OgpCYWxhbmNlBEhBbW91bnQgdHJhbnNmZXJyZWQBGHNvdXJjZW0GATBTdGF0ZU1hY2hpbmUERERlc3RpbmF0aW9uIGNoYWluAgQdAUFuIGFzc2V0IGhhcyBiZWVuIHJlZnVuZGVkIGFuZCB0cmFuc2ZlcnJlZCB0byB0aGUgYmVuZWZpY2lhcnkncyBhY2NvdW50iEVSQzYxNjBBc3NldFJlZ2lzdHJhdGlvbkRpc3BhdGNoZWQEAShjb21taXRtZW50NAEQSDI1NgRIUmVxdWVzdCBjb21taXRtZW50AwTgRVJDNjE2MCBhc3NldCBjcmVhdGlvbiByZXF1ZXN0IGRpc3BhdGNoZWQgdG8gaHlwZXJicmlkZ2UE1FBhbGxldCBldmVudHMgdGhhdCBmdW5jdGlvbnMgaW4gdGhpcyBwYWxsZXQgY2FuIGVtaXQunQgMRHBhbGxldF9lbWFfb3JhY2xlGHBhbGxldBRFdmVudAQEVAABCEBBZGRlZFRvV2hpdGVsaXN0CAEYc291cmNl/QEBGFNvdXJjZQABGGFzc2V0c00DAUgoQXNzZXRJZCwgQXNzZXRJZCkAAASIT3JhY2xlIHdhcyBhZGRlZCB0byB0aGUgd2hpdGVsaXN0LlBSZW1vdmVkRnJvbVdoaXRlbGlzdAgBGHNvdXJjZf0BARhTb3VyY2UAARhhc3NldHNNAwFIKEFzc2V0SWQsIEFzc2V0SWQpAAEEmE9yYWNsZSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSB3aGl0ZWxpc3QuBHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0oQgMQHBhbGxldF9icm9hZGNhc3QYcGFsbGV0FEV2ZW50BARUAAEEIFN3YXBwZWQzIAEcc3dhcHBlcgABMFQ6OkFjY291bnRJZAABGGZpbGxlcgABMFQ6OkFjY291bnRJZAABLGZpbGxlcl90eXBlpQgBGEZpbGxlcgABJG9wZXJhdGlvbqkIAThUcmFkZU9wZXJhdGlvbgABGGlucHV0c60IAShWZWM8QXNzZXQ+AAEcb3V0cHV0c60IAShWZWM8QXNzZXQ+AAEQZmVlc7UIAVhWZWM8RmVlPFQ6OkFjY291bnRJZD4+AAE8b3BlcmF0aW9uX3N0YWNrwQgBSFZlYzxFeGVjdXRpb25UeXBlPgAAIDxUcmFkZSBleGVjdXRlZC4A8FN3YXBwZWQzIGlzIGEgZml4ZWQgYW5kIHJlbmFtZWQgdmVyc2lvbiBvZiBvcmlnaW5hbCBTd2FwcGVkLAUBYXMgU3dhcHBlZCBjb250YWluZWQgd3JvbmcgaW5wdXQvb3V0cHV0IGFtb3VudHMgZm9yIFhZSyBidXkgdHJhZGUA9FN3YXBwZWQzIGlzIGEgZml4ZWQgYW5kIHJlbmFtZWQgdmVyc2lvbiBvZiBvcmlnaW5hbCBTd2FwcGVkMyzgYXMgU3dhcHBlZCBjb250YWluZWQgd3JvbmcgZmlsbGVyIGFjY291bnQgb24gQUFWRSB0cmFkZXMABHxUaGUgYEV2ZW50YCBlbnVtIG9mIHRoaXMgcGFsbGV0pQgMQHBhbGxldF9icm9hZGNhc3QUdHlwZXMYRmlsbGVyAAEcIE9tbmlwb29sAAAAKFN0YWJsZXN3YXAEABABHEFzc2V0SWQAAQAMWFlLBAAQARxBc3NldElkAAIADExCUAADAAxPVEMEABABKE90Y09yZGVySWQABAAQQUFWRQAFAAxIU00ABgAAqQgMQHBhbGxldF9icm9hZGNhc3QUdHlwZXM4VHJhZGVPcGVyYXRpb24AARQcRXhhY3RJbgAAACBFeGFjdE91dAABABRMaW1pdAACADBMaXF1aWRpdHlBZGQAAwA8TGlxdWlkaXR5UmVtb3ZlAAQAAK0IAAACsQgAsQgMQHBhbGxldF9icm9hZGNhc3QUdHlwZXMUQXNzZXQAAAgBFGFzc2V0EAEcQXNzZXRJZAABGGFtb3VudBgBHEJhbGFuY2UAALUIAAACuQgAuQgMQHBhbGxldF9icm9hZGNhc3QUdHlwZXMMRmVlBCRBY2NvdW50SWQBAAAMARRhc3NldBABHEFzc2V0SWQAARhhbW91bnQYARxCYWxhbmNlAAEsZGVzdGluYXRpb269CAFYRGVzdGluYXRpb248QWNjb3VudElkPgAAvQgMQHBhbGxldF9icm9hZGNhc3QUdHlwZXMsRGVzdGluYXRpb24EJEFjY291bnRJZAEAAQgcQWNjb3VudAQAAAEkQWNjb3VudElkAAAAGEJ1cm5lZAABAADBCAAAAsUIAMUIDEBwYWxsZXRfYnJvYWRjYXN0FHR5cGVzNEV4ZWN1dGlvblR5cGUAARgYUm91dGVyBAAQAURJbmNyZW1lbnRhbElkVHlwZQAAAAxEQ0EIABABKFNjaGVkdWxlSWQAABABREluY3JlbWVudGFsSWRUeXBlAAEAFEJhdGNoBAAQAURJbmNyZW1lbnRhbElkVHlwZQACACBPbW5pcG9vbAQAEAFESW5jcmVtZW50YWxJZFR5cGUAAwAsWGNtRXhjaGFuZ2UEABABREluY3JlbWVudGFsSWRUeXBlAAQADFhjbQgABAEgW3U4OyAzMl0AABABREluY3JlbWVudGFsSWRUeXBlAAUAAMkICDBmcmFtZV9zeXN0ZW0UUGhhc2UAAQw4QXBwbHlFeHRyaW5zaWMEABABDHUzMgAAADBGaW5hbGl6YXRpb24AAQA4SW5pdGlhbGl6YXRpb24AAgAAzQgIMGZyYW1lX3N5c3RlbVhMYXN0UnVudGltZVVwZ3JhZGVJbmZvAAAIATBzcGVjX3ZlcnNpb25VAQFMY29kZWM6OkNvbXBhY3Q8dTMyPgABJHNwZWNfbmFtZQkIAWRzcF9ydW50aW1lOjpSdW50aW1lU3RyaW5nAADRCAgwZnJhbWVfc3lzdGVtYENvZGVVcGdyYWRlQXV0aG9yaXphdGlvbgQEVAAACAEkY29kZV9oYXNoNAEcVDo6SGFzaAABNGNoZWNrX3ZlcnNpb24gARBib29sAADVCAwwZnJhbWVfc3lzdGVtGGxpbWl0czBCbG9ja1dlaWdodHMAAAwBKGJhc2VfYmxvY2soARhXZWlnaHQAASRtYXhfYmxvY2soARhXZWlnaHQAASRwZXJfY2xhc3PZCAGEUGVyRGlzcGF0Y2hDbGFzczxXZWlnaHRzUGVyQ2xhc3M+AADZCAw0ZnJhbWVfc3VwcG9ydCBkaXNwYXRjaEBQZXJEaXNwYXRjaENsYXNzBARUAd0IAAwBGG5vcm1hbN0IAQRUAAEsb3BlcmF0aW9uYWzdCAEEVAABJG1hbmRhdG9yed0IAQRUAADdCAwwZnJhbWVfc3lzdGVtGGxpbWl0czxXZWlnaHRzUGVyQ2xhc3MAABABOGJhc2VfZXh0cmluc2ljKAEYV2VpZ2h0AAE0bWF4X2V4dHJpbnNpY10HAThPcHRpb248V2VpZ2h0PgABJG1heF90b3RhbF0HAThPcHRpb248V2VpZ2h0PgABIHJlc2VydmVkXQcBOE9wdGlvbjxXZWlnaHQ+AADhCAwwZnJhbWVfc3lzdGVtGGxpbWl0cyxCbG9ja0xlbmd0aAAABAEMbWF45QgBVFBlckRpc3BhdGNoQ2xhc3M8dTMyPgAA5QgMNGZyYW1lX3N1cHBvcnQgZGlzcGF0Y2hAUGVyRGlzcGF0Y2hDbGFzcwQEVAEQAAwBGG5vcm1hbBABBFQAASxvcGVyYXRpb25hbBABBFQAASRtYW5kYXRvcnkQAQRUAADpCAgoc3Bfd2VpZ2h0czxSdW50aW1lRGJXZWlnaHQAAAgBEHJlYWQwAQx1NjQAARR3cml0ZTABDHU2NAAA7QgIKHNwX3ZlcnNpb244UnVudGltZVZlcnNpb24AACABJHNwZWNfbmFtZQkIATRSdW50aW1lU3RyaW5nAAEkaW1wbF9uYW1lCQgBNFJ1bnRpbWVTdHJpbmcAAURhdXRob3JpbmdfdmVyc2lvbhABDHUzMgABMHNwZWNfdmVyc2lvbhABDHUzMgABMGltcGxfdmVyc2lvbhABDHUzMgABEGFwaXPxCAEcQXBpc1ZlYwABTHRyYW5zYWN0aW9uX3ZlcnNpb24QAQx1MzIAATRzdGF0ZV92ZXJzaW9uCAEIdTgAAPEIBAxDb3cEBFQB9QgABAD1CAAAAPUIAAAC+QgA+QgAAAQI/QEQAP0IDDBmcmFtZV9zeXN0ZW0YcGFsbGV0FEVycm9yBARUAAEkPEludmFsaWRTcGVjTmFtZQAACBEBVGhlIG5hbWUgb2Ygc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBtYXRjaCBiZXR3ZWVuIHRoZSBjdXJyZW50IHJ1bnRpbWVQYW5kIHRoZSBuZXcgcnVudGltZS5oU3BlY1ZlcnNpb25OZWVkc1RvSW5jcmVhc2UAAQhBAVRoZSBzcGVjaWZpY2F0aW9uIHZlcnNpb24gaXMgbm90IGFsbG93ZWQgdG8gZGVjcmVhc2UgYmV0d2VlbiB0aGUgY3VycmVudCBydW50aW1lUGFuZCB0aGUgbmV3IHJ1bnRpbWUudEZhaWxlZFRvRXh0cmFjdFJ1bnRpbWVWZXJzaW9uAAIM7EZhaWxlZCB0byBleHRyYWN0IHRoZSBydW50aW1lIHZlcnNpb24gZnJvbSB0aGUgbmV3IHJ1bnRpbWUuAAkBRWl0aGVyIGNhbGxpbmcgYENvcmVfdmVyc2lvbmAgb3IgZGVjb2RpbmcgYFJ1bnRpbWVWZXJzaW9uYCBmYWlsZWQuTE5vbkRlZmF1bHRDb21wb3NpdGUAAwT8U3VpY2lkZSBjYWxsZWQgd2hlbiB0aGUgYWNjb3VudCBoYXMgbm9uLWRlZmF1bHQgY29tcG9zaXRlIGRhdGEuPE5vblplcm9SZWZDb3VudAAEBDUBVGhlcmUgaXMgYSBub24temVybyByZWZlcmVuY2UgY291bnQgcHJldmVudGluZyB0aGUgYWNjb3VudCBmcm9tIGJlaW5nIHB1cmdlZC4wQ2FsbEZpbHRlcmVkAAUE0FRoZSBvcmlnaW4gZmlsdGVyIHByZXZlbnQgdGhlIGNhbGwgdG8gYmUgZGlzcGF0Y2hlZC5sTXVsdGlCbG9ja01pZ3JhdGlvbnNPbmdvaW5nAAYEVQFBIG11bHRpLWJsb2NrIG1pZ3JhdGlvbiBpcyBvbmdvaW5nIGFuZCBwcmV2ZW50cyB0aGUgY3VycmVudCBjb2RlIGZyb20gYmVpbmcgcmVwbGFjZWQuRE5vdGhpbmdBdXRob3JpemVkAAcEWE5vIHVwZ3JhZGUgYXV0aG9yaXplZC4wVW5hdXRob3JpemVkAAgElFRoZSBzdWJtaXR0ZWQgY29kZSBpcyBub3QgYXV0aG9yaXplZC4EbEVycm9yIGZvciB0aGUgU3lzdGVtIHBhbGxldAEJDExib3VuZGVkX2NvbGxlY3Rpb25zQHdlYWtfYm91bmRlZF92ZWM4V2Vha0JvdW5kZWRWZWMIBFQBBQkEUwAABAANCQEYVmVjPFQ+AAAFCQw8cGFsbGV0X2JhbGFuY2VzFHR5cGVzLEJhbGFuY2VMb2NrBBxCYWxhbmNlARgADAEIaWT9AQE4TG9ja0lkZW50aWZpZXIAARhhbW91bnQYARxCYWxhbmNlAAEccmVhc29ucwkJARxSZWFzb25zAAAJCQw8cGFsbGV0X2JhbGFuY2VzFHR5cGVzHFJlYXNvbnMAAQwMRmVlAAAAEE1pc2MAAQAMQWxsAAIAAA0JAAACBQkAEQkMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEVCQRTAAAEABkJARhWZWM8VD4AABUJDDxwYWxsZXRfYmFsYW5jZXMUdHlwZXMsUmVzZXJ2ZURhdGEIRFJlc2VydmVJZGVudGlmaWVyAf0BHEJhbGFuY2UBGAAIAQhpZP0BAURSZXNlcnZlSWRlbnRpZmllcgABGGFtb3VudBgBHEJhbGFuY2UAABkJAAACFQkAHQkMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEhCQRTAAAEADEJARhWZWM8VD4AACEJFDRmcmFtZV9zdXBwb3J0GHRyYWl0cxh0b2tlbnMQbWlzYyBJZEFtb3VudAgISWQBJQkcQmFsYW5jZQEYAAgBCGlkJQkBCElkAAEYYW1vdW50GAEcQmFsYW5jZQAAJQkIPGh5ZHJhZHhfcnVudGltZURSdW50aW1lSG9sZFJlYXNvbgABCCBQcmVpbWFnZQQAKQkBbHBhbGxldF9wcmVpbWFnZTo6SG9sZFJlYXNvbgAPAEhTdGF0ZVRyaWVNaWdyYXRpb24EAC0JAZxwYWxsZXRfc3RhdGVfdHJpZV9taWdyYXRpb246OkhvbGRSZWFzb24AIwAAKQkMPHBhbGxldF9wcmVpbWFnZRhwYWxsZXQoSG9sZFJlYXNvbgABBCBQcmVpbWFnZQAAAAAtCQxscGFsbGV0X3N0YXRlX3RyaWVfbWlncmF0aW9uGHBhbGxldChIb2xkUmVhc29uAAEEPFNsYXNoRm9yTWlncmF0ZQAAAAAxCQAAAiEJADUJDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBOQkEUwAABAA9CQEYVmVjPFQ+AAA5CRQ0ZnJhbWVfc3VwcG9ydBh0cmFpdHMYdG9rZW5zEG1pc2MgSWRBbW91bnQICElkAZAcQmFsYW5jZQEYAAgBCGlkkAEISWQAARhhbW91bnQYARxCYWxhbmNlAAA9CQAAAjkJAEEJDDxwYWxsZXRfYmFsYW5jZXMYcGFsbGV0FEVycm9yCARUAARJAAEwOFZlc3RpbmdCYWxhbmNlAAAEnFZlc3RpbmcgYmFsYW5jZSB0b28gaGlnaCB0byBzZW5kIHZhbHVlLlRMaXF1aWRpdHlSZXN0cmljdGlvbnMAAQTIQWNjb3VudCBsaXF1aWRpdHkgcmVzdHJpY3Rpb25zIHByZXZlbnQgd2l0aGRyYXdhbC5MSW5zdWZmaWNpZW50QmFsYW5jZQACBHhCYWxhbmNlIHRvbyBsb3cgdG8gc2VuZCB2YWx1ZS5IRXhpc3RlbnRpYWxEZXBvc2l0AAME7FZhbHVlIHRvbyBsb3cgdG8gY3JlYXRlIGFjY291bnQgZHVlIHRvIGV4aXN0ZW50aWFsIGRlcG9zaXQuNEV4cGVuZGFiaWxpdHkABASQVHJhbnNmZXIvcGF5bWVudCB3b3VsZCBraWxsIGFjY291bnQuXEV4aXN0aW5nVmVzdGluZ1NjaGVkdWxlAAUEzEEgdmVzdGluZyBzY2hlZHVsZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBhY2NvdW50LixEZWFkQWNjb3VudAAGBIxCZW5lZmljaWFyeSBhY2NvdW50IG11c3QgcHJlLWV4aXN0LjxUb29NYW55UmVzZXJ2ZXMABwS4TnVtYmVyIG9mIG5hbWVkIHJlc2VydmVzIGV4Y2VlZCBgTWF4UmVzZXJ2ZXNgLjBUb29NYW55SG9sZHMACAT4TnVtYmVyIG9mIGhvbGRzIGV4Y2VlZCBgVmFyaWFudENvdW50T2Y8VDo6UnVudGltZUhvbGRSZWFzb24+YC44VG9vTWFueUZyZWV6ZXMACQSYTnVtYmVyIG9mIGZyZWV6ZXMgZXhjZWVkIGBNYXhGcmVlemVzYC5MSXNzdWFuY2VEZWFjdGl2YXRlZAAKBAEBVGhlIGlzc3VhbmNlIGNhbm5vdCBiZSBtb2RpZmllZCBzaW5jZSBpdCBpcyBhbHJlYWR5IGRlYWN0aXZhdGVkLiREZWx0YVplcm8ACwRkVGhlIGRlbHRhIGNhbm5vdCBiZSB6ZXJvLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5FCQhocGFsbGV0X3RyYW5zYWN0aW9uX3BheW1lbnQgUmVsZWFzZXMAAQgkVjFBbmNpZW50AAAACFYyAAEAAEkJDIBwYWxsZXRfdHJhbnNhY3Rpb25fbXVsdGlfcGF5bWVudBhwYWxsZXQURXJyb3IEBFQAATBMVW5zdXBwb3J0ZWRDdXJyZW5jeQAABIxTZWxlY3RlZCBjdXJyZW5jeSBpcyBub3Qgc3VwcG9ydGVkLixaZXJvQmFsYW5jZQABBIxBY2NvdW50IGJhbGFuY2Ugc2hvdWxkIGJlIG5vbi16ZXJvLjxBbHJlYWR5QWNjZXB0ZWQAAgTcQ3VycmVuY3kgaXMgYWxyZWFkeSBpbiB0aGUgbGlzdCBvZiBhY2NlcHRlZCBjdXJyZW5jaWVzLkxDb3JlQXNzZXROb3RBbGxvd2VkAAMEbQFJdCBpcyBub3QgYWxsb3dlZCB0byBhZGQgQ29yZSBBc3NldCBhcyBhY2NlcHRlZCBjdXJyZW5jeS4gQ29yZSBhc3NldCBpcyBhY2NlcHRlZCBieSBkZXNpZ24uJFplcm9QcmljZQAEBHhGYWxsYmFjayBwcmljZSBjYW5ub3QgYmUgemVyby5URmFsbGJhY2tQcmljZU5vdEZvdW5kAAUEdEZhbGxiYWNrIHByaWNlIHdhcyBub3QgZm91bmQuIE92ZXJmbG93AAYENE1hdGggb3ZlcmZsb3dQRXZtQWNjb3VudE5vdEFsbG93ZWQABwT8SXQgaXMgbm90IGFsbG93ZWQgdG8gY2hhbmdlIHBheW1lbnQgY3VycmVuY3kgb2YgYW4gRVZNIGFjY291bnQuQEV2bVBlcm1pdEV4cGlyZWQACARMRVZNIHBlcm1pdCBleHBpcmVkLkBFdm1QZXJtaXRJbnZhbGlkAAkEWEVWTSBwZXJtaXQgaXMgaW52YWxpZC5sRXZtUGVybWl0Q2FsbEV4ZWN1dGlvbkVycm9yAAoEXEVWTSBwZXJtaXQgY2FsbCBmYWlsZWQuUEV2bVBlcm1pdFJ1bm5lckVycm9yAAsEXEVWTSBwZXJtaXQgY2FsbCBmYWlsZWQuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Lk0JCDxwYWxsZXRfdHJlYXN1cnkgUHJvcG9zYWwIJEFjY291bnRJZAEAHEJhbGFuY2UBGAAQASBwcm9wb3NlcgABJEFjY291bnRJZAABFHZhbHVlGAEcQmFsYW5jZQABLGJlbmVmaWNpYXJ5AAEkQWNjb3VudElkAAEQYm9uZBgBHEJhbGFuY2UAAFEJDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBEARTAAAEAFkDARhWZWM8VD4AAFUJCDxwYWxsZXRfdHJlYXN1cnksU3BlbmRTdGF0dXMUJEFzc2V0S2luZAGQMEFzc2V0QmFsYW5jZQEYLEJlbmVmaWNpYXJ5AQAsQmxvY2tOdW1iZXIBECRQYXltZW50SWQBkAAYAShhc3NldF9raW5kkAEkQXNzZXRLaW5kAAEYYW1vdW50GAEwQXNzZXRCYWxhbmNlAAEsYmVuZWZpY2lhcnkAASxCZW5lZmljaWFyeQABKHZhbGlkX2Zyb20QASxCbG9ja051bWJlcgABJGV4cGlyZV9hdBABLEJsb2NrTnVtYmVyAAEYc3RhdHVzWQkBXFBheW1lbnRTdGF0ZTxQYXltZW50SWQ+AABZCQg8cGFsbGV0X3RyZWFzdXJ5MFBheW1lbnRTdGF0ZQQISWQBkAEMHFBlbmRpbmcAAAAkQXR0ZW1wdGVkBAEIaWSQAQhJZAABABhGYWlsZWQAAgAAXQkINGZyYW1lX3N1cHBvcnQgUGFsbGV0SWQAAAQA/QEBHFt1ODsgOF0AAGEJDDxwYWxsZXRfdHJlYXN1cnkYcGFsbGV0FEVycm9yCARUAARJAAEsMEludmFsaWRJbmRleAAABKxObyBwcm9wb3NhbCwgYm91bnR5IG9yIHNwZW5kIGF0IHRoYXQgaW5kZXguQFRvb01hbnlBcHByb3ZhbHMAAQSAVG9vIG1hbnkgYXBwcm92YWxzIGluIHRoZSBxdWV1ZS5YSW5zdWZmaWNpZW50UGVybWlzc2lvbgACCEUBVGhlIHNwZW5kIG9yaWdpbiBpcyB2YWxpZCBidXQgdGhlIGFtb3VudCBpdCBpcyBhbGxvd2VkIHRvIHNwZW5kIGlzIGxvd2VyIHRoYW4gdGhlTGFtb3VudCB0byBiZSBzcGVudC5MUHJvcG9zYWxOb3RBcHByb3ZlZAADBHxQcm9wb3NhbCBoYXMgbm90IGJlZW4gYXBwcm92ZWQuWEZhaWxlZFRvQ29udmVydEJhbGFuY2UABARRAVRoZSBiYWxhbmNlIG9mIHRoZSBhc3NldCBraW5kIGlzIG5vdCBjb252ZXJ0aWJsZSB0byB0aGUgYmFsYW5jZSBvZiB0aGUgbmF0aXZlIGFzc2V0LjBTcGVuZEV4cGlyZWQABQSwVGhlIHNwZW5kIGhhcyBleHBpcmVkIGFuZCBjYW5ub3QgYmUgY2xhaW1lZC4sRWFybHlQYXlvdXQABgSkVGhlIHNwZW5kIGlzIG5vdCB5ZXQgZWxpZ2libGUgZm9yIHBheW91dC5AQWxyZWFkeUF0dGVtcHRlZAAHBJxUaGUgcGF5bWVudCBoYXMgYWxyZWFkeSBiZWVuIGF0dGVtcHRlZC4sUGF5b3V0RXJyb3IACATMVGhlcmUgd2FzIHNvbWUgaXNzdWUgd2l0aCB0aGUgbWVjaGFuaXNtIG9mIHBheW1lbnQuME5vdEF0dGVtcHRlZAAJBKRUaGUgcGF5b3V0IHdhcyBub3QgeWV0IGF0dGVtcHRlZC9jbGFpbWVkLjBJbmNvbmNsdXNpdmUACgTEVGhlIHBheW1lbnQgaGFzIG5laXRoZXIgZmFpbGVkIG5vciBzdWNjZWVkZWQgeWV0LgR4RXJyb3IgZm9yIHRoZSB0cmVhc3VyeSBwYWxsZXQuZQkMOHBhbGxldF91dGlsaXR5GHBhbGxldBRFcnJvcgQEVAABBDBUb29NYW55Q2FsbHMAAARcVG9vIG1hbnkgY2FsbHMgYmF0Y2hlZC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuaQkIPHBhbGxldF9wcmVpbWFnZUBPbGRSZXF1ZXN0U3RhdHVzCCRBY2NvdW50SWQBABxCYWxhbmNlARgBCCxVbnJlcXVlc3RlZAgBHGRlcG9zaXRtCQFQKEFjY291bnRJZCwgQmFsYW5jZSkAAQxsZW4QAQx1MzIAAAAkUmVxdWVzdGVkDAEcZGVwb3NpdHEJAXBPcHRpb248KEFjY291bnRJZCwgQmFsYW5jZSk+AAEUY291bnQQAQx1MzIAAQxsZW5ZAQEsT3B0aW9uPHUzMj4AAQAAbQkAAAQIABgAcQkEGE9wdGlvbgQEVAFtCQEIEE5vbmUAAAAQU29tZQQAbQkAAAEAAHUJCDxwYWxsZXRfcHJlaW1hZ2U0UmVxdWVzdFN0YXR1cwgkQWNjb3VudElkAQAYVGlja2V0AXkJAQgsVW5yZXF1ZXN0ZWQIARh0aWNrZXR9CQFMKEFjY291bnRJZCwgVGlja2V0KQABDGxlbhABDHUzMgAAACRSZXF1ZXN0ZWQMATBtYXliZV90aWNrZXSBCQFsT3B0aW9uPChBY2NvdW50SWQsIFRpY2tldCk+AAEUY291bnQQAQx1MzIAASRtYXliZV9sZW5ZAQEsT3B0aW9uPHUzMj4AAQAAeQkUNGZyYW1lX3N1cHBvcnQYdHJhaXRzGHRva2VucyBmdW5naWJsZURIb2xkQ29uc2lkZXJhdGlvbhQEQQAERgAEUgAERAAIRnAAAAQAGAEoRjo6QmFsYW5jZQAAfQkAAAQIAHkJAIEJBBhPcHRpb24EBFQBfQkBCBBOb25lAAAAEFNvbWUEAH0JAAABAACFCQAABAg0EACJCQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQgEUwAABAA4ARhWZWM8VD4AAI0JDDxwYWxsZXRfcHJlaW1hZ2UYcGFsbGV0FEVycm9yBARUAAEgGFRvb0JpZwAABKBQcmVpbWFnZSBpcyB0b28gbGFyZ2UgdG8gc3RvcmUgb24tY2hhaW4uMEFscmVhZHlOb3RlZAABBKRQcmVpbWFnZSBoYXMgYWxyZWFkeSBiZWVuIG5vdGVkIG9uLWNoYWluLjROb3RBdXRob3JpemVkAAIEyFRoZSB1c2VyIGlzIG5vdCBhdXRob3JpemVkIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uIE5vdE5vdGVkAAME/FRoZSBwcmVpbWFnZSBjYW5ub3QgYmUgcmVtb3ZlZCBzaW5jZSBpdCBoYXMgbm90IHlldCBiZWVuIG5vdGVkLiRSZXF1ZXN0ZWQABAQJAUEgcHJlaW1hZ2UgbWF5IG5vdCBiZSByZW1vdmVkIHdoZW4gdGhlcmUgYXJlIG91dHN0YW5kaW5nIHJlcXVlc3RzLjBOb3RSZXF1ZXN0ZWQABQQtAVRoZSBwcmVpbWFnZSByZXF1ZXN0IGNhbm5vdCBiZSByZW1vdmVkIHNpbmNlIG5vIG91dHN0YW5kaW5nIHJlcXVlc3RzIGV4aXN0LhxUb29NYW55AAYEVQFNb3JlIHRoYW4gYE1BWF9IQVNIX1VQR1JBREVfQlVMS19DT1VOVGAgaGFzaGVzIHdlcmUgcmVxdWVzdGVkIHRvIGJlIHVwZ3JhZGVkIGF0IG9uY2UuGFRvb0ZldwAHBORUb28gZmV3IGhhc2hlcyB3ZXJlIHJlcXVlc3RlZCB0byBiZSB1cGdyYWRlZCAoaS5lLiB6ZXJvKS4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQukQkAAAQIlQmlCQCVCQw8cGFsbGV0X2lkZW50aXR5FHR5cGVzMFJlZ2lzdHJhdGlvbgwcQmFsYW5jZQEYNE1heEp1ZGdlbWVudHMAMElkZW50aXR5SW5mbwHRAQAMAShqdWRnZW1lbnRzmQkB/EJvdW5kZWRWZWM8KFJlZ2lzdHJhckluZGV4LCBKdWRnZW1lbnQ8QmFsYW5jZT4pLCBNYXhKdWRnZW1lbnRzPgABHGRlcG9zaXQYARxCYWxhbmNlAAEQaW5mb9EBATBJZGVudGl0eUluZm8AAJkJDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBnQkEUwAABAChCQEYVmVjPFQ+AACdCQAABAgQaQIAoQkAAAKdCQClCQQYT3B0aW9uBARUAaQBCBBOb25lAAAAEFNvbWUEAKQAAAEAAKkJAAAECBitCQCtCQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQAEUwAABAAxAQEYVmVjPFQ+AACxCQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAbUJBFMAAAQAvQkBGFZlYzxUPgAAtQkEGE9wdGlvbgQEVAG5CQEIEE5vbmUAAAAQU29tZQQAuQkAAAEAALkJDDxwYWxsZXRfaWRlbnRpdHkUdHlwZXM0UmVnaXN0cmFySW5mbwwcQmFsYW5jZQEYJEFjY291bnRJZAEAHElkRmllbGQBMAAMARxhY2NvdW50AAEkQWNjb3VudElkAAEMZmVlGAEcQmFsYW5jZQABGGZpZWxkczABHElkRmllbGQAAL0JAAACtQkAwQkMPHBhbGxldF9pZGVudGl0eRR0eXBlc0xBdXRob3JpdHlQcm9wZXJ0aWVzBBhTdWZmaXgBxQkACAEYc3VmZml4xQkBGFN1ZmZpeAABKGFsbG9jYXRpb24QAShBbGxvY2F0aW9uAADFCQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQgEUwAABAA4ARhWZWM8VD4AAMkJAAAECAAQAM0JDDxwYWxsZXRfaWRlbnRpdHkYcGFsbGV0FEVycm9yBARUAAFoSFRvb01hbnlTdWJBY2NvdW50cwAABFxUb28gbWFueSBzdWJzLWFjY291bnRzLiBOb3RGb3VuZAABBFBBY2NvdW50IGlzbid0IGZvdW5kLiBOb3ROYW1lZAACBFBBY2NvdW50IGlzbid0IG5hbWVkLihFbXB0eUluZGV4AAMEMEVtcHR5IGluZGV4LihGZWVDaGFuZ2VkAAQEPEZlZSBpcyBjaGFuZ2VkLihOb0lkZW50aXR5AAUESE5vIGlkZW50aXR5IGZvdW5kLjxTdGlja3lKdWRnZW1lbnQABgREU3RpY2t5IGp1ZGdlbWVudC44SnVkZ2VtZW50R2l2ZW4ABwRASnVkZ2VtZW50IGdpdmVuLkBJbnZhbGlkSnVkZ2VtZW50AAgESEludmFsaWQganVkZ2VtZW50LjBJbnZhbGlkSW5kZXgACQRUVGhlIGluZGV4IGlzIGludmFsaWQuNEludmFsaWRUYXJnZXQACgRYVGhlIHRhcmdldCBpcyBpbnZhbGlkLkRUb29NYW55UmVnaXN0cmFycwALBOhNYXhpbXVtIGFtb3VudCBvZiByZWdpc3RyYXJzIHJlYWNoZWQuIENhbm5vdCBhZGQgYW55IG1vcmUuOEFscmVhZHlDbGFpbWVkAAwEcEFjY291bnQgSUQgaXMgYWxyZWFkeSBuYW1lZC4YTm90U3ViAA0EcFNlbmRlciBpcyBub3QgYSBzdWItYWNjb3VudC4gTm90T3duZWQADgSIU3ViLWFjY291bnQgaXNuJ3Qgb3duZWQgYnkgc2VuZGVyLnRKdWRnZW1lbnRGb3JEaWZmZXJlbnRJZGVudGl0eQAPBNBUaGUgcHJvdmlkZWQganVkZ2VtZW50IHdhcyBmb3IgYSBkaWZmZXJlbnQgaWRlbnRpdHkuWEp1ZGdlbWVudFBheW1lbnRGYWlsZWQAEAT4RXJyb3IgdGhhdCBvY2N1cnMgd2hlbiB0aGVyZSBpcyBhbiBpc3N1ZSBwYXlpbmcgZm9yIGp1ZGdlbWVudC40SW52YWxpZFN1ZmZpeAARBIBUaGUgcHJvdmlkZWQgc3VmZml4IGlzIHRvbyBsb25nLlBOb3RVc2VybmFtZUF1dGhvcml0eQASBOBUaGUgc2VuZGVyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBpc3N1ZSBhIHVzZXJuYW1lLjBOb0FsbG9jYXRpb24AEwTEVGhlIGF1dGhvcml0eSBjYW5ub3QgYWxsb2NhdGUgYW55IG1vcmUgdXNlcm5hbWVzLkBJbnZhbGlkU2lnbmF0dXJlABQEqFRoZSBzaWduYXR1cmUgb24gYSB1c2VybmFtZSB3YXMgbm90IHZhbGlkLkRSZXF1aXJlc1NpZ25hdHVyZQAVBAkBU2V0dGluZyB0aGlzIHVzZXJuYW1lIHJlcXVpcmVzIGEgc2lnbmF0dXJlLCBidXQgbm9uZSB3YXMgcHJvdmlkZWQuPEludmFsaWRVc2VybmFtZQAWBLBUaGUgdXNlcm5hbWUgZG9lcyBub3QgbWVldCB0aGUgcmVxdWlyZW1lbnRzLjRVc2VybmFtZVRha2VuABcEeFRoZSB1c2VybmFtZSBpcyBhbHJlYWR5IHRha2VuLihOb1VzZXJuYW1lABgEmFRoZSByZXF1ZXN0ZWQgdXNlcm5hbWUgZG9lcyBub3QgZXhpc3QuKE5vdEV4cGlyZWQAGQQtAVRoZSB1c2VybmFtZSBjYW5ub3QgYmUgZm9yY2VmdWxseSByZW1vdmVkIGJlY2F1c2UgaXQgY2FuIHN0aWxsIGJlIGFjY2VwdGVkLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC7RCQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAdUJBFMAAAQA2QkBGFZlYzxUPgAA1QkAAAQMEA0BAADZCQAAAtUJAN0JAAAECOEJGADhCQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAQAEUwAABAAxAQEYVmVjPFQ+AADlCQxAcGFsbGV0X2RlbW9jcmFjeRR0eXBlczhSZWZlcmVuZHVtSW5mbwwsQmxvY2tOdW1iZXIBECBQcm9wb3NhbAENARxCYWxhbmNlARgBCBxPbmdvaW5nBADpCQHAUmVmZXJlbmR1bVN0YXR1czxCbG9ja051bWJlciwgUHJvcG9zYWwsIEJhbGFuY2U+AAAAIEZpbmlzaGVkCAEgYXBwcm92ZWQgARBib29sAAEMZW5kEAEsQmxvY2tOdW1iZXIAAQAA6QkMQHBhbGxldF9kZW1vY3JhY3kUdHlwZXNAUmVmZXJlbmR1bVN0YXR1cwwsQmxvY2tOdW1iZXIBECBQcm9wb3NhbAENARxCYWxhbmNlARgAFAEMZW5kEAEsQmxvY2tOdW1iZXIAASBwcm9wb3NhbA0BASBQcm9wb3NhbAABJHRocmVzaG9sZKwBNFZvdGVUaHJlc2hvbGQAARRkZWxheRABLEJsb2NrTnVtYmVyAAEUdGFsbHntCQE4VGFsbHk8QmFsYW5jZT4AAO0JDEBwYWxsZXRfZGVtb2NyYWN5FHR5cGVzFFRhbGx5BBxCYWxhbmNlARgADAEQYXllcxgBHEJhbGFuY2UAARBuYXlzGAEcQmFsYW5jZQABHHR1cm5vdXQYARxCYWxhbmNlAADxCQxAcGFsbGV0X2RlbW9jcmFjeRB2b3RlGFZvdGluZxAcQmFsYW5jZQEYJEFjY291bnRJZAEALEJsb2NrTnVtYmVyARAgTWF4Vm90ZXMAAQgYRGlyZWN0DAEUdm90ZXP1CQH0Qm91bmRlZFZlYzwoUmVmZXJlbmR1bUluZGV4LCBBY2NvdW50Vm90ZTxCYWxhbmNlPiksIE1heFZvdGVzPgABLGRlbGVnYXRpb25zAQoBUERlbGVnYXRpb25zPEJhbGFuY2U+AAEUcHJpb3IFCgF8UHJpb3JMb2NrPEJsb2NrTnVtYmVyLCBCYWxhbmNlPgAAAChEZWxlZ2F0aW5nFAEcYmFsYW5jZRgBHEJhbGFuY2UAARh0YXJnZXQAASRBY2NvdW50SWQAAShjb252aWN0aW9ugQIBKENvbnZpY3Rpb24AASxkZWxlZ2F0aW9ucwEKAVBEZWxlZ2F0aW9uczxCYWxhbmNlPgABFHByaW9yBQoBfFByaW9yTG9jazxCbG9ja051bWJlciwgQmFsYW5jZT4AAQAA9QkMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAH5CQRTAAAEAP0JARhWZWM8VD4AAPkJAAAECBCwAP0JAAAC+QkAAQoMQHBhbGxldF9kZW1vY3JhY3kUdHlwZXMsRGVsZWdhdGlvbnMEHEJhbGFuY2UBGAAIARR2b3RlcxgBHEJhbGFuY2UAARxjYXBpdGFsGAEcQmFsYW5jZQAABQoMQHBhbGxldF9kZW1vY3JhY3kQdm90ZSRQcmlvckxvY2sILEJsb2NrTnVtYmVyARAcQmFsYW5jZQEYAAgAEAEsQmxvY2tOdW1iZXIAABgBHEJhbGFuY2UAAAkKAAAECA0BrAANCgAABAgQ4QkAEQoMQHBhbGxldF9kZW1vY3JhY3kYcGFsbGV0FEVycm9yBARUAAFgIFZhbHVlTG93AAAENFZhbHVlIHRvbyBsb3c8UHJvcG9zYWxNaXNzaW5nAAEEXFByb3Bvc2FsIGRvZXMgbm90IGV4aXN0PEFscmVhZHlDYW5jZWxlZAACBJRDYW5ub3QgY2FuY2VsIHRoZSBzYW1lIHByb3Bvc2FsIHR3aWNlRER1cGxpY2F0ZVByb3Bvc2FsAAMEVFByb3Bvc2FsIGFscmVhZHkgbWFkZUxQcm9wb3NhbEJsYWNrbGlzdGVkAAQEaFByb3Bvc2FsIHN0aWxsIGJsYWNrbGlzdGVkRE5vdFNpbXBsZU1ham9yaXR5AAUEqE5leHQgZXh0ZXJuYWwgcHJvcG9zYWwgbm90IHNpbXBsZSBtYWpvcml0eSxJbnZhbGlkSGFzaAAGBDBJbnZhbGlkIGhhc2goTm9Qcm9wb3NhbAAHBFBObyBleHRlcm5hbCBwcm9wb3NhbDRBbHJlYWR5VmV0b2VkAAgEmElkZW50aXR5IG1heSBub3QgdmV0byBhIHByb3Bvc2FsIHR3aWNlRFJlZmVyZW5kdW1JbnZhbGlkAAkEhFZvdGUgZ2l2ZW4gZm9yIGludmFsaWQgcmVmZXJlbmR1bSxOb25lV2FpdGluZwAKBFBObyBwcm9wb3NhbHMgd2FpdGluZyBOb3RWb3RlcgALBMRUaGUgZ2l2ZW4gYWNjb3VudCBkaWQgbm90IHZvdGUgb24gdGhlIHJlZmVyZW5kdW0uME5vUGVybWlzc2lvbgAMBMhUaGUgYWN0b3IgaGFzIG5vIHBlcm1pc3Npb24gdG8gY29uZHVjdCB0aGUgYWN0aW9uLkRBbHJlYWR5RGVsZWdhdGluZwANBIhUaGUgYWNjb3VudCBpcyBhbHJlYWR5IGRlbGVnYXRpbmcuREluc3VmZmljaWVudEZ1bmRzAA4E/FRvbyBoaWdoIGEgYmFsYW5jZSB3YXMgcHJvdmlkZWQgdGhhdCB0aGUgYWNjb3VudCBjYW5ub3QgYWZmb3JkLjROb3REZWxlZ2F0aW5nAA8EoFRoZSBhY2NvdW50IGlzIG5vdCBjdXJyZW50bHkgZGVsZWdhdGluZy4oVm90ZXNFeGlzdAAQCFUBVGhlIGFjY291bnQgY3VycmVudGx5IGhhcyB2b3RlcyBhdHRhY2hlZCB0byBpdCBhbmQgdGhlIG9wZXJhdGlvbiBjYW5ub3Qgc3VjY2VlZCB1bnRpbOh0aGVzZSBhcmUgcmVtb3ZlZCwgZWl0aGVyIHRocm91Z2ggYHVudm90ZWAgb3IgYHJlYXBfdm90ZWAuREluc3RhbnROb3RBbGxvd2VkABEE2FRoZSBpbnN0YW50IHJlZmVyZW5kdW0gb3JpZ2luIGlzIGN1cnJlbnRseSBkaXNhbGxvd2VkLiBOb25zZW5zZQASBJREZWxlZ2F0aW9uIHRvIG9uZXNlbGYgbWFrZXMgbm8gc2Vuc2UuPFdyb25nVXBwZXJCb3VuZAATBFBJbnZhbGlkIHVwcGVyIGJvdW5kLjxNYXhWb3Rlc1JlYWNoZWQAFASATWF4aW11bSBudW1iZXIgb2Ygdm90ZXMgcmVhY2hlZC4cVG9vTWFueQAVBIBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyByZWFjaGVkLjxWb3RpbmdQZXJpb2RMb3cAFgRUVm90aW5nIHBlcmlvZCB0b28gbG93QFByZWltYWdlTm90RXhpc3QAFwRwVGhlIHByZWltYWdlIGRvZXMgbm90IGV4aXN0LgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC4VCgxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUATQEUwAABADJAQEYVmVjPFQ+AAAZCghEcGFsbGV0X2NvbGxlY3RpdmUUVm90ZXMIJEFjY291bnRJZAEALEJsb2NrTnVtYmVyARAAFAEUaW5kZXgQATRQcm9wb3NhbEluZGV4AAEkdGhyZXNob2xkEAEsTWVtYmVyQ291bnQAARBheWVzMQEBOFZlYzxBY2NvdW50SWQ+AAEQbmF5czEBAThWZWM8QWNjb3VudElkPgABDGVuZBABLEJsb2NrTnVtYmVyAAAdCgxEcGFsbGV0X2NvbGxlY3RpdmUYcGFsbGV0FEVycm9yCARUAARJAAEsJE5vdE1lbWJlcgAABFxBY2NvdW50IGlzIG5vdCBhIG1lbWJlckREdXBsaWNhdGVQcm9wb3NhbAABBHxEdXBsaWNhdGUgcHJvcG9zYWxzIG5vdCBhbGxvd2VkPFByb3Bvc2FsTWlzc2luZwACBExQcm9wb3NhbCBtdXN0IGV4aXN0KFdyb25nSW5kZXgAAwRATWlzbWF0Y2hlZCBpbmRleDREdXBsaWNhdGVWb3RlAAQEWER1cGxpY2F0ZSB2b3RlIGlnbm9yZWRIQWxyZWFkeUluaXRpYWxpemVkAAUEgE1lbWJlcnMgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWQhIFRvb0Vhcmx5AAYEAQFUaGUgY2xvc2UgY2FsbCB3YXMgbWFkZSB0b28gZWFybHksIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSB2b3RpbmcuQFRvb01hbnlQcm9wb3NhbHMABwT8VGhlcmUgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mIGBNYXhQcm9wb3NhbHNgIGFjdGl2ZSBwcm9wb3NhbHMuTFdyb25nUHJvcG9zYWxXZWlnaHQACATQVGhlIGdpdmVuIHdlaWdodCBib3VuZCBmb3IgdGhlIHByb3Bvc2FsIHdhcyB0b28gbG93LkxXcm9uZ1Byb3Bvc2FsTGVuZ3RoAAkE0FRoZSBnaXZlbiBsZW5ndGggYm91bmQgZm9yIHRoZSBwcm9wb3NhbCB3YXMgdG9vIGxvdy5UUHJpbWVBY2NvdW50Tm90TWVtYmVyAAoEdFByaW1lIGFjY291bnQgaXMgbm90IGEgbWVtYmVyBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LiEKAAAECCUKGAAlCgxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUASkKBFMAAAQALQoBGFZlYzxUPgAAKQoIMHBhbGxldF9wcm94eTxQcm94eURlZmluaXRpb24MJEFjY291bnRJZAEAJFByb3h5VHlwZQHELEJsb2NrTnVtYmVyARAADAEgZGVsZWdhdGUAASRBY2NvdW50SWQAAShwcm94eV90eXBlxAEkUHJveHlUeXBlAAEUZGVsYXkQASxCbG9ja051bWJlcgAALQoAAAIpCgAxCgAABAg1ChgANQoMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAE5CgRTAAAEAD0KARhWZWM8VD4AADkKCDBwYWxsZXRfcHJveHkwQW5ub3VuY2VtZW50DCRBY2NvdW50SWQBABBIYXNoATQsQmxvY2tOdW1iZXIBEAAMARByZWFsAAEkQWNjb3VudElkAAEkY2FsbF9oYXNoNAEQSGFzaAABGGhlaWdodBABLEJsb2NrTnVtYmVyAAA9CgAAAjkKAEEKDDBwYWxsZXRfcHJveHkYcGFsbGV0FEVycm9yBARUAAEgHFRvb01hbnkAAAQhAVRoZXJlIGFyZSB0b28gbWFueSBwcm94aWVzIHJlZ2lzdGVyZWQgb3IgdG9vIG1hbnkgYW5ub3VuY2VtZW50cyBwZW5kaW5nLiBOb3RGb3VuZAABBHRQcm94eSByZWdpc3RyYXRpb24gbm90IGZvdW5kLiBOb3RQcm94eQACBMxTZW5kZXIgaXMgbm90IGEgcHJveHkgb2YgdGhlIGFjY291bnQgdG8gYmUgcHJveGllZC4sVW5wcm94eWFibGUAAwQhAUEgY2FsbCB3aGljaCBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgcHJveHkgdHlwZSdzIGZpbHRlciB3YXMgYXR0ZW1wdGVkLiREdXBsaWNhdGUABARsQWNjb3VudCBpcyBhbHJlYWR5IGEgcHJveHkuME5vUGVybWlzc2lvbgAFBBUBQ2FsbCBtYXkgbm90IGJlIG1hZGUgYnkgcHJveHkgYmVjYXVzZSBpdCBtYXkgZXNjYWxhdGUgaXRzIHByaXZpbGVnZXMuLFVuYW5ub3VuY2VkAAYE0EFubm91bmNlbWVudCwgaWYgbWFkZSBhdCBhbGwsIHdhcyBtYWRlIHRvbyByZWNlbnRseS4sTm9TZWxmUHJveHkABwRkQ2Fubm90IGFkZCBzZWxmIGFzIHByb3h5LgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5FCgAABAgABABJCgg8cGFsbGV0X211bHRpc2lnIE11bHRpc2lnECxCbG9ja051bWJlcgEQHEJhbGFuY2UBGCRBY2NvdW50SWQBADBNYXhBcHByb3ZhbHMAABABEHdoZW7QAVhUaW1lcG9pbnQ8QmxvY2tOdW1iZXI+AAEcZGVwb3NpdBgBHEJhbGFuY2UAASRkZXBvc2l0b3IAASRBY2NvdW50SWQAASRhcHByb3ZhbHNNCgGMQm91bmRlZFZlYzxBY2NvdW50SWQsIE1heEFwcHJvdmFscz4AAE0KDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBAARTAAAEADEBARhWZWM8VD4AAFEKDDxwYWxsZXRfbXVsdGlzaWcYcGFsbGV0FEVycm9yBARUAAE4QE1pbmltdW1UaHJlc2hvbGQAAAR8VGhyZXNob2xkIG11c3QgYmUgMiBvciBncmVhdGVyLjxBbHJlYWR5QXBwcm92ZWQAAQSsQ2FsbCBpcyBhbHJlYWR5IGFwcHJvdmVkIGJ5IHRoaXMgc2lnbmF0b3J5LkROb0FwcHJvdmFsc05lZWRlZAACBJxDYWxsIGRvZXNuJ3QgbmVlZCBhbnkgKG1vcmUpIGFwcHJvdmFscy5EVG9vRmV3U2lnbmF0b3JpZXMAAwSoVGhlcmUgYXJlIHRvbyBmZXcgc2lnbmF0b3JpZXMgaW4gdGhlIGxpc3QuSFRvb01hbnlTaWduYXRvcmllcwAEBKxUaGVyZSBhcmUgdG9vIG1hbnkgc2lnbmF0b3JpZXMgaW4gdGhlIGxpc3QuVFNpZ25hdG9yaWVzT3V0T2ZPcmRlcgAFBA0BVGhlIHNpZ25hdG9yaWVzIHdlcmUgcHJvdmlkZWQgb3V0IG9mIG9yZGVyOyB0aGV5IHNob3VsZCBiZSBvcmRlcmVkLkxTZW5kZXJJblNpZ25hdG9yaWVzAAYEDQFUaGUgc2VuZGVyIHdhcyBjb250YWluZWQgaW4gdGhlIG90aGVyIHNpZ25hdG9yaWVzOyBpdCBzaG91bGRuJ3QgYmUuIE5vdEZvdW5kAAcE3E11bHRpc2lnIG9wZXJhdGlvbiBub3QgZm91bmQgd2hlbiBhdHRlbXB0aW5nIHRvIGNhbmNlbC4gTm90T3duZXIACAQtAU9ubHkgdGhlIGFjY291bnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhlIG11bHRpc2lnIGlzIGFibGUgdG8gY2FuY2VsIGl0LixOb1RpbWVwb2ludAAJBB0BTm8gdGltZXBvaW50IHdhcyBnaXZlbiwgeWV0IHRoZSBtdWx0aXNpZyBvcGVyYXRpb24gaXMgYWxyZWFkeSB1bmRlcndheS44V3JvbmdUaW1lcG9pbnQACgQtAUEgZGlmZmVyZW50IHRpbWVwb2ludCB3YXMgZ2l2ZW4gdG8gdGhlIG11bHRpc2lnIG9wZXJhdGlvbiB0aGF0IGlzIHVuZGVyd2F5LkxVbmV4cGVjdGVkVGltZXBvaW50AAsE9EEgdGltZXBvaW50IHdhcyBnaXZlbiwgeWV0IG5vIG11bHRpc2lnIG9wZXJhdGlvbiBpcyB1bmRlcndheS48TWF4V2VpZ2h0VG9vTG93AAwE0FRoZSBtYXhpbXVtIHdlaWdodCBpbmZvcm1hdGlvbiBwcm92aWRlZCB3YXMgdG9vIGxvdy40QWxyZWFkeVN0b3JlZAANBKBUaGUgZGF0YSB0byBiZSBzdG9yZWQgaXMgYWxyZWFkeSBzdG9yZWQuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LlUKDDhwYWxsZXRfdW5pcXVlcxR0eXBlc0RDb2xsZWN0aW9uRGV0YWlscwgkQWNjb3VudElkAQA4RGVwb3NpdEJhbGFuY2UBGAAoARRvd25lcgABJEFjY291bnRJZAABGGlzc3VlcgABJEFjY291bnRJZAABFGFkbWluAAEkQWNjb3VudElkAAEcZnJlZXplcgABJEFjY291bnRJZAABNHRvdGFsX2RlcG9zaXQYAThEZXBvc2l0QmFsYW5jZQABMGZyZWVfaG9sZGluZyABEGJvb2wAARRpdGVtcxABDHUzMgABOGl0ZW1fbWV0YWRhdGFzEAEMdTMyAAEoYXR0cmlidXRlcxABDHUzMgABJGlzX2Zyb3plbiABEGJvb2wAAFkKAAAEDAAYGABdCgw4cGFsbGV0X3VuaXF1ZXMUdHlwZXMsSXRlbURldGFpbHMIJEFjY291bnRJZAEAOERlcG9zaXRCYWxhbmNlARgAEAEUb3duZXIAASRBY2NvdW50SWQAASBhcHByb3ZlZOwBRE9wdGlvbjxBY2NvdW50SWQ+AAEkaXNfZnJvemVuIAEQYm9vbAABHGRlcG9zaXQYAThEZXBvc2l0QmFsYW5jZQAAYQoMOHBhbGxldF91bmlxdWVzFHR5cGVzSENvbGxlY3Rpb25NZXRhZGF0YQg4RGVwb3NpdEJhbGFuY2UBGCxTdHJpbmdMaW1pdAAADAEcZGVwb3NpdBgBOERlcG9zaXRCYWxhbmNlAAEQZGF0YdgBbEJvdW5kZWRWZWM8dTgsIFN0cmluZ0xpbWl0PgABJGlzX2Zyb3plbiABEGJvb2wAAGUKDDhwYWxsZXRfdW5pcXVlcxR0eXBlczBJdGVtTWV0YWRhdGEIOERlcG9zaXRCYWxhbmNlARgsU3RyaW5nTGltaXQAAAwBHGRlcG9zaXQYAThEZXBvc2l0QmFsYW5jZQABEGRhdGHYAWxCb3VuZGVkVmVjPHU4LCBTdHJpbmdMaW1pdD4AASRpc19mcm96ZW4gARBib29sAABpCgAABAwY4OQAbQoAAAQI6BgAcQoAAAQIGOwAdQoMOHBhbGxldF91bmlxdWVzGHBhbGxldBRFcnJvcggEVAAESQABSDBOb1Blcm1pc3Npb24AAAToVGhlIHNpZ25pbmcgYWNjb3VudCBoYXMgbm8gcGVybWlzc2lvbiB0byBkbyB0aGUgb3BlcmF0aW9uLkRVbmtub3duQ29sbGVjdGlvbgABBHRUaGUgZ2l2ZW4gaXRlbSBJRCBpcyB1bmtub3duLjRBbHJlYWR5RXhpc3RzAAIEuFRoZSBpdGVtIElEIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBmb3IgYW4gaXRlbS4oV3JvbmdPd25lcgADBOhUaGUgb3duZXIgdHVybmVkIG91dCB0byBiZSBkaWZmZXJlbnQgdG8gd2hhdCB3YXMgZXhwZWN0ZWQuKEJhZFdpdG5lc3MABARsSW52YWxpZCB3aXRuZXNzIGRhdGEgZ2l2ZW4uFEluVXNlAAUEdFRoZSBpdGVtIElEIGlzIGFscmVhZHkgdGFrZW4uGEZyb3plbgAGBIRUaGUgaXRlbSBvciBjb2xsZWN0aW9uIGlzIGZyb3plbi40V3JvbmdEZWxlZ2F0ZQAHBPRUaGUgZGVsZWdhdGUgdHVybmVkIG91dCB0byBiZSBkaWZmZXJlbnQgdG8gd2hhdCB3YXMgZXhwZWN0ZWQuKE5vRGVsZWdhdGUACAR4VGhlcmUgaXMgbm8gZGVsZWdhdGUgYXBwcm92ZWQuKFVuYXBwcm92ZWQACQTETm8gYXBwcm92YWwgZXhpc3RzIHRoYXQgd291bGQgYWxsb3cgdGhlIHRyYW5zZmVyLihVbmFjY2VwdGVkAAoEJQFUaGUgbmFtZWQgb3duZXIgaGFzIG5vdCBzaWduZWQgb3duZXJzaGlwIG9mIHRoZSBjb2xsZWN0aW9uIGlzIGFjY2VwdGFibGUuGExvY2tlZAALBExUaGUgaXRlbSBpcyBsb2NrZWQuQE1heFN1cHBseVJlYWNoZWQADARsQWxsIGl0ZW1zIGhhdmUgYmVlbiBtaW50ZWQuTE1heFN1cHBseUFscmVhZHlTZXQADQSQVGhlIG1heCBzdXBwbHkgaGFzIGFscmVhZHkgYmVlbiBzZXQuRE1heFN1cHBseVRvb1NtYWxsAA4EQQFUaGUgcHJvdmlkZWQgbWF4IHN1cHBseSBpcyBsZXNzIHRvIHRoZSBhbW91bnQgb2YgaXRlbXMgYSBjb2xsZWN0aW9uIGFscmVhZHkgaGFzLixVbmtub3duSXRlbQAPBHRUaGUgZ2l2ZW4gaXRlbSBJRCBpcyB1bmtub3duLihOb3RGb3JTYWxlABAEVEl0ZW0gaXMgbm90IGZvciBzYWxlLiRCaWRUb29Mb3cAEQRwVGhlIHByb3ZpZGVkIGJpZCBpcyB0b28gbG93LgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC55CgAABAgAyAB9CgxgcGFsbGV0X2NvbnZpY3Rpb25fdm90aW5nEHZvdGUYVm90aW5nFBxCYWxhbmNlARgkQWNjb3VudElkAQAsQmxvY2tOdW1iZXIBECRQb2xsSW5kZXgBECBNYXhWb3RlcwABCBxDYXN0aW5nBACBCgHIQ2FzdGluZzxCYWxhbmNlLCBCbG9ja051bWJlciwgUG9sbEluZGV4LCBNYXhWb3Rlcz4AAAAoRGVsZWdhdGluZwQAmQoBrERlbGVnYXRpbmc8QmFsYW5jZSwgQWNjb3VudElkLCBCbG9ja051bWJlcj4AAQAAgQoMYHBhbGxldF9jb252aWN0aW9uX3ZvdGluZxB2b3RlHENhc3RpbmcQHEJhbGFuY2UBGCxCbG9ja051bWJlcgEQJFBvbGxJbmRleAEQIE1heFZvdGVzAAAMARR2b3Rlc4UKAdxCb3VuZGVkVmVjPChQb2xsSW5kZXgsIEFjY291bnRWb3RlPEJhbGFuY2U+KSwgTWF4Vm90ZXM+AAEsZGVsZWdhdGlvbnORCgFQRGVsZWdhdGlvbnM8QmFsYW5jZT4AARRwcmlvcpUKAXxQcmlvckxvY2s8QmxvY2tOdW1iZXIsIEJhbGFuY2U+AACFCgxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAYkKBFMAAAQAjQoBGFZlYzxUPgAAiQoAAAQIEAEBAI0KAAACiQoAkQoMYHBhbGxldF9jb252aWN0aW9uX3ZvdGluZxR0eXBlcyxEZWxlZ2F0aW9ucwQcQmFsYW5jZQEYAAgBFHZvdGVzGAEcQmFsYW5jZQABHGNhcGl0YWwYARxCYWxhbmNlAACVCgxgcGFsbGV0X2NvbnZpY3Rpb25fdm90aW5nEHZvdGUkUHJpb3JMb2NrCCxCbG9ja051bWJlcgEQHEJhbGFuY2UBGAAIABABLEJsb2NrTnVtYmVyAAAYARxCYWxhbmNlAACZCgxgcGFsbGV0X2NvbnZpY3Rpb25fdm90aW5nEHZvdGUoRGVsZWdhdGluZwwcQmFsYW5jZQEYJEFjY291bnRJZAEALEJsb2NrTnVtYmVyARAAFAEcYmFsYW5jZRgBHEJhbGFuY2UAARh0YXJnZXQAASRBY2NvdW50SWQAAShjb252aWN0aW9uwQIBKENvbnZpY3Rpb24AASxkZWxlZ2F0aW9uc5EKAVBEZWxlZ2F0aW9uczxCYWxhbmNlPgABFHByaW9ylQoBfFByaW9yTG9jazxCbG9ja051bWJlciwgQmFsYW5jZT4AAJ0KDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBoQoEUwAABAClCgEYVmVjPFQ+AAChCgAABAjIGAClCgAAAqEKAKkKDGBwYWxsZXRfY29udmljdGlvbl92b3RpbmcYcGFsbGV0FEVycm9yCARUAARJAAEwKE5vdE9uZ29pbmcAAARQUG9sbCBpcyBub3Qgb25nb2luZy4gTm90Vm90ZXIAAQSsVGhlIGdpdmVuIGFjY291bnQgZGlkIG5vdCB2b3RlIG9uIHRoZSBwb2xsLjBOb1Blcm1pc3Npb24AAgTIVGhlIGFjdG9yIGhhcyBubyBwZXJtaXNzaW9uIHRvIGNvbmR1Y3QgdGhlIGFjdGlvbi48Tm9QZXJtaXNzaW9uWWV0AAMEWQFUaGUgYWN0b3IgaGFzIG5vIHBlcm1pc3Npb24gdG8gY29uZHVjdCB0aGUgYWN0aW9uIHJpZ2h0IG5vdyBidXQgd2lsbCBkbyBpbiB0aGUgZnV0dXJlLkRBbHJlYWR5RGVsZWdhdGluZwAEBIhUaGUgYWNjb3VudCBpcyBhbHJlYWR5IGRlbGVnYXRpbmcuNEFscmVhZHlWb3RpbmcABQhVAVRoZSBhY2NvdW50IGN1cnJlbnRseSBoYXMgdm90ZXMgYXR0YWNoZWQgdG8gaXQgYW5kIHRoZSBvcGVyYXRpb24gY2Fubm90IHN1Y2NlZWQgdW50aWygdGhlc2UgYXJlIHJlbW92ZWQgdGhyb3VnaCBgcmVtb3ZlX3ZvdGVgLkRJbnN1ZmZpY2llbnRGdW5kcwAGBPxUb28gaGlnaCBhIGJhbGFuY2Ugd2FzIHByb3ZpZGVkIHRoYXQgdGhlIGFjY291bnQgY2Fubm90IGFmZm9yZC40Tm90RGVsZWdhdGluZwAHBKBUaGUgYWNjb3VudCBpcyBub3QgY3VycmVudGx5IGRlbGVnYXRpbmcuIE5vbnNlbnNlAAgElERlbGVnYXRpb24gdG8gb25lc2VsZiBtYWtlcyBubyBzZW5zZS48TWF4Vm90ZXNSZWFjaGVkAAkEgE1heGltdW0gbnVtYmVyIG9mIHZvdGVzIHJlYWNoZWQuLENsYXNzTmVlZGVkAAoEOQFUaGUgY2xhc3MgbXVzdCBiZSBzdXBwbGllZCBzaW5jZSBpdCBpcyBub3QgZWFzaWx5IGRldGVybWluYWJsZSBmcm9tIHRoZSBzdGF0ZS4gQmFkQ2xhc3MACwSEVGhlIGNsYXNzIElEIHN1cHBsaWVkIGlzIGludmFsaWQuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Lq0KDEBwYWxsZXRfcmVmZXJlbmRhFHR5cGVzOFJlZmVyZW5kdW1JbmZvIBxUcmFja0lkAcg0UnVudGltZU9yaWdpbgFlARhNb21lbnQBEBBDYWxsAQ0BHEJhbGFuY2UBGBRUYWxseQFNByRBY2NvdW50SWQBADxTY2hlZHVsZUFkZHJlc3MBTQMBGBxPbmdvaW5nBACxCgGNAVJlZmVyZW5kdW1TdGF0dXM8VHJhY2tJZCwgUnVudGltZU9yaWdpbiwgTW9tZW50LCBDYWxsLCBCYWxhbmNlLCBUYWxseSwKQWNjb3VudElkLCBTY2hlZHVsZUFkZHJlc3MsPgAAACBBcHByb3ZlZAwAEAEYTW9tZW50AAC5CgGMT3B0aW9uPERlcG9zaXQ8QWNjb3VudElkLCBCYWxhbmNlPj4AALkKAYxPcHRpb248RGVwb3NpdDxBY2NvdW50SWQsIEJhbGFuY2U+PgABACBSZWplY3RlZAwAEAEYTW9tZW50AAC5CgGMT3B0aW9uPERlcG9zaXQ8QWNjb3VudElkLCBCYWxhbmNlPj4AALkKAYxPcHRpb248RGVwb3NpdDxBY2NvdW50SWQsIEJhbGFuY2U+PgACACRDYW5jZWxsZWQMABABGE1vbWVudAAAuQoBjE9wdGlvbjxEZXBvc2l0PEFjY291bnRJZCwgQmFsYW5jZT4+AAC5CgGMT3B0aW9uPERlcG9zaXQ8QWNjb3VudElkLCBCYWxhbmNlPj4AAwAgVGltZWRPdXQMABABGE1vbWVudAAAuQoBjE9wdGlvbjxEZXBvc2l0PEFjY291bnRJZCwgQmFsYW5jZT4+AAC5CgGMT3B0aW9uPERlcG9zaXQ8QWNjb3VudElkLCBCYWxhbmNlPj4ABAAYS2lsbGVkBAAQARhNb21lbnQABQAAsQoMQHBhbGxldF9yZWZlcmVuZGEUdHlwZXNAUmVmZXJlbmR1bVN0YXR1cyAcVHJhY2tJZAHINFJ1bnRpbWVPcmlnaW4BZQEYTW9tZW50ARAQQ2FsbAENARxCYWxhbmNlARgUVGFsbHkBTQckQWNjb3VudElkAQA8U2NoZWR1bGVBZGRyZXNzAU0DACwBFHRyYWNryAEcVHJhY2tJZAABGG9yaWdpbmUBATRSdW50aW1lT3JpZ2luAAEgcHJvcG9zYWwNAQEQQ2FsbAABJGVuYWN0bWVudM0CAVBEaXNwYXRjaFRpbWU8TW9tZW50PgABJHN1Ym1pdHRlZBABGE1vbWVudAABSHN1Ym1pc3Npb25fZGVwb3NpdLUKAWxEZXBvc2l0PEFjY291bnRJZCwgQmFsYW5jZT4AAUBkZWNpc2lvbl9kZXBvc2l0uQoBjE9wdGlvbjxEZXBvc2l0PEFjY291bnRJZCwgQmFsYW5jZT4+AAEgZGVjaWRpbme9CgF4T3B0aW9uPERlY2lkaW5nU3RhdHVzPE1vbWVudD4+AAEUdGFsbHlNBwEUVGFsbHkAASBpbl9xdWV1ZSABEGJvb2wAARRhbGFybcUKAYRPcHRpb248KE1vbWVudCwgU2NoZWR1bGVBZGRyZXNzKT4AALUKDEBwYWxsZXRfcmVmZXJlbmRhFHR5cGVzHERlcG9zaXQIJEFjY291bnRJZAEAHEJhbGFuY2UBGAAIAQx3aG8AASRBY2NvdW50SWQAARhhbW91bnQYARxCYWxhbmNlAAC5CgQYT3B0aW9uBARUAbUKAQgQTm9uZQAAABBTb21lBAC1CgAAAQAAvQoEGE9wdGlvbgQEVAHBCgEIEE5vbmUAAAAQU29tZQQAwQoAAAEAAMEKDEBwYWxsZXRfcmVmZXJlbmRhFHR5cGVzOERlY2lkaW5nU3RhdHVzBCxCbG9ja051bWJlcgEQAAgBFHNpbmNlEAEsQmxvY2tOdW1iZXIAAShjb25maXJtaW5nWQEBTE9wdGlvbjxCbG9ja051bWJlcj4AAMUKBBhPcHRpb24EBFQByQoBCBBOb25lAAAAEFNvbWUEAMkKAAABAADJCgAABAgQTQMAzQoMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAHVAwRTAAAEADkGARhWZWM8VD4AANEKAAAC1QoA1QoAAAQIyNkKANkKDEBwYWxsZXRfcmVmZXJlbmRhFHR5cGVzJFRyYWNrSW5mbwgcQmFsYW5jZQEYGE1vbWVudAEQACQBEG5hbWUJCAEwJidzdGF0aWMgc3RyAAEwbWF4X2RlY2lkaW5nEAEMdTMyAAFAZGVjaXNpb25fZGVwb3NpdBgBHEJhbGFuY2UAAThwcmVwYXJlX3BlcmlvZBABGE1vbWVudAABPGRlY2lzaW9uX3BlcmlvZBABGE1vbWVudAABOGNvbmZpcm1fcGVyaW9kEAEYTW9tZW50AAFQbWluX2VuYWN0bWVudF9wZXJpb2QQARhNb21lbnQAATBtaW5fYXBwcm92YWzdCgEUQ3VydmUAASxtaW5fc3VwcG9ydN0KARRDdXJ2ZQAA3QoMQHBhbGxldF9yZWZlcmVuZGEUdHlwZXMUQ3VydmUAAQxATGluZWFyRGVjcmVhc2luZwwBGGxlbmd0aMEDARxQZXJiaWxsAAEUZmxvb3LBAwEcUGVyYmlsbAABEGNlaWzBAwEcUGVyYmlsbAAAAERTdGVwcGVkRGVjcmVhc2luZxABFGJlZ2luwQMBHFBlcmJpbGwAAQxlbmTBAwEcUGVyYmlsbAABEHN0ZXDBAwEcUGVyYmlsbAABGHBlcmlvZMEDARxQZXJiaWxsAAEAKFJlY2lwcm9jYWwMARhmYWN0b3LhCgEgRml4ZWRJNjQAASB4X29mZnNldOEKASBGaXhlZEk2NAABIHlfb2Zmc2V04QoBIEZpeGVkSTY0AAIAAOEKDDRzcF9hcml0aG1ldGljLGZpeGVkX3BvaW50IEZpeGVkSTY0AAAEAOUKAQxpNjQAAOUKAAAFDADpCgxAcGFsbGV0X3JlZmVyZW5kYRhwYWxsZXQURXJyb3IIBFQABEkAATgoTm90T25nb2luZwAABGhSZWZlcmVuZHVtIGlzIG5vdCBvbmdvaW5nLihIYXNEZXBvc2l0AAEEuFJlZmVyZW5kdW0ncyBkZWNpc2lvbiBkZXBvc2l0IGlzIGFscmVhZHkgcGFpZC4gQmFkVHJhY2sAAgScVGhlIHRyYWNrIGlkZW50aWZpZXIgZ2l2ZW4gd2FzIGludmFsaWQuEEZ1bGwAAwQxAVRoZXJlIGFyZSBhbHJlYWR5IGEgZnVsbCBjb21wbGVtZW50IG9mIHJlZmVyZW5kYSBpbiBwcm9ncmVzcyBmb3IgdGhpcyB0cmFjay4oUXVldWVFbXB0eQAEBIBUaGUgcXVldWUgb2YgdGhlIHRyYWNrIGlzIGVtcHR5LjRCYWRSZWZlcmVuZHVtAAUE5FRoZSByZWZlcmVuZHVtIGluZGV4IHByb3ZpZGVkIGlzIGludmFsaWQgaW4gdGhpcyBjb250ZXh0LixOb3RoaW5nVG9EbwAGBKxUaGVyZSB3YXMgbm90aGluZyB0byBkbyBpbiB0aGUgYWR2YW5jZW1lbnQuHE5vVHJhY2sABwSgTm8gdHJhY2sgZXhpc3RzIGZvciB0aGUgcHJvcG9zYWwgb3JpZ2luLihVbmZpbmlzaGVkAAgEAQFBbnkgZGVwb3NpdCBjYW5ub3QgYmUgcmVmdW5kZWQgdW50aWwgYWZ0ZXIgdGhlIGRlY2lzaW9uIGlzIG92ZXIuME5vUGVybWlzc2lvbgAJBKhUaGUgZGVwb3NpdCByZWZ1bmRlciBpcyBub3QgdGhlIGRlcG9zaXRvci4kTm9EZXBvc2l0AAoEzFRoZSBkZXBvc2l0IGNhbm5vdCBiZSByZWZ1bmRlZCBzaW5jZSBub25lIHdhcyBtYWRlLiRCYWRTdGF0dXMACwTQVGhlIHJlZmVyZW5kdW0gc3RhdHVzIGlzIGludmFsaWQgZm9yIHRoaXMgb3BlcmF0aW9uLkBQcmVpbWFnZU5vdEV4aXN0AAwEcFRoZSBwcmVpbWFnZSBkb2VzIG5vdCBleGlzdC6EUHJlaW1hZ2VTdG9yZWRXaXRoRGlmZmVyZW50TGVuZ3RoAA0EFQFUaGUgcHJlaW1hZ2UgaXMgc3RvcmVkIHdpdGggYSBkaWZmZXJlbnQgbGVuZ3RoIHRoYW4gdGhlIG9uZSBwcm92aWRlZC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQu7QoMQHBhbGxldF93aGl0ZWxpc3QYcGFsbGV0FEVycm9yBARUAAEUTFVuYXZhaWxhYmxlUHJlSW1hZ2UAAATIVGhlIHByZWltYWdlIG9mIHRoZSBjYWxsIGhhc2ggY291bGQgbm90IGJlIGxvYWRlZC48VW5kZWNvZGFibGVDYWxsAAEEeFRoZSBjYWxsIGNvdWxkIG5vdCBiZSBkZWNvZGVkLmBJbnZhbGlkQ2FsbFdlaWdodFdpdG5lc3MAAgTsVGhlIHdlaWdodCBvZiB0aGUgZGVjb2RlZCBjYWxsIHdhcyBoaWdoZXIgdGhhbiB0aGUgd2l0bmVzcy5QQ2FsbElzTm90V2hpdGVsaXN0ZWQAAwR0VGhlIGNhbGwgd2FzIG5vdCB3aGl0ZWxpc3RlZC5YQ2FsbEFscmVhZHlXaGl0ZWxpc3RlZAAEBKBUaGUgY2FsbCB3YXMgYWxyZWFkeSB3aGl0ZWxpc3RlZDsgTm8tT3AuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LvEKDERwYWxsZXRfZGlzcGF0Y2hlchhwYWxsZXQURXJyb3IEBFQAAQg0RXZtQ2FsbEZhaWxlZAAACD0BVGhlIEVWTSBjYWxsIGV4ZWN1dGlvbiBmYWlsZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBFVk0gcmV0dXJucyBhbiBleGl0IHJlYXNvbvRvdGhlciB0aGFuIGBFeGl0U3VjY2VlZChSZXR1cm5lZClgIG9yIGBFeGl0U3VjY2VlZChTdG9wcGVkKWAuKE5vdEV2bUNhbGwAAQRtAVRoZSBwcm92aWRlZCBjYWxsIGlzIG5vdCBhbiBFVk0gY2FsbC4gVGhpcyBleHRyaW5zaWMgb25seSBhY2NlcHRzIGBwYWxsZXRfZXZtOjpDYWxsOjpjYWxsYC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQu9QoMVHBhbGxldF9hc3NldF9yZWdpc3RyeRR0eXBlczBBc3NldERldGFpbHMELFN0cmluZ0xpbWl0AAAcARBuYW1l3QIBZE9wdGlvbjxOYW1lPFN0cmluZ0xpbWl0Pj4AAShhc3NldF90eXBl5QIBJEFzc2V0VHlwZQABTGV4aXN0ZW50aWFsX2RlcG9zaXQYARxCYWxhbmNlAAEYc3ltYm9s3QIBbE9wdGlvbjxTeW1ib2w8U3RyaW5nTGltaXQ+PgABIGRlY2ltYWxz6QIBKE9wdGlvbjx1OD4AATh4Y21fcmF0ZV9saW1pdOABPE9wdGlvbjxCYWxhbmNlPgABNGlzX3N1ZmZpY2llbnQgARBib29sAAD5CgxUcGFsbGV0X2Fzc2V0X3JlZ2lzdHJ5GHBhbGxldBRFcnJvcgQEVAABPDROb0lkQXZhaWxhYmxlAAAEcQFBc3NldCBJRCBpcyBub3QgYXZhaWxhYmxlLiBUaGlzIG9ubHkgaGFwcGVucyB3aGVuIGl0IHJlYWNoZXMgdGhlIE1BWCB2YWx1ZSBvZiBnaXZlbiBpZCB0eXBlLjRBc3NldE5vdEZvdW5kAAEEdEludmFsaWQgYXNzZXQgbmFtZSBvciBzeW1ib2wuIFRvb1Nob3J0AAIEyExlbmd0aCBvZiBuYW1lIG9yIHN5bWJvbCBpcyBsZXNzIHRoYW4gbWluLiBsZW5ndGguNEludmFsaWRTeW1ib2wAAwTQQXNzZXQncyBzeW1ib2wgY2FuJ3QgY29udGFpbiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgLkhBc3NldE5vdFJlZ2lzdGVyZWQABATEQXNzZXQgSUQgaXMgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIGFzc2V0LXJlZ2lzdHJ5LlhBc3NldEFscmVhZHlSZWdpc3RlcmVkAAUEcEFzc2V0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5USW52YWxpZFNoYXJlZEFzc2V0TGVuAAYE7EluY29ycmVjdCBudW1iZXIgb2YgYXNzZXRzIHByb3ZpZGVkIHRvIGNyZWF0ZSBzaGFyZWQgYXNzZXQuUENhbm5vdFVwZGF0ZUxvY2F0aW9uAAcEdENhbm5vdCB1cGRhdGUgYXNzZXQgbG9jYXRpb24uSE5vdEluUmVzZXJ2ZWRSYW5nZQAIBKxTZWxlY3RlZCBhc3NldCBpZCBpcyBvdXQgb2YgcmVzZXJ2ZWQgcmFuZ2UuZExvY2F0aW9uQWxyZWFkeVJlZ2lzdGVyZWQACQTETG9jYXRpb24gYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggZGlmZmVyZW50IGFzc2V0LiRGb3JiaWRkZW4ACgSgT3JpZ2luIGlzIGZvcmJpZGRlbiB0byBzZXQvdXBkYXRlIHZhbHVlLkxJbnN1ZmZpY2llbnRCYWxhbmNlAAsEQEJhbGFuY2UgdG9vIGxvdy5oRm9yYmlkZGVuU3VmZmljaWVuY3lDaGFuZ2UADATMU3VmZmljaWVudCBhc3NldHMgY2FuJ3QgYmUgY2hhbmdlZCB0byBpbnN1ZmZpY2llbnQuSEFzc2V0QWxyZWFkeUJhbm5lZAANBGBBc3NldCBpcyBhbHJlYWR5IGJhbm5lZC44QXNzZXROb3RCYW5uZWQADgRQQXNzZXQgaXMgbm90IGJhbm5lZC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQu/QoMNHBhbGxldF9jbGFpbXMYcGFsbGV0FEVycm9yBARUAAEMYEludmFsaWRFdGhlcmV1bVNpZ25hdHVyZQAABHxFdGhlcmV1bSBzaWduYXR1cmUgaXMgbm90IHZhbGlkXE5vQ2xhaW1PckFscmVhZHlDbGFpbWVkAAEESENsYWltIGlzIG5vdCB2YWxpZDxCYWxhbmNlT3ZlcmZsb3cAAgTcVmFsdWUgcmVhY2hlZCBtYXhpbXVtIGFuZCBjYW5ub3QgYmUgaW5jcmVtZW50ZWQgZnVydGhlcgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC4BCwhYcGFsbGV0X2dlbmVzaXNfaGlzdG9yeRRDaGFpbgAACAEwZ2VuZXNpc19oYXNoNAEQSDI1NgABPGxhc3RfYmxvY2tfaGFzaDQBEEgyNTYAAAULDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBAARTAAAEADEBARhWZWM8VD4AAAkLDFxwYWxsZXRfY29sbGF0b3JfcmV3YXJkcxhwYWxsZXQURXJyb3IEBFQAAQAEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuDQsMPHBhbGxldF9vbW5pcG9vbBR0eXBlcyhBc3NldFN0YXRlBBxCYWxhbmNlARgAFAEsaHViX3Jlc2VydmUYARxCYWxhbmNlAAEYc2hhcmVzGAEcQmFsYW5jZQABPHByb3RvY29sX3NoYXJlcxgBHEJhbGFuY2UAAQxjYXAYARB1MTI4AAEgdHJhZGFibGUlAwEsVHJhZGFiaWxpdHkAABELDDxwYWxsZXRfb21uaXBvb2wUdHlwZXMgUG9zaXRpb24IHEJhbGFuY2UBGBxBc3NldElkARAAEAEgYXNzZXRfaWQQARxBc3NldElkAAEYYW1vdW50GAEcQmFsYW5jZQABGHNoYXJlcxgBHEJhbGFuY2UAARRwcmljZSkDAUgoQmFsYW5jZSwgQmFsYW5jZSkAABULDDxwYWxsZXRfb21uaXBvb2wYcGFsbGV0FEVycm9yBARUAAGATEluc3VmZmljaWVudEJhbGFuY2UAAAQ8QmFsYW5jZSB0b28gbG93REFzc2V0QWxyZWFkeUFkZGVkAAEEcEFzc2V0IGlzIGFscmVhZHkgaW4gb21uaXBvb2w0QXNzZXROb3RGb3VuZAACBGBBc3NldCBpcyBub3QgaW4gb21uaXBvb2w4TWlzc2luZ0JhbGFuY2UAAwQZAUZhaWxlZCB0byBhZGQgdG9rZW4gdG8gT21uaXBvb2wgZHVlIHRvIGluc3VmZmljaWVudCBpbml0aWFsIGxpcXVpZGl0eS5gSW52YWxpZEluaXRpYWxBc3NldFByaWNlAAQEcEludmFsaWQgaW5pdGlhbCBhc3NldCBwcmljZS5IQnV5TGltaXROb3RSZWFjaGVkAAUE5FNsaXBwYWdlIHByb3RlY3Rpb24gLSBtaW5pbXVtIGxpbWl0IGhhcyBub3QgYmVlbiByZWFjaGVkLkRTZWxsTGltaXRFeGNlZWRlZAAGBNhTbGlwcGFnZSBwcm90ZWN0aW9uIC0gbWF4aW11bSBsaW1pdCBoYXMgYmVlbiBleGNlZWRlZC5AUG9zaXRpb25Ob3RGb3VuZAAHBHBQb3NpdGlvbiBoYXMgbm90IGJlZW4gZm91bmQuSEluc3VmZmljaWVudFNoYXJlcwAIBHxJbnN1ZmZpY2llbnQgc2hhcmVzIGluIHBvc2l0aW9uKE5vdEFsbG93ZWQACQSIQXNzZXQgaXMgbm90IGFsbG93ZWQgdG8gYmUgdHJhZGVkLiRGb3JiaWRkZW4ACgTEU2lnbmVkIGFjY291bnQgaXMgbm90IG93bmVyIG9mIHBvc2l0aW9uIGluc3RhbmNlLlhBc3NldFdlaWdodENhcEV4Y2VlZGVkAAsEjEFzc2V0IHdlaWdodCBjYXAgaGFzIGJlZW4gZXhjZWVkZWQuSEFzc2V0Tm90UmVnaXN0ZXJlZAAMBKRBc3NldCBpcyBub3QgcmVnaXN0ZXJlZCBpbiBhc3NldCByZWdpc3RyeVRJbnN1ZmZpY2llbnRMaXF1aWRpdHkADQTEUHJvdmlkZWQgbGlxdWlkaXR5IGlzIGJlbG93IG1pbmltdW0gYWxsb3dlZCBsaW1pdGRJbnN1ZmZpY2llbnRUcmFkaW5nQW1vdW50AA4EsFRyYWRlZCBhbW91bnQgaXMgYmVsb3cgbWluaW11bSBhbGxvd2VkIGxpbWl0YFNhbWVBc3NldFRyYWRlTm90QWxsb3dlZAAPBLxTZWxsIG9yIGJ1eSB3aXRoIHNhbWUgYXNzZXQgaWRzIGlzIG5vdCBhbGxvd2VkLkxIdWJBc3NldFVwZGF0ZUVycm9yABAEyExSTkEgdXBkYXRlIGFmdGVyIHRyYWRlIHJlc3VsdHMgaW4gcG9zaXRpdmUgdmFsdWUuTEludmFsaWRTaGFyZXNBbW91bnQAEQSYQW1vdW50IG9mIHNoYXJlcyBwcm92aWRlZCBjYW5ub3QgYmUgMC5wSW52YWxpZEh1YkFzc2V0VHJhZGFibGVTdGF0ZQASBJRIdWIgYXNzZXQgaXMgb25seSBhbGxvd2VkIHRvIGJlIHNvbGQuVEFzc2V0UmVmdW5kTm90QWxsb3dlZAATBJBBc3NldCBpcyBub3QgYWxsb3dlZCB0byBiZSByZWZ1bmRlZC5MTWF4T3V0UmF0aW9FeGNlZWRlZAAUBLxNYXggZnJhY3Rpb24gb2YgYXNzZXQgdG8gYnV5IGhhcyBiZWVuIGV4Y2VlZGVkLkhNYXhJblJhdGlvRXhjZWVkZWQAFQTATWF4IGZyYWN0aW9uIG9mIGFzc2V0IHRvIHNlbGwgaGFzIGJlZW4gZXhjZWVkZWQuWFByaWNlRGlmZmVyZW5jZVRvb0hpZ2gAFgS8TWF4IGFsbG93ZWQgcHJpY2UgZGlmZmVyZW5jZSBoYXMgYmVlbiBleGNlZWRlZC5ISW52YWxpZE9yYWNsZVByaWNlABcEoEludmFsaWQgb3JhY2xlIHByaWNlIC0gZGl2aXNpb24gYnkgemVyby5QSW52YWxpZFdpdGhkcmF3YWxGZWUAGASMRmFpbGVkIHRvIGNhbGN1bGF0ZSB3aXRoZHJhd2FsIGZlZS4wRmVlT3ZlcmRyYWZ0ABkE1E1vcmUgdGhhbiBhbGxvd2VkIGFtb3VudCBvZiBmZWUgaGFzIGJlZW4gdHJhbnNmZXJyZWQuPFNoYXJlc1JlbWFpbmluZwAaBD0BVG9rZW4gY2Fubm90IGJlIHJlbW92ZWQgZnJvbSBPbW5pcG9vbCBkdWUgdG8gc2hhcmVzIHN0aWxsIG93bmVkIGJ5IG90aGVyIHVzZXJzLjhBc3NldE5vdEZyb3plbgAbBAkBVG9rZW4gY2Fubm90IGJlIHJlbW92ZWQgZnJvbSBPbW5pcG9vbCBiZWNhdXNlIGFzc2V0IGlzIG5vdCBmcm96ZW4uNFplcm9BbW91bnRPdXQAHAS4Q2FsY3VsYXRlZCBhbW91bnQgb3V0IGZyb20gc2VsbCB0cmFkZSBpcyB6ZXJvLnhFeGlzdGVudGlhbERlcG9zaXROb3RBdmFpbGFibGUAHQS4RXhpc3RlbnRpYWwgZGVwb3NpdCBvZiBhc3NldCBpcyBub3QgYXZhaWxhYmxlLjRTbGlwcGFnZUxpbWl0AB4ETFNsaXBwYWdlIHByb3RlY3Rpb25YUHJvdG9jb2xGZWVOb3RDb25zdW1lZAAfBKRFeHRyYSBwcm90b2NvbCBmZWUgaGFzIG5vdCBiZWVuIGNvbnN1bWVkLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC4ZCwAABAgdCx0LAB0LDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAAIQsMYHBhbGxldF90cmFuc2FjdGlvbl9wYXVzZRhwYWxsZXQURXJyb3IEBFQAAQwsQ2Fubm90UGF1c2UAAAQ0Y2FuIG5vdCBwYXVzZUBJbnZhbGlkQ2hhcmFjdGVyAAEEaGludmFsaWQgY2hhcmFjdGVyIGVuY29kaW5nLE5hbWVUb29Mb25nAAIEoHBhbGxldCBuYW1lIG9yIGZ1bmN0aW9uIG5hbWUgaXMgdG9vIGxvbmcEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuJQsMNHBhbGxldF9kdXN0ZXIYcGFsbGV0FEVycm9yBARUAAEYSEFjY291bnRXaGl0ZWxpc3RlZAAABIRBY2NvdW50IGlzIGV4Y2x1ZGVkIGZyb20gZHVzdGluZy5UQWNjb3VudE5vdFdoaXRlbGlzdGVkAAEEwEFjY291bnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIG5vbi1kdXN0YWJsZSBsaXN0LixaZXJvQmFsYW5jZQACBFBUaGUgYmFsYW5jZSBpcyB6ZXJvLjhOb25aZXJvQmFsYW5jZQADBKkBVGhlIGJhbGFuY2Ugd2FzIG5vdCBmdWxseSBkdXN0ZWQsIHRoZXJlIGlzIHNvbWUgbGVmdG92ZXIgb24gdGhlIGFjY291bnQuIE5vcm1hbGx5LCBpdCBzaG91bGQgbmV2ZXIgaGFwcGVuLkRCYWxhbmNlU3VmZmljaWVudAAEBLxUaGUgYmFsYW5jZSBpcyBzdWZmaWNpZW50IHRvIGtlZXAgYWNjb3VudCBvcGVuLlBSZXNlcnZlQWNjb3VudE5vdFNldAAFBGxSZXNlcnZlIGFjY291bnQgaXMgbm90IHNldC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuKQsMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nFHR5cGVzOEdsb2JhbEZhcm1EYXRhCARUAARJAABIAQhpZBABMEdsb2JhbEZhcm1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAEodXBkYXRlZF9hdBABLFBlcmlvZE9mPFQ+AAE4dG90YWxfc2hhcmVzX3oYARxCYWxhbmNlAAE8YWNjdW11bGF0ZWRfcnB6PQEBJEZpeGVkVTEyOAABPHJld2FyZF9jdXJyZW5jeRABKFQ6OkFzc2V0SWQAATxwZW5kaW5nX3Jld2FyZHMYARxCYWxhbmNlAAFgYWNjdW11bGF0ZWRfcGFpZF9yZXdhcmRzGAEcQmFsYW5jZQABQHlpZWxkX3Blcl9wZXJpb2Q9AwEsUGVycXVpbnRpbGwAAWBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMQASxQZXJpb2RPZjxUPgABRGJsb2Nrc19wZXJfcGVyaW9kEAFEQmxvY2tOdW1iZXJGb3I8VD4AAUhpbmNlbnRpdml6ZWRfYXNzZXQQAShUOjpBc3NldElkAAFUbWF4X3Jld2FyZF9wZXJfcGVyaW9kGAEcQmFsYW5jZQABLG1pbl9kZXBvc2l0GAEcQmFsYW5jZQABWGxpdmVfeWllbGRfZmFybXNfY291bnQQAQx1MzIAAVx0b3RhbF95aWVsZF9mYXJtc19jb3VudBABDHUzMgABQHByaWNlX2FkanVzdG1lbnQ9AQEkRml4ZWRVMTI4AAEUc3RhdGUtCwEkRmFybVN0YXRlAAAtCwxccGFsbGV0X2xpcXVpZGl0eV9taW5pbmcUdHlwZXMkRmFybVN0YXRlAAEMGEFjdGl2ZQAAABxTdG9wcGVkAAEAKFRlcm1pbmF0ZWQAAgAAMQsAAAQMEBAQADULDFxwYWxsZXRfbGlxdWlkaXR5X21pbmluZxR0eXBlczRZaWVsZEZhcm1EYXRhCARUAARJAAAwAQhpZBABGEZhcm1JZAABKHVwZGF0ZWRfYXQQASxQZXJpb2RPZjxUPgABMHRvdGFsX3NoYXJlcxgBHEJhbGFuY2UAAUx0b3RhbF92YWx1ZWRfc2hhcmVzGAEcQmFsYW5jZQABQGFjY3VtdWxhdGVkX3JwdnM9AQEkRml4ZWRVMTI4AAE8YWNjdW11bGF0ZWRfcnB6PQEBJEZpeGVkVTEyOAABNGxveWFsdHlfY3VydmVBAwFQT3B0aW9uPExveWFsdHlDdXJ2ZT4AAShtdWx0aXBsaWVyPQEBOEZhcm1NdWx0aXBsaWVyAAEUc3RhdGUtCwEkRmFybVN0YXRlAAE0ZW50cmllc19jb3VudDABDHU2NAABSGxlZnRfdG9fZGlzdHJpYnV0ZRgBHEJhbGFuY2UAATR0b3RhbF9zdG9wcGVkEAEsUGVyaW9kT2Y8VD4AADkLDFxwYWxsZXRfbGlxdWlkaXR5X21pbmluZxR0eXBlcyxEZXBvc2l0RGF0YQgEVAAESQAADAEYc2hhcmVzGAEcQmFsYW5jZQABLGFtbV9wb29sX2lkEAEwVDo6QW1tUG9vbElkAAFIeWllbGRfZmFybV9lbnRyaWVzPQsB9EJvdW5kZWRWZWM8WWllbGRGYXJtRW50cnk8VCwgST4sIFQ6Ok1heEZhcm1FbnRyaWVzUGVyRGVwb3NpdD4AAD0LDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBQQsEUwAABABFCwEYVmVjPFQ+AABBCwxccGFsbGV0X2xpcXVpZGl0eV9taW5pbmcUdHlwZXM4WWllbGRGYXJtRW50cnkIBFQABEkAACABOGdsb2JhbF9mYXJtX2lkEAEwR2xvYmFsRmFybUlkAAE0eWllbGRfZmFybV9pZBABLFlpZWxkRmFybUlkAAE0dmFsdWVkX3NoYXJlcxgBHEJhbGFuY2UAAUBhY2N1bXVsYXRlZF9ycHZzPQEBJEZpeGVkVTEyOAABbGFjY3VtdWxhdGVkX2NsYWltZWRfcmV3YXJkcxgBHEJhbGFuY2UAAShlbnRlcmVkX2F0EAEsUGVyaW9kT2Y8VD4AASh1cGRhdGVkX2F0EAEsUGVyaW9kT2Y8VD4AAUxzdG9wcGVkX2F0X2NyZWF0aW9uEAEsUGVyaW9kT2Y8VD4AAEULAAACQQsASQsMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nGHBhbGxldBRFcnJvcggEVAAESQABdEhHbG9iYWxGYXJtTm90Rm91bmQAAARsR2xvYmFsIGZhcm0gZG9lcyBub3QgZXhpc3QuRFlpZWxkRmFybU5vdEZvdW5kAAEEaFlpZWxkIGZhcm0gZG9lcyBub3QgZXhpc3QuTERvdWJsZUNsYWltSW5QZXJpb2QAAgTITXVsdGlwbGUgY2xhaW1zIGluIHRoZSBzYW1lIHBlcmlvZCBpcyBub3QgYWxsb3dlZC5cTGlxdWlkaXR5TWluaW5nQ2FuY2VsZWQAAwR0TGlxdWlkaXR5IG1pbmluZyBpcyBjYW5jZWxlZC5cTGlxdWlkaXR5TWluaW5nSXNBY3RpdmUABASETGlxdWlkaXR5IG1pbmluZyBpcyBub3QgY2FuY2VsZWQubExpcXVpZGl0eU1pbmluZ0lzTm90U3RvcHBlZAAFBFUBTGlxdWlkaXR5IG1pbmluZyBpcyBpbiBgYWN0aXZlYCBvciBgdGVybWluYXRlZGAgc3RhdGUgYW5kIGFjdGlvbiBjYW5ub3QgYmUgY29tcGxldGVkLiRGb3JiaWRkZW4ABgSkQWNjb3VudCBpcyBub3QgYWxsb3dlZCB0byBwZXJmb3JtIGFjdGlvbi5ESW52YWxpZE11bHRpcGxpZXIABwSEWWllbGQgZmFybSBtdWx0aXBsaWVyIGNhbid0IGJlIDAuWFlpZWxkRmFybUFscmVhZHlFeGlzdHMACAQJAVlpZWxkIGZhcm0gd2l0aCBnaXZlbiBgYW1tX3Bvb2xfaWRgIGFscmVhZHkgZXhpc3RzIGluIGdsb2JhbCBmYXJtLnhJbnZhbGlkSW5pdGlhbFJld2FyZFBlcmNlbnRhZ2UACQQ9AUxveWFsdHkgY3VydmUncyBpbml0aWFsIHJld2FyZCBwZXJjZW50YWdlIGlzIG5vdCB2YWxpZC4gVmFsaWQgcmFuZ2UgaXM6IFswLCAxKS5QR2xvYmFsRmFybUlzTm90RW1wdHkACgS0T25lIG9yIG1vcmUgeWllbGQgZmFybXMgZXhpc3QgaW4gZ2xvYmFsIGZhcm0uYE1pc3NpbmdJbmNlbnRpdml6ZWRBc3NldAALBPhGYXJtJ3MgYGluY2VudGl2aXplZF9hc3NldGAgaXMgbWlzc2luZyBpbiBwcm92aWRlZCBhc3NldCBwYWlyLoRJbnN1ZmZpY2llbnRSZXdhcmRDdXJyZW5jeUJhbGFuY2UADASoUmV3YXJkIGN1cnJlbmN5IGJhbGFuY2UgaXMgbm90IHN1ZmZpY2llbnQuWEludmFsaWRCbG9ja3NQZXJQZXJpb2QADQR0QmxvY2tzIHBlciBwZXJpb2QgY2FuJ3QgYmUgMC5USW52YWxpZFlpZWxkUGVyUGVyaW9kAA4EcFlpZWxkIHBlciBwZXJpb2QgY2FuJ3QgYmUgMC5MSW52YWxpZFRvdGFsUmV3YXJkcwAPBMRUb3RhbCByZXdhcmRzIGlzIGxlc3MgdGhhbiBgTWluVG90YWxGYXJtUmV3YXJkc2AudEludmFsaWRQbGFubmVkWWllbGRpbmdQZXJpb2RzABAECQFQbGFubmVkIHlpZWxkaW5nIHBlcmlvZHMgaXMgbGVzcyB0aGFuIGBNaW5QbGFubmVkWWllbGRpbmdQZXJpb2RzYC5QTWF4RW50cmllc1BlckRlcG9zaXQAEQSwTWF4aW11bSBudW1iZXIgb2YgbG9ja3MgcmVhY2hlZCBmb3IgZGVwb3NpdC4oRG91YmxlTG9jawASBOBUcnlpbmcgdG8gbG9jayBMUCBzaGFyZXMgaW50byBhbHJlYWR5IGxvY2tlZCB5aWVsZCBmYXJtLlhZaWVsZEZhcm1FbnRyeU5vdEZvdW5kABMExFlpZWxkIGZhcm0gZW50cnkgZG9lc24ndCBleGlzdCBmb3IgZ2l2ZW4gZGVwb3NpdC5AR2xvYmFsRmFybUlzRnVsbAAUCEkBTWF4IG51bWJlciBvZiB5aWVsZCBmYXJtcyBpbiBnbG9iYWwgZmFybSB3YXMgcmVhY2hlZC4gR2xvYmFsIGZhcm0gY2FuJ3QgYWNjZXB0IG5ld/h5aWVsZCBmYXJtcyB1bnRpbCBzb21lIHlpZWxkIGZhcm0gaXMgbm90IHJlbW92ZWQgZnJvbSBzdG9yYWdlLkRJbnZhbGlkTWluRGVwb3NpdAAVBLRJbnZhbGlkIG1pbi4gZGVwb3NpdCB3YXMgc2V0IGZvciBnbG9iYWwgZmFybS5YSW52YWxpZFByaWNlQWRqdXN0bWVudAAWBJxQcmljZSBhZGp1c3RtZW50IG11bHRpcGxpZXIgY2FuJ3QgYmUgMC5ERXJyb3JHZXRBY2NvdW50SWQAFwSAQWNjb3VudCBjcmVhdGlvbiBmcm9tIGlkIGZhaWxlZC5USW5jb3JyZWN0VmFsdWVkU2hhcmVzABgEJQFWYWx1ZSBvZiBkZXBvc2l0ZWQgc2hhcmVzIGFtb3VudCBpbiByZXdhcmQgY3VycmVuY3kgaXMgYmVsbG93IG1pbi4gbGltaXQubFJld2FyZEN1cnJlbmN5Tm90UmVnaXN0ZXJlZAAZBNhgcmV3YXJkX2N1cnJlbmN5YCBpcyBub3QgcmVnaXN0ZXJlZCBpbiBhc3NldCByZWdpc3RyeS54SW5jZW50aXZpemVkQXNzZXROb3RSZWdpc3RlcmVkABoE5GBpbmNlbnRpdml6ZWRfYXNzZXRgIGlzIG5vdCByZWdpc3RlcmVkIGluIGFzc2V0IHJlZ2lzdHJ5LkRBbW1Qb29sSWRNaXNtYXRjaAAbBPRQcm92aWRlZCBgYW1tX3Bvb2xfaWRgIGRvZXNuJ3QgbWF0Y2ggZGVwb3NpdCdzIGBhbW1fcG9vbF9pZGAuREluY29uc2lzdGVudFN0YXRlBABNCwFYSW5jb25zaXN0ZW50U3RhdGVFcnJvcgAcCGUBQWN0aW9uIGNhbm5vdCBiZSBjb21wbGV0ZWQgYmVjYXVzZSB1bmV4cGVjdGVkIGVycm9yIGhhcyBvY2N1cnJlZC4gVGhpcyBzaG91bGQgYmUgcmVwb3J0ZWRgdG8gcHJvdG9jb2wgbWFpbnRhaW5lcnMuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Lk0LDFxwYWxsZXRfbGlxdWlkaXR5X21pbmluZxhwYWxsZXRYSW5jb25zaXN0ZW50U3RhdGVFcnJvcgABRERZaWVsZEZhcm1Ob3RGb3VuZAAAAEhHbG9iYWxGYXJtTm90Rm91bmQAAQBQTGlxdWlkaXR5SXNOb3RBY3RpdmUAAgBUR2xvYmFsRmFybUlzTm90QWN0aXZlAAMAPERlcG9zaXROb3RGb3VuZAAEADRJbnZhbGlkUGVyaW9kAAUAbE5vdEVub3VnaFJld2FyZHNJbllpZWxkRmFybQAGAGRJbnZhbGlkTGl2ZVlpZWxGYXJtc0NvdW50AAcAbEludmFsaWRUb3RhbFlpZWxkRmFybXNDb3VudAAIAHBJbnZhbGlkWWllbGRGYXJtRW50cmllc0NvdW50AAkASEludmFsaWRUb3RhbFNoYXJlcwAKAExJbnZhbGlkVmFsdWVkU2hhcmVzAAsATEludmFsaWRUb3RhbFNoYXJlc1oADAB0SW52YWxpZFBhaWRBY2N1bXVsYXRlZFJld2FyZHMADQA0SW52YWxpZEZhcm1JZAAOAGBJbnZhbGlkTG95YWx0eU11bHRpcGxpZXIADwBwTm9FeGlzdGVudGlhbERlcG9zaXRGb3JBc3NldAAQAABRCwyAcGFsbGV0X29tbmlwb29sX2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0FEVycm9yBARUAAEcNEFzc2V0Tm90Rm91bmQAAAR0QXNzZXQgaXMgbm90IGluIHRoZSBvbW5pcG9vbC4kRm9yYmlkZGVuAAEErFNpZ25lZCBhY2NvdW50IGlzIG5vdCBvd25lciBvZiB0aGUgZGVwb3NpdC5IWmVyb0NsYWltZWRSZXdhcmRzAAIEXFJld2FyZHMgdG8gY2xhaW0gYXJlIDAuREluY29uc2lzdGVudFN0YXRlBABVCwFYSW5jb25zaXN0ZW50U3RhdGVFcnJvcgADCGUBQWN0aW9uIGNhbm5vdCBiZSBjb21wbGV0ZWQgYmVjYXVzZSB1bmV4cGVjdGVkIGVycm9yIGhhcyBvY2N1cnJlZC4gVGhpcyBzaG91bGQgYmUgcmVwb3J0ZWRgdG8gcHJvdG9jb2wgbWFpbnRhaW5lcnMuSE9yYWNsZU5vdEF2YWlsYWJsZQAEBLxPcmFjbGUgY291bGQgbm90IGJlIGZvdW5kIGZvciByZXF1ZXN0ZWQgYXNzZXRzLmxQcmljZUFkanVzdG1lbnROb3RBdmFpbGFibGUABQQxAU9yYWNsZSBwcm92aWRpbmcgYHByaWNlX2FkanVzdG1lbnRgIGNvdWxkIG5vdCBiZSBmb3VuZCBmb3IgcmVxdWVzdGVkIGFzc2V0cy5YTm9GYXJtRW50cmllc1NwZWNpZmllZAAGBGhObyBmYXJtcyBzcGVjaWZpZWQgdG8gam9pbgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5VCwyAcGFsbGV0X29tbmlwb29sX2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0WEluY29uc2lzdGVudFN0YXRlRXJyb3IAAQhETWlzc2luZ0xwUG9zaXRpb24AAABMRGVwb3NpdERhdGFOb3RGb3VuZAABAABZCwgocGFsbGV0X290YxRPcmRlcggkQWNjb3VudElkAQAcQXNzZXRJZAEQABgBFG93bmVyAAEkQWNjb3VudElkAAEgYXNzZXRfaW4QARxBc3NldElkAAEkYXNzZXRfb3V0EAEcQXNzZXRJZAABJGFtb3VudF9pbhgBHEJhbGFuY2UAAShhbW91bnRfb3V0GAEcQmFsYW5jZQABSHBhcnRpYWxseV9maWxsYWJsZSABEGJvb2wAAF0LDChwYWxsZXRfb3RjGHBhbGxldBRFcnJvcgQEVAABIEhBc3NldE5vdFJlZ2lzdGVyZWQAAASAQXNzZXQgZG9lcyBub3QgZXhpc3QgaW4gcmVnaXN0cnk0T3JkZXJOb3RGb3VuZAABBFRPcmRlciBjYW5ub3QgYmUgZm91bmRET3JkZXJJZE91dE9mQm91bmQAAgSIU2l6ZSBvZiBvcmRlciBJRCBleGNlZWRzIHRoZSBib3VuZGRPcmRlck5vdFBhcnRpYWxseUZpbGxhYmxlAAME+ENhbm5vdCBwYXJ0aWFsbHkgZmlsbCBhbiBvcmRlciB3aGljaCBpcyBub3QgcGFydGlhbGx5IGZpbGxhYmxlTE9yZGVyQW1vdW50VG9vU21hbGwABAxhAU9yZGVyIGFtb3VudF9pbiBhbmQgYW1vdW50X291dCBtdXN0IGF0IGFsbCB0aW1lcyBiZSBncmVhdGVyIHRoYW4gdGhlIGV4aXN0ZW50aWFsIGRlcG9zaXT0Zm9yIHRoZSBhc3NldCBtdWx0aXBsaWVkIGJ5IHRoZSBFeGlzdGVudGlhbERlcG9zaXRNdWx0aXBsaWVyLvBBIGZpbGwgb3JkZXIgbWF5IG5vdCBsZWF2ZSBiZWhpbmQgYW1vdW50cyBzbWFsbGVyIHRoYW4gdGhpcy4kTWF0aEVycm9yAAUEcEVycm9yIHdpdGggbWF0aCBjYWxjdWxhdGlvbnMkRm9yYmlkZGVuAAYE6FRoZSBjYWxsZXIgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGNvbXBsZXRlIHRoZSBhY3Rpb25oSW5zdWZmaWNpZW50UmVzZXJ2ZWRBbW91bnQABwR8UmVzZXJ2ZWQgYW1vdW50IG5vdCBzdWZmaWNpZW50LgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5hCwhYcGFsbGV0X2NpcmN1aXRfYnJlYWtlckBUcmFkZVZvbHVtZUxpbWl0BARUAAAMASR2b2x1bWVfaW4YAShUOjpCYWxhbmNlAAEodm9sdW1lX291dBgBKFQ6OkJhbGFuY2UAARRsaW1pdBgBKFQ6OkJhbGFuY2UAAGULCFhwYWxsZXRfY2lyY3VpdF9icmVha2VyOExpcXVpZGl0eUxpbWl0BARUAAAIASRsaXF1aWRpdHkYAShUOjpCYWxhbmNlAAEUbGltaXQYAShUOjpCYWxhbmNlAABpCwxYcGFsbGV0X2NpcmN1aXRfYnJlYWtlchR0eXBlczhMb2NrZG93blN0YXR1cwgsQmxvY2tOdW1iZXIBEBxCYWxhbmNlARgBCBhMb2NrZWQEABABLEJsb2NrTnVtYmVyAAAAIFVubG9ja2VkBADVAwFYKEJsb2NrTnVtYmVyLCBCYWxhbmNlKQABAABtCwxYcGFsbGV0X2NpcmN1aXRfYnJlYWtlchhwYWxsZXQURXJyb3IEBFQAASRESW52YWxpZExpbWl0VmFsdWUAAATISW52YWxpZCB2YWx1ZSBmb3IgYSBsaW1pdC4gTGltaXQgbXVzdCBiZSBub24temVyby58TGlxdWlkaXR5TGltaXROb3RTdG9yZWRGb3JBc3NldAABBLxBbGxvd2VkIGxpcXVpZGl0eSBsaW1pdCBpcyBub3Qgc3RvcmVkIGZvciBhc3NldGBUb2tlbk91dGZsb3dMaW1pdFJlYWNoZWQAAgS4VG9rZW4gdHJhZGUgb3V0ZmxvdyBwZXIgYmxvY2sgaGFzIGJlZW4gcmVhY2hlZFxUb2tlbkluZmx1eExpbWl0UmVhY2hlZAADBLRUb2tlbiB0cmFkZSBpbmZsdXggcGVyIGJsb2NrIGhhcyBiZWVuIHJlYWNoZWSATWF4TGlxdWlkaXR5TGltaXRQZXJCbG9ja1JlYWNoZWQABATkTWF4aW11bSBwb29sJ3MgbGlxdWlkaXR5IGxpbWl0IHBlciBibG9jayBoYXMgYmVlbiByZWFjaGVkKE5vdEFsbG93ZWQABQSQQXNzZXQgaXMgbm90IGFsbG93ZWQgdG8gaGF2ZSBhIGxpbWl0PEFzc2V0SW5Mb2NrZG93bgAGDDkBQXNzZXQgc3RpbGwgaW4gbG9ja2Rvd24gYXMgaXQgcmVhY2hlZCB0aGUgYWxsb3dlZCBkZXBvc2l0IGxpbWl0IGZvciB0aGUgcGVyaW9kcQFRdWVyeSB0aGUgYGFzc2V0X2xvY2tkb3duX3N0YXRlYCBzdG9yYWdlIHRvIGRldGVybWluZSB1bnRpbCB3aGljaCBibG9jayB0aGUgYXNzZXQgaXMgbG9ja2VkLLhzbyB0aGF0IHRoZSBkZXBvc2l0IGNhbiBiZSByZWxlYXNlZCBhZnRlcndhcmQuSEFzc2V0Tm90SW5Mb2NrZG93bgAHBGhBc3NldCBpcyBub3QgaW4gYSBsb2NrZG93bjRJbnZhbGlkQW1vdW50AAgEeEludmFsaWQgYW1vdW50IHRvIHNhdmUgZGVwb3NpdASAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5xCwxUcGFsbGV0X3JvdXRlX2V4ZWN1dG9yGHBhbGxldBRFcnJvcgQEVAABKExUcmFkaW5nTGltaXRSZWFjaGVkAAAEiFRoZSB0cmFkaW5nIGxpbWl0IGhhcyBiZWVuIHJlYWNoZWRETWF4VHJhZGVzRXhjZWVkZWQAAQS0VGhlIHRoZSBtYXggbnVtYmVyIG9mIHRyYWRlcyBsaW1pdCBpcyByZWFjaGVkQFBvb2xOb3RTdXBwb3J0ZWQAAgTIVGhlIEFNTSBwb29sIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGV4ZWN1dGluZyB0cmFkZXNMSW5zdWZmaWNpZW50QmFsYW5jZQADBNBUaGUgdXNlciBoYXMgbm90IGVub3VnaCBiYWxhbmNlIHRvIGV4ZWN1dGUgdGhlIHRyYWRlWFJvdXRlQ2FsY3VsYXRpb25GYWlsZWQABAQNAVRoZSBjYWxjdWxhdGlvbiBvZiByb3V0ZSB0cmFkZSBhbW91bnRzIGZhaWxlZCBpbiB0aGUgdW5kZXJseWluZyBBTU0wSW52YWxpZFJvdXRlAAUEUFRoZSByb3V0ZSBpcyBpbnZhbGlkaFJvdXRlVXBkYXRlSXNOb3RTdWNjZXNzZnVsAAYEjFRoZSByb3V0ZSB1cGRhdGUgd2FzIG5vdCBzdWNjZXNzZnVsQFJvdXRlSGFzTm9PcmFjbGUABwS0Um91dGUgY29udGFpbnMgYXNzZXRzIHRoYXQgaGFzIG5vIG9yYWNsZSBkYXRhVEludmFsaWRSb3V0ZUV4ZWN1dGlvbgAIBMBUaGUgcm91dGUgZXhlY3V0aW9uIGZhaWxlZCBpbiB0aGUgdW5kZXJseWluZyBBTU0oTm90QWxsb3dlZAAJBIxUcmFkaW5nIHNhbWUgYXNzZXRzIGlzIG5vdCBhbGxvd2VkLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC51CwxMcGFsbGV0X2R5bmFtaWNfZmVlcxR0eXBlcyBGZWVFbnRyeQgMRmVlASEDFEJsb2NrARAADAEkYXNzZXRfZmVlIQMBDEZlZQABMHByb3RvY29sX2ZlZSEDAQxGZWUAASR0aW1lc3RhbXAQARRCbG9jawAAeQsMTHBhbGxldF9keW5hbWljX2ZlZXMYcGFsbGV0FEVycm9yBARUAAEEUEludmFsaWRGZWVQYXJhbWV0ZXJzAAAEfEludmFsaWQgZmVlIHBhcmFtZXRlcnMgcHJvdmlkZWQEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQufQsMOHBhbGxldF9zdGFraW5nFHR5cGVzLFN0YWtpbmdEYXRhAAAMASx0b3RhbF9zdGFrZRgBHEJhbGFuY2UAAXBhY2N1bXVsYXRlZF9yZXdhcmRfcGVyX3N0YWtlPQEBJEZpeGVkVTEyOAABUHBvdF9yZXNlcnZlZF9iYWxhbmNlGAEcQmFsYW5jZQAAgQsMOHBhbGxldF9zdGFraW5nFHR5cGVzIFBvc2l0aW9uBCxCbG9ja051bWJlcgEQABwBFHN0YWtlGAEcQmFsYW5jZQABNGFjdGlvbl9wb2ludHMYARRQb2ludAABQHJld2FyZF9wZXJfc3Rha2U9AQEkRml4ZWRVMTI4AAEoY3JlYXRlZF9hdBABLEJsb2NrTnVtYmVyAAFgYWNjdW11bGF0ZWRfc2xhc2hfcG9pbnRzGAEUUG9pbnQAAWhhY2N1bXVsYXRlZF91bnBhaWRfcmV3YXJkcxgBHEJhbGFuY2UAAWhhY2N1bXVsYXRlZF9sb2NrZWRfcmV3YXJkcxgBHEJhbGFuY2UAAIULDDhwYWxsZXRfc3Rha2luZxR0eXBlcxhWb3RpbmcEIE1heFZvdGVzAAAEARR2b3Rlc4kLAbRCb3VuZGVkVmVjPChSZWZlcmVuZHVtSW5kZXgsIFZvdGUpLCBNYXhWb3Rlcz4AAIkLDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBjQsEUwAABACZCwEYVmVjPFQ+AACNCwAABAgQkQsAkQsMOHBhbGxldF9zdGFraW5nFHR5cGVzEFZvdGUAAAgBGGFtb3VudBgBHEJhbGFuY2UAAShjb252aWN0aW9ulQsBKENvbnZpY3Rpb24AAJULDDhwYWxsZXRfc3Rha2luZxR0eXBlcyhDb252aWN0aW9uAAEcEE5vbmUAAAAgTG9ja2VkMXgAAQAgTG9ja2VkMngAAgAgTG9ja2VkM3gAAwAgTG9ja2VkNHgABAAgTG9ja2VkNXgABQAgTG9ja2VkNngABgAAmQsAAAKNCwCdCww4cGFsbGV0X3N0YWtpbmcYcGFsbGV0FEVycm9yBARUAAE0TEluc3VmZmljaWVudEJhbGFuY2UAAARMQmFsYW5jZSBpcyB0b28gbG93LkRJbnN1ZmZpY2llbnRTdGFrZQABBGRTdGFrZWQgYW1vdW50IGlzIHRvbyBsb3cuQFBvc2l0aW9uTm90Rm91bmQAAgSQU3Rha2luZyBwb3NpdGlvbiBoYXMgbm90IGJlZW4gZm91bmQuPE1heFZvdGVzUmVhY2hlZAADBOhNYXhpbXVtIGFtb3VudCBvZiB2b3RlcyB3ZXJlIHJlYWNoZWQgZm9yIHN0YWtpbmcgcG9zaXRpb24uOE5vdEluaXRpYWxpemVkAAQEbFN0YWtpbmcgaXMgbm90IGluaXRpYWxpemVkLkhBbHJlYWR5SW5pdGlhbGl6ZWQABQR8U3Rha2luZyBpcyBhbHJlYWR5IGluaXRpYWxpemVkLihBcml0aG1ldGljAAYEREFyaXRobWV0aWMgZXJyb3IuRE1pc3NpbmdQb3RCYWxhbmNlAAcEWFBvdCdzIGJhbGFuY2UgaXMgemVyby5UUG9zaXRpb25BbHJlYWR5RXhpc3RzAAgEiEFjY291bnQncyBwb3NpdGlvbiBhbHJlYWR5IGV4aXN0cy4kRm9yYmlkZGVuAAkEvFNpZ25lciBpcyBub3QgYW4gb3duZXIgb2YgdGhlIHN0YWtpbmcgcG9zaXRpb24uNEV4aXN0aW5nVm90ZXMACgSMUG9zaXRpb24gY29udGFpbnMgcmVnaXN0ZXJlZCB2b3Rlcy5YRXhpc3RpbmdQcm9jZXNzZWRWb3RlcwALBIUBUG9zaXRpb24gY29udGFpbnMgcHJvY2Vzc2VkIHZvdGVzLiBSZW1vdmVkIHRoZXNlIHZvdGVzIGZpcnN0IGJlZm9yZSBpbmNyZWFzaW5nIHN0YWtlIG9yIGNsYWltaW5nLkRJbmNvbnNpc3RlbnRTdGF0ZQQAoQsBWEluY29uc2lzdGVudFN0YXRlRXJyb3IADAhlAUFjdGlvbiBjYW5ub3QgYmUgY29tcGxldGVkIGJlY2F1c2UgdW5leHBlY3RlZCBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgc2hvdWxkIGJlIHJlcG9ydGVkYHRvIHByb3RvY29sIG1haW50YWluZXJzLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC6hCww4cGFsbGV0X3N0YWtpbmcYcGFsbGV0WEluY29uc2lzdGVudFN0YXRlRXJyb3IAARRAUG9zaXRpb25Ob3RGb3VuZAAAAFhOZWdhdGl2ZVBlbmRpbmdSZXdhcmRzAAEAVE5lZ2F0aXZlVW5wYWlkUmV3YXJkcwACAEBUb29NYW55UG9zaXRpb25zAAMAKEFyaXRobWV0aWMABAAApQsMRHBhbGxldF9zdGFibGVzd2FwFHR5cGVzIFBvb2xJbmZvCBxBc3NldElkARAsQmxvY2tOdW1iZXIBEAAYARhhc3NldHOlAwHEQm91bmRlZFZlYzxBc3NldElkLCBDb25zdFUzMjxNQVhfQVNTRVRTX0lOX1BPT0w+PgABVGluaXRpYWxfYW1wbGlmaWNhdGlvbqUHAShOb25aZXJvVTE2AAFMZmluYWxfYW1wbGlmaWNhdGlvbqUHAShOb25aZXJvVTE2AAE0aW5pdGlhbF9ibG9jaxABLEJsb2NrTnVtYmVyAAEsZmluYWxfYmxvY2sQASxCbG9ja051bWJlcgABDGZlZSEDARxQZXJtaWxsAACpCwxEcGFsbGV0X3N0YWJsZXN3YXAUdHlwZXMwUG9vbFNuYXBzaG90BBxBc3NldElkARAAGAEYYXNzZXRzpQMBxEJvdW5kZWRWZWM8QXNzZXRJZCwgQ29uc3RVMzI8TUFYX0FTU0VUU19JTl9QT09MPj4AASByZXNlcnZlc60LAdhCb3VuZGVkVmVjPEFzc2V0UmVzZXJ2ZSwgQ29uc3RVMzI8TUFYX0FTU0VUU19JTl9QT09MPj4AATRhbXBsaWZpY2F0aW9uGAEQdTEyOAABDGZlZSEDARxQZXJtaWxsAAEQcGVnc7EHAcRCb3VuZGVkVmVjPFBlZ1R5cGUsIENvbnN0VTMyPE1BWF9BU1NFVFNfSU5fUE9PTD4+AAE4c2hhcmVfaXNzdWFuY2UYARxCYWxhbmNlAACtCwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAbELBFMAAAQAtQsBGFZlYzxUPgAAsQsQNGh5ZHJhX2R4X21hdGgoc3RhYmxlc3dhcBR0eXBlczBBc3NldFJlc2VydmUAAAgBGGFtb3VudBgBHEJhbGFuY2UAASBkZWNpbWFscwgBCHU4AAC1CwAAArELALkLBDhSYW5nZUluY2x1c2l2ZQQMSWR4AaUHAAgBFHN0YXJ0pQcBDElkeAABDGVuZKUHAQxJZHgAAL0LDERwYWxsZXRfc3RhYmxlc3dhcBhwYWxsZXQURXJyb3IEBFQAAXA8SW5jb3JyZWN0QXNzZXRzAAAEGQFDcmVhdGluZyBhIHBvb2wgd2l0aCBzYW1lIGFzc2V0cyBvciBsZXNzIHRoYW4gMiBhc3NldHMgaXMgbm90IGFsbG93ZWQuRE1heEFzc2V0c0V4Y2VlZGVkAAEErE1heGltdW0gbnVtYmVyIG9mIGFzc2V0cyBoYXMgYmVlbiBleGNlZWRlZC4wUG9vbE5vdEZvdW5kAAIEoEEgcG9vbCB3aXRoIGdpdmVuIGFzc2V0cyBkb2VzIG5vdCBleGlzdC4oUG9vbEV4aXN0cwADBKBBIHBvb2wgd2l0aCBnaXZlbiBhc3NldHMgYWxyZWFkeSBleGlzdHMuOEFzc2V0Tm90SW5Qb29sAAQEZEFzc2V0IGlzIG5vdCBpbiB0aGUgcG9vbC5cU2hhcmVBc3NldE5vdFJlZ2lzdGVyZWQABQSoU2hhcmUgYXNzZXQgaXMgbm90IHJlZ2lzdGVyZWQgaW4gUmVnaXN0cnkuWFNoYXJlQXNzZXRJblBvb2xBc3NldHMABgTIU2hhcmUgYXNzZXQgaXMgYW1vdW50IGFzc2V0cyB3aGVuIGNyZWF0aW5nIGEgcG9vbC5IQXNzZXROb3RSZWdpc3RlcmVkAAcE2E9uZSBvciBtb3JlIGFzc2V0cyBhcmUgbm90IHJlZ2lzdGVyZWQgaW4gQXNzZXRSZWdpc3RyeUhJbnZhbGlkQXNzZXRBbW91bnQACAQBAUludmFsaWQgYXNzZXQgYW1vdW50IHByb3ZpZGVkLiBBbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5MSW5zdWZmaWNpZW50QmFsYW5jZQAJBORCYWxhbmNlIG9mIGFuIGFzc2V0IGlzIG5vdCBzdWZmaWNpZW50IHRvIHBlcmZvcm0gYSB0cmFkZS5ISW5zdWZmaWNpZW50U2hhcmVzAAoEBQFCYWxhbmNlIG9mIGEgc2hhcmUgYXNzZXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gd2l0aGRyYXcgbGlxdWlkaXR5LlRJbnN1ZmZpY2llbnRMaXF1aWRpdHkACwS8TGlxdWlkaXR5IGhhcyBub3QgcmVhY2hlZCB0aGUgcmVxdWlyZWQgbWluaW11bS54SW5zdWZmaWNpZW50TGlxdWlkaXR5UmVtYWluaW5nAAwE5Eluc3VmZmljaWVudCBsaXF1aWRpdHkgbGVmdCBpbiB0aGUgcG9vbCBhZnRlciB3aXRoZHJhd2FsLmRJbnN1ZmZpY2llbnRUcmFkaW5nQW1vdW50AA0E6EFtb3VudCBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdHJhZGluZyBhbW91bnQgY29uZmlndXJlZC5IQnV5TGltaXROb3RSZWFjaGVkAA4EwE1pbmltdW0gbGltaXQgaGFzIG5vdCBiZWVuIHJlYWNoZWQgZHVyaW5nIHRyYWRlLkRTZWxsTGltaXRFeGNlZWRlZAAPBLRNYXhpbXVtIGxpbWl0IGhhcyBiZWVuIGV4Y2VlZGVkIGR1cmluZyB0cmFkZS5cSW52YWxpZEluaXRpYWxMaXF1aWRpdHkAEAScSW5pdGlhbCBsaXF1aWRpdHkgb2YgYXNzZXQgbXVzdCBiZSA+IDAuUEludmFsaWRBbXBsaWZpY2F0aW9uABEEqEFtcGxpZmljYXRpb24gaXMgb3V0c2lkZSBjb25maWd1cmVkIHJhbmdlLmBJbnN1ZmZpY2llbnRTaGFyZUJhbGFuY2UAEgQZAVJlbWFpbmluZyBiYWxhbmNlIG9mIHNoYXJlIGFzc2V0IGlzIGJlbG93IGFzc2V0J3MgZXhpc3RlbnRpYWwgZGVwb3NpdC4oTm90QWxsb3dlZAATBMxOb3QgYWxsb3dlZCB0byBwZXJmb3JtIGFuIG9wZXJhdGlvbiBvbiBnaXZlbiBhc3NldC4kUGFzdEJsb2NrABQEjEZ1dHVyZSBibG9jayBudW1iZXIgaXMgaW4gdGhlIHBhc3QuRFNhbWVBbXBsaWZpY2F0aW9uABUExE5ldyBhbXBsaWZpY2F0aW9uIGlzIGVxdWFsIHRvIHRoZSBwcmV2aW91cyB2YWx1ZS40U2xpcHBhZ2VMaW1pdAAWBFBTbGlwcGFnZSBwcm90ZWN0aW9uLjxVbmtub3duRGVjaW1hbHMAFwSIRmFpbGVkIHRvIHJldHJpZXZlIGFzc2V0IGRlY2ltYWxzLlBJbmNvcnJlY3RJbml0aWFsUGVncwAYBIxMaXN0IG9mIHByb3ZpZGVkIHBlZ3MgaXMgaW5jb3JyZWN0LlhNaXNzaW5nVGFyZ2V0UGVnT3JhY2xlABkEgEZhaWxlZCB0byByZXRyaWV2ZSBvcmFjbGUgZW50cnkuWEluY29ycmVjdEFzc2V0RGVjaW1hbHMAGgQlAUNyZWF0aW5nIHBvb2wgd2l0aCBwZWdzIGlzIG5vdCBhbGxvd2VkIGZvciBhc3NldCB3aXRoIGRpZmZlcmVudCBkZWNpbWFscy4sTm9QZWdTb3VyY2UAGwSMUG9vbCBkb2VzIG5vdCBoYXZlIHBlZ3MgY29uZmlndXJlZC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuwQsAAAQIEDAAxQsMMHBhbGxldF9ib25kcxhwYWxsZXQURXJyb3IEBFQAARw0Tm90UmVnaXN0ZXJlZAAABExCb25kIG5vdCByZWdpc3RlcmVkJE5vdE1hdHVyZQABBEhCb25kIGlzIG5vdCBtYXR1cmU8SW52YWxpZE1hdHVyaXR5AAIEYE1hdHVyaXR5IG5vdCBsb25nIGVub3VnaDxEaXNhbGxvd2VkQXNzZXQAAwSsQXNzZXQgdHlwZSBub3QgYWxsb3dlZCBmb3IgdW5kZXJseWluZyBhc3NldDRBc3NldE5vdEZvdW5kAAQEqEFzc2V0IGlzIG5vdCByZWdpc3RlcmVkIGluIGBBc3NldFJlZ2lzdHJ5YDxJbnZhbGlkQm9uZE5hbWUABQRwR2VuZXJhdGVkIG5hbWUgaXMgbm90IHZhbGlkLjxGYWlsVG9QYXJzZU5hbWUABgSYQm9uZCdzIG5hbWUgcGFyc2luZyB3YXMgbm93IHN1Y2Nlc3NmdWwEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuyQsMWHBhbGxldF9vdGNfc2V0dGxlbWVudHMYcGFsbGV0FEVycm9yBARUAAEcNE9yZGVyTm90Rm91bmQAAARMT3RjIG9yZGVyIG5vdCBmb3VuZFBOb3RQYXJ0aWFsbHlGaWxsYWJsZQABBIxPVEMgb3JkZXIgaXMgbm90IHBhcnRpYWxseSBmaWxsYWJsZTBJbnZhbGlkUm91dGUAAgS8UHJvdmlkZWQgcm91dGUgZG9lc24ndCBtYXRjaCB0aGUgZXhpc3Rpbmcgcm91dGVQQmFsYW5jZUluY29uc2lzdGVuY3kAAwScSW5pdGlhbCBhbmQgZmluYWwgYmFsYW5jZSBhcmUgZGlmZmVyZW50SFRyYWRlQW1vdW50VG9vSGlnaAAEBIhUcmFkZSBhbW91bnQgaGlnaGVyIHRoYW4gbmVjZXNzYXJ5RFRyYWRlQW1vdW50VG9vTG93AAUEhFRyYWRlIGFtb3VudCBsb3dlciB0aGFuIG5lY2Vzc2FyeURQcmljZU5vdEF2YWlsYWJsZQAGBIhQcmljZSBmb3IgYSByb3V0ZSBpcyBub3QgYXZhaWxhYmxlBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Ls0LDChwYWxsZXRfbGJwGHBhbGxldBRFcnJvcgQEVAABXHhDYW5ub3RDcmVhdGVQb29sV2l0aFNhbWVBc3NldHMAAAR8UG9vbCBhc3NldHMgY2FuIG5vdCBiZSB0aGUgc2FtZSBOb3RPd25lcgABBGxBY2NvdW50IGlzIG5vdCBhIHBvb2wgb3duZXIsU2FsZVN0YXJ0ZWQAAgRQU2FsZSBhbHJlYWR5IHN0YXJ0ZWQwU2FsZU5vdEVuZGVkAAMEZFNhbGUgaXMgc3RpbGwgaW4gcHJvZ3Jlc3NAU2FsZUlzTm90UnVubmluZwAEBExTYWxlIGlzIG5vdCBydW5uaW5nXE1heFNhbGVEdXJhdGlvbkV4Y2VlZGVkAAUEZFNhbGUgZHVyYXRpb24gaXMgdG9vIGxvbmdYQ2Fubm90QWRkWmVyb0xpcXVpZGl0eQAGBKBMaXF1aWRpdHkgYmVpbmcgYWRkZWQgc2hvdWxkIG5vdCBiZSB6ZXJvYEluc3VmZmljaWVudEFzc2V0QmFsYW5jZQAHBFRBc3NldCBiYWxhbmNlIHRvbyBsb3cwUG9vbE5vdEZvdW5kAAgETFBvb2wgZG9lcyBub3QgZXhpc3REUG9vbEFscmVhZHlFeGlzdHMACQR0UG9vbCBoYXMgYmVlbiBhbHJlYWR5IGNyZWF0ZWRESW52YWxpZEJsb2NrUmFuZ2UACgRMSW52YWxpZCBibG9jayByYW5nZVhXZWlnaHRDYWxjdWxhdGlvbkVycm9yAAsERENhbGN1bGF0aW9uIGVycm9yNEludmFsaWRXZWlnaHQADARoV2VpZ2h0IHNldCBpcyBvdXQgb2YgcmFuZ2UoWmVyb0Ftb3VudAANBKBDYW4gbm90IHBlcmZvcm0gYSB0cmFkZSB3aXRoIHplcm8gYW1vdW50SE1heEluUmF0aW9FeGNlZWRlZAAOBGBUcmFkZSBhbW91bnQgaXMgdG9vIGhpZ2hMTWF4T3V0UmF0aW9FeGNlZWRlZAAPBGBUcmFkZSBhbW91bnQgaXMgdG9vIGhpZ2hARmVlQW1vdW50SW52YWxpZAAQBEhJbnZhbGlkIGZlZSBhbW91bnRMVHJhZGluZ0xpbWl0UmVhY2hlZAARBFRUcmFkaW5nIGxpbWl0IHJlYWNoZWQgT3ZlcmZsb3cAEgScQW4gdW5leHBlY3RlZCBpbnRlZ2VyIG92ZXJmbG93IG9jY3VycmVkPE5vdGhpbmdUb1VwZGF0ZQATBEROb3RoaW5nIHRvIHVwZGF0ZVRJbnN1ZmZpY2llbnRMaXF1aWRpdHkAFAS8TGlxdWlkaXR5IGhhcyBub3QgcmVhY2hlZCB0aGUgcmVxdWlyZWQgbWluaW11bS5kSW5zdWZmaWNpZW50VHJhZGluZ0Ftb3VudAAVBKhBbW91bnQgaXMgbGVzcyB0aGFuIG1pbmltdW0gdHJhZGluZyBsaW1pdC6ARmVlQ29sbGVjdG9yV2l0aEFzc2V0QWxyZWFkeVVzZWQAFgSwTm90IG1vcmUgdGhhbiBvbmUgZmVlIGNvbGxlY3RvciBwZXIgYXNzZXQgaWQEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQu0QsMKHBhbGxldF94eWsYcGFsbGV0FEVycm9yBARUAAFoeENhbm5vdENyZWF0ZVBvb2xXaXRoU2FtZUFzc2V0cwAABNxJdCBpcyBub3QgYWxsb3dlZCB0byBjcmVhdGUgYSBwb29sIGJldHdlZW4gc2FtZSBhc3NldHMuVEluc3VmZmljaWVudExpcXVpZGl0eQABBLxMaXF1aWRpdHkgaGFzIG5vdCByZWFjaGVkIHRoZSByZXF1aXJlZCBtaW5pbXVtLmRJbnN1ZmZpY2llbnRUcmFkaW5nQW1vdW50AAIEmEFtb3VudCBpcyBsZXNzIHRoYW4gbWluIHRyYWRpbmcgbGltaXQuNFplcm9MaXF1aWRpdHkAAwRITGlxdWlkaXR5IGlzIHplcm8uQFplcm9Jbml0aWFsUHJpY2UABAjsSXQgaXMgbm90IGFsbG93ZWQgdG8gY3JlYXRlIGEgcG9vbCB3aXRoIHplcm8gaW5pdGlhbCBwcmljZS6kTm90IHVzZWQsIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlwQ3JlYXRlUG9vbEFzc2V0QW1vdW50SW52YWxpZAAFCCBPdmVyZmxvd6ROb3QgdXNlZCwga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVhJbnZhbGlkTWludGVkTGlxdWlkaXR5AAYEIE92ZXJmbG93WEludmFsaWRMaXF1aWRpdHlBbW91bnQABwQgT3ZlcmZsb3dgQXNzZXRBbW91bnRFeGNlZWRlZExpbWl0AAgEmEFzc2V0IGFtb3VudCBoYXMgZXhjZWVkZWQgZ2l2ZW4gbGltaXQuaEFzc2V0QW1vdW50Tm90UmVhY2hlZExpbWl0AAkEpEFzc2V0IGFtb3VudCBoYXMgbm90IHJlYWNoZWQgZ2l2ZW4gbGltaXQuYEluc3VmZmljaWVudEFzc2V0QmFsYW5jZQAKBIBBc3NldCBiYWxhbmNlIGlzIG5vdCBzdWZmaWNpZW50LnBJbnN1ZmZpY2llbnRQb29sQXNzZXRCYWxhbmNlAAsEnE5vdCBlbm91Z2ggYXNzZXQgbGlxdWlkaXR5IGluIHRoZSBwb29sLoRJbnN1ZmZpY2llbnROYXRpdmVDdXJyZW5jeUJhbGFuY2UADASwTm90IGVub3VnaCBjb3JlIGFzc2V0IGxpcXVpZGl0eSBpbiB0aGUgcG9vbC5EVG9rZW5Qb29sTm90Rm91bmQADQS8TGlxdWlkaXR5IHBvb2wgZm9yIGdpdmVuIGFzc2V0cyBkb2VzIG5vdCBleGlzdC5YVG9rZW5Qb29sQWxyZWFkeUV4aXN0cwAOBLxMaXF1aWRpdHkgcG9vbCBmb3IgZ2l2ZW4gYXNzZXRzIGFscmVhZHkgZXhpc3RzLlRBZGRBc3NldEFtb3VudEludmFsaWQADwQgT3ZlcmZsb3dgUmVtb3ZlQXNzZXRBbW91bnRJbnZhbGlkABAEIE92ZXJmbG93WFNlbGxBc3NldEFtb3VudEludmFsaWQAEQQgT3ZlcmZsb3dUQnV5QXNzZXRBbW91bnRJbnZhbGlkABIEIE92ZXJmbG93QEZlZUFtb3VudEludmFsaWQAEwQgT3ZlcmZsb3dMQ2Fubm90QXBwbHlEaXNjb3VudAAUBCBPdmVyZmxvd0xNYXhPdXRSYXRpb0V4Y2VlZGVkABUEEQFNYXggZnJhY3Rpb24gb2YgcG9vbCB0byBidXkgaW4gc2luZ2xlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLkhNYXhJblJhdGlvRXhjZWVkZWQAFgQVAU1heCBmcmFjdGlvbiBvZiBwb29sIHRvIHNlbGwgaW4gc2luZ2xlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLiBPdmVyZmxvdwAXBCBPdmVyZmxvd0BDYW5ub3RDcmVhdGVQb29sABgEuFBvb2wgY2Fubm90IGJlIGNyZWF0ZWQgZHVlIHRvIG91dHNpZGUgZmFjdG9ycy40U2xpcHBhZ2VMaW1pdAAZBFBTbGlwcGFnZSBwcm90ZWN0aW9uLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC7VCwAABAjlAxgA2QsAAAQIEOUDAN0LAAAEDBAYAADhCwxAcGFsbGV0X3JlZmVycmFscxhwYWxsZXQURXJyb3IEBFQAATgcVG9vTG9uZwAABGhSZWZlcnJhbCBjb2RlIGlzIHRvbyBsb25nLiBUb29TaG9ydAABBGxSZWZlcnJhbCBjb2RlIGlzIHRvbyBzaG9ydC5ASW52YWxpZENoYXJhY3RlcgACBE0BUmVmZXJyYWwgY29kZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3Rlci4gT25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhcmUgYWxsb3dlZC40QWxyZWFkeUV4aXN0cwADBHRSZWZlcnJhbCBjb2RlIGFscmVhZHkgZXhpc3RzLixJbnZhbGlkQ29kZQAEBCEBUHJvdmlkZWQgcmVmZXJyYWwgY29kZSBpcyBpbnZhbGlkLiBFaXRoZXIgZG9lcyBub3QgZXhpc3Qgb3IgaXMgdG9vIGxvbmcuNEFscmVhZHlMaW5rZWQABQTYQWNjb3VudCBpcyBhbHJlYWR5IGxpbmtlZCB0byBhbm90aGVyIHJlZmVycmFsIGFjY291bnQuKFplcm9BbW91bnQABgTITm90aGluZyBpbiB0aGUgcmVmZXJyYWwgcG90IGFjY291bnQgZm9yIHRoZSBhc3NldC44TGlua05vdEFsbG93ZWQABwT8TGlua2luZyBhbiBhY2NvdW50IHRvIHRoZSBzYW1lIHJlZmVycmFsIGFjY291bnQgaXMgbm90IGFsbG93ZWQuaEluY29ycmVjdFJld2FyZENhbGN1bGF0aW9uAAgEkQFDYWxjdWxhdGVkIHJld2FyZHMgYXJlIG1vcmUgdGhhbiB0aGUgZmVlIGFtb3VudC4gVGhpcyBjYW4gaGFwcGVuIGlmIHBlcmNlbnRhZ2VzIGFyZSBpbmNvcnJlY3RseSBzZXQuZEluY29ycmVjdFJld2FyZFBlcmNlbnRhZ2UACQTsR2l2ZW4gcmVmZXJyZXIgYW5kIHRyYWRlciBwZXJjZW50YWdlcyBleGNlZWRzIDEwMCUgcGVyY2VudC5EQWxyZWFkeVJlZ2lzdGVyZWQACgSoVGhlIGFjY291bnQgaGFzIGFscmVhZHkgYSBjb2RlIHJlZ2lzdGVyZWQuNFByaWNlTm90Rm91bmQACwSUUHJpY2UgZm9yIGdpdmVuIGFzc2V0IHBhaXIgbm90IGZvdW5kLpBDb252ZXJzaW9uTWluVHJhZGluZ0Ftb3VudE5vdFJlYWNoZWQADATsTWluaW11bSB0cmFkaW5nIGFtb3VudCBmb3IgY29udmVyc2lvbiBoYXMgbm90IGJlZW4gcmVhY2hlZC5wQ29udmVyc2lvblplcm9BbW91bnRSZWNlaXZlZAANBJRaZXJvIGFtb3VudCByZWNlaXZlZCBmcm9tIGNvbnZlcnNpb24uBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LuULDEhwYWxsZXRfbGlxdWlkYXRpb24YcGFsbGV0FEVycm9yBARUAAEYVEFzc2V0Q29udmVyc2lvbkZhaWxlZAAABKBBc3NldElkIHRvIEVWTSBhZGRyZXNzIGNvbnZlcnNpb24gZmFpbGVkVExpcXVpZGF0aW9uQ2FsbEZhaWxlZAABBFxMaXF1aWRhdGlvbiBjYWxsIGZhaWxlZDBJbnZhbGlkUm91dGUAAgS8UHJvdmlkZWQgcm91dGUgZG9lc24ndCBtYXRjaCB0aGUgZXhpc3Rpbmcgcm91dGU0Tm90UHJvZml0YWJsZQADBORMaXF1aWRhdGlvbiB3YXMgbm90IHByb2ZpdGFibGUgZW5vdWdoIHRvIHJlcGF5IGZsYXNoIGxvYW5ERmxhc2hNaW50ZXJOb3RTZXQABAQ5AUZsYXNoIG1pbnRlciBjb250cmFjdCBhZGRyZXNzIG5vdCBzZXQuIEl0IGlzIHJlcXVpcmVkIGZvciBIb2xsYXIgbGlxdWlkYXRpb25zLlhJbnZhbGlkTGlxdWlkYXRpb25EYXRhAAUEhEludmFsaWQgbGlxdWlkYXRpb24gZGF0YSBwcm92aWRlZASAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC7pCwwocGFsbGV0X2hzbRR0eXBlczhDb2xsYXRlcmFsSW5mbwQcQXNzZXRJZAEQABgBHHBvb2xfaWQQARxBc3NldElkAAEwcHVyY2hhc2VfZmVlIQMBHFBlcm1pbGwAAWRtYXhfYnV5X3ByaWNlX2NvZWZmaWNpZW50PQEBQENvZWZmaWNpZW50UmF0aW8AATBidXliYWNrX3JhdGXBAwEcUGVyYmlsbAABMGJ1eV9iYWNrX2ZlZSEDARxQZXJtaWxsAAE4bWF4X2luX2hvbGRpbmfgATxPcHRpb248QmFsYW5jZT4AAO0LDChwYWxsZXRfaHNtGHBhbGxldBRFcnJvcgQEVAABVEBBc3NldE5vdEFwcHJvdmVkAAAMjEFzc2V0IGlzIG5vdCBhcHByb3ZlZCBhcyBjb2xsYXRlcmFsAGUBVGhlIG9wZXJhdGlvbiBhdHRlbXB0ZWQgdG8gdXNlIGFuIGFzc2V0IHRoYXQgaXMgbm90IHJlZ2lzdGVyZWQgYXMgYW4gYXBwcm92ZWQgY29sbGF0ZXJhbC5QQXNzZXRBbHJlYWR5QXBwcm92ZWQAAQycQXNzZXQgaXMgYWxyZWFkeSBhcHByb3ZlZCBhcyBjb2xsYXRlcmFsABUBQXR0ZW1wdGVkIHRvIGFkZCBhbiBhc3NldCB0aGF0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBhIGNvbGxhdGVyYWwuYFBvb2xBbHJlYWR5SGFzQ29sbGF0ZXJhbAACDNBBbm90aGVyIGFzc2V0IGZyb20gdGhlIHNhbWUgcG9vbCBpcyBhbHJlYWR5IGFwcHJvdmVkAA0BT25seSBvbmUgYXNzZXQgZnJvbSBlYWNoIFN0YWJsZVN3YXAgcG9vbCBjYW4gYmUgdXNlZCBhcyBjb2xsYXRlcmFsLkBJbnZhbGlkQXNzZXRQYWlyAAMM6EludmFsaWQgYXNzZXQgcGFpciwgbXVzdCBiZSBIb2xsYXIgYW5kIGFwcHJvdmVkIGNvbGxhdGVyYWwAvQFUaGUgYXNzZXQgcGFpciBmb3IgYnV5L3NlbGwgb3BlcmF0aW9ucyBtdXN0IGluY2x1ZGUgSG9sbGFyIGFzIG9uZSBzaWRlIGFuZCBhbiBhcHByb3ZlZCBjb2xsYXRlcmFsIGFzIHRoZSBvdGhlci5MTWF4QnV5UHJpY2VFeGNlZWRlZAAEDFhNYXggYnV5IHByaWNlIGV4Y2VlZGVkAEkBVGhlIGNhbGN1bGF0ZWQgYnV5IHByaWNlIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBidXkgcHJpY2UgZm9yIHRoZSBjb2xsYXRlcmFsLkhNYXhCdXlCYWNrRXhjZWVkZWQABQywTWF4IGJ1eSBiYWNrIGFtb3VudCBpbiBzaW5nbGUgYmxvY2sgZXhjZWVkZWQApQFUaGUgYW1vdW50IG9mIEhvbGxhciBiZWluZyBzb2xkIHRvIEhTTSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgaW4gYSBzaW5nbGUgYmxvY2sgZm9yIHRoaXMgY29sbGF0ZXJhbC5ITWF4SG9sZGluZ0V4Y2VlZGVkAAYMqE1heCBob2xkaW5nIGFtb3VudCBmb3IgY29sbGF0ZXJhbCBleGNlZWRlZAB1AVRoZSBvcGVyYXRpb24gd291bGQgY2F1c2UgdGhlIEhTTSB0byBob2xkIG1vcmUgb2YgdGhlIGNvbGxhdGVyYWwgdGhhbiB0aGUgY29uZmlndXJlZCBtYXhpbXVtLlRTbGlwcGFnZUxpbWl0RXhjZWVkZWQABwxcU2xpcHBhZ2UgbGltaXQgZXhjZWVkZWQAAQFUaGUgY2FsY3VsYXRlZCBhbW91bnQgaXMgd29yc2UgdGhhbiB0aGUgcHJvdmlkZWQgc2xpcHBhZ2UgbGltaXQuVEludmFsaWRFVk1JbnRlcmFjdGlvbgAIDIBJbnZhbGlkIEVWTSBjb250cmFjdCBpbnRlcmFjdGlvbgDcVGhlIGNhbGwgdG8gdGhlIEVWTSBjb250cmFjdCAoR0hPIEhvbGxhciB0b2tlbikgZmFpbGVkLlhEZWNpbWFsUmV0cmlldmFsRmFpbGVkAAkMYERlY2ltYWwgcmV0cmlldmFsIGZhaWxlZADgRmFpbGVkIHRvIHJldHJpZXZlIHRoZSBkZWNpbWFsIGluZm9ybWF0aW9uIGZvciBhbiBhc3NldC5YTm9BcmJpdHJhZ2VPcHBvcnR1bml0eQAKDGBObyBhcmJpdHJhZ2Ugb3Bwb3J0dW5pdHkAKQFUaGVyZSBpcyBubyBwcm9maXRhYmxlIGFyYml0cmFnZSBvcHBvcnR1bml0eSBmb3IgdGhlIHNwZWNpZmllZCBjb2xsYXRlcmFsLjRBc3NldE5vdEZvdW5kAAsMVEFzc2V0IG5vdCBpbiB0aGUgcG9vbAC4VGhlIHNwZWNpZmllZCBhc3NldCB3YXMgbm90IGZvdW5kIGluIHRoZSBwb29sLkBJbnZhbGlkUG9vbFN0YXRlAAwMeFByb3ZpZGVkIHBvb2wgc3RhdGUgaXMgaW52YWxpZADoVGhlIHJldHJpZXZlZCBwb29sIHN0YXRlIGhhcyBpbmNvbnNpc3RlbnQgb3IgaW52YWxpZCBkYXRhLkhDb2xsYXRlcmFsTm90RW1wdHkADQxcQ29sbGF0ZXJhbCBpcyBub3QgZW1wdHkAWQFDYW5ub3QgcmVtb3ZlIGEgY29sbGF0ZXJhbCBhc3NldCB0aGF0IHN0aWxsIGhhcyBhIG5vbi16ZXJvIGJhbGFuY2UgaW4gdGhlIEhTTSBhY2NvdW50LjhBc3NldE5vdEluUG9vbAAODFRBc3NldCBub3QgaW4gdGhlIHBvb2wA6FRoZSBjb2xsYXRlcmFsIGFzc2V0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzcGVjaWZpZWQgcG9vbC48SG9sbGFyTm90SW5Qb29sAA8MZEhvbGxhciBpcyBub3QgaW4gdGhlIHBvb2wA2FRoZSBIb2xsYXIgYXNzZXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHNwZWNpZmllZCBwb29sLnRJbnN1ZmZpY2llbnRDb2xsYXRlcmFsQmFsYW5jZQAQDHxJbnN1ZmZpY2llbnQgY29sbGF0ZXJhbCBiYWxhbmNlAD0BVGhlIEhTTSBkb2VzIG5vdCBoYXZlIGVub3VnaCBvZiB0aGUgY29sbGF0ZXJhbCBhc3NldCB0byBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uLnRIb2xsYXJDb250cmFjdEFkZHJlc3NOb3RGb3VuZAARDHhHSE8gQ29udHJhY3QgYWRkcmVzcyBub3QgZm91bmQACQFUaGUgRVZNIGFkZHJlc3MgZm9yIHRoZSBHSE8gKEhvbGxhcikgdG9rZW4gY29udHJhY3Qgd2FzIG5vdCBmb3VuZC50TWF4TnVtYmVyT2ZDb2xsYXRlcmFsc1JlYWNoZWQAEgTkSFNNIGNvbnRhaW5zIG1heGltdW0gbnVtYmVyIG9mIGFsbG93ZWQgY29sbGF0ZXJhbCBhc3NldHMuREZsYXNoTWludGVyTm90U2V0ABMEcEZsYXNoIG1pbnRlciBhZGRyZXNzIG5vdCBzZXRQSW52YWxpZEFyYml0cmFnZURhdGEAFASIUHJvdmlkZWQgYXJiaXRyYWdlIGRhdGEgaXMgaW52YWxpZASAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC7xCwxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAfULBFMAAAQA+QsBGFZlYzxUPgAA9QsILG9ybWxfdG9rZW5zLEJhbGFuY2VMb2NrBBxCYWxhbmNlARgACAEIaWT9AQE4TG9ja0lkZW50aWZpZXIAARhhbW91bnQYARxCYWxhbmNlAAD5CwAAAvULAP0LCCxvcm1sX3Rva2VucyxBY2NvdW50RGF0YQQcQmFsYW5jZQEYAAwBEGZyZWUYARxCYWxhbmNlAAEgcmVzZXJ2ZWQYARxCYWxhbmNlAAEYZnJvemVuGAEcQmFsYW5jZQAAAQwMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAEFDARTAAAEAAkMARhWZWM8VD4AAAUMCCxvcm1sX3Rva2VucyxSZXNlcnZlRGF0YQhEUmVzZXJ2ZUlkZW50aWZpZXIB/QEcQmFsYW5jZQEYAAgBCGlk/QEBRFJlc2VydmVJZGVudGlmaWVyAAEYYW1vdW50GAEcQmFsYW5jZQAACQwAAAIFDAANDAwsb3JtbF90b2tlbnMYbW9kdWxlFEVycm9yBARUAAEgNEJhbGFuY2VUb29Mb3cAAARYVGhlIGJhbGFuY2UgaXMgdG9vIGxvd1xBbW91bnRJbnRvQmFsYW5jZUZhaWxlZAABBJxDYW5ub3QgY29udmVydCBBbW91bnQgaW50byBCYWxhbmNlIHR5cGVUTGlxdWlkaXR5UmVzdHJpY3Rpb25zAAIE0EZhaWxlZCBiZWNhdXNlIGxpcXVpZGl0eSByZXN0cmljdGlvbnMgZHVlIHRvIGxvY2tpbmdATWF4TG9ja3NFeGNlZWRlZAADBLRGYWlsZWQgYmVjYXVzZSB0aGUgbWF4aW11bSBsb2NrcyB3YXMgZXhjZWVkZWQkS2VlcEFsaXZlAAQEjFRyYW5zZmVyL3BheW1lbnQgd291bGQga2lsbCBhY2NvdW50SEV4aXN0ZW50aWFsRGVwb3NpdAAFBOhWYWx1ZSB0b28gbG93IHRvIGNyZWF0ZSBhY2NvdW50IGR1ZSB0byBleGlzdGVudGlhbCBkZXBvc2l0LERlYWRBY2NvdW50AAYEiEJlbmVmaWNpYXJ5IGFjY291bnQgbXVzdCBwcmUtZXhpc3Q8VG9vTWFueVJlc2VydmVzAAcABIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LhEMDERwYWxsZXRfY3VycmVuY2llcxhtb2R1bGUURXJyb3IEBFQAARBcQW1vdW50SW50b0JhbGFuY2VGYWlsZWQAAAS8VW5hYmxlIHRvIGNvbnZlcnQgdGhlIEFtb3VudCB0eXBlIGludG8gQmFsYW5jZS40QmFsYW5jZVRvb0xvdwABBExCYWxhbmNlIGlzIHRvbyBsb3cuNERlcG9zaXRGYWlsZWQAAgR4RGVwb3NpdCByZXN1bHQgaXMgbm90IGV4cGVjdGVkME5vdFN1cHBvcnRlZAADBLBPcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjdXJyZW5jeQSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC4VDAxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAR0EBFMAAAQAIQQBGFZlYzxUPgAAGQwMMG9ybWxfdmVzdGluZxhtb2R1bGUURXJyb3IEBFQAARhEWmVyb1Zlc3RpbmdQZXJpb2QAAARYVmVzdGluZyBwZXJpb2QgaXMgemVyb1haZXJvVmVzdGluZ1BlcmlvZENvdW50AAEEXE51bWJlciBvZiB2ZXN0cyBpcyB6ZXJvZEluc3VmZmljaWVudEJhbGFuY2VUb0xvY2sAAgSYSW5zdWZmaWNpZW50IGFtb3VudCBvZiBiYWxhbmNlIHRvIGxvY2tcVG9vTWFueVZlc3RpbmdTY2hlZHVsZXMAAwSwVGhpcyBhY2NvdW50IGhhdmUgdG9vIG1hbnkgdmVzdGluZyBzY2hlZHVsZXMkQW1vdW50TG93AAQElFRoZSB2ZXN0ZWQgdHJhbnNmZXIgYW1vdW50IGlzIHRvbyBsb3dsTWF4VmVzdGluZ1NjaGVkdWxlc0V4Y2VlZGVkAAUE5EZhaWxlZCBiZWNhdXNlIHRoZSBtYXhpbXVtIHZlc3Rpbmcgc2NoZWR1bGVzIHdhcyBleGNlZWRlZASAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC4dDAgocGFsbGV0X2V2bTBDb2RlTWV0YWRhdGEAAAgBEHNpemUwAQx1NjQAARBoYXNoNAEQSDI1NgAAIQwAAAQIQQE0ACUMDChwYWxsZXRfZXZtGHBhbGxldBRFcnJvcgQEVAABNChCYWxhbmNlTG93AAAEkE5vdCBlbm91Z2ggYmFsYW5jZSB0byBwZXJmb3JtIGFjdGlvbixGZWVPdmVyZmxvdwABBIBDYWxjdWxhdGluZyB0b3RhbCBmZWUgb3ZlcmZsb3dlZDxQYXltZW50T3ZlcmZsb3cAAgSQQ2FsY3VsYXRpbmcgdG90YWwgcGF5bWVudCBvdmVyZmxvd2VkOFdpdGhkcmF3RmFpbGVkAAMETFdpdGhkcmF3IGZlZSBmYWlsZWQ4R2FzUHJpY2VUb29Mb3cABARUR2FzIHByaWNlIGlzIHRvbyBsb3cuMEludmFsaWROb25jZQAFBEBOb25jZSBpcyBpbnZhbGlkOEdhc0xpbWl0VG9vTG93AAYEVEdhcyBsaW1pdCBpcyB0b28gbG93LjxHYXNMaW1pdFRvb0hpZ2gABwRYR2FzIGxpbWl0IGlzIHRvbyBoaWdoLjhJbnZhbGlkQ2hhaW5JZAAIBGBUaGUgY2hhaW4gaWQgaXMgaW52YWxpZC5ASW52YWxpZFNpZ25hdHVyZQAJBGR0aGUgc2lnbmF0dXJlIGlzIGludmFsaWQuKFJlZW50cmFuY3kACgQ4RVZNIHJlZW50cmFuY3loVHJhbnNhY3Rpb25NdXN0Q29tZUZyb21FT0EACwQkRUlQLTM2MDcsJFVuZGVmaW5lZAAMBEBVbmRlZmluZWQgZXJyb3IuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LikMAAAEDDkELQxBDAAtDAgYZnBfcnBjRFRyYW5zYWN0aW9uU3RhdHVzAAAcAUB0cmFuc2FjdGlvbl9oYXNoNAEQSDI1NgABRHRyYW5zYWN0aW9uX2luZGV4EAEMdTMyAAEQZnJvbUEBARxBZGRyZXNzAAEIdG8xDAE8T3B0aW9uPEFkZHJlc3M+AAFAY29udHJhY3RfYWRkcmVzczEMATxPcHRpb248QWRkcmVzcz4AARBsb2dzNQwBIFZlYzxMb2c+AAEobG9nc19ibG9vbTkMARRCbG9vbQAAMQwEGE9wdGlvbgQEVAFBAQEIEE5vbmUAAAAQU29tZQQAQQEAAAEAADUMAAAC7QcAOQwIIGV0aGJsb29tFEJsb29tAAAEAD0MAUBbdTg7IEJMT09NX1NJWkVdAAA9DAAAAwABAAAIAEEMDCBldGhlcmV1bRxyZWNlaXB0JFJlY2VpcHRWMwABDBhMZWdhY3kEAEUMAURFSVA2NThSZWNlaXB0RGF0YQAAABxFSVAyOTMwBABFDAFIRUlQMjkzMFJlY2VpcHREYXRhAAEAHEVJUDE1NTkEAEUMAUhFSVAxNTU5UmVjZWlwdERhdGEAAgAARQwMIGV0aGVyZXVtHHJlY2VpcHRERUlQNjU4UmVjZWlwdERhdGEAABABLHN0YXR1c19jb2RlCAEIdTgAASB1c2VkX2dhc0kBARBVMjU2AAEobG9nc19ibG9vbTkMARRCbG9vbQABEGxvZ3M1DAEgVmVjPExvZz4AAEkMDCBldGhlcmV1bRRibG9jaxRCbG9jawQEVAE5BAAMARhoZWFkZXJNDAEYSGVhZGVyAAEwdHJhbnNhY3Rpb25zVQwBGFZlYzxUPgABGG9tbWVyc1kMASxWZWM8SGVhZGVyPgAATQwMIGV0aGVyZXVtGGhlYWRlchhIZWFkZXIAADwBLHBhcmVudF9oYXNoNAEQSDI1NgABLG9tbWVyc19oYXNoNAEQSDI1NgABLGJlbmVmaWNpYXJ5QQEBEEgxNjAAAShzdGF0ZV9yb290NAEQSDI1NgABRHRyYW5zYWN0aW9uc19yb290NAEQSDI1NgABNHJlY2VpcHRzX3Jvb3Q0ARBIMjU2AAEobG9nc19ibG9vbTkMARRCbG9vbQABKGRpZmZpY3VsdHlJAQEQVTI1NgABGG51bWJlckkBARBVMjU2AAEkZ2FzX2xpbWl0SQEBEFUyNTYAASBnYXNfdXNlZEkBARBVMjU2AAEkdGltZXN0YW1wMAEMdTY0AAEoZXh0cmFfZGF0YTgBFEJ5dGVzAAEgbWl4X2hhc2g0ARBIMjU2AAEUbm9uY2VRDAEMSDY0AABRDAw4ZXRoZXJldW1fdHlwZXMQaGFzaAxINjQAAAQA/QEBHFt1ODsgOF0AAFUMAAACOQQAWQwAAAJNDABdDAAAAkEMAGEMAAACLQwAZQwMPHBhbGxldF9ldGhlcmV1bRhwYWxsZXQURXJyb3IEBFQAAQhASW52YWxpZFNpZ25hdHVyZQAABFRTaWduYXR1cmUgaXMgaW52YWxpZC4wUHJlTG9nRXhpc3RzAAEE2FByZS1sb2cgaXMgcHJlc2VudCwgdGhlcmVmb3JlIHRyYW5zYWN0IGlzIG5vdCBhbGxvd2VkLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5pDAxMcGFsbGV0X2V2bV9hY2NvdW50cxhwYWxsZXQURXJyb3IEBFQAARBsVHJ1bmNhdGVkQWNjb3VudEFscmVhZHlVc2VkAAAEiEFjdGl2ZSBFVk0gYWNjb3VudCBjYW5ub3QgYmUgYm91bmRMQWRkcmVzc0FscmVhZHlCb3VuZAABBGBBZGRyZXNzIGlzIGFscmVhZHkgYm91bmRgQm91bmRBZGRyZXNzQ2Fubm90QmVVc2VkAAIEcEJvdW5kIGFkZHJlc3MgY2Fubm90IGJlIHVzZWRUQWRkcmVzc05vdFdoaXRlbGlzdGVkAAMEXEFkZHJlc3Mgbm90IHdoaXRlbGlzdGVkBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Lm0MDGxwYWxsZXRfeHlrX2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0FEVycm9yBARUAAE0UENhbnRGaW5kRGVwb3NpdE93bmVyAAAEiE5mdCBwYWxsZXQgZGlkbid0IHJldHVybiBhbiBvd25lci5wSW5zdWZmaWNpZW50WHlrU2hhcmVzQmFsYW5jZQABBNRBY2NvdW50IGJhbGFuY2Ugb2YgWFlLIHBvb2wgc2hhcmVzIGlzIG5vdCBzdWZmaWNpZW50LkhYeWtQb29sRG9lc250RXhpc3QAAgRcWFlLIHBvb2wgZG9lcyBub3QgZXhpc3Q8Tm90RGVwb3NpdE93bmVyAAMEdEFjY291bnQgaXMgbm90IGRlcG9zaXQgb3duZXIuQENhbnRHZXRYeWtBc3NldHMABASsWFlLIGRpZCBub3QgcmV0dXJuIGFzc2V0cyBmb3IgZ2l2ZW4gcG9vbCBpZExEZXBvc2l0RGF0YU5vdEZvdW5kAAUEWERlcG9zaXQgZGF0YSBub3QgZm91bmRIWmVyb0NsYWltZWRSZXdhcmRzAAYEgENhbGN1bGF0ZWQgcmV3YXJkIHRvIGNsYWltIGlzIDAuTEFzc2V0Tm90SW5Bc3NldFBhaXIABwSAQXNzZXQgaXMgbm90IGluIHRoZSBgQXNzZXRQYWlyYC5ASW52YWxpZEFzc2V0UGFpcgAIBMBQcm92aWRlZCBgQXNzZXRQYWlyYCBpcyBub3QgdXNlZCBieSB0aGUgZGVwb3NpdC5IQXNzZXROb3RSZWdpc3RlcmVkAAkEqEFzc2V0IGlzIG5vdCByZWdpc3RlcmVkIGluIGFzc2V0IHJlZ2lzdHJ5LjhGYWlsVG9HZXRQb3RJZAAKBJBGYWlsZWQgdG8gY2FsY3VsYXRlIGBwb3RgJ3MgYWNjb3VudC5ATm9GYXJtc1NwZWNpZmllZAALBMxObyBnbG9iYWwgZmFybSAtIHlpZWxkIGZhcm0gcGFpcnMgc3BlY2lmaWVkIHRvIGpvaW5MRmFpbGVkVG9WYWx1ZVNoYXJlcwAMBJxGYWlsZWQgdG8gY2FsY3VsYXRlIHZhbHVlIG9mIHh5ayBzaGFyZXMEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQucQwMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nFHR5cGVzOEdsb2JhbEZhcm1EYXRhCARUAARJAABIAQhpZBABMEdsb2JhbEZhcm1JZAABFG93bmVyAAEwVDo6QWNjb3VudElkAAEodXBkYXRlZF9hdBABLFBlcmlvZE9mPFQ+AAE4dG90YWxfc2hhcmVzX3oYARxCYWxhbmNlAAE8YWNjdW11bGF0ZWRfcnB6PQEBJEZpeGVkVTEyOAABPHJld2FyZF9jdXJyZW5jeRABKFQ6OkFzc2V0SWQAATxwZW5kaW5nX3Jld2FyZHMYARxCYWxhbmNlAAFgYWNjdW11bGF0ZWRfcGFpZF9yZXdhcmRzGAEcQmFsYW5jZQABQHlpZWxkX3Blcl9wZXJpb2Q9AwEsUGVycXVpbnRpbGwAAWBwbGFubmVkX3lpZWxkaW5nX3BlcmlvZHMQASxQZXJpb2RPZjxUPgABRGJsb2Nrc19wZXJfcGVyaW9kEAFEQmxvY2tOdW1iZXJGb3I8VD4AAUhpbmNlbnRpdml6ZWRfYXNzZXQQAShUOjpBc3NldElkAAFUbWF4X3Jld2FyZF9wZXJfcGVyaW9kGAEcQmFsYW5jZQABLG1pbl9kZXBvc2l0GAEcQmFsYW5jZQABWGxpdmVfeWllbGRfZmFybXNfY291bnQQAQx1MzIAAVx0b3RhbF95aWVsZF9mYXJtc19jb3VudBABDHUzMgABQHByaWNlX2FkanVzdG1lbnQ9AQEkRml4ZWRVMTI4AAEUc3RhdGUtCwEkRmFybVN0YXRlAAB1DAAABAwAEBAAeQwMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nFHR5cGVzNFlpZWxkRmFybURhdGEIBFQABEkAADABCGlkEAEYRmFybUlkAAEodXBkYXRlZF9hdBABLFBlcmlvZE9mPFQ+AAEwdG90YWxfc2hhcmVzGAEcQmFsYW5jZQABTHRvdGFsX3ZhbHVlZF9zaGFyZXMYARxCYWxhbmNlAAFAYWNjdW11bGF0ZWRfcnB2cz0BASRGaXhlZFUxMjgAATxhY2N1bXVsYXRlZF9ycHo9AQEkRml4ZWRVMTI4AAE0bG95YWx0eV9jdXJ2ZUEDAVBPcHRpb248TG95YWx0eUN1cnZlPgABKG11bHRpcGxpZXI9AQE4RmFybU11bHRpcGxpZXIAARRzdGF0ZS0LASRGYXJtU3RhdGUAATRlbnRyaWVzX2NvdW50MAEMdTY0AAFIbGVmdF90b19kaXN0cmlidXRlGAEcQmFsYW5jZQABNHRvdGFsX3N0b3BwZWQQASxQZXJpb2RPZjxUPgAAfQwMXHBhbGxldF9saXF1aWRpdHlfbWluaW5nFHR5cGVzLERlcG9zaXREYXRhCARUAARJAAAMARhzaGFyZXMYARxCYWxhbmNlAAEsYW1tX3Bvb2xfaWQAATBUOjpBbW1Qb29sSWQAAUh5aWVsZF9mYXJtX2VudHJpZXOBDAH0Qm91bmRlZFZlYzxZaWVsZEZhcm1FbnRyeTxULCBJPiwgVDo6TWF4RmFybUVudHJpZXNQZXJEZXBvc2l0PgAAgQwMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAGFDARTAAAEAIkMARhWZWM8VD4AAIUMDFxwYWxsZXRfbGlxdWlkaXR5X21pbmluZxR0eXBlczhZaWVsZEZhcm1FbnRyeQgEVAAESQAAIAE4Z2xvYmFsX2Zhcm1faWQQATBHbG9iYWxGYXJtSWQAATR5aWVsZF9mYXJtX2lkEAEsWWllbGRGYXJtSWQAATR2YWx1ZWRfc2hhcmVzGAEcQmFsYW5jZQABQGFjY3VtdWxhdGVkX3JwdnM9AQEkRml4ZWRVMTI4AAFsYWNjdW11bGF0ZWRfY2xhaW1lZF9yZXdhcmRzGAEcQmFsYW5jZQABKGVudGVyZWRfYXQQASxQZXJpb2RPZjxUPgABKHVwZGF0ZWRfYXQQASxQZXJpb2RPZjxUPgABTHN0b3BwZWRfYXRfY3JlYXRpb24QASxQZXJpb2RPZjxUPgAAiQwAAAKFDACNDAxccGFsbGV0X2xpcXVpZGl0eV9taW5pbmcYcGFsbGV0FEVycm9yCARUAARJAAF0SEdsb2JhbEZhcm1Ob3RGb3VuZAAABGxHbG9iYWwgZmFybSBkb2VzIG5vdCBleGlzdC5EWWllbGRGYXJtTm90Rm91bmQAAQRoWWllbGQgZmFybSBkb2VzIG5vdCBleGlzdC5MRG91YmxlQ2xhaW1JblBlcmlvZAACBMhNdWx0aXBsZSBjbGFpbXMgaW4gdGhlIHNhbWUgcGVyaW9kIGlzIG5vdCBhbGxvd2VkLlxMaXF1aWRpdHlNaW5pbmdDYW5jZWxlZAADBHRMaXF1aWRpdHkgbWluaW5nIGlzIGNhbmNlbGVkLlxMaXF1aWRpdHlNaW5pbmdJc0FjdGl2ZQAEBIRMaXF1aWRpdHkgbWluaW5nIGlzIG5vdCBjYW5jZWxlZC5sTGlxdWlkaXR5TWluaW5nSXNOb3RTdG9wcGVkAAUEVQFMaXF1aWRpdHkgbWluaW5nIGlzIGluIGBhY3RpdmVgIG9yIGB0ZXJtaW5hdGVkYCBzdGF0ZSBhbmQgYWN0aW9uIGNhbm5vdCBiZSBjb21wbGV0ZWQuJEZvcmJpZGRlbgAGBKRBY2NvdW50IGlzIG5vdCBhbGxvd2VkIHRvIHBlcmZvcm0gYWN0aW9uLkRJbnZhbGlkTXVsdGlwbGllcgAHBIRZaWVsZCBmYXJtIG11bHRpcGxpZXIgY2FuJ3QgYmUgMC5YWWllbGRGYXJtQWxyZWFkeUV4aXN0cwAIBAkBWWllbGQgZmFybSB3aXRoIGdpdmVuIGBhbW1fcG9vbF9pZGAgYWxyZWFkeSBleGlzdHMgaW4gZ2xvYmFsIGZhcm0ueEludmFsaWRJbml0aWFsUmV3YXJkUGVyY2VudGFnZQAJBD0BTG95YWx0eSBjdXJ2ZSdzIGluaXRpYWwgcmV3YXJkIHBlcmNlbnRhZ2UgaXMgbm90IHZhbGlkLiBWYWxpZCByYW5nZSBpczogWzAsIDEpLlBHbG9iYWxGYXJtSXNOb3RFbXB0eQAKBLRPbmUgb3IgbW9yZSB5aWVsZCBmYXJtcyBleGlzdCBpbiBnbG9iYWwgZmFybS5gTWlzc2luZ0luY2VudGl2aXplZEFzc2V0AAsE+EZhcm0ncyBgaW5jZW50aXZpemVkX2Fzc2V0YCBpcyBtaXNzaW5nIGluIHByb3ZpZGVkIGFzc2V0IHBhaXIuhEluc3VmZmljaWVudFJld2FyZEN1cnJlbmN5QmFsYW5jZQAMBKhSZXdhcmQgY3VycmVuY3kgYmFsYW5jZSBpcyBub3Qgc3VmZmljaWVudC5YSW52YWxpZEJsb2Nrc1BlclBlcmlvZAANBHRCbG9ja3MgcGVyIHBlcmlvZCBjYW4ndCBiZSAwLlRJbnZhbGlkWWllbGRQZXJQZXJpb2QADgRwWWllbGQgcGVyIHBlcmlvZCBjYW4ndCBiZSAwLkxJbnZhbGlkVG90YWxSZXdhcmRzAA8ExFRvdGFsIHJld2FyZHMgaXMgbGVzcyB0aGFuIGBNaW5Ub3RhbEZhcm1SZXdhcmRzYC50SW52YWxpZFBsYW5uZWRZaWVsZGluZ1BlcmlvZHMAEAQJAVBsYW5uZWQgeWllbGRpbmcgcGVyaW9kcyBpcyBsZXNzIHRoYW4gYE1pblBsYW5uZWRZaWVsZGluZ1BlcmlvZHNgLlBNYXhFbnRyaWVzUGVyRGVwb3NpdAARBLBNYXhpbXVtIG51bWJlciBvZiBsb2NrcyByZWFjaGVkIGZvciBkZXBvc2l0LihEb3VibGVMb2NrABIE4FRyeWluZyB0byBsb2NrIExQIHNoYXJlcyBpbnRvIGFscmVhZHkgbG9ja2VkIHlpZWxkIGZhcm0uWFlpZWxkRmFybUVudHJ5Tm90Rm91bmQAEwTEWWllbGQgZmFybSBlbnRyeSBkb2Vzbid0IGV4aXN0IGZvciBnaXZlbiBkZXBvc2l0LkBHbG9iYWxGYXJtSXNGdWxsABQISQFNYXggbnVtYmVyIG9mIHlpZWxkIGZhcm1zIGluIGdsb2JhbCBmYXJtIHdhcyByZWFjaGVkLiBHbG9iYWwgZmFybSBjYW4ndCBhY2NlcHQgbmV3+HlpZWxkIGZhcm1zIHVudGlsIHNvbWUgeWllbGQgZmFybSBpcyBub3QgcmVtb3ZlZCBmcm9tIHN0b3JhZ2UuREludmFsaWRNaW5EZXBvc2l0ABUEtEludmFsaWQgbWluLiBkZXBvc2l0IHdhcyBzZXQgZm9yIGdsb2JhbCBmYXJtLlhJbnZhbGlkUHJpY2VBZGp1c3RtZW50ABYEnFByaWNlIGFkanVzdG1lbnQgbXVsdGlwbGllciBjYW4ndCBiZSAwLkRFcnJvckdldEFjY291bnRJZAAXBIBBY2NvdW50IGNyZWF0aW9uIGZyb20gaWQgZmFpbGVkLlRJbmNvcnJlY3RWYWx1ZWRTaGFyZXMAGAQlAVZhbHVlIG9mIGRlcG9zaXRlZCBzaGFyZXMgYW1vdW50IGluIHJld2FyZCBjdXJyZW5jeSBpcyBiZWxsb3cgbWluLiBsaW1pdC5sUmV3YXJkQ3VycmVuY3lOb3RSZWdpc3RlcmVkABkE2GByZXdhcmRfY3VycmVuY3lgIGlzIG5vdCByZWdpc3RlcmVkIGluIGFzc2V0IHJlZ2lzdHJ5LnhJbmNlbnRpdml6ZWRBc3NldE5vdFJlZ2lzdGVyZWQAGgTkYGluY2VudGl2aXplZF9hc3NldGAgaXMgbm90IHJlZ2lzdGVyZWQgaW4gYXNzZXQgcmVnaXN0cnkuREFtbVBvb2xJZE1pc21hdGNoABsE9FByb3ZpZGVkIGBhbW1fcG9vbF9pZGAgZG9lc24ndCBtYXRjaCBkZXBvc2l0J3MgYGFtbV9wb29sX2lkYC5ESW5jb25zaXN0ZW50U3RhdGUEAE0LAVhJbmNvbnNpc3RlbnRTdGF0ZUVycm9yABwIZQFBY3Rpb24gY2Fubm90IGJlIGNvbXBsZXRlZCBiZWNhdXNlIHVuZXhwZWN0ZWQgZXJyb3IgaGFzIG9jY3VycmVkLiBUaGlzIHNob3VsZCBiZSByZXBvcnRlZGB0byBwcm90b2NvbCBtYWludGFpbmVycy4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQukQwMWHBhbGxldF9yZWxheWNoYWluX2luZm8YcGFsbGV0FEVycm9yBARUAAEABIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LpUMDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBEARTAAAEAFkDARhWZWM8VD4AAJkMDDRzcF9hcml0aG1ldGljKHBlcl90aGluZ3McUGVyY2VudAAABAAIAQh1OAAAnQwMKHBhbGxldF9kY2EYcGFsbGV0FEVycm9yBARUAAFQQFNjaGVkdWxlTm90Rm91bmQAAARIU2NoZWR1bGUgbm90IGV4aXN0YE1pblRyYWRlQW1vdW50Tm90UmVhY2hlZAABBIxUaGUgbWluIHRyYWRlIGFtb3VudCBpcyBub3QgcmVhY2hlZCRGb3JiaWRkZW4AAgTYRm9yYmlkZGVuIGFzIHRoZSB1c2VyIGlzIG5vdCB0aGUgb3duZXIgb2YgdGhlIHNjaGVkdWxlYEJsb2NrTnVtYmVySXNOb3RJbkZ1dHVyZQADBNBUaGUgbmV4dCBleGVjdXRpb24gYmxvY2sgbnVtYmVyIGlzIG5vdCBpbiB0aGUgZnV0dXJlNFByaWNlVW5zdGFibGUABAQ1AVByaWNlIGlzIHVuc3RhYmxlIGFzIHByaWNlIGNoYW5nZSBmcm9tIG9yYWNsZSBkYXRhIGlzIGJpZ2dlciB0aGFuIG1heCBhbGxvd2VkGEJ1bXBlZAAFBLBPcmRlciB3YXMgcmFuZG9tbHkgcmVzY2hlZHVsZWQgdG8gbmV4dCBibG9ja1RDYWxjdWxhdGluZ1ByaWNlRXJyb3IABgSURXJyb3Igb2NjdXJyZWQgd2hlbiBjYWxjdWxhdGluZyBwcmljZYRUb3RhbEFtb3VudElzU21hbGxlclRoYW5NaW5CdWRnZXQABwToVGhlIHRvdGFsIGFtb3VudCB0byBiZSByZXNlcnZlZCBpcyBzbWFsbGVyIHRoYW4gbWluIGJ1ZGdldDBCdWRnZXRUb29Mb3cACATcVGhlIGJ1ZGdldCBpcyB0b28gbG93IGZvciBleGVjdXRpbmcgYXQgbGVhc3QgdHdvIG9yZGVyc0BOb0ZyZWVCbG9ja0ZvdW5kAAkEyFRoZXJlIGlzIG5vIGZyZWUgYmxvY2sgZm91bmQgdG8gcGxhbiBEQ0EgZXhlY3V0aW9uSE1hbnVhbGx5VGVybWluYXRlZAAKBLRUaGUgRENBIHNjaGVkdWxlIGhhcyBiZWVuIG1hbnVhbGx5IHRlcm1pbmF0ZWQ8TWF4UmV0cnlSZWFjaGVkAAsEqE1heCBudW1iZXIgb2YgcmV0cmllcyByZWFjaGVkIGZvciBzY2hlZHVsZURUcmFkZUxpbWl0UmVhY2hlZAAMBMBBYnNvbHV0ZWx5IHRyYWRlIGxpbWl0IHJlYWNoZWQsIGxlYWRpbmcgdG8gcmV0cnlQU2xpcHBhZ2VMaW1pdFJlYWNoZWQADQQJAVNsaXBwYWdlIGxpbWl0IGNhbGN1bGF0ZWQgZnJvbSBvcmFjbGUgaXMgcmVhY2hlZCwgbGVhZGluZyB0byByZXRyeUROb1BhcmVudEhhc2hGb3VuZAAOBLhObyBwYXJlbnQgaGFzaCBoYXMgYmVlbiBmb3VuZCBmcm9tIHJlbGF5IGNoYWluMEludmFsaWRTdGF0ZQAPBIUBRXJyb3IgdGhhdCBzaG91bGQgbm90IHJlYWxseSBoYXBwZW4gb25seSBpbiBjYXNlIG9mIGludmFsaWQgc3RhdGUgb2YgdGhlIHNjaGVkdWxlIHN0b3JhZ2UgZW50cmllczhQZXJpb2RUb29TaG9ydAAQBJRQZXJpb2Qgc2hvdWxkIGJlIGxvbmdlciB0aGFuIDUgYmxvY2tzZFN0YWJpbGl0eVRocmVzaG9sZFRvb0hpZ2gAEQRZAVN0YWJpbGl0eSB0aHJlc2hvbGQgY2Fubm90IGJlIGhpZ2hlciB0aGFuIGBNYXhDb25maWd1cmFibGVQcmljZURpZmZlcmVuY2VCZXR3ZWVuQmxvY2tgSEhhc0FjdGl2ZVNjaGVkdWxlcwASBPhVc2VyIHN0aWxsIGhhcyBhY3RpdmUgRENBIHNjaGVkdWxlcyBhbmQgY2Fubm90IHVubG9jayByZXNlcnZlc0BOb1Jlc2VydmVzTG9ja2VkABME3E5vIHJlc2VydmVzIGFyZSBsb2NrZWQgZm9yIHRoZSB1c2VyIGZvciB0aGUgZ2l2ZW4gYXNzZXQEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuoQwMTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAGlDARTAAAEAK0MARhWZWM8VD4AAKUMBBhPcHRpb24EBFQBqQwBCBBOb25lAAAAEFNvbWUEAKkMAAABAACpDAhAcGFsbGV0X3NjaGVkdWxlciRTY2hlZHVsZWQUEE5hbWUBBBBDYWxsAQ0BLEJsb2NrTnVtYmVyARA0UGFsbGV0c09yaWdpbgFlASRBY2NvdW50SWQBAAAUASBtYXliZV9pZC0IATBPcHRpb248TmFtZT4AASBwcmlvcml0eQgBSHNjaGVkdWxlOjpQcmlvcml0eQABEGNhbGwNAQEQQ2FsbAABOG1heWJlX3BlcmlvZGljdQMBlE9wdGlvbjxzY2hlZHVsZTo6UGVyaW9kPEJsb2NrTnVtYmVyPj4AARhvcmlnaW5lAQE0UGFsbGV0c09yaWdpbgAArQwAAAKlDACxDAhAcGFsbGV0X3NjaGVkdWxlcixSZXRyeUNvbmZpZwQYUGVyaW9kARAADAE0dG90YWxfcmV0cmllcwgBCHU4AAEkcmVtYWluaW5nCAEIdTgAARhwZXJpb2QQARhQZXJpb2QAALUMDEBwYWxsZXRfc2NoZWR1bGVyGHBhbGxldBRFcnJvcgQEVAABFEBGYWlsZWRUb1NjaGVkdWxlAAAEZEZhaWxlZCB0byBzY2hlZHVsZSBhIGNhbGwgTm90Rm91bmQAAQR8Q2Fubm90IGZpbmQgdGhlIHNjaGVkdWxlZCBjYWxsLlxUYXJnZXRCbG9ja051bWJlckluUGFzdAACBKRHaXZlbiB0YXJnZXQgYmxvY2sgbnVtYmVyIGlzIGluIHRoZSBwYXN0LkhSZXNjaGVkdWxlTm9DaGFuZ2UAAwTwUmVzY2hlZHVsZSBmYWlsZWQgYmVjYXVzZSBpdCBkb2VzIG5vdCBjaGFuZ2Ugc2NoZWR1bGVkIHRpbWUuFE5hbWVkAAQE0EF0dGVtcHQgdG8gdXNlIGEgbm9uLW5hbWVkIGZ1bmN0aW9uIG9uIGEgbmFtZWQgdGFzay4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuuQwAAAK9DAC9DAx8Y3VtdWx1c19wYWxsZXRfcGFyYWNoYWluX3N5c3RlbUh1bmluY2x1ZGVkX3NlZ21lbnQgQW5jZXN0b3IEBEgBNAAMATh1c2VkX2JhbmR3aWR0aMEMATRVc2VkQmFuZHdpZHRoAAE4cGFyYV9oZWFkX2hhc2iFAgEkT3B0aW9uPEg+AAFgY29uc3VtZWRfZ29fYWhlYWRfc2lnbmFs1QwBjE9wdGlvbjxyZWxheV9jaGFpbjo6VXBncmFkZUdvQWhlYWQ+AADBDAx8Y3VtdWx1c19wYWxsZXRfcGFyYWNoYWluX3N5c3RlbUh1bmluY2x1ZGVkX3NlZ21lbnQ0VXNlZEJhbmR3aWR0aAAADAE0dW1wX21zZ19jb3VudBABDHUzMgABPHVtcF90b3RhbF9ieXRlcxABDHUzMgABNGhybXBfb3V0Z29pbmfFDAGMQlRyZWVNYXA8UGFyYUlkLCBIcm1wQ2hhbm5lbFVwZGF0ZT4AAMUMBCBCVHJlZU1hcAgESwG9AQRWAckMAAQAzQwAAADJDAx8Y3VtdWx1c19wYWxsZXRfcGFyYWNoYWluX3N5c3RlbUh1bmluY2x1ZGVkX3NlZ21lbnRESHJtcENoYW5uZWxVcGRhdGUAAAgBJG1zZ19jb3VudBABDHUzMgABLHRvdGFsX2J5dGVzEAEMdTMyAADNDAAAAtEMANEMAAAECL0ByQwA1QwEGE9wdGlvbgQEVAHZDAEIEE5vbmUAAAAQU29tZQQA2QwAAAEAANkMDExwb2xrYWRvdF9wcmltaXRpdmVzCHY4OFVwZ3JhZGVHb0FoZWFkAAEIFEFib3J0AAAAHEdvQWhlYWQAAQAA3QwMfGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW1IdW5pbmNsdWRlZF9zZWdtZW50OFNlZ21lbnRUcmFja2VyBARIATQADAE4dXNlZF9iYW5kd2lkdGjBDAE0VXNlZEJhbmR3aWR0aAABOGhybXBfd2F0ZXJtYXJrWQEBgE9wdGlvbjxyZWxheV9jaGFpbjo6QmxvY2tOdW1iZXI+AAFgY29uc3VtZWRfZ29fYWhlYWRfc2lnbmFs1QwBjE9wdGlvbjxyZWxheV9jaGFpbjo6VXBncmFkZUdvQWhlYWQ+AADhDAQYT3B0aW9uBARUAeUMAQgQTm9uZQAAABBTb21lBADlDAAAAQAA5QwMTHBvbGthZG90X3ByaW1pdGl2ZXMIdjhIVXBncmFkZVJlc3RyaWN0aW9uAAEEHFByZXNlbnQAAAAA6QwMfGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW1QcmVsYXlfc3RhdGVfc25hcHNob3RYTWVzc2FnaW5nU3RhdGVTbmFwc2hvdAAAEAEwZG1xX21xY19oZWFkNAFEcmVsYXlfY2hhaW46Okhhc2gAAZxyZWxheV9kaXNwYXRjaF9xdWV1ZV9yZW1haW5pbmdfY2FwYWNpdHntDAGMUmVsYXlEaXNwYXRjaFF1ZXVlUmVtYWluaW5nQ2FwYWNpdHkAAUBpbmdyZXNzX2NoYW5uZWxz8QwBiFZlYzwoUGFyYUlkLCBBYnJpZGdlZEhybXBDaGFubmVsKT4AATxlZ3Jlc3NfY2hhbm5lbHPxDAGIVmVjPChQYXJhSWQsIEFicmlkZ2VkSHJtcENoYW5uZWwpPgAA7QwMfGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW1QcmVsYXlfc3RhdGVfc25hcHNob3SMUmVsYXlEaXNwYXRjaFF1ZXVlUmVtYWluaW5nQ2FwYWNpdHkAAAgBPHJlbWFpbmluZ19jb3VudBABDHUzMgABOHJlbWFpbmluZ19zaXplEAEMdTMyAADxDAAAAvUMAPUMAAAECL0B+QwA+QwMTHBvbGthZG90X3ByaW1pdGl2ZXMIdjhMQWJyaWRnZWRIcm1wQ2hhbm5lbAAAGAEwbWF4X2NhcGFjaXR5EAEMdTMyAAE4bWF4X3RvdGFsX3NpemUQAQx1MzIAAUBtYXhfbWVzc2FnZV9zaXplEAEMdTMyAAEkbXNnX2NvdW50EAEMdTMyAAEodG90YWxfc2l6ZRABDHUzMgABIG1xY19oZWFkhQIBME9wdGlvbjxIYXNoPgAA/QwMTHBvbGthZG90X3ByaW1pdGl2ZXMIdjhkQWJyaWRnZWRIb3N0Q29uZmlndXJhdGlvbgAAKAE0bWF4X2NvZGVfc2l6ZRABDHUzMgABSG1heF9oZWFkX2RhdGFfc2l6ZRABDHUzMgABWG1heF91cHdhcmRfcXVldWVfY291bnQQAQx1MzIAAVRtYXhfdXB3YXJkX3F1ZXVlX3NpemUQAQx1MzIAAVxtYXhfdXB3YXJkX21lc3NhZ2Vfc2l6ZRABDHUzMgABkG1heF91cHdhcmRfbWVzc2FnZV9udW1fcGVyX2NhbmRpZGF0ZRABDHUzMgABiGhybXBfbWF4X21lc3NhZ2VfbnVtX3Blcl9jYW5kaWRhdGUQAQx1MzIAAWx2YWxpZGF0aW9uX3VwZ3JhZGVfY29vbGRvd24QASxCbG9ja051bWJlcgABYHZhbGlkYXRpb25fdXBncmFkZV9kZWxheRABLEJsb2NrTnVtYmVyAAFQYXN5bmNfYmFja2luZ19wYXJhbXMBDQFIQXN5bmNCYWNraW5nUGFyYW1zAAABDRBMcG9sa2Fkb3RfcHJpbWl0aXZlcwh2ODRhc3luY19iYWNraW5nSEFzeW5jQmFja2luZ1BhcmFtcwAACAFMbWF4X2NhbmRpZGF0ZV9kZXB0aBABDHUzMgABUGFsbG93ZWRfYW5jZXN0cnlfbGVuEAEMdTMyAAAFDQiUY3VtdWx1c19wcmltaXRpdmVzX3BhcmFjaGFpbl9pbmhlcmVudERNZXNzYWdlUXVldWVDaGFpbgAABAA0ASRSZWxheUhhc2gAAAkNBCBCVHJlZU1hcAgESwG9AQRWAQUNAAQADQ0AAAANDQAAAhENABENAAAECL0BBQ0AFQ0AAAIZDQAZDQhgcG9sa2Fkb3RfY29yZV9wcmltaXRpdmVzTE91dGJvdW5kSHJtcE1lc3NhZ2UECElkAb0BAAgBJHJlY2lwaWVudL0BAQhJZAABEGRhdGE4AUxhbGxvYzo6dmVjOjpWZWM8dTg+AAAdDQx8Y3VtdWx1c19wYWxsZXRfcGFyYWNoYWluX3N5c3RlbRhwYWxsZXQURXJyb3IEBFQAASBMT3ZlcmxhcHBpbmdVcGdyYWRlcwAABBkBQXR0ZW1wdCB0byB1cGdyYWRlIHZhbGlkYXRpb24gZnVuY3Rpb24gd2hpbGUgZXhpc3RpbmcgdXBncmFkZSBwZW5kaW5nLlBQcm9oaWJpdGVkQnlQb2xrYWRvdAABBE0BUG9sa2Fkb3QgY3VycmVudGx5IHByb2hpYml0cyB0aGlzIHBhcmFjaGFpbiBmcm9tIHVwZ3JhZGluZyBpdHMgdmFsaWRhdGlvbiBmdW5jdGlvbi4YVG9vQmlnAAIIRQFUaGUgc3VwcGxpZWQgdmFsaWRhdGlvbiBmdW5jdGlvbiBoYXMgY29tcGlsZWQgaW50byBhIGJsb2IgbGFyZ2VyIHRoYW4gUG9sa2Fkb3QgaXM8d2lsbGluZyB0byBydW4uaFZhbGlkYXRpb25EYXRhTm90QXZhaWxhYmxlAAMEHQFUaGUgaW5oZXJlbnQgd2hpY2ggc3VwcGxpZXMgdGhlIHZhbGlkYXRpb24gZGF0YSBkaWQgbm90IHJ1biB0aGlzIGJsb2NrLnRIb3N0Q29uZmlndXJhdGlvbk5vdEF2YWlsYWJsZQAEBCkBVGhlIGluaGVyZW50IHdoaWNoIHN1cHBsaWVzIHRoZSBob3N0IGNvbmZpZ3VyYXRpb24gZGlkIG5vdCBydW4gdGhpcyBibG9jay4wTm90U2NoZWR1bGVkAAUE2E5vIHZhbGlkYXRpb24gZnVuY3Rpb24gdXBncmFkZSBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLkROb3RoaW5nQXV0aG9yaXplZAAGBJBObyBjb2RlIHVwZ3JhZGUgaGFzIGJlZW4gYXV0aG9yaXplZC4wVW5hdXRob3JpemVkAAcEvFRoZSBnaXZlbiBjb2RlIHVwZ3JhZGUgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LiENDChwYWxsZXRfeGNtGHBhbGxldCxRdWVyeVN0YXR1cwQsQmxvY2tOdW1iZXIBEAEMHFBlbmRpbmcQASRyZXNwb25kZXLFBAFEVmVyc2lvbmVkTG9jYXRpb24AAUxtYXliZV9tYXRjaF9xdWVyaWVyJQ0BZE9wdGlvbjxWZXJzaW9uZWRMb2NhdGlvbj4AATBtYXliZV9ub3RpZnkpDQFAT3B0aW9uPCh1OCwgdTgpPgABHHRpbWVvdXQQASxCbG9ja051bWJlcgAAADxWZXJzaW9uTm90aWZpZXIIARhvcmlnaW7FBAFEVmVyc2lvbmVkTG9jYXRpb24AASRpc19hY3RpdmUgARBib29sAAEAFFJlYWR5CAEgcmVzcG9uc2UxDQFEVmVyc2lvbmVkUmVzcG9uc2UAAQhhdBABLEJsb2NrTnVtYmVyAAIAACUNBBhPcHRpb24EBFQBxQQBCBBOb25lAAAAEFNvbWUEAMUEAAABAAApDQQYT3B0aW9uBARUAS0NAQgQTm9uZQAAABBTb21lBAAtDQAAAQAALQ0AAAQICAgAMQ0IDHhjbURWZXJzaW9uZWRSZXNwb25zZQABDAhWMgQADQUBMHYyOjpSZXNwb25zZQACAAhWMwQAWQUBMHYzOjpSZXNwb25zZQADAAhWNAQAwQUBMHY0OjpSZXNwb25zZQAEAAA1DQAABAgQxQQAOQ0AAAQMMCgQAD0NDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBQQ0EUwAABABFDQEYVmVjPFQ+AABBDQAABAjFBBAARQ0AAAJBDQBJDQwocGFsbGV0X3hjbRhwYWxsZXRUVmVyc2lvbk1pZ3JhdGlvblN0YWdlAAEQXE1pZ3JhdGVTdXBwb3J0ZWRWZXJzaW9uAAAAXE1pZ3JhdGVWZXJzaW9uTm90aWZpZXJzAAEAUE5vdGlmeUN1cnJlbnRUYXJnZXRzBACpBgE8T3B0aW9uPFZlYzx1OD4+AAIAaE1pZ3JhdGVBbmROb3RpZnlPbGRUYXJnZXRzAAMAAE0NAAAEDBAAHQYAUQ0MKHBhbGxldF94Y20YcGFsbGV0aFJlbW90ZUxvY2tlZEZ1bmdpYmxlUmVjb3JkCEhDb25zdW1lcklkZW50aWZpZXIBkDBNYXhDb25zdW1lcnMAABABGGFtb3VudBgBEHUxMjgAARRvd25lcsUEAURWZXJzaW9uZWRMb2NhdGlvbgABGGxvY2tlcsUEAURWZXJzaW9uZWRMb2NhdGlvbgABJGNvbnN1bWVyc1UNAdBCb3VuZGVkVmVjPChDb25zdW1lcklkZW50aWZpZXIsIHUxMjgpLCBNYXhDb25zdW1lcnM+AABVDQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAVkNBFMAAAQAXQ0BGFZlYzxUPgAAWQ0AAAQIkBgAXQ0AAAJZDQBhDQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAWUNBFMAAAQAaQ0BGFZlYzxUPgAAZQ0AAAQIGMUEAGkNAAACZQ0AbQ0MKHBhbGxldF94Y20YcGFsbGV0FEVycm9yBARUAAFgLFVucmVhY2hhYmxlAAAIXQFUaGUgZGVzaXJlZCBkZXN0aW5hdGlvbiB3YXMgdW5yZWFjaGFibGUsIGdlbmVyYWxseSBiZWNhdXNlIHRoZXJlIGlzIGEgbm8gd2F5IG9mIHJvdXRpbmcYdG8gaXQuLFNlbmRGYWlsdXJlAAEIQQFUaGVyZSB3YXMgc29tZSBvdGhlciBpc3N1ZSAoaS5lLiBub3QgdG8gZG8gd2l0aCByb3V0aW5nKSBpbiBzZW5kaW5nIHRoZSBtZXNzYWdlLshQZXJoYXBzIGEgbGFjayBvZiBzcGFjZSBmb3IgYnVmZmVyaW5nIHRoZSBtZXNzYWdlLiBGaWx0ZXJlZAACBJxUaGUgbWVzc2FnZSBleGVjdXRpb24gZmFpbHMgdGhlIGZpbHRlci5IVW53ZWlnaGFibGVNZXNzYWdlAAMEtFRoZSBtZXNzYWdlJ3Mgd2VpZ2h0IGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkLmBEZXN0aW5hdGlvbk5vdEludmVydGlibGUABATcVGhlIGRlc3RpbmF0aW9uIGBMb2NhdGlvbmAgcHJvdmlkZWQgY2Fubm90IGJlIGludmVydGVkLhRFbXB0eQAFBIBUaGUgYXNzZXRzIHRvIGJlIHNlbnQgYXJlIGVtcHR5LjhDYW5ub3RSZWFuY2hvcgAGBDUBQ291bGQgbm90IHJlLWFuY2hvciB0aGUgYXNzZXRzIHRvIGRlY2xhcmUgdGhlIGZlZXMgZm9yIHRoZSBkZXN0aW5hdGlvbiBjaGFpbi40VG9vTWFueUFzc2V0cwAHBMRUb28gbWFueSBhc3NldHMgaGF2ZSBiZWVuIGF0dGVtcHRlZCBmb3IgdHJhbnNmZXIuNEludmFsaWRPcmlnaW4ACAR4T3JpZ2luIGlzIGludmFsaWQgZm9yIHNlbmRpbmcuKEJhZFZlcnNpb24ACQQhAVRoZSB2ZXJzaW9uIG9mIHRoZSBgVmVyc2lvbmVkYCB2YWx1ZSB1c2VkIGlzIG5vdCBhYmxlIHRvIGJlIGludGVycHJldGVkLixCYWRMb2NhdGlvbgAKCEEBVGhlIGdpdmVuIGxvY2F0aW9uIGNvdWxkIG5vdCBiZSB1c2VkIChlLmcuIGJlY2F1c2UgaXQgY2Fubm90IGJlIGV4cHJlc3NlZCBpbiB0aGVgZGVzaXJlZCB2ZXJzaW9uIG9mIFhDTSkuOE5vU3Vic2NyaXB0aW9uAAsEvFRoZSByZWZlcmVuY2VkIHN1YnNjcmlwdGlvbiBjb3VsZCBub3QgYmUgZm91bmQuREFscmVhZHlTdWJzY3JpYmVkAAwEEQFUaGUgbG9jYXRpb24gaXMgaW52YWxpZCBzaW5jZSBpdCBhbHJlYWR5IGhhcyBhIHN1YnNjcmlwdGlvbiBmcm9tIHVzLlhDYW5ub3RDaGVja091dFRlbGVwb3J0AA0EKQFDb3VsZCBub3QgY2hlY2stb3V0IHRoZSBhc3NldHMgZm9yIHRlbGVwb3J0YXRpb24gdG8gdGhlIGRlc3RpbmF0aW9uIGNoYWluLihMb3dCYWxhbmNlAA4EQQFUaGUgb3duZXIgZG9lcyBub3Qgb3duIChhbGwpIG9mIHRoZSBhc3NldCB0aGF0IHRoZXkgd2lzaCB0byBkbyB0aGUgb3BlcmF0aW9uIG9uLjBUb29NYW55TG9ja3MADwTAVGhlIGFzc2V0IG93bmVyIGhhcyB0b28gbWFueSBsb2NrcyBvbiB0aGUgYXNzZXQuTEFjY291bnROb3RTb3ZlcmVpZ24AEAQxAVRoZSBnaXZlbiBhY2NvdW50IGlzIG5vdCBhbiBpZGVudGlmaWFibGUgc292ZXJlaWduIGFjY291bnQgZm9yIGFueSBsb2NhdGlvbi4oRmVlc05vdE1ldAARBCkBVGhlIG9wZXJhdGlvbiByZXF1aXJlZCBmZWVzIHRvIGJlIHBhaWQgd2hpY2ggdGhlIGluaXRpYXRvciBjb3VsZCBub3QgbWVldC4wTG9ja05vdEZvdW5kABIE9EEgcmVtb3RlIGxvY2sgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBkYXRhIGNvdWxkIG5vdCBiZSBmb3VuZC4USW5Vc2UAEwRJAVRoZSB1bmxvY2sgb3BlcmF0aW9uIGNhbm5vdCBzdWNjZWVkIGJlY2F1c2UgdGhlcmUgYXJlIHN0aWxsIGNvbnN1bWVycyBvZiB0aGUgbG9jay5oSW52YWxpZEFzc2V0VW5rbm93blJlc2VydmUAFQTwSW52YWxpZCBhc3NldCwgcmVzZXJ2ZSBjaGFpbiBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZCBmb3IgaXQueEludmFsaWRBc3NldFVuc3VwcG9ydGVkUmVzZXJ2ZQAWBEUBSW52YWxpZCBhc3NldCwgZG8gbm90IHN1cHBvcnQgcmVtb3RlIGFzc2V0IHJlc2VydmVzIHdpdGggZGlmZmVyZW50IGZlZXMgcmVzZXJ2ZXMuPFRvb01hbnlSZXNlcnZlcwAXBEkBVG9vIG1hbnkgYXNzZXRzIHdpdGggZGlmZmVyZW50IHJlc2VydmUgbG9jYXRpb25zIGhhdmUgYmVlbiBhdHRlbXB0ZWQgZm9yIHRyYW5zZmVyLmBMb2NhbEV4ZWN1dGlvbkluY29tcGxldGUAGAR8TG9jYWwgWENNIGV4ZWN1dGlvbiBpbmNvbXBsZXRlLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5xDQxMYm91bmRlZF9jb2xsZWN0aW9uc0Rib3VuZGVkX2J0cmVlX3NldDxCb3VuZGVkQlRyZWVTZXQIBFQBvQEEUwAABAB1DQEsQlRyZWVTZXQ8VD4AAHUNBCBCVHJlZVNldAQEVAG9AQAEAHkNAAAAeQ0AAAK9AQB9DQxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAYENBFMAAAQAiQ0BGFZlYzxUPgAAgQ0IZGN1bXVsdXNfcGFsbGV0X3hjbXBfcXVldWVYT3V0Ym91bmRDaGFubmVsRGV0YWlscwAAFAEkcmVjaXBpZW50vQEBGFBhcmFJZAABFHN0YXRlhQ0BNE91dGJvdW5kU3RhdGUAATRzaWduYWxzX2V4aXN0IAEQYm9vbAABLGZpcnN0X2luZGV4yAEMdTE2AAEobGFzdF9pbmRleMgBDHUxNgAAhQ0IZGN1bXVsdXNfcGFsbGV0X3hjbXBfcXVldWU0T3V0Ym91bmRTdGF0ZQABCAhPawAAACRTdXNwZW5kZWQAAQAAiQ0AAAKBDQCNDQAABAi9AcgAkQ0MTGJvdW5kZWRfY29sbGVjdGlvbnNAd2Vha19ib3VuZGVkX3ZlYzhXZWFrQm91bmRlZFZlYwgEVAEIBFMAAAQAOAEYVmVjPFQ+AACVDQhkY3VtdWx1c19wYWxsZXRfeGNtcF9xdWV1ZTxRdWV1ZUNvbmZpZ0RhdGEAAAwBRHN1c3BlbmRfdGhyZXNob2xkEAEMdTMyAAE4ZHJvcF90aHJlc2hvbGQQAQx1MzIAAUByZXN1bWVfdGhyZXNob2xkEAEMdTMyAACZDQxkY3VtdWx1c19wYWxsZXRfeGNtcF9xdWV1ZRhwYWxsZXQURXJyb3IEBFQAARQ4QmFkUXVldWVDb25maWcAAAQRAVNldHRpbmcgdGhlIHF1ZXVlIGNvbmZpZyBmYWlsZWQgc2luY2Ugb25lIG9mIGl0cyB2YWx1ZXMgd2FzIGludmFsaWQuQEFscmVhZHlTdXNwZW5kZWQAAQSMVGhlIGV4ZWN1dGlvbiBpcyBhbHJlYWR5IHN1c3BlbmRlZC44QWxyZWFkeVJlc3VtZWQAAgSEVGhlIGV4ZWN1dGlvbiBpcyBhbHJlYWR5IHJlc3VtZWQudFRvb01hbnlBY3RpdmVPdXRib3VuZENoYW5uZWxzAAMEsFRoZXJlIGFyZSB0b28gbWFueSBhY3RpdmUgb3V0Ym91bmQgY2hhbm5lbHMuGFRvb0JpZwAEBFxUaGUgbWVzc2FnZSBpcyB0b28gYmlnLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC6dDQhQcGFsbGV0X21lc3NhZ2VfcXVldWUkQm9va1N0YXRlBDRNZXNzYWdlT3JpZ2luASkGABgBFGJlZ2luEAEkUGFnZUluZGV4AAEMZW5kEAEkUGFnZUluZGV4AAEUY291bnQQASRQYWdlSW5kZXgAAUByZWFkeV9uZWlnaGJvdXJzoQ0BhE9wdGlvbjxOZWlnaGJvdXJzPE1lc3NhZ2VPcmlnaW4+PgABNG1lc3NhZ2VfY291bnQwAQx1NjQAARBzaXplMAEMdTY0AAChDQQYT3B0aW9uBARUAaUNAQgQTm9uZQAAABBTb21lBAClDQAAAQAApQ0IUHBhbGxldF9tZXNzYWdlX3F1ZXVlKE5laWdoYm91cnMENE1lc3NhZ2VPcmlnaW4BKQYACAEQcHJldikGATRNZXNzYWdlT3JpZ2luAAEQbmV4dCkGATRNZXNzYWdlT3JpZ2luAACpDQAABAgpBhAArQ0IUHBhbGxldF9tZXNzYWdlX3F1ZXVlEFBhZ2UIEFNpemUBECBIZWFwU2l6ZQAAGAEkcmVtYWluaW5nEAEQU2l6ZQABOHJlbWFpbmluZ19zaXplEAEQU2l6ZQABLGZpcnN0X2luZGV4EAEQU2l6ZQABFGZpcnN0EAEQU2l6ZQABEGxhc3QQARBTaXplAAEQaGVhcLENAZxCb3VuZGVkVmVjPHU4LCBJbnRvVTMyPEhlYXBTaXplLCBTaXplPj4AALENDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQBCARTAAAEADgBGFZlYzxUPgAAtQ0MUHBhbGxldF9tZXNzYWdlX3F1ZXVlGHBhbGxldBRFcnJvcgQEVAABJCxOb3RSZWFwYWJsZQAACEkBUGFnZSBpcyBub3QgcmVhcGFibGUgYmVjYXVzZSBpdCBoYXMgaXRlbXMgcmVtYWluaW5nIHRvIGJlIHByb2Nlc3NlZCBhbmQgaXMgbm90IG9sZBxlbm91Z2guGE5vUGFnZQABBIRQYWdlIHRvIGJlIHJlYXBlZCBkb2VzIG5vdCBleGlzdC4kTm9NZXNzYWdlAAIEqFRoZSByZWZlcmVuY2VkIG1lc3NhZ2UgY291bGQgbm90IGJlIGZvdW5kLkBBbHJlYWR5UHJvY2Vzc2VkAAMEAQFUaGUgbWVzc2FnZSB3YXMgYWxyZWFkeSBwcm9jZXNzZWQgYW5kIGNhbm5vdCBiZSBwcm9jZXNzZWQgYWdhaW4uGFF1ZXVlZAAEBKxUaGUgbWVzc2FnZSBpcyBxdWV1ZWQgZm9yIGZ1dHVyZSBleGVjdXRpb24uSEluc3VmZmljaWVudFdlaWdodAAFBBkBVGhlcmUgaXMgdGVtcG9yYXJpbHkgbm90IGVub3VnaCB3ZWlnaHQgdG8gY29udGludWUgc2VydmljaW5nIG1lc3NhZ2VzLmBUZW1wb3JhcmlseVVucHJvY2Vzc2FibGUABhCoVGhpcyBtZXNzYWdlIGlzIHRlbXBvcmFyaWx5IHVucHJvY2Vzc2FibGUuAFkBU3VjaCBlcnJvcnMgYXJlIGV4cGVjdGVkLCBidXQgbm90IGd1YXJhbnRlZWQsIHRvIHJlc29sdmUgdGhlbXNlbHZlcyBldmVudHVhbGx5IHRocm91Z2gkcmV0cnlpbmcuLFF1ZXVlUGF1c2VkAAcM7FRoZSBxdWV1ZSBpcyBwYXVzZWQgYW5kIG5vIG1lc3NhZ2UgY2FuIGJlIGV4ZWN1dGVkIGZyb20gaXQuAB0BVGhpcyBjYW4gY2hhbmdlIGF0IGFueSB0aW1lIGFuZCBtYXkgcmVzb2x2ZSBpbiB0aGUgZnV0dXJlIGJ5IHJlLXRyeWluZy5MUmVjdXJzaXZlRGlzYWxsb3dlZAAIBDEBQW5vdGhlciBjYWxsIGlzIGluIHByb2dyZXNzIGFuZCBuZWVkcyB0byBmaW5pc2ggYmVmb3JlIHRoaXMgY2FsbCBjYW4gaGFwcGVuLgSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC65DQwgb3JtbF94Y20YbW9kdWxlFEVycm9yBARUAAEMLFVucmVhY2hhYmxlAAAIDQFUaGUgbWVzc2FnZSBhbmQgZGVzdGluYXRpb24gY29tYmluYXRpb24gd2FzIG5vdCByZWNvZ25pemVkIGFzIGJlaW5nKHJlYWNoYWJsZS4sU2VuZEZhaWx1cmUAAQgFAVRoZSBtZXNzYWdlIGFuZCBkZXN0aW5hdGlvbiB3YXMgcmVjb2duaXplZCBhcyBiZWluZyByZWFjaGFibGUgYnV0lHRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIGNvbXBsZXRlZC4oQmFkVmVyc2lvbgACCOxUaGUgdmVyc2lvbiBvZiB0aGUgYFZlcnNpb25lZGAgdmFsdWUgdXNlZCBpcyBub3QgYWJsZSB0byBiZTBpbnRlcnByZXRlZC4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuvQ0MMG9ybWxfeHRva2Vucxhtb2R1bGUURXJyb3IEBFQAAVBEQXNzZXRIYXNOb1Jlc2VydmUAAAR4QXNzZXQgaGFzIG5vIHJlc2VydmUgbG9jYXRpb24uVE5vdENyb3NzQ2hhaW5UcmFuc2ZlcgABBGROb3QgY3Jvc3MtY2hhaW4gdHJhbnNmZXIuLEludmFsaWREZXN0AAIEdEludmFsaWQgdHJhbnNmZXIgZGVzdGluYXRpb24uhE5vdENyb3NzQ2hhaW5UcmFuc2ZlcmFibGVDdXJyZW5jeQADBKRDdXJyZW5jeSBpcyBub3QgY3Jvc3MtY2hhaW4gdHJhbnNmZXJhYmxlLkhVbndlaWdoYWJsZU1lc3NhZ2UABAS0VGhlIG1lc3NhZ2UncyB3ZWlnaHQgY291bGQgbm90IGJlIGRldGVybWluZWQuSFhjbUV4ZWN1dGlvbkZhaWxlZAAFBFRYQ00gZXhlY3V0aW9uIGZhaWxlZC44Q2Fubm90UmVhbmNob3IABgjoQ291bGQgbm90IHJlLWFuY2hvciB0aGUgYXNzZXRzIHRvIGRlY2xhcmUgdGhlIGZlZXMgZm9yIHRoZUhkZXN0aW5hdGlvbiBjaGFpbi48SW52YWxpZEFuY2VzdHJ5AAcExENvdWxkIG5vdCBnZXQgYW5jZXN0cnkgb2YgYXNzZXQgcmVzZXJ2ZSBsb2NhdGlvbi4wSW52YWxpZEFzc2V0AAgEVFRoZSBBc3NldCBpcyBpbnZhbGlkLmBEZXN0aW5hdGlvbk5vdEludmVydGlibGUACQTcVGhlIGRlc3RpbmF0aW9uIGBMb2NhdGlvbmAgcHJvdmlkZWQgY2Fubm90IGJlIGludmVydGVkLihCYWRWZXJzaW9uAAoI7FRoZSB2ZXJzaW9uIG9mIHRoZSBgVmVyc2lvbmVkYCB2YWx1ZSB1c2VkIGlzIG5vdCBhYmxlIHRvIGJlMGludGVycHJldGVkLnREaXN0aW5jdFJlc2VydmVGb3JBc3NldEFuZEZlZQALCPxXZSB0cmllZCBzZW5kaW5nIGRpc3RpbmN0IGFzc2V0IGFuZCBmZWUgYnV0IHRoZXkgaGF2ZSBkaWZmZXJlbnQ8cmVzZXJ2ZSBjaGFpbnMuHFplcm9GZWUADARAVGhlIGZlZSBpcyB6ZXJvLihaZXJvQW1vdW50AA0ElFRoZSB0cmFuc2ZlcmluZyBhc3NldCBhbW91bnQgaXMgemVyby5YVG9vTWFueUFzc2V0c0JlaW5nU2VudAAOBNBUaGUgbnVtYmVyIG9mIGFzc2V0cyB0byBiZSBzZW50IGlzIG92ZXIgdGhlIG1heGltdW0uVEFzc2V0SW5kZXhOb25FeGlzdGVudAAPBNhUaGUgc3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IGV4aXN0IGluIGEgQXNzZXRzIHN0cnVjdC4wRmVlTm90RW5vdWdoABAESEZlZSBpcyBub3QgZW5vdWdoLlBOb3RTdXBwb3J0ZWRMb2NhdGlvbgARBFhOb3Qgc3VwcG9ydGVkIExvY2F0aW9uTE1pblhjbUZlZU5vdERlZmluZWQAEgTUTWluWGNtRmVlIG5vdCByZWdpc3RlcmVkIGZvciBjZXJ0YWluIHJlc2VydmUgbG9jYXRpb24sUmF0ZUxpbWl0ZWQAEwSkQXNzZXQgdHJhbnNmZXIgaXMgbGltaXRlZCBieSBSYXRlTGltaXRlci4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuwQ0AAAQIfQF9AQDFDQAABAh9ATgAyQ0MTG9ybWxfdW5rbm93bl90b2tlbnMYbW9kdWxlFEVycm9yBARUAAEMNEJhbGFuY2VUb29Mb3cAAARcVGhlIGJhbGFuY2UgaXMgdG9vIGxvdy48QmFsYW5jZU92ZXJmbG93AAEEtFRoZSBvcGVyYXRpb24gd2lsbCBjYXVzZSBiYWxhbmNlIHRvIG92ZXJmbG93LjhVbmhhbmRsZWRBc3NldAACBEBVbmhhbmRsZWQgYXNzZXQuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Ls0NDExib3VuZGVkX2NvbGxlY3Rpb25zLGJvdW5kZWRfdmVjKEJvdW5kZWRWZWMIBFQB0Q0EUwAABADVDQEYVmVjPFQ+AADRDQxkcGFsbGV0X2NvbGxhdG9yX3NlbGVjdGlvbhhwYWxsZXQ0Q2FuZGlkYXRlSW5mbwgkQWNjb3VudElkAQAcQmFsYW5jZQEYAAgBDHdobwABJEFjY291bnRJZAABHGRlcG9zaXQYARxCYWxhbmNlAADVDQAAAtENANkNDGRwYWxsZXRfY29sbGF0b3Jfc2VsZWN0aW9uGHBhbGxldBRFcnJvcgQEVAABRERUb29NYW55Q2FuZGlkYXRlcwAABIxUaGUgcGFsbGV0IGhhcyB0b28gbWFueSBjYW5kaWRhdGVzLlxUb29GZXdFbGlnaWJsZUNvbGxhdG9ycwABBKxMZWF2aW5nIHdvdWxkIHJlc3VsdCBpbiB0b28gZmV3IGNhbmRpZGF0ZXMuQEFscmVhZHlDYW5kaWRhdGUAAgR8QWNjb3VudCBpcyBhbHJlYWR5IGEgY2FuZGlkYXRlLjBOb3RDYW5kaWRhdGUAAwRsQWNjb3VudCBpcyBub3QgYSBjYW5kaWRhdGUuUFRvb01hbnlJbnZ1bG5lcmFibGVzAAQEhFRoZXJlIGFyZSB0b28gbWFueSBJbnZ1bG5lcmFibGVzLkxBbHJlYWR5SW52dWxuZXJhYmxlAAUEjEFjY291bnQgaXMgYWxyZWFkeSBhbiBJbnZ1bG5lcmFibGUuPE5vdEludnVsbmVyYWJsZQAGBHxBY2NvdW50IGlzIG5vdCBhbiBJbnZ1bG5lcmFibGUuXE5vQXNzb2NpYXRlZFZhbGlkYXRvcklkAAcEnEFjY291bnQgaGFzIG5vIGFzc29jaWF0ZWQgdmFsaWRhdG9yIElELlhWYWxpZGF0b3JOb3RSZWdpc3RlcmVkAAgEjFZhbGlkYXRvciBJRCBpcyBub3QgeWV0IHJlZ2lzdGVyZWQubEluc2VydFRvQ2FuZGlkYXRlTGlzdEZhaWxlZAAJBJxDb3VsZCBub3QgaW5zZXJ0IGluIHRoZSBjYW5kaWRhdGUgbGlzdC50UmVtb3ZlRnJvbUNhbmRpZGF0ZUxpc3RGYWlsZWQACgSkQ291bGQgbm90IHJlbW92ZSBmcm9tIHRoZSBjYW5kaWRhdGUgbGlzdC40RGVwb3NpdFRvb0xvdwALBPROZXcgZGVwb3NpdCBhbW91bnQgd291bGQgYmUgYmVsb3cgdGhlIG1pbmltdW0gY2FuZGlkYWN5IGJvbmQuZFVwZGF0ZUNhbmRpZGF0ZUxpc3RGYWlsZWQADASQQ291bGQgbm90IHVwZGF0ZSB0aGUgY2FuZGlkYXRlIGxpc3QuQEluc3VmZmljaWVudEJvbmQADQQpAURlcG9zaXQgYW1vdW50IGlzIHRvbyBsb3cgdG8gdGFrZSB0aGUgdGFyZ2V0J3Mgc2xvdCBpbiB0aGUgY2FuZGlkYXRlIGxpc3QuUFRhcmdldElzTm90Q2FuZGlkYXRlAA4ELQFUaGUgdGFyZ2V0IGFjY291bnQgdG8gYmUgcmVwbGFjZWQgaW4gdGhlIGNhbmRpZGF0ZSBsaXN0IGlzIG5vdCBhIGNhbmRpZGF0ZS5ASWRlbnRpY2FsRGVwb3NpdAAPBA0BVGhlIHVwZGF0ZWQgZGVwb3NpdCBhbW91bnQgaXMgZXF1YWwgdG8gdGhlIGFtb3VudCBhbHJlYWR5IHJlc2VydmVkLkBJbnZhbGlkVW5yZXNlcnZlABAEPQFDYW5ub3QgbG93ZXIgY2FuZGlkYWN5IGJvbmQgd2hpbGUgb2NjdXB5aW5nIGEgZnV0dXJlIGNvbGxhdG9yIHNsb3QgaW4gdGhlIGxpc3QuBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0Lt0NAAAC4Q0A4Q0AAAQIAEUGAOUNAAAECOkNOADpDQwcc3BfY29yZRhjcnlwdG8kS2V5VHlwZUlkAAAEAEgBHFt1ODsgNF0AAO0NDDhwYWxsZXRfc2Vzc2lvbhhwYWxsZXQURXJyb3IEBFQAARQwSW52YWxpZFByb29mAAAEYEludmFsaWQgb3duZXJzaGlwIHByb29mLlxOb0Fzc29jaWF0ZWRWYWxpZGF0b3JJZAABBJxObyBhc3NvY2lhdGVkIHZhbGlkYXRvciBJRCBmb3IgYWNjb3VudC40RHVwbGljYXRlZEtleQACBGRSZWdpc3RlcmVkIGR1cGxpY2F0ZSBrZXkuGE5vS2V5cwADBKRObyBrZXlzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBhY2NvdW50LiROb0FjY291bnQABAQZAUtleSBzZXR0aW5nIGFjY291bnQgaXMgbm90IGxpdmUsIHNvIGl0J3MgaW1wb3NzaWJsZSB0byBhc3NvY2lhdGUga2V5cy4EdEVycm9yIGZvciB0aGUgc2Vzc2lvbiBwYWxsZXQu8Q0MTGJvdW5kZWRfY29sbGVjdGlvbnMsYm91bmRlZF92ZWMoQm91bmRlZFZlYwgEVAFJBgRTAAAEAPUNARhWZWM8VD4AAPUNAAACSQYA+Q0ISHNwX2NvbnNlbnN1c19zbG90cxBTbG90AAAEADABDHU2NAAA/Q0AAAQI+Q0QAAEODCxwYWxsZXRfaXNtcBhwYWxsZXQURXJyb3IEBFQAARQ4SW52YWxpZE1lc3NhZ2UAAARQSW52YWxpZCBJU01QIG1lc3NhZ2U8TWVzc2FnZU5vdEZvdW5kAAEEfFJlcXVlc3RlZCBtZXNzYWdlIHdhcyBub3QgZm91bmR0Q29uc2Vuc3VzQ2xpZW50Q3JlYXRpb25GYWlsZWQAAgTkRW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGNvbnNlbnN1cyBjbGllbnQubFVuYm9uZGluZ1BlcmlvZFVwZGF0ZUZhaWxlZAADBIBDb3VsZG4ndCB1cGRhdGUgdW5ib25kaW5nIHBlcmlvZGxDaGFsbGVuZ2VQZXJpb2RVcGRhdGVGYWlsZWQABASAQ291bGRuJ3QgdXBkYXRlIGNoYWxsZW5nZSBwZXJpb2QENFBhbGxldCBlcnJvcnMFDgw4aXNtcF9wYXJhY2hhaW4YcGFsbGV0FEVycm9yBARUAAEIXEludmFsaWRDb25zZW5zdXNTdGF0ZUlkAAAEDQFPbmx5IFBhcmFjaGFpbiBDb25zZW5zdXMgdXBkYXRlcyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBpbmhlcmVudHMuXENvbnNlbnN1c0FscmVhZHlVcGRhdGVkAAEE0FZhbGlkYXRpb25EYXRhIG11c3QgYmUgdXBkYXRlZCBvbmx5IG9uY2UgaW4gYSBibG9jay4EgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuCQ4MSHBhbGxldF9oeXBlcmJyaWRnZRhwYWxsZXQURXJyb3IEBFQAAQAEgFRoZSBgRXJyb3JgIGVudW0gb2YgdGhpcyBwYWxsZXQuDQ4AAAQIEG0GABEODFBwYWxsZXRfdG9rZW5fZ2F0ZXdheRhwYWxsZXQURXJyb3IEBFQAASREVW5yZWdpc3RlcmVkQXNzZXQAAASQQSBhc3NldCB0aGF0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkSEFzc2V0VGVsZXBvcnRFcnJvcgABBHRFcnJvciB3aGlsZSB0ZWxlcG9ydGluZyBhc3NldGBDb3Byb2Nlc3Nvck5vdENvbmZpZ3VyZWQAAgS0Q29wcm9jZXNzb3Igd2FzIG5vdCBjb25maWd1cmVkIGluIHRoZSBydW50aW1lNERpc3BhdGNoRXJyb3IAAwR4QXNzZXQgb3IgdXBkYXRlIERpc3BhdGNoIEVycm9ySEFzc2V0Q3JlYXRpb25FcnJvcgAEBGBBc3NldCBJZCBjcmVhdGlvbiBmYWlsZWRUQXNzZXREZWNpbWFsc05vdEZvdW5kAAUEYEFzc2V0IGRlY2ltYWxzIG5vdCBmb3VuZDhOb3RJbml0aWFsaXplZAAGBKRQcm90b2NvbCBQYXJhbXMgaGF2ZSBub3QgYmVlbiBpbml0aWFsaXplZDBVbmtub3duQXNzZXQABwQ0VW5rbm93biBBc3NldDROb3RBc3NldE93bmVyAAgEpE9ubHkgcm9vdCBvciBhc3NldCBvd25lciBjYW4gdXBkYXRlIGFzc2V0BKxFcnJvcnMgdGhhdCBjYW4gYmUgcmV0dXJuZWQgYnkgdGhpcyBwYWxsZXQuFQ4MTGJvdW5kZWRfY29sbGVjdGlvbnNEYm91bmRlZF9idHJlZV9tYXA8Qm91bmRlZEJUcmVlTWFwDARLARkOBFYBHQ4EUwAABAAtDgE4QlRyZWVNYXA8SywgVj4AABkOAAAECP0BTQMAHQ4MRHBhbGxldF9lbWFfb3JhY2xlFHR5cGVzLE9yYWNsZUVudHJ5BCxCbG9ja051bWJlcgEQABQBFHByaWNlIQ4BFFByaWNlAAEYdm9sdW1lJQ4BPFZvbHVtZTxCYWxhbmNlPgABJGxpcXVpZGl0eSkOAUhMaXF1aWRpdHk8QmFsYW5jZT4AATxzaGFyZXNfaXNzdWFuY2XgATxPcHRpb248QmFsYW5jZT4AASh1cGRhdGVkX2F0EAEsQmxvY2tOdW1iZXIAACEODDRoeWRyYV9keF9tYXRoFHJhdGlvFFJhdGlvAAAIAQRuGAEQdTEyOAABBGQYARB1MTI4AAAlDgw4aHlkcmFkeF90cmFpdHMYb3JhY2xlGFZvbHVtZQQcQmFsYW5jZQEYABABEGFfaW4YARxCYWxhbmNlAAEUYl9vdXQYARxCYWxhbmNlAAEUYV9vdXQYARxCYWxhbmNlAAEQYl9pbhgBHEJhbGFuY2UAACkODDhoeWRyYWR4X3RyYWl0cxhvcmFjbGUkTGlxdWlkaXR5BBxCYWxhbmNlARgACAEEYRgBHEJhbGFuY2UAAQRiGAEcQmFsYW5jZQAALQ4EIEJUcmVlTWFwCARLARkOBFYBHQ4ABAAxDgAAADEOAAACNQ4ANQ4AAAQIGQ4dDgA5DgAABAz9AU0DuQMAPQ4AAAQIHQ4QAEEODExib3VuZGVkX2NvbGxlY3Rpb25zRGJvdW5kZWRfYnRyZWVfc2V0PEJvdW5kZWRCVHJlZVNldAgEVAEZDgRTAAAEAEUOASxCVHJlZVNldDxUPgAARQ4EIEJUcmVlU2V0BARUARkOAAQASQ4AAABJDgAAAhkOAE0ODERwYWxsZXRfZW1hX29yYWNsZRhwYWxsZXQURXJyb3IEBFQAARRQVG9vTWFueVVuaXF1ZUVudHJpZXMAAABAT25UcmFkZVZhbHVlWmVybwABADhPcmFjbGVOb3RGb3VuZAACADRBc3NldE5vdEZvdW5kAAMEPEFzc2V0IG5vdCBmb3VuZGBQcmljZU91dHNpZGVBbGxvd2VkUmFuZ2UABAS4VGhlIG5ldyBwcmljZSBpcyBvdXRzaWRlIHRoZSBtYXggYWxsb3dlZCByYW5nZQSAVGhlIGBFcnJvcmAgZW51bSBvZiB0aGlzIHBhbGxldC5RDgxMYm91bmRlZF9jb2xsZWN0aW9ucyxib3VuZGVkX3ZlYyhCb3VuZGVkVmVjCARUAcUIBFMAAAQAwQgBGFZlYzxUPgAAVQ4MQHBhbGxldF9icm9hZGNhc3QYcGFsbGV0FEVycm9yBARUAAEIaEV4ZWN1dGlvbkNhbGxTdGFja092ZXJmbG93AAAE9FRoZSBleGVjdXRpb24gY29udGV4dCBjYWxsIHN0YWNrIGhhcyByZWFjaGVkIGl0cyBtYXhpbXVtIHNpemVsRXhlY3V0aW9uQ2FsbFN0YWNrVW5kZXJmbG93AAEEDQFUaGUgZXhlY3V0aW9uIGNvbnRleHQgY2FsbCBzdGFjayBpcyBlbXB0eSwgdW5hYmxlIHRvIGRlY3JlYXNlIGxldmVsBIBUaGUgYEVycm9yYCBlbnVtIG9mIHRoaXMgcGFsbGV0LlkOAAAELF0OYQ5lDmkObQ51DnkOfQ6BDoUOjQ4AXQ4QMGZyYW1lX3N5c3RlbShleHRlbnNpb25zVGNoZWNrX25vbl96ZXJvX3NlbmRlckhDaGVja05vblplcm9TZW5kZXIEBFQAAAAAYQ4QMGZyYW1lX3N5c3RlbShleHRlbnNpb25zSGNoZWNrX3NwZWNfdmVyc2lvbkBDaGVja1NwZWNWZXJzaW9uBARUAAAAAGUOEDBmcmFtZV9zeXN0ZW0oZXh0ZW5zaW9uc0BjaGVja190eF92ZXJzaW9uOENoZWNrVHhWZXJzaW9uBARUAAAAAGkOEDBmcmFtZV9zeXN0ZW0oZXh0ZW5zaW9uczRjaGVja19nZW5lc2lzMENoZWNrR2VuZXNpcwQEVAAAAABtDhAwZnJhbWVfc3lzdGVtKGV4dGVuc2lvbnM8Y2hlY2tfbW9ydGFsaXR5OENoZWNrTW9ydGFsaXR5BARUAAAEAHEOAQxFcmEAAHEOEChzcF9ydW50aW1lHGdlbmVyaWMMZXJhDEVyYQABAQQgSW1tb3J0YWwAAAAcTW9ydGFsMQQACAAAAQAcTW9ydGFsMgQACAAAAgAcTW9ydGFsMwQACAAAAwAcTW9ydGFsNAQACAAABAAcTW9ydGFsNQQACAAABQAcTW9ydGFsNgQACAAABgAcTW9ydGFsNwQACAAABwAcTW9ydGFsOAQACAAACAAcTW9ydGFsOQQACAAACQAgTW9ydGFsMTAEAAgAAAoAIE1vcnRhbDExBAAIAAALACBNb3J0YWwxMgQACAAADAAgTW9ydGFsMTMEAAgAAA0AIE1vcnRhbDE0BAAIAAAOACBNb3J0YWwxNQQACAAADwAgTW9ydGFsMTYEAAgAABAAIE1vcnRhbDE3BAAIAAARACBNb3J0YWwxOAQACAAAEgAgTW9ydGFsMTkEAAgAABMAIE1vcnRhbDIwBAAIAAAUACBNb3J0YWwyMQQACAAAFQAgTW9ydGFsMjIEAAgAABYAIE1vcnRhbDIzBAAIAAAXACBNb3J0YWwyNAQACAAAGAAgTW9ydGFsMjUEAAgAABkAIE1vcnRhbDI2BAAIAAAaACBNb3J0YWwyNwQACAAAGwAgTW9ydGFsMjgEAAgAABwAIE1vcnRhbDI5BAAIAAAdACBNb3J0YWwzMAQACAAAHgAgTW9ydGFsMzEEAAgAAB8AIE1vcnRhbDMyBAAIAAAgACBNb3J0YWwzMwQACAAAIQAgTW9ydGFsMzQEAAgAACIAIE1vcnRhbDM1BAAIAAAjACBNb3J0YWwzNgQACAAAJAAgTW9ydGFsMzcEAAgAACUAIE1vcnRhbDM4BAAIAAAmACBNb3J0YWwzOQQACAAAJwAgTW9ydGFsNDAEAAgAACgAIE1vcnRhbDQxBAAIAAApACBNb3J0YWw0MgQACAAAKgAgTW9ydGFsNDMEAAgAACsAIE1vcnRhbDQ0BAAIAAAsACBNb3J0YWw0NQQACAAALQAgTW9ydGFsNDYEAAgAAC4AIE1vcnRhbDQ3BAAIAAAvACBNb3J0YWw0OAQACAAAMAAgTW9ydGFsNDkEAAgAADEAIE1vcnRhbDUwBAAIAAAyACBNb3J0YWw1MQQACAAAMwAgTW9ydGFsNTIEAAgAADQAIE1vcnRhbDUzBAAIAAA1ACBNb3J0YWw1NAQACAAANgAgTW9ydGFsNTUEAAgAADcAIE1vcnRhbDU2BAAIAAA4ACBNb3J0YWw1NwQACAAAOQAgTW9ydGFsNTgEAAgAADoAIE1vcnRhbDU5BAAIAAA7ACBNb3J0YWw2MAQACAAAPAAgTW9ydGFsNjEEAAgAAD0AIE1vcnRhbDYyBAAIAAA+ACBNb3J0YWw2MwQACAAAPwAgTW9ydGFsNjQEAAgAAEAAIE1vcnRhbDY1BAAIAABBACBNb3J0YWw2NgQACAAAQgAgTW9ydGFsNjcEAAgAAEMAIE1vcnRhbDY4BAAIAABEACBNb3J0YWw2OQQACAAARQAgTW9ydGFsNzAEAAgAAEYAIE1vcnRhbDcxBAAIAABHACBNb3J0YWw3MgQACAAASAAgTW9ydGFsNzMEAAgAAEkAIE1vcnRhbDc0BAAIAABKACBNb3J0YWw3NQQACAAASwAgTW9ydGFsNzYEAAgAAEwAIE1vcnRhbDc3BAAIAABNACBNb3J0YWw3OAQACAAATgAgTW9ydGFsNzkEAAgAAE8AIE1vcnRhbDgwBAAIAABQACBNb3J0YWw4MQQACAAAUQAgTW9ydGFsODIEAAgAAFIAIE1vcnRhbDgzBAAIAABTACBNb3J0YWw4NAQACAAAVAAgTW9ydGFsODUEAAgAAFUAIE1vcnRhbDg2BAAIAABWACBNb3J0YWw4NwQACAAAVwAgTW9ydGFsODgEAAgAAFgAIE1vcnRhbDg5BAAIAABZACBNb3J0YWw5MAQACAAAWgAgTW9ydGFsOTEEAAgAAFsAIE1vcnRhbDkyBAAIAABcACBNb3J0YWw5MwQACAAAXQAgTW9ydGFsOTQEAAgAAF4AIE1vcnRhbDk1BAAIAABfACBNb3J0YWw5NgQACAAAYAAgTW9ydGFsOTcEAAgAAGEAIE1vcnRhbDk4BAAIAABiACBNb3J0YWw5OQQACAAAYwAkTW9ydGFsMTAwBAAIAABkACRNb3J0YWwxMDEEAAgAAGUAJE1vcnRhbDEwMgQACAAAZgAkTW9ydGFsMTAzBAAIAABnACRNb3J0YWwxMDQEAAgAAGgAJE1vcnRhbDEwNQQACAAAaQAkTW9ydGFsMTA2BAAIAABqACRNb3J0YWwxMDcEAAgAAGsAJE1vcnRhbDEwOAQACAAAbAAkTW9ydGFsMTA5BAAIAABtACRNb3J0YWwxMTAEAAgAAG4AJE1vcnRhbDExMQQACAAAbwAkTW9ydGFsMTEyBAAIAABwACRNb3J0YWwxMTMEAAgAAHEAJE1vcnRhbDExNAQACAAAcgAkTW9ydGFsMTE1BAAIAABzACRNb3J0YWwxMTYEAAgAAHQAJE1vcnRhbDExNwQACAAAdQAkTW9ydGFsMTE4BAAIAAB2ACRNb3J0YWwxMTkEAAgAAHcAJE1vcnRhbDEyMAQACAAAeAAkTW9ydGFsMTIxBAAIAAB5ACRNb3J0YWwxMjIEAAgAAHoAJE1vcnRhbDEyMwQACAAAewAkTW9ydGFsMTI0BAAIAAB8ACRNb3J0YWwxMjUEAAgAAH0AJE1vcnRhbDEyNgQACAAAfgAkTW9ydGFsMTI3BAAIAAB/ACRNb3J0YWwxMjgEAAgAAIAAJE1vcnRhbDEyOQQACAAAgQAkTW9ydGFsMTMwBAAIAACCACRNb3J0YWwxMzEEAAgAAIMAJE1vcnRhbDEzMgQACAAAhAAkTW9ydGFsMTMzBAAIAACFACRNb3J0YWwxMzQEAAgAAIYAJE1vcnRhbDEzNQQACAAAhwAkTW9ydGFsMTM2BAAIAACIACRNb3J0YWwxMzcEAAgAAIkAJE1vcnRhbDEzOAQACAAAigAkTW9ydGFsMTM5BAAIAACLACRNb3J0YWwxNDAEAAgAAIwAJE1vcnRhbDE0MQQACAAAjQAkTW9ydGFsMTQyBAAIAACOACRNb3J0YWwxNDMEAAgAAI8AJE1vcnRhbDE0NAQACAAAkAAkTW9ydGFsMTQ1BAAIAACRACRNb3J0YWwxNDYEAAgAAJIAJE1vcnRhbDE0NwQACAAAkwAkTW9ydGFsMTQ4BAAIAACUACRNb3J0YWwxNDkEAAgAAJUAJE1vcnRhbDE1MAQACAAAlgAkTW9ydGFsMTUxBAAIAACXACRNb3J0YWwxNTIEAAgAAJgAJE1vcnRhbDE1MwQACAAAmQAkTW9ydGFsMTU0BAAIAACaACRNb3J0YWwxNTUEAAgAAJsAJE1vcnRhbDE1NgQACAAAnAAkTW9ydGFsMTU3BAAIAACdACRNb3J0YWwxNTgEAAgAAJ4AJE1vcnRhbDE1OQQACAAAnwAkTW9ydGFsMTYwBAAIAACgACRNb3J0YWwxNjEEAAgAAKEAJE1vcnRhbDE2MgQACAAAogAkTW9ydGFsMTYzBAAIAACjACRNb3J0YWwxNjQEAAgAAKQAJE1vcnRhbDE2NQQACAAApQAkTW9ydGFsMTY2BAAIAACmACRNb3J0YWwxNjcEAAgAAKcAJE1vcnRhbDE2OAQACAAAqAAkTW9ydGFsMTY5BAAIAACpACRNb3J0YWwxNzAEAAgAAKoAJE1vcnRhbDE3MQQACAAAqwAkTW9ydGFsMTcyBAAIAACsACRNb3J0YWwxNzMEAAgAAK0AJE1vcnRhbDE3NAQACAAArgAkTW9ydGFsMTc1BAAIAACvACRNb3J0YWwxNzYEAAgAALAAJE1vcnRhbDE3NwQACAAAsQAkTW9ydGFsMTc4BAAIAACyACRNb3J0YWwxNzkEAAgAALMAJE1vcnRhbDE4MAQACAAAtAAkTW9ydGFsMTgxBAAIAAC1ACRNb3J0YWwxODIEAAgAALYAJE1vcnRhbDE4MwQACAAAtwAkTW9ydGFsMTg0BAAIAAC4ACRNb3J0YWwxODUEAAgAALkAJE1vcnRhbDE4NgQACAAAugAkTW9ydGFsMTg3BAAIAAC7ACRNb3J0YWwxODgEAAgAALwAJE1vcnRhbDE4OQQACAAAvQAkTW9ydGFsMTkwBAAIAAC+ACRNb3J0YWwxOTEEAAgAAL8AJE1vcnRhbDE5MgQACAAAwAAkTW9ydGFsMTkzBAAIAADBACRNb3J0YWwxOTQEAAgAAMIAJE1vcnRhbDE5NQQACAAAwwAkTW9ydGFsMTk2BAAIAADEACRNb3J0YWwxOTcEAAgAAMUAJE1vcnRhbDE5OAQACAAAxgAkTW9ydGFsMTk5BAAIAADHACRNb3J0YWwyMDAEAAgAAMgAJE1vcnRhbDIwMQQACAAAyQAkTW9ydGFsMjAyBAAIAADKACRNb3J0YWwyMDMEAAgAAMsAJE1vcnRhbDIwNAQACAAAzAAkTW9ydGFsMjA1BAAIAADNACRNb3J0YWwyMDYEAAgAAM4AJE1vcnRhbDIwNwQACAAAzwAkTW9ydGFsMjA4BAAIAADQACRNb3J0YWwyMDkEAAgAANEAJE1vcnRhbDIxMAQACAAA0gAkTW9ydGFsMjExBAAIAADTACRNb3J0YWwyMTIEAAgAANQAJE1vcnRhbDIxMwQACAAA1QAkTW9ydGFsMjE0BAAIAADWACRNb3J0YWwyMTUEAAgAANcAJE1vcnRhbDIxNgQACAAA2AAkTW9ydGFsMjE3BAAIAADZACRNb3J0YWwyMTgEAAgAANoAJE1vcnRhbDIxOQQACAAA2wAkTW9ydGFsMjIwBAAIAADcACRNb3J0YWwyMjEEAAgAAN0AJE1vcnRhbDIyMgQACAAA3gAkTW9ydGFsMjIzBAAIAADfACRNb3J0YWwyMjQEAAgAAOAAJE1vcnRhbDIyNQQACAAA4QAkTW9ydGFsMjI2BAAIAADiACRNb3J0YWwyMjcEAAgAAOMAJE1vcnRhbDIyOAQACAAA5AAkTW9ydGFsMjI5BAAIAADlACRNb3J0YWwyMzAEAAgAAOYAJE1vcnRhbDIzMQQACAAA5wAkTW9ydGFsMjMyBAAIAADoACRNb3J0YWwyMzMEAAgAAOkAJE1vcnRhbDIzNAQACAAA6gAkTW9ydGFsMjM1BAAIAADrACRNb3J0YWwyMzYEAAgAAOwAJE1vcnRhbDIzNwQACAAA7QAkTW9ydGFsMjM4BAAIAADuACRNb3J0YWwyMzkEAAgAAO8AJE1vcnRhbDI0MAQACAAA8AAkTW9ydGFsMjQxBAAIAADxACRNb3J0YWwyNDIEAAgAAPIAJE1vcnRhbDI0MwQACAAA8wAkTW9ydGFsMjQ0BAAIAAD0ACRNb3J0YWwyNDUEAAgAAPUAJE1vcnRhbDI0NgQACAAA9gAkTW9ydGFsMjQ3BAAIAAD3ACRNb3J0YWwyNDgEAAgAAPgAJE1vcnRhbDI0OQQACAAA+QAkTW9ydGFsMjUwBAAIAAD6ACRNb3J0YWwyNTEEAAgAAPsAJE1vcnRhbDI1MgQACAAA/AAkTW9ydGFsMjUzBAAIAAD9ACRNb3J0YWwyNTQEAAgAAP4AJE1vcnRhbDI1NQQACAAA/wAAdQ4QMGZyYW1lX3N5c3RlbShleHRlbnNpb25zLGNoZWNrX25vbmNlKENoZWNrTm9uY2UEBFQAAAQAVQEBIFQ6Ok5vbmNlAAB5DhAwZnJhbWVfc3lzdGVtKGV4dGVuc2lvbnMwY2hlY2tfd2VpZ2h0LENoZWNrV2VpZ2h0BARUAAAAAH0OCGhwYWxsZXRfdHJhbnNhY3Rpb25fcGF5bWVudGBDaGFyZ2VUcmFuc2FjdGlvblBheW1lbnQEBFQAAAQALQEBMEJhbGFuY2VPZjxUPgAAgQ4INHBhbGxldF9jbGFpbXM0VmFsaWRhdGVDbGFpbQQEVAAAAACFDgh0ZnJhbWVfbWV0YWRhdGFfaGFzaF9leHRlbnNpb25EQ2hlY2tNZXRhZGF0YUhhc2gEBFQAAAQBEG1vZGWJDgEQTW9kZQAAiQ4IdGZyYW1lX21ldGFkYXRhX2hhc2hfZXh0ZW5zaW9uEE1vZGUAAQggRGlzYWJsZWQAAAAcRW5hYmxlZAABAACNDgikY3VtdWx1c19wcmltaXRpdmVzX3N0b3JhZ2Vfd2VpZ2h0X3JlY2xhaW1QU3RvcmFnZVdlaWdodFJlY2xhaW0EBFQAAAAAkQ4IPGh5ZHJhZHhfcnVudGltZRxSdW50aW1lAAAAAJUOEChzcF9ydW50aW1lHGdlbmVyaWMUYmxvY2sUQmxvY2sIGEhlYWRlcgGZDiRFeHRyaW5zaWMBnQ4ACAEYaGVhZGVymQ4BGEhlYWRlcgABKGV4dHJpbnNpY3OlDgE4VmVjPEV4dHJpbnNpYz4AAJkOEChzcF9ydW50aW1lHGdlbmVyaWMYaGVhZGVyGEhlYWRlcggYTnVtYmVyARAQSGFzaAAAFAEscGFyZW50X2hhc2g0ATBIYXNoOjpPdXRwdXQAARhudW1iZXJVAQEYTnVtYmVyAAEoc3RhdGVfcm9vdDQBMEhhc2g6Ok91dHB1dAABPGV4dHJpbnNpY3Nfcm9vdDQBMEhhc2g6Ok91dHB1dAABGGRpZ2VzdDwBGERpZ2VzdAAAnQ4MRGZwX3NlbGZfY29udGFpbmVkTHVuY2hlY2tlZF9leHRyaW5zaWNIVW5jaGVja2VkRXh0cmluc2ljEBxBZGRyZXNzAQAQQ2FsbAERASRTaWduYXR1cmUBcQIURXh0cmEBWQ4ABAChDgElAXNwX3J1bnRpbWU6OmdlbmVyaWM6OlVuY2hlY2tlZEV4dHJpbnNpYzxBZGRyZXNzLCBDYWxsLCBTaWduYXR1cmUsIEV4dHJhCj4AAKEOEChzcF9ydW50aW1lHGdlbmVyaWNMdW5jaGVja2VkX2V4dHJpbnNpY0hVbmNoZWNrZWRFeHRyaW5zaWMQHEFkZHJlc3MBABBDYWxsAREBJFNpZ25hdHVyZQFxAhRFeHRyYQFZDgAEADgAAAClDgAAAp0OAKkOCChzcF9ydW50aW1lWEV4dHJpbnNpY0luY2x1c2lvbk1vZGUAAQg0QWxsRXh0cmluc2ljcwAAADRPbmx5SW5oZXJlbnRzAAEAAK0OCBxzcF9jb3JlOE9wYXF1ZU1ldGFkYXRhAAAEADgBHFZlYzx1OD4AALEOBBhPcHRpb24EBFQBrQ4BCBBOb25lAAAAEFNvbWUEAK0OAAABAAC1DgQYUmVzdWx0CARUAZgERQG5DgEICE9rBACYAAAAAAxFcnIEALkOAAABAAC5Dgwoc3BfcnVudGltZVB0cmFuc2FjdGlvbl92YWxpZGl0eWBUcmFuc2FjdGlvblZhbGlkaXR5RXJyb3IAAQgcSW52YWxpZAQAvQ4BSEludmFsaWRUcmFuc2FjdGlvbgAAABxVbmtub3duBADBDgFIVW5rbm93blRyYW5zYWN0aW9uAAEAAL0ODChzcF9ydW50aW1lUHRyYW5zYWN0aW9uX3ZhbGlkaXR5SEludmFsaWRUcmFuc2FjdGlvbgABLBBDYWxsAAAAHFBheW1lbnQAAQAYRnV0dXJlAAIAFFN0YWxlAAMAIEJhZFByb29mAAQAREFuY2llbnRCaXJ0aEJsb2NrAAUAREV4aGF1c3RzUmVzb3VyY2VzAAYAGEN1c3RvbQQACAEIdTgABwAwQmFkTWFuZGF0b3J5AAgATE1hbmRhdG9yeVZhbGlkYXRpb24ACQAkQmFkU2lnbmVyAAoAAMEODChzcF9ydW50aW1lUHRyYW5zYWN0aW9uX3ZhbGlkaXR5SFVua25vd25UcmFuc2FjdGlvbgABDDBDYW5ub3RMb29rdXAAAABMTm9VbnNpZ25lZFZhbGlkYXRvcgABABhDdXN0b20EAAgBCHU4AAIAAMUOCDBzcF9pbmhlcmVudHMwSW5oZXJlbnREYXRhAAAEARBkYXRhyQ4BlEJUcmVlTWFwPEluaGVyZW50SWRlbnRpZmllciwgVmVjPHU4Pj4AAMkOBCBCVHJlZU1hcAgESwH9AQRWATgABADNDgAAAM0OAAAC0Q4A0Q4AAAQI/QE4ANUOCDBzcF9pbmhlcmVudHNQQ2hlY2tJbmhlcmVudHNSZXN1bHQAAAwBEG9rYXkgARBib29sAAEsZmF0YWxfZXJyb3IgARBib29sAAEYZXJyb3JzxQ4BMEluaGVyZW50RGF0YQAA2Q4MKHNwX3J1bnRpbWVQdHJhbnNhY3Rpb25fdmFsaWRpdHlEVHJhbnNhY3Rpb25Tb3VyY2UAAQwcSW5CbG9jawAAABRMb2NhbAABACBFeHRlcm5hbAACAADdDgQYUmVzdWx0CARUAeEOBEUBuQ4BCAhPawQA4Q4AAAAADEVycgQAuQ4AAAEAAOEODChzcF9ydW50aW1lUHRyYW5zYWN0aW9uX3ZhbGlkaXR5QFZhbGlkVHJhbnNhY3Rpb24AABQBIHByaW9yaXR5MAFMVHJhbnNhY3Rpb25Qcmlvcml0eQABIHJlcXVpcmVzIQEBTFZlYzxUcmFuc2FjdGlvblRhZz4AASBwcm92aWRlcyEBAUxWZWM8VHJhbnNhY3Rpb25UYWc+AAEkbG9uZ2V2aXR5MAFQVHJhbnNhY3Rpb25Mb25nZXZpdHkAASRwcm9wYWdhdGUgARBib29sAADlDgQYT3B0aW9uBARUAekOAQgQTm9uZQAAABBTb21lBADpDgAAAQAA6Q4AAALtDgDtDgAABAg46Q0A8Q4ISHNwX2NvbnNlbnN1c19zbG90czBTbG90RHVyYXRpb24AAAQAMAEMdTY0AAD1DghcY3VtdWx1c19wcmltaXRpdmVzX2NvcmU0Q29sbGF0aW9uSW5mbwAAGAE8dXB3YXJkX21lc3NhZ2VzIQEBSFZlYzxVcHdhcmRNZXNzYWdlPgABTGhvcml6b250YWxfbWVzc2FnZXMVDQFgVmVjPE91dGJvdW5kSHJtcE1lc3NhZ2U+AAFMbmV3X3ZhbGlkYXRpb25fY29kZfkOAYxPcHRpb248cmVsYXlfY2hhaW46OlZhbGlkYXRpb25Db2RlPgABbHByb2Nlc3NlZF9kb3dud2FyZF9tZXNzYWdlcxABDHUzMgABOGhybXBfd2F0ZXJtYXJrEAFgcmVsYXlfY2hhaW46OkJsb2NrTnVtYmVyAAEkaGVhZF9kYXRhlQQBIEhlYWREYXRhAAD5DgQYT3B0aW9uBARUAf0OAQgQTm9uZQAAABBTb21lBAD9DgAAAQAA/Q4MdHBvbGthZG90X3BhcmFjaGFpbl9wcmltaXRpdmVzKHByaW1pdGl2ZXM4VmFsaWRhdGlvbkNvZGUAAAQAOAEcVmVjPHU4PgAAAQ8IhHBhbGxldF9jdXJyZW5jaWVzX3JwY19ydW50aW1lX2FwaSxBY2NvdW50RGF0YQQcQmFsYW5jZQEYAAwBEGZyZWUYARxCYWxhbmNlAAEgcmVzZXJ2ZWQYARxCYWxhbmNlAAEYZnJvemVuGAEcQmFsYW5jZQAABQ8AAAIJDwAJDwAABAgQAQ8ADQ8MaHBhbGxldF90cmFuc2FjdGlvbl9wYXltZW50FHR5cGVzTFJ1bnRpbWVEaXNwYXRjaEluZm8IHEJhbGFuY2UBGBhXZWlnaHQBKAAMARh3ZWlnaHQoARhXZWlnaHQAARRjbGFzc2ABNERpc3BhdGNoQ2xhc3MAASxwYXJ0aWFsX2ZlZRgBHEJhbGFuY2UAABEPDGhwYWxsZXRfdHJhbnNhY3Rpb25fcGF5bWVudBR0eXBlcyhGZWVEZXRhaWxzBBxCYWxhbmNlARgACAE0aW5jbHVzaW9uX2ZlZRUPAXRPcHRpb248SW5jbHVzaW9uRmVlPEJhbGFuY2U+PgABDHRpcBgBHEJhbGFuY2UAABUPBBhPcHRpb24EBFQBGQ8BCBBOb25lAAAAEFNvbWUEABkPAAABAAAZDwxocGFsbGV0X3RyYW5zYWN0aW9uX3BheW1lbnQUdHlwZXMwSW5jbHVzaW9uRmVlBBxCYWxhbmNlARgADAEgYmFzZV9mZWUYARxCYWxhbmNlAAEcbGVuX2ZlZRgBHEJhbGFuY2UAAUxhZGp1c3RlZF93ZWlnaHRfZmVlGAEcQmFsYW5jZQAAHQ8MDGV2bRxiYWNrZW5kFEJhc2ljAAAIARxiYWxhbmNlSQEBEFUyNTYAARRub25jZUkBARBVMjU2AAAhDwQYT3B0aW9uBARUAS0EAQgQTm9uZQAAABBTb21lBAAtBAAAAQAAJQ8EGFJlc3VsdAgEVAEpDwRFAWgBCAhPawQAKQ8AAAAADEVycgQAaAAAAQAAKQ8IGGZwX2V2bTxFeGVjdXRpb25JbmZvVjIEBFQBOAAUASxleGl0X3JlYXNvbvUHAShFeGl0UmVhc29uAAEUdmFsdWU4AQRUAAEgdXNlZF9nYXMtDwEcVXNlZEdhcwABLHdlaWdodF9pbmZvMQ8BSE9wdGlvbjxXZWlnaHRJbmZvPgABEGxvZ3M1DAEgVmVjPExvZz4AAC0PCBhmcF9ldm0cVXNlZEdhcwAACAEgc3RhbmRhcmRJAQEQVTI1NgABJGVmZmVjdGl2ZUkBARBVMjU2AAAxDwQYT3B0aW9uBARUATUPAQgQTm9uZQAAABBTb21lBAA1DwAAAQAANQ8IGGZwX2V2bShXZWlnaHRJbmZvAAAQAThyZWZfdGltZV9saW1pdNkGASxPcHRpb248dTY0PgABQHByb29mX3NpemVfbGltaXTZBgEsT3B0aW9uPHU2ND4AAThyZWZfdGltZV91c2FnZdkGASxPcHRpb248dTY0PgABQHByb29mX3NpemVfdXNhZ2XZBgEsT3B0aW9uPHU2ND4AADkPBBhSZXN1bHQIBFQBPQ8ERQFoAQgIT2sEAD0PAAAAAAxFcnIEAGgAAAEAAD0PCBhmcF9ldm08RXhlY3V0aW9uSW5mb1YyBARUAUEBABQBLGV4aXRfcmVhc29u9QcBKEV4aXRSZWFzb24AARR2YWx1ZUEBAQRUAAEgdXNlZF9nYXMtDwEcVXNlZEdhcwABLHdlaWdodF9pbmZvMQ8BSE9wdGlvbjxXZWlnaHRJbmZvPgABEGxvZ3M1DAEgVmVjPExvZz4AAEEPBBhPcHRpb24EBFQBSQwBCBBOb25lAAAAEFNvbWUEAEkMAAABAABFDwQYT3B0aW9uBARUAV0MAQgQTm9uZQAAABBTb21lBABdDAAAAQAASQ8EGE9wdGlvbgQEVAFhDAEIEE5vbmUAAAAQU29tZQQAYQwAAAEAAE0PAAAEDEEPRQ9JDwBRDwAABAhBD0kPAFUPBBhSZXN1bHQIBFQBWQ8ERQFdDwEICE9rBABZDwAAAAAMRXJyBABdDwAAAQAAWQ8AAAIdBgBdDwxAeGNtX3J1bnRpbWVfYXBpcxBmZWVzFEVycm9yAAEYNFVuaW1wbGVtZW50ZWQAAABkVmVyc2lvbmVkQ29udmVyc2lvbkZhaWxlZAABAExXZWlnaHROb3RDb21wdXRhYmxlAAIATFVuaGFuZGxlZFhjbVZlcnNpb24AAwA0QXNzZXROb3RGb3VuZAAEAChVbnJvdXRhYmxlAAUAAGEPBBhSZXN1bHQIBFQBKARFAV0PAQgIT2sEACgAAAAADEVycgQAXQ8AAAEAAGUPBBhSZXN1bHQIBFQBGARFAV0PAQgIT2sEABgAAAAADEVycgQAXQ8AAAEAAGkPBBhSZXN1bHQIBFQB6QUERQFdDwEICE9rBADpBQAAAAAMRXJyBABdDwAAAQAAbQ8EGFJlc3VsdAgEVAFxDwRFAYkPAQgIT2sEAHEPAAAAAAxFcnIEAIkPAAABAABxDwxAeGNtX3J1bnRpbWVfYXBpcxxkcnlfcnVuRENhbGxEcnlSdW5FZmZlY3RzBBRFdmVudAFUABABQGV4ZWN1dGlvbl9yZXN1bHRVBwFoRGlzcGF0Y2hSZXN1bHRXaXRoUG9zdEluZm8AAThlbWl0dGVkX2V2ZW50c3UPAShWZWM8RXZlbnQ+AAEkbG9jYWxfeGNteQ8BYE9wdGlvbjxWZXJzaW9uZWRYY208KCk+PgABOGZvcndhcmRlZF94Y21zfQ8BvFZlYzwoVmVyc2lvbmVkTG9jYXRpb24sIFZlYzxWZXJzaW9uZWRYY208KCk+Pik+AAB1DwAAAlQAeQ8EGE9wdGlvbgQEVAHlBAEIEE5vbmUAAAAQU29tZQQA5QQAAAEAAH0PAAACgQ8AgQ8AAAQIxQSFDwCFDwAAAuUEAIkPDEB4Y21fcnVudGltZV9hcGlzHGRyeV9ydW4URXJyb3IAAQg0VW5pbXBsZW1lbnRlZAAAAGRWZXJzaW9uZWRDb252ZXJzaW9uRmFpbGVkAAEAAI0PBBhSZXN1bHQIBFQBkQ8ERQGJDwEICE9rBACRDwAAAAAMRXJyBACJDwAAAQAAkQ8MQHhjbV9ydW50aW1lX2FwaXMcZHJ5X3J1bkBYY21EcnlSdW5FZmZlY3RzBBRFdmVudAFUAAwBQGV4ZWN1dGlvbl9yZXN1bHQ5CAEcT3V0Y29tZQABOGVtaXR0ZWRfZXZlbnRzdQ8BKFZlYzxFdmVudD4AAThmb3J3YXJkZWRfeGNtc30PAbxWZWM8KFZlcnNpb25lZExvY2F0aW9uLCBWZWM8VmVyc2lvbmVkWGNtPCgpPj4pPgAAlQ8EGFJlc3VsdAgEVAEABEUBmQ8BCAhPawQAAAAAAAAMRXJyBACZDwAAAQAAmQ8MQHhjbV9ydW50aW1lX2FwaXMsY29udmVyc2lvbnMURXJyb3IAAQgsVW5zdXBwb3J0ZWQAAABkVmVyc2lvbmVkQ29udmVyc2lvbkZhaWxlZAABAACdDwQYT3B0aW9uBARUAaEPAQgQTm9uZQAAABBTb21lBAChDwAAAQAAoQ8AAAQQEBC5A/0BAKUPEDxoeWRyYWR4X3J1bnRpbWUMZXZtTGFhdmVfdHJhZGVfZXhlY3V0b3IgUG9vbERhdGEEHEJhbGFuY2UBGAAQARxyZXNlcnZlEAEcQXNzZXRJZAABGGF0b2tlbhABHEFzc2V0SWQAASxsaXF1ZGl0eV9pbhgBHEJhbGFuY2UAATBsaXF1ZGl0eV9vdXQYARxCYWxhbmNlAACpDwAAAqUPAK0PAAACsQ8AsQ8MEGlzbXAYZXZlbnRzFEV2ZW50AAEwTFN0YXRlTWFjaGluZVVwZGF0ZWQEALUPAUxTdGF0ZU1hY2hpbmVVcGRhdGVkAAAAVFN0YXRlQ29tbWl0bWVudFZldG9lZAQAuQ8BVFN0YXRlQ29tbWl0bWVudFZldG9lZAABACxQb3N0UmVxdWVzdAQAaQYBLFBvc3RSZXF1ZXN0AAIAMFBvc3RSZXNwb25zZQQAmQYBMFBvc3RSZXNwb25zZQADACxHZXRSZXNwb25zZQQAnQYBLEdldFJlc3BvbnNlAAQAKEdldFJlcXVlc3QEAI0GAShHZXRSZXF1ZXN0AAUASFBvc3RSZXF1ZXN0SGFuZGxlZAQAdQgBWFJlcXVlc3RSZXNwb25zZUhhbmRsZWQABgBMUG9zdFJlc3BvbnNlSGFuZGxlZAQAdQgBWFJlcXVlc3RSZXNwb25zZUhhbmRsZWQABwBkUG9zdFJlcXVlc3RUaW1lb3V0SGFuZGxlZAQAeQgBOFRpbWVvdXRIYW5kbGVkAAgAaFBvc3RSZXNwb25zZVRpbWVvdXRIYW5kbGVkBAB5CAE4VGltZW91dEhhbmRsZWQACQBER2V0UmVxdWVzdEhhbmRsZWQEAHUIAVhSZXF1ZXN0UmVzcG9uc2VIYW5kbGVkAAoAYEdldFJlcXVlc3RUaW1lb3V0SGFuZGxlZAQAeQgBOFRpbWVvdXRIYW5kbGVkAAsAALUPDBBpc21wGGV2ZW50c0xTdGF0ZU1hY2hpbmVVcGRhdGVkAAAIAUBzdGF0ZV9tYWNoaW5lX2lkeQYBOFN0YXRlTWFjaGluZUlkAAE0bGF0ZXN0X2hlaWdodDABDHU2NAAAuQ8MEGlzbXAYZXZlbnRzVFN0YXRlQ29tbWl0bWVudFZldG9lZAAACAEYaGVpZ2h0dQYBSFN0YXRlTWFjaGluZUhlaWdodAABJGZpc2hlcm1hbjgBHFZlYzx1OD4AAL0PAAACwQ8AwQ8AAAQIsQ9ZAQDFDwh8Y3VtdWx1c19wYWxsZXRfcGFyYWNoYWluX3N5c3RlbTxSZWxheUNoYWluU3RhdGUAAAgBGG51bWJlchABYHJlbGF5X2NoYWluOjpCbG9ja051bWJlcgABKHN0YXRlX3Jvb3Q0AURyZWxheV9jaGFpbjo6SGFzaAAAyQ8EGFJlc3VsdAgEVAGQBEUBCQgBCAhPawQAkAAAAAAMRXJyBAAJCAAAAQAAzQ8EGE9wdGlvbgQEVAEJCAEIEE5vbmUAAAAQU29tZQQACQgAAAEAANEPAAACCQgA1Q8IPGh5ZHJhZHhfcnVudGltZTBSdW50aW1lRXJyb3IAAQEBGFN5c3RlbQQA/QgBcGZyYW1lX3N5c3RlbTo6RXJyb3I8UnVudGltZT4AAQAgQmFsYW5jZXMEAEEJAXxwYWxsZXRfYmFsYW5jZXM6OkVycm9yPFJ1bnRpbWU+AAcAXE11bHRpVHJhbnNhY3Rpb25QYXltZW50BABJCQHAcGFsbGV0X3RyYW5zYWN0aW9uX211bHRpX3BheW1lbnQ6OkVycm9yPFJ1bnRpbWU+AMsAIFRyZWFzdXJ5BABhCQF8cGFsbGV0X3RyZWFzdXJ5OjpFcnJvcjxSdW50aW1lPgALABxVdGlsaXR5BABlCQF4cGFsbGV0X3V0aWxpdHk6OkVycm9yPFJ1bnRpbWU+AA0AIFByZWltYWdlBACNCQF8cGFsbGV0X3ByZWltYWdlOjpFcnJvcjxSdW50aW1lPgAPACBJZGVudGl0eQQAzQkBfHBhbGxldF9pZGVudGl0eTo6RXJyb3I8UnVudGltZT4AEQAkRGVtb2NyYWN5BAARCgGAcGFsbGV0X2RlbW9jcmFjeTo6RXJyb3I8UnVudGltZT4AEwBIVGVjaG5pY2FsQ29tbWl0dGVlBAAdCgH8cGFsbGV0X2NvbGxlY3RpdmU6OkVycm9yPFJ1bnRpbWUsIHBhbGxldF9jb2xsZWN0aXZlOjpJbnN0YW5jZTI+ABkAFFByb3h5BABBCgFwcGFsbGV0X3Byb3h5OjpFcnJvcjxSdW50aW1lPgAdACBNdWx0aXNpZwQAUQoBfHBhbGxldF9tdWx0aXNpZzo6RXJyb3I8UnVudGltZT4AHwAcVW5pcXVlcwQAdQoBeHBhbGxldF91bmlxdWVzOjpFcnJvcjxSdW50aW1lPgAgAEhTdGF0ZVRyaWVNaWdyYXRpb24EAPgBrHBhbGxldF9zdGF0ZV90cmllX21pZ3JhdGlvbjo6RXJyb3I8UnVudGltZT4AIwBAQ29udmljdGlvblZvdGluZwQAqQoBoHBhbGxldF9jb252aWN0aW9uX3ZvdGluZzo6RXJyb3I8UnVudGltZT4AJAAkUmVmZXJlbmRhBADpCgGAcGFsbGV0X3JlZmVyZW5kYTo6RXJyb3I8UnVudGltZT4AJQAkV2hpdGVsaXN0BADtCgGAcGFsbGV0X3doaXRlbGlzdDo6RXJyb3I8UnVudGltZT4AJwAoRGlzcGF0Y2hlcgQA8QoBhHBhbGxldF9kaXNwYXRjaGVyOjpFcnJvcjxSdW50aW1lPgAoADRBc3NldFJlZ2lzdHJ5BAD5CgGUcGFsbGV0X2Fzc2V0X3JlZ2lzdHJ5OjpFcnJvcjxSdW50aW1lPgAzABhDbGFpbXMEAP0KAXRwYWxsZXRfY2xhaW1zOjpFcnJvcjxSdW50aW1lPgA1ADxDb2xsYXRvclJld2FyZHMEAAkLAZxwYWxsZXRfY29sbGF0b3JfcmV3YXJkczo6RXJyb3I8UnVudGltZT4AOQAgT21uaXBvb2wEABULAXxwYWxsZXRfb21uaXBvb2w6OkVycm9yPFJ1bnRpbWU+ADsAQFRyYW5zYWN0aW9uUGF1c2UEACELAaBwYWxsZXRfdHJhbnNhY3Rpb25fcGF1c2U6OkVycm9yPFJ1bnRpbWU+ADwAGER1c3RlcgQAJQsBdHBhbGxldF9kdXN0ZXI6OkVycm9yPFJ1bnRpbWU+AD0ATE9tbmlwb29sV2FyZWhvdXNlTE0EAEkLAUkBd2FyZWhvdXNlX2xpcXVpZGl0eV9taW5pbmc6OkVycm9yPFJ1bnRpbWUsIHdhcmVob3VzZV9saXF1aWRpdHlfbWluaW5nOjoKSW5zdGFuY2UxPgA+AFxPbW5pcG9vbExpcXVpZGl0eU1pbmluZwQAUQsBwHBhbGxldF9vbW5pcG9vbF9saXF1aWRpdHlfbWluaW5nOjpFcnJvcjxSdW50aW1lPgA/AAxPVEMEAF0LAWhwYWxsZXRfb3RjOjpFcnJvcjxSdW50aW1lPgBAADhDaXJjdWl0QnJlYWtlcgQAbQsBmHBhbGxldF9jaXJjdWl0X2JyZWFrZXI6OkVycm9yPFJ1bnRpbWU+AEEAGFJvdXRlcgQAcQsBlHBhbGxldF9yb3V0ZV9leGVjdXRvcjo6RXJyb3I8UnVudGltZT4AQwAsRHluYW1pY0ZlZXMEAHkLAYxwYWxsZXRfZHluYW1pY19mZWVzOjpFcnJvcjxSdW50aW1lPgBEABxTdGFraW5nBACdCwF4cGFsbGV0X3N0YWtpbmc6OkVycm9yPFJ1bnRpbWU+AEUAKFN0YWJsZXN3YXAEAL0LAYRwYWxsZXRfc3RhYmxlc3dhcDo6RXJyb3I8UnVudGltZT4ARgAUQm9uZHMEAMULAXBwYWxsZXRfYm9uZHM6OkVycm9yPFJ1bnRpbWU+AEcAOE90Y1NldHRsZW1lbnRzBADJCwGYcGFsbGV0X290Y19zZXR0bGVtZW50czo6RXJyb3I8UnVudGltZT4ASAAMTEJQBADNCwFocGFsbGV0X2xicDo6RXJyb3I8UnVudGltZT4ASQAMWFlLBADRCwFocGFsbGV0X3h5azo6RXJyb3I8UnVudGltZT4ASgAkUmVmZXJyYWxzBADhCwGAcGFsbGV0X3JlZmVycmFsczo6RXJyb3I8UnVudGltZT4ASwAsTGlxdWlkYXRpb24EAOULAYhwYWxsZXRfbGlxdWlkYXRpb246OkVycm9yPFJ1bnRpbWU+AEwADEhTTQQA7QsBaHBhbGxldF9oc206OkVycm9yPFJ1bnRpbWU+AFIAGFRva2VucwQADQwBbG9ybWxfdG9rZW5zOjpFcnJvcjxSdW50aW1lPgBNAChDdXJyZW5jaWVzBAARDAGEcGFsbGV0X2N1cnJlbmNpZXM6OkVycm9yPFJ1bnRpbWU+AE8AHFZlc3RpbmcEABkMAXBvcm1sX3Zlc3Rpbmc6OkVycm9yPFJ1bnRpbWU+AFEADEVWTQQAJQwBaHBhbGxldF9ldm06OkVycm9yPFJ1bnRpbWU+AFoAIEV0aGVyZXVtBABlDAF8cGFsbGV0X2V0aGVyZXVtOjpFcnJvcjxSdW50aW1lPgBcACxFVk1BY2NvdW50cwQAaQwBjHBhbGxldF9ldm1fYWNjb3VudHM6OkVycm9yPFJ1bnRpbWU+AF0ASFhZS0xpcXVpZGl0eU1pbmluZwQAbQwBrHBhbGxldF94eWtfbGlxdWlkaXR5X21pbmluZzo6RXJyb3I8UnVudGltZT4AXwA4WFlLV2FyZWhvdXNlTE0EAI0MAUkBd2FyZWhvdXNlX2xpcXVpZGl0eV9taW5pbmc6OkVycm9yPFJ1bnRpbWUsIHdhcmVob3VzZV9saXF1aWRpdHlfbWluaW5nOjoKSW5zdGFuY2UyPgBgADhSZWxheUNoYWluSW5mbwQAkQwBmHBhbGxldF9yZWxheWNoYWluX2luZm86OkVycm9yPFJ1bnRpbWU+AMkADERDQQQAnQwBaHBhbGxldF9kY2E6OkVycm9yPFJ1bnRpbWU+AEIAJFNjaGVkdWxlcgQAtQwBgHBhbGxldF9zY2hlZHVsZXI6OkVycm9yPFJ1bnRpbWU+AAUAPFBhcmFjaGFpblN5c3RlbQQAHQ0BvGN1bXVsdXNfcGFsbGV0X3BhcmFjaGFpbl9zeXN0ZW06OkVycm9yPFJ1bnRpbWU+AGcALFBvbGthZG90WGNtBABtDQFocGFsbGV0X3hjbTo6RXJyb3I8UnVudGltZT4AawAkWGNtcFF1ZXVlBACZDQGkY3VtdWx1c19wYWxsZXRfeGNtcF9xdWV1ZTo6RXJyb3I8UnVudGltZT4AbwAwTWVzc2FnZVF1ZXVlBAC1DQGQcGFsbGV0X21lc3NhZ2VfcXVldWU6OkVycm9yPFJ1bnRpbWU+AHIAHE9ybWxYY20EALkNAWBvcm1sX3hjbTo6RXJyb3I8UnVudGltZT4AhwAcWFRva2VucwQAvQ0BcG9ybWxfeHRva2Vuczo6RXJyb3I8UnVudGltZT4AiQA0VW5rbm93blRva2VucwQAyQ0BjG9ybWxfdW5rbm93bl90b2tlbnM6OkVycm9yPFJ1bnRpbWU+AIsARENvbGxhdG9yU2VsZWN0aW9uBADZDQGkcGFsbGV0X2NvbGxhdG9yX3NlbGVjdGlvbjo6RXJyb3I8UnVudGltZT4AowAcU2Vzc2lvbgQA7Q0BeHBhbGxldF9zZXNzaW9uOjpFcnJvcjxSdW50aW1lPgClABBJc21wBAABDgFscGFsbGV0X2lzbXA6OkVycm9yPFJ1bnRpbWU+ALQANElzbXBQYXJhY2hhaW4EAAUOAXhpc21wX3BhcmFjaGFpbjo6RXJyb3I8UnVudGltZT4AtQAsSHlwZXJicmlkZ2UEAAkOAYhwYWxsZXRfaHlwZXJicmlkZ2U6OkVycm9yPFJ1bnRpbWU+ALYAMFRva2VuR2F0ZXdheQQAEQ4BkHBhbGxldF90b2tlbl9nYXRld2F5OjpFcnJvcjxSdW50aW1lPgC3ACRFbWFPcmFjbGUEAE0OAYRwYWxsZXRfZW1hX29yYWNsZTo6RXJyb3I8UnVudGltZT4AygAkQnJvYWRjYXN0BABVDgGAcGFsbGV0X2Jyb2FkY2FzdDo6RXJyb3I8UnVudGltZT4AzAAAMQEYU3lzdGVtARhTeXN0ZW1IHEFjY291bnQBAQQCAAxBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACABOggVGhlIGZ1bGwgYWNjb3VudCBpbmZvcm1hdGlvbiBmb3IgYSBwYXJ0aWN1bGFyIGFjY291bnQgSUQuOEV4dHJpbnNpY0NvdW50AAAQBAAEuCBUb3RhbCBleHRyaW5zaWNzIGNvdW50IGZvciB0aGUgY3VycmVudCBibG9jay5ASW5oZXJlbnRzQXBwbGllZAEAIAQABKQgV2hldGhlciBhbGwgaW5oZXJlbnRzIGhhdmUgYmVlbiBhcHBsaWVkLixCbG9ja1dlaWdodAEAJBgAAAAAAAAEiCBUaGUgY3VycmVudCB3ZWlnaHQgZm9yIHRoZSBibG9jay5AQWxsRXh0cmluc2ljc0xlbgAAEAQABEEBIFRvdGFsIGxlbmd0aCAoaW4gYnl0ZXMpIGZvciBhbGwgZXh0cmluc2ljcyBwdXQgdG9nZXRoZXIsIGZvciB0aGUgY3VycmVudCBibG9jay4kQmxvY2tIYXNoAQEEBRA0gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJggTWFwIG9mIGJsb2NrIG51bWJlcnMgdG8gYmxvY2sgaGFzaGVzLjRFeHRyaW5zaWNEYXRhAQEEBRA4BAAEPQEgRXh0cmluc2ljcyBkYXRhIGZvciB0aGUgY3VycmVudCBibG9jayAobWFwcyBhbiBleHRyaW5zaWMncyBpbmRleCB0byBpdHMgZGF0YSkuGE51bWJlcgEAEBAAAAAABAkBIFRoZSBjdXJyZW50IGJsb2NrIG51bWJlciBiZWluZyBwcm9jZXNzZWQuIFNldCBieSBgZXhlY3V0ZV9ibG9ja2AuKFBhcmVudEhhc2gBADSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEcCBIYXNoIG9mIHRoZSBwcmV2aW91cyBibG9jay4YRGlnZXN0AQA8BAAE8CBEaWdlc3Qgb2YgdGhlIGN1cnJlbnQgYmxvY2ssIGFsc28gcGFydCBvZiB0aGUgYmxvY2sgaGVhZGVyLhhFdmVudHMBAEwEABygIEV2ZW50cyBkZXBvc2l0ZWQgZm9yIHRoZSBjdXJyZW50IGJsb2NrLgAdASBOT1RFOiBUaGUgaXRlbSBpcyB1bmJvdW5kIGFuZCBzaG91bGQgdGhlcmVmb3JlIG5ldmVyIGJlIHJlYWQgb24gY2hhaW4u0CBJdCBjb3VsZCBvdGhlcndpc2UgaW5mbGF0ZSB0aGUgUG9WIHNpemUgb2YgYSBibG9jay4ALQEgRXZlbnRzIGhhdmUgYSBsYXJnZSBpbi1tZW1vcnkgc2l6ZS4gQm94IHRoZSBldmVudHMgdG8gbm90IGdvIG91dC1vZi1tZW1vcnn8IGp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIHJlYWRzIHRoZW0gZnJvbSB3aXRoaW4gdGhlIHJ1bnRpbWUuKEV2ZW50Q291bnQBABAQAAAAAAS4IFRoZSBudW1iZXIgb2YgZXZlbnRzIGluIHRoZSBgRXZlbnRzPFQ+YCBsaXN0LixFdmVudFRvcGljcwEBBAI0UQMEACglASBNYXBwaW5nIGJldHdlZW4gYSB0b3BpYyAocmVwcmVzZW50ZWQgYnkgVDo6SGFzaCkgYW5kIGEgdmVjdG9yIG9mIGluZGV4ZXOUIG9mIGV2ZW50cyBpbiB0aGUgYDxFdmVudHM8VD4+YCBsaXN0LgBRASBBbGwgdG9waWMgdmVjdG9ycyBoYXZlIGRldGVybWluaXN0aWMgc3RvcmFnZSBsb2NhdGlvbnMgZGVwZW5kaW5nIG9uIHRoZSB0b3BpYy4gVGhpc0UBIGFsbG93cyBsaWdodC1jbGllbnRzIHRvIGxldmVyYWdlIHRoZSBjaGFuZ2VzIHRyaWUgc3RvcmFnZSB0cmFja2luZyBtZWNoYW5pc20gYW5k5CBpbiBjYXNlIG9mIGNoYW5nZXMgZmV0Y2ggdGhlIGxpc3Qgb2YgZXZlbnRzIG9mIGludGVyZXN0LgBZASBUaGUgdmFsdWUgaGFzIHRoZSB0eXBlIGAoQmxvY2tOdW1iZXJGb3I8VD4sIEV2ZW50SW5kZXgpYCBiZWNhdXNlIGlmIHdlIHVzZWQgb25seSBqdXN0TQEgdGhlIGBFdmVudEluZGV4YCB0aGVuIGluIGNhc2UgaWYgdGhlIHRvcGljIGhhcyB0aGUgc2FtZSBjb250ZW50cyBvbiB0aGUgbmV4dCBibG9jawEBIG5vIG5vdGlmaWNhdGlvbiB3aWxsIGJlIHRyaWdnZXJlZCB0aHVzIHRoZSBldmVudCBtaWdodCBiZSBsb3N0LkhMYXN0UnVudGltZVVwZ3JhZGUAAM0IBAAEVQEgU3RvcmVzIHRoZSBgc3BlY192ZXJzaW9uYCBhbmQgYHNwZWNfbmFtZWAgb2Ygd2hlbiB0aGUgbGFzdCBydW50aW1lIHVwZ3JhZGUgaGFwcGVuZWQuVFVwZ3JhZGVkVG9VMzJSZWZDb3VudAEAIAQABE0BIFRydWUgaWYgd2UgaGF2ZSB1cGdyYWRlZCBzbyB0aGF0IGB0eXBlIFJlZkNvdW50YCBpcyBgdTMyYC4gRmFsc2UgKGRlZmF1bHQpIGlmIG5vdC5gVXBncmFkZWRUb1RyaXBsZVJlZkNvdW50AQAgBAAIXQEgVHJ1ZSBpZiB3ZSBoYXZlIHVwZ3JhZGVkIHNvIHRoYXQgQWNjb3VudEluZm8gY29udGFpbnMgdGhyZWUgdHlwZXMgb2YgYFJlZkNvdW50YC4gRmFsc2VIIChkZWZhdWx0KSBpZiBub3QuOEV4ZWN1dGlvblBoYXNlAADJCAQABIggVGhlIGV4ZWN1dGlvbiBwaGFzZSBvZiB0aGUgYmxvY2suREF1dGhvcml6ZWRVcGdyYWRlAADRCAQABLggYFNvbWVgIGlmIGEgY29kZSB1cGdyYWRlIGhhcyBiZWVuIGF1dGhvcml6ZWQuARUBAVgYMEJsb2NrV2VpZ2h0c9UImQFiTRhsAAsAIEqp0QECAEABAxBNhF/psAEL8NY3O1EBGk/nAAELAJj3Pl0BAgDwAAEAAAMQTYRf6bABC/BeiqXFARpPNwEBCwAgSqnRAQIAQAEBBwCIUmp0AgBQAAMQTYRf6bAAAAAE0CBCbG9jayAmIGV4dHJpbnNpY3Mgd2VpZ2h0czogYmFzZSB2YWx1ZXMgYW5kIGxpbWl0cy4sQmxvY2tMZW5ndGjhCDAAADwAAABQAAAAUAAEqCBUaGUgbWF4aW11bSBsZW5ndGggb2YgYSBibG9jayAoaW4gYnl0ZXMpLjhCbG9ja0hhc2hDb3VudBAQYAkAAARVASBNYXhpbXVtIG51bWJlciBvZiBibG9jayBudW1iZXIgdG8gYmxvY2sgaGFzaCBtYXBwaW5ncyB0byBrZWVwIChvbGRlc3QgcHJ1bmVkIGZpcnN0KS4gRGJXZWlnaHTpCEBAeH0BAAAAAADh9QUAAAAABAkBIFRoZSB3ZWlnaHQgb2YgcnVudGltZSBkYXRhYmFzZSBvcGVyYXRpb25zIHRoZSBydW50aW1lIGNhbiBpbnZva2UuHFZlcnNpb27tCAkFHGh5ZHJhZHgcaHlkcmFkeAEAAABoAQAAAAAAAGDfastomQdgmwUAAAA345f8fJH15AIAAABA/jrUAfiVmgYAAADSvJiX7tCPFQMAAAD3iyeL5T9FTAIAAACrPAVyKR/riwEAAADdcY1cxTJi1AEAAADqk+Pxbz1pYgIAAACa+GdRtwwRLQEAAAC8nYmQT1uSPwEAAAA3yLsTUKmiqAQAAABYIhH2W7FLiQUAAADmWwDkbO3QqgIAAAALtnpS/NBA/wEAAABUIzT+T9fK2gEAAABv9S7oWObFvQEAAADXvdiicsoNZQEAAACRscixYyjrkgEAAACf+1BapzjWnAEAAAArX1vNJGDk8AEAAACisrSE/LhpQwEAAAAOvI/YSuIK2gEAAABdHfL+fU9ryAEAAAD7xXe510fv1gEAAAABAAAAAQSEIEdldCB0aGUgY2hhaW4ncyBpbi1jb2RlIHZlcnNpb24uKFNTNThQcmVmaXjICAAAFKggVGhlIGRlc2lnbmF0ZWQgU1M1OCBwcmVmaXggb2YgdGhpcyBjaGFpbi4AOQEgVGhpcyByZXBsYWNlcyB0aGUgInNzNThGb3JtYXQiIHByb3BlcnR5IGRlY2xhcmVkIGluIHRoZSBjaGFpbiBzcGVjLiBSZWFzb24gaXMxASB0aGF0IHRoZSBydW50aW1lIHNob3VsZCBrbm93IGFib3V0IHRoZSBwcmVmaXggaW4gb3JkZXIgdG8gbWFrZSB1c2Ugb2YgaXQgYXNwIGFuIGlkZW50aWZpZXIgb2YgdGhlIGNoYWluLgH9CAEAJFRpbWVzdGFtcAEkVGltZXN0YW1wCAxOb3cBADAgAAAAAAAAAAAEoCBUaGUgY3VycmVudCB0aW1lIGZvciB0aGUgY3VycmVudCBibG9jay4kRGlkVXBkYXRlAQAgBAAQ2CBXaGV0aGVyIHRoZSB0aW1lc3RhbXAgaGFzIGJlZW4gdXBkYXRlZCBpbiB0aGlzIGJsb2NrLgBVASBUaGlzIHZhbHVlIGlzIHVwZGF0ZWQgdG8gYHRydWVgIHVwb24gc3VjY2Vzc2Z1bCBzdWJtaXNzaW9uIG9mIGEgdGltZXN0YW1wIGJ5IGEgbm9kZS5FASBJdCBpcyB0aGVuIGNoZWNrZWQgYXQgdGhlIGVuZCBvZiBlYWNoIGJsb2NrIGV4ZWN1dGlvbiBpbiB0aGUgYG9uX2ZpbmFsaXplYCBob29rLgElAQAENE1pbmltdW1QZXJpb2QwILgLAAAAAAAAGIwgVGhlIG1pbmltdW0gcGVyaW9kIGJldHdlZW4gYmxvY2tzLgBNASBCZSBhd2FyZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IHRvIHRoZSAqZXhwZWN0ZWQqIHBlcmlvZCB0aGF0IHRoZSBibG9jayBwcm9kdWN0aW9uSQEgYXBwYXJhdHVzIHByb3ZpZGVzLiBZb3VyIGNob3NlbiBjb25zZW5zdXMgc3lzdGVtIHdpbGwgZ2VuZXJhbGx5IHdvcmsgd2l0aCB0aGlzIHRvYQEgZGV0ZXJtaW5lIGEgc2Vuc2libGUgYmxvY2sgdGltZS4gRm9yIGV4YW1wbGUsIGluIHRoZSBBdXJhIHBhbGxldCBpdCB3aWxsIGJlIGRvdWJsZSB0aGlzcCBwZXJpb2Qgb24gZGVmYXVsdCBzZXR0aW5ncy4AAwAgQmFsYW5jZXMBIEJhbGFuY2VzHDRUb3RhbElzc3VhbmNlAQAYQAAAAAAAAAAAAAAAAAAAAAAEmCBUaGUgdG90YWwgdW5pdHMgaXNzdWVkIGluIHRoZSBzeXN0ZW0uQEluYWN0aXZlSXNzdWFuY2UBABhAAAAAAAAAAAAAAAAAAAAAAAQJASBUaGUgdG90YWwgdW5pdHMgb2Ygb3V0c3RhbmRpbmcgZGVhY3RpdmF0ZWQgYmFsYW5jZSBpbiB0aGUgc3lzdGVtLhxBY2NvdW50AQEEAgAUAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAYAkBIFRoZSBCYWxhbmNlcyBwYWxsZXQgZXhhbXBsZSBvZiBzdG9yaW5nIHRoZSBiYWxhbmNlIG9mIGFuIGFjY291bnQuACggIyBFeGFtcGxlADQgYGBgbm9jb21waWxlsCAgaW1wbCBwYWxsZXRfYmFsYW5jZXM6OkNvbmZpZyBmb3IgUnVudGltZSB7GQIgICAgdHlwZSBBY2NvdW50U3RvcmUgPSBTdG9yYWdlTWFwU2hpbTxTZWxmOjpBY2NvdW50PFJ1bnRpbWU+LCBmcmFtZV9zeXN0ZW06OlByb3ZpZGVyPFJ1bnRpbWU+LCBBY2NvdW50SWQsIFNlbGY6OkFjY291bnREYXRhPEJhbGFuY2U+PgwgIH0QIGBgYAAVASBZb3UgY2FuIGFsc28gc3RvcmUgdGhlIGJhbGFuY2Ugb2YgYW4gYWNjb3VudCBpbiB0aGUgYFN5c3RlbWAgcGFsbGV0LgAoICMgRXhhbXBsZQA0IGBgYG5vY29tcGlsZbAgIGltcGwgcGFsbGV0X2JhbGFuY2VzOjpDb25maWcgZm9yIFJ1bnRpbWUge3QgICB0eXBlIEFjY291bnRTdG9yZSA9IFN5c3RlbQwgIH0QIGBgYABRASBCdXQgdGhpcyBjb21lcyB3aXRoIHRyYWRlb2Zmcywgc3RvcmluZyBhY2NvdW50IGJhbGFuY2VzIGluIHRoZSBzeXN0ZW0gcGFsbGV0IHN0b3Jlc20BIGBmcmFtZV9zeXN0ZW1gIGRhdGEgYWxvbmdzaWRlIHRoZSBhY2NvdW50IGRhdGEgY29udHJhcnkgdG8gc3RvcmluZyBhY2NvdW50IGJhbGFuY2VzIGluIHRoZSkBIGBCYWxhbmNlc2AgcGFsbGV0LCB3aGljaCB1c2VzIGEgYFN0b3JhZ2VNYXBgIHRvIHN0b3JlIGJhbGFuY2VzIGRhdGEgb25seS5BASBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSB0aGF0IHRoaXMgcGFsbGV0IGlzIHVzZWQgdG8gc3RvcmUgYmFsYW5jZXMuFExvY2tzAQEEAgABCQQAELggQW55IGxpcXVpZGl0eSBsb2NrcyBvbiBzb21lIGFjY291bnQgYmFsYW5jZXMuJQEgTk9URTogU2hvdWxkIG9ubHkgYmUgYWNjZXNzZWQgd2hlbiBzZXR0aW5nLCBjaGFuZ2luZyBhbmQgZnJlZWluZyBhIGxvY2suAK0BIFVzZSBvZiBsb2NrcyBpcyBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBmcmVlemVzLiBTZWUgYGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJpdHl0ZWNoL3N1YnN0cmF0ZS9wdWxsLzEyOTUxL2AgUmVzZXJ2ZXMBAQQCABEJBAAMpCBOYW1lZCByZXNlcnZlcyBvbiBzb21lIGFjY291bnQgYmFsYW5jZXMuALEBIFVzZSBvZiByZXNlcnZlcyBpcyBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBob2xkcy4gU2VlIGBodHRwczovL2dpdGh1Yi5jb20vcGFyaXR5dGVjaC9zdWJzdHJhdGUvcHVsbC8xMjk1MS9gFEhvbGRzAQEEAgAdCQQABGwgSG9sZHMgb24gYWNjb3VudCBiYWxhbmNlcy4cRnJlZXplcwEBBAIANQkEAASIIEZyZWV6ZSBsb2NrcyBvbiBhY2NvdW50IGJhbGFuY2VzLgEpAQF8EEhFeGlzdGVudGlhbERlcG9zaXQYQAAQpdToAAAAAAAAAAAAAAAgQQEgVGhlIG1pbmltdW0gYW1vdW50IHJlcXVpcmVkIHRvIGtlZXAgYW4gYWNjb3VudCBvcGVuLiBNVVNUIEJFIEdSRUFURVIgVEhBTiBaRVJPIQBZASBJZiB5b3UgKnJlYWxseSogbmVlZCBpdCB0byBiZSB6ZXJvLCB5b3UgY2FuIGVuYWJsZSB0aGUgZmVhdHVyZSBgaW5zZWN1cmVfemVyb19lZGAgZm9yYQEgdGhpcyBwYWxsZXQuIEhvd2V2ZXIsIHlvdSBkbyBzbyBhdCB5b3VyIG93biByaXNrOiB0aGlzIHdpbGwgb3BlbiB1cCBhIG1ham9yIERvUyB2ZWN0b3IuWQEgSW4gY2FzZSB5b3UgaGF2ZSBtdWx0aXBsZSBzb3VyY2VzIG9mIHByb3ZpZGVyIHJlZmVyZW5jZXMsIHlvdSBtYXkgYWxzbyBnZXQgdW5leHBlY3RlZIwgYmVoYXZpb3VyIGlmIHlvdSBzZXQgdGhpcyB0byB6ZXJvLgDwIEJvdHRvbSBsaW5lOiBEbyB5b3Vyc2VsZiBhIGZhdm91ciBhbmQgbWFrZSBpdCBhdCBsZWFzdCBvbmUhIE1heExvY2tzEBAyAAAAEPQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGxvY2tzIHRoYXQgc2hvdWxkIGV4aXN0IG9uIGFuIGFjY291bnQu3CBOb3Qgc3RyaWN0bHkgZW5mb3JjZWQsIGJ1dCB1c2VkIGZvciB3ZWlnaHQgZXN0aW1hdGlvbi4ArQEgVXNlIG9mIGxvY2tzIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGZyZWV6ZXMuIFNlZSBgaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc3Vic3RyYXRlL3B1bGwvMTI5NTEvYCxNYXhSZXNlcnZlcxAQMgAAAAwNASBUaGUgbWF4aW11bSBudW1iZXIgb2YgbmFtZWQgcmVzZXJ2ZXMgdGhhdCBjYW4gZXhpc3Qgb24gYW4gYWNjb3VudC4AsQEgVXNlIG9mIHJlc2VydmVzIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGhvbGRzLiBTZWUgYGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJpdHl0ZWNoL3N1YnN0cmF0ZS9wdWxsLzEyOTUxL2AoTWF4RnJlZXplcxAQAAAAAARhASBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5kaXZpZHVhbCBmcmVlemUgbG9ja3MgdGhhdCBjYW4gZXhpc3Qgb24gYW4gYWNjb3VudCBhdCBhbnkgdGltZS4BQQkHAEhUcmFuc2FjdGlvblBheW1lbnQBSFRyYW5zYWN0aW9uUGF5bWVudAhETmV4dEZlZU11bHRpcGxpZXIBAD0BQAAAZKeztuANAAAAAAAAAAAAOFN0b3JhZ2VWZXJzaW9uAQBFCQQAAAABhARgT3BlcmF0aW9uYWxGZWVNdWx0aXBsaWVyCAQAVFkBIEEgZmVlIG11bHRpcGxpZXIgZm9yIGBPcGVyYXRpb25hbGAgZXh0cmluc2ljcyB0byBjb21wdXRlICJ2aXJ0dWFsIHRpcCIgdG8gYm9vc3QgdGhlaXIsIGBwcmlvcml0eWAAUQEgVGhpcyB2YWx1ZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZSBgZmluYWxfZmVlYCB0byBvYnRhaW4gYSAidmlydHVhbCB0aXAiIHRoYXQgaXMgbGF0ZXL0IGFkZGVkIHRvIGEgdGlwIGNvbXBvbmVudCBpbiByZWd1bGFyIGBwcmlvcml0eWAgY2FsY3VsYXRpb25zLk0BIEl0IG1lYW5zIHRoYXQgYSBgTm9ybWFsYCB0cmFuc2FjdGlvbiBjYW4gZnJvbnQtcnVuIGEgc2ltaWxhcmx5LXNpemVkIGBPcGVyYXRpb25hbGBBASBleHRyaW5zaWMgKHdpdGggbm8gdGlwKSwgYnkgaW5jbHVkaW5nIGEgdGlwIHZhbHVlIGdyZWF0ZXIgdGhhbiB0aGUgdmlydHVhbCB0aXAuADwgYGBgcnVzdCxpZ25vcmVAIC8vIEZvciBgTm9ybWFsYIwgbGV0IHByaW9yaXR5ID0gcHJpb3JpdHlfY2FsYyh0aXApOwBUIC8vIEZvciBgT3BlcmF0aW9uYWxgEQEgbGV0IHZpcnR1YWxfdGlwID0gKGluY2x1c2lvbl9mZWUgKyB0aXApICogT3BlcmF0aW9uYWxGZWVNdWx0aXBsaWVyO8QgbGV0IHByaW9yaXR5ID0gcHJpb3JpdHlfY2FsYyh0aXAgKyB2aXJ0dWFsX3RpcCk7ECBgYGAAUQEgTm90ZSB0aGF0IHNpbmNlIHdlIHVzZSBgZmluYWxfZmVlYCB0aGUgbXVsdGlwbGllciBhcHBsaWVzIGFsc28gdG8gdGhlIHJlZ3VsYXIgYHRpcGBdASBzZW50IHdpdGggdGhlIHRyYW5zYWN0aW9uLiBTbywgbm90IG9ubHkgZG9lcyB0aGUgdHJhbnNhY3Rpb24gZ2V0IGEgcHJpb3JpdHkgYnVtcCBiYXNlZGEBIG9uIHRoZSBgaW5jbHVzaW9uX2ZlZWAsIGJ1dCB3ZSBhbHNvIGFtcGxpZnkgdGhlIGltcGFjdCBvZiB0aXBzIGFwcGxpZWQgdG8gYE9wZXJhdGlvbmFsYDggdHJhbnNhY3Rpb25zLgAJAFxNdWx0aVRyYW5zYWN0aW9uUGF5bWVudAFcTXVsdGlUcmFuc2FjdGlvblBheW1lbnQQSEFjY291bnRDdXJyZW5jeU1hcAABBAIAEAQABFQgQWNjb3VudCBjdXJyZW5jeSBtYXBIQWNjZXB0ZWRDdXJyZW5jaWVzAAEEBRA9AQQABGUBIEN1cmF0ZWQgbGlzdCBvZiBjdXJyZW5jaWVzIHdoaWNoIGZlZXMgY2FuIGJlIHBhaWQgbWFwcGVkIHRvIGNvcnJlc3BvbmRpbmcgZmFsbGJhY2sgcHJpY2VUQWNjZXB0ZWRDdXJyZW5jeVByaWNlAAEEBRA9AQQABCECIEFzc2V0IHByaWNlcyBmcm9tIHRoZSBzcG90IHByaWNlIHByb3ZpZGVyIG9yIHRoZSBmYWxsYmFjayBwcmljZSBpZiB0aGUgcHJpY2UgaXMgbm90IGF2YWlsYWJsZS4gVXBkYXRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGV2ZXJ5IGJsb2NrLmxUcmFuc2FjdGlvbkN1cnJlbmN5T3ZlcnJpZGUAAQQFABAEAAABOQEBiAw0TmF0aXZlQXNzZXRJZBAQAAAAAAQ0IE5hdGl2ZSBBc3NldFRQb2xrYWRvdE5hdGl2ZUFzc2V0SWQQEAUAAAAEcCBQb2xrYWRvdCBOYXRpdmUgQXNzZXQgKERPVCkoRXZtQXNzZXRJZBAQFAAAAAQoIEVWTSBBc3NldAFJCcsAIFRyZWFzdXJ5ASBUcmVhc3VyeRg0UHJvcG9zYWxDb3VudAEAEBAAAAAABKQgTnVtYmVyIG9mIHByb3Bvc2FscyB0aGF0IGhhdmUgYmVlbiBtYWRlLiRQcm9wb3NhbHMAAQQFEE0JBAAEfCBQcm9wb3NhbHMgdGhhdCBoYXZlIGJlZW4gbWFkZS4sRGVhY3RpdmF0ZWQBABhAAAAAAAAAAAAAAAAAAAAAAATwIFRoZSBhbW91bnQgd2hpY2ggaGFzIGJlZW4gcmVwb3J0ZWQgYXMgaW5hY3RpdmUgdG8gQ3VycmVuY3kuJEFwcHJvdmFscwEAUQkEAAT4IFByb3Bvc2FsIGluZGljZXMgdGhhdCBoYXZlIGJlZW4gYXBwcm92ZWQgYnV0IG5vdCB5ZXQgYXdhcmRlZC4oU3BlbmRDb3VudAEAEBAAAAAABKQgVGhlIGNvdW50IG9mIHNwZW5kcyB0aGF0IGhhdmUgYmVlbiBtYWRlLhhTcGVuZHMAAQQFEFUJBAAE0CBTcGVuZHMgdGhhdCBoYXZlIGJlZW4gYXBwcm92ZWQgYW5kIGJlaW5nIHByb2Nlc3NlZC4BUQEBjBQsU3BlbmRQZXJpb2QQEEA4AAAEiCBQZXJpb2QgYmV0d2VlbiBzdWNjZXNzaXZlIHNwZW5kcy4QQnVybiEDEAAAAAAEEQEgUGVyY2VudGFnZSBvZiBzcGFyZSBmdW5kcyAoaWYgYW55KSB0aGF0IGFyZSBidXJudCBwZXIgc3BlbmQgcGVyaW9kLiBQYWxsZXRJZF0JIHB5L3Ryc3J5BBkBIFRoZSB0cmVhc3VyeSdzIHBhbGxldCBpZCwgdXNlZCBmb3IgZGVyaXZpbmcgaXRzIHNvdmVyZWlnbiBhY2NvdW50IElELjBNYXhBcHByb3ZhbHMQEGQAAAAMFQEgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFwcHJvdmFscyB0aGF0IGNhbiB3YWl0IGluIHRoZSBzcGVuZGluZyBxdWV1ZS4ATQEgTk9URTogVGhpcyBwYXJhbWV0ZXIgaXMgYWxzbyB1c2VkIHdpdGhpbiB0aGUgQm91bnRpZXMgUGFsbGV0IGV4dGVuc2lvbiBpZiBlbmFibGVkLjBQYXlvdXRQZXJpb2QQEICXBgAEGQEgVGhlIHBlcmlvZCBkdXJpbmcgd2hpY2ggYW4gYXBwcm92ZWQgdHJlYXN1cnkgc3BlbmQgaGFzIHRvIGJlIGNsYWltZWQuAWEJCwAcVXRpbGl0eQABXQEBlARMYmF0Y2hlZF9jYWxsc19saW1pdBAQqioAAASoIFRoZSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGJhdGNoZWQgY2FsbHMuAWUJDQAgUHJlaW1hZ2UBIFByZWltYWdlDCRTdGF0dXNGb3IAAQQGNGkJBAAEkCBUaGUgcmVxdWVzdCBzdGF0dXMgb2YgYSBnaXZlbiBoYXNoLkBSZXF1ZXN0U3RhdHVzRm9yAAEEBjR1CQQABJAgVGhlIHJlcXVlc3Qgc3RhdHVzIG9mIGEgZ2l2ZW4gaGFzaC4sUHJlaW1hZ2VGb3IAAQQGhQmJCQQAAAHFAQGcAAGNCQ8AIElkZW50aXR5ASBJZGVudGl0eRwoSWRlbnRpdHlPZgABBAUAkQkEABBpASBJbmZvcm1hdGlvbiB0aGF0IGlzIHBlcnRpbmVudCB0byBpZGVudGlmeSB0aGUgZW50aXR5IGJlaGluZCBhbiBhY2NvdW50LiBGaXJzdCBpdGVtIGlzIHRoZeAgcmVnaXN0cmF0aW9uLCBzZWNvbmQgaXMgdGhlIGFjY291bnQncyBwcmltYXJ5IHVzZXJuYW1lLgDAIFRXT1gtTk9URTogT0sg4oCVIGBBY2NvdW50SWRgIGlzIGEgc2VjdXJlIGhhc2guHFN1cGVyT2YAAQQCAGUCBAAIYQEgVGhlIHN1cGVyLWlkZW50aXR5IG9mIGFuIGFsdGVybmF0aXZlICJzdWIiIGlkZW50aXR5IHRvZ2V0aGVyIHdpdGggaXRzIG5hbWUsIHdpdGhpbiB0aGF0UQEgY29udGV4dC4gSWYgdGhlIGFjY291bnQgaXMgbm90IHNvbWUgb3RoZXIgYWNjb3VudCdzIHN1Yi1pZGVudGl0eSwgdGhlbiBqdXN0IGBOb25lYC4YU3Vic09mAQEEBQCpCUQAAAAAAAAAAAAAAAAAAAAAABS4IEFsdGVybmF0aXZlICJzdWIiIGlkZW50aXRpZXMgb2YgdGhpcyBhY2NvdW50LgAdASBUaGUgZmlyc3QgaXRlbSBpcyB0aGUgZGVwb3NpdCwgdGhlIHNlY29uZCBpcyBhIHZlY3RvciBvZiB0aGUgYWNjb3VudHMuAMAgVFdPWC1OT1RFOiBPSyDigJUgYEFjY291bnRJZGAgaXMgYSBzZWN1cmUgaGFzaC4oUmVnaXN0cmFycwEAsQkEABBNASBUaGUgc2V0IG9mIHJlZ2lzdHJhcnMuIE5vdCBleHBlY3RlZCB0byBnZXQgdmVyeSBiaWcgYXMgY2FuIG9ubHkgYmUgYWRkZWQgdGhyb3VnaCBhqCBzcGVjaWFsIG9yaWdpbiAobGlrZWx5IGEgY291bmNpbCBtb3Rpb24pLgApASBUaGUgaW5kZXggaW50byB0aGlzIGNhbiBiZSBjYXN0IHRvIGBSZWdpc3RyYXJJbmRleGAgdG8gZ2V0IGEgdmFsaWQgdmFsdWUuTFVzZXJuYW1lQXV0aG9yaXRpZXMAAQQFAMEJBAAE9CBBIG1hcCBvZiB0aGUgYWNjb3VudHMgd2hvIGFyZSBhdXRob3JpemVkIHRvIGdyYW50IHVzZXJuYW1lcy5EQWNjb3VudE9mVXNlcm5hbWUAAQQCpAAEABRtASBSZXZlcnNlIGxvb2t1cCBmcm9tIGB1c2VybmFtZWAgdG8gdGhlIGBBY2NvdW50SWRgIHRoYXQgaGFzIHJlZ2lzdGVyZWQgaXQuIFRoZSB2YWx1ZSBzaG91bGRlASBiZSBhIGtleSBpbiB0aGUgYElkZW50aXR5T2ZgIG1hcCwgYnV0IGl0IG1heSBub3QgaWYgdGhlIHVzZXIgaGFzIGNsZWFyZWQgdGhlaXIgaWRlbnRpdHkuAGkBIE11bHRpcGxlIHVzZXJuYW1lcyBtYXkgbWFwIHRvIHRoZSBzYW1lIGBBY2NvdW50SWRgLCBidXQgYElkZW50aXR5T2ZgIHdpbGwgb25seSBtYXAgdG8gb25lSCBwcmltYXJ5IHVzZXJuYW1lLkBQZW5kaW5nVXNlcm5hbWVzAAEEAqTJCQQAGG0BIFVzZXJuYW1lcyB0aGF0IGFuIGF1dGhvcml0eSBoYXMgZ3JhbnRlZCwgYnV0IHRoYXQgdGhlIGFjY291bnQgY29udHJvbGxlciBoYXMgbm90IGNvbmZpcm1lZHEBIHRoYXQgdGhleSB3YW50IGl0LiBVc2VkIHByaW1hcmlseSBpbiBjYXNlcyB3aGVyZSB0aGUgYEFjY291bnRJZGAgY2Fubm90IHByb3ZpZGUgYSBzaWduYXR1cmVdASBiZWNhdXNlIHRoZXkgYXJlIGEgcHVyZSBwcm94eSwgbXVsdGlzaWcsIGV0Yy4gSW4gb3JkZXIgdG8gY29uZmlybSBpdCwgdGhleSBzaG91bGQgY2FsbGwgW2BDYWxsOjphY2NlcHRfdXNlcm5hbWVgXS4AHQEgRmlyc3QgdHVwbGUgaXRlbSBpcyB0aGUgYWNjb3VudCBhbmQgc2Vjb25kIGlzIHRoZSBhY2NlcHRhbmNlIGRlYWRsaW5lLgHNAQGgIDBCYXNpY0RlcG9zaXQYQABAY1K/xgEAAAAAAAAAAAAE2CBUaGUgYW1vdW50IGhlbGQgb24gZGVwb3NpdCBmb3IgYSByZWdpc3RlcmVkIGlkZW50aXR5LixCeXRlRGVwb3NpdBhAAKByThgJAAAAAAAAAAAAAAQdASBUaGUgYW1vdW50IGhlbGQgb24gZGVwb3NpdCBwZXIgZW5jb2RlZCBieXRlIGZvciBhIHJlZ2lzdGVyZWQgaWRlbnRpdHkuRFN1YkFjY291bnREZXBvc2l0GEAAQGNSv8YBAAAAAAAAAAAADGUBIFRoZSBhbW91bnQgaGVsZCBvbiBkZXBvc2l0IGZvciBhIHJlZ2lzdGVyZWQgc3ViYWNjb3VudC4gVGhpcyBzaG91bGQgYWNjb3VudCBmb3IgdGhlIGZhY3RlASB0aGF0IG9uZSBzdG9yYWdlIGl0ZW0ncyB2YWx1ZSB3aWxsIGluY3JlYXNlIGJ5IHRoZSBzaXplIG9mIGFuIGFjY291bnQgSUQsIGFuZCB0aGVyZSB3aWxsNQEgYmUgYW5vdGhlciB0cmllIGl0ZW0gd2hvc2UgdmFsdWUgaXMgdGhlIHNpemUgb2YgYW4gYWNjb3VudCBJRCBwbHVzIDMyIGJ5dGVzLjhNYXhTdWJBY2NvdW50cxAQZAAAAAQNASBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3ViLWFjY291bnRzIGFsbG93ZWQgcGVyIGlkZW50aWZpZWQgYWNjb3VudC40TWF4UmVnaXN0cmFycxAQFAAAAAhNASBNYXhpbXVtIG51bWJlciBvZiByZWdpc3RyYXJzIGFsbG93ZWQgaW4gdGhlIHN5c3RlbS4gTmVlZGVkIHRvIGJvdW5kIHRoZSBjb21wbGV4aXR5fCBvZiwgZS5nLiwgdXBkYXRpbmcganVkZ2VtZW50cy5kUGVuZGluZ1VzZXJuYW1lRXhwaXJhdGlvbhAQwIkBAAQVASBUaGUgbnVtYmVyIG9mIGJsb2NrcyB3aXRoaW4gd2hpY2ggYSB1c2VybmFtZSBncmFudCBtdXN0IGJlIGFjY2VwdGVkLjxNYXhTdWZmaXhMZW5ndGgQEAcAAAAEgCBUaGUgbWF4aW11bSBsZW5ndGggb2YgYSBzdWZmaXguRE1heFVzZXJuYW1lTGVuZ3RoEBAgAAAABGEBIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIHVzZXJuYW1lLCBpbmNsdWRpbmcgaXRzIHN1ZmZpeCBhbmQgYW55IHN5c3RlbS1hZGRlZCBkZWxpbWl0ZXJzLgHNCREAJERlbW9jcmFjeQEkRGVtb2NyYWN5MDxQdWJsaWNQcm9wQ291bnQBABAQAAAAAAT0IFRoZSBudW1iZXIgb2YgKHB1YmxpYykgcHJvcG9zYWxzIHRoYXQgaGF2ZSBiZWVuIG1hZGUgc28gZmFyLixQdWJsaWNQcm9wcwEA0QkEAAQFASBUaGUgcHVibGljIHByb3Bvc2Fscy4gVW5zb3J0ZWQuIFRoZSBzZWNvbmQgaXRlbSBpcyB0aGUgcHJvcG9zYWwuJERlcG9zaXRPZgABBAUQ3QkEAAyEIFRob3NlIHdobyBoYXZlIGxvY2tlZCBhIGRlcG9zaXQuANggVFdPWC1OT1RFOiBTYWZlLCBhcyBpbmNyZWFzaW5nIGludGVnZXIga2V5cyBhcmUgc2FmZS48UmVmZXJlbmR1bUNvdW50AQAQEAAAAAAEMQEgVGhlIG5leHQgZnJlZSByZWZlcmVuZHVtIGluZGV4LCBha2EgdGhlIG51bWJlciBvZiByZWZlcmVuZGEgc3RhcnRlZCBzbyBmYXIuNExvd2VzdFVuYmFrZWQBABAQAAAAAAglASBUaGUgbG93ZXN0IHJlZmVyZW5kdW0gaW5kZXggcmVwcmVzZW50aW5nIGFuIHVuYmFrZWQgcmVmZXJlbmR1bS4gRXF1YWwgdG/cIGBSZWZlcmVuZHVtQ291bnRgIGlmIHRoZXJlIGlzbid0IGEgdW5iYWtlZCByZWZlcmVuZHVtLkBSZWZlcmVuZHVtSW5mb09mAAEEBRDlCQQADLQgSW5mb3JtYXRpb24gY29uY2VybmluZyBhbnkgZ2l2ZW4gcmVmZXJlbmR1bS4ACQEgVFdPWC1OT1RFOiBTQUZFIGFzIGluZGV4ZXMgYXJlIG5vdCB1bmRlciBhbiBhdHRhY2tlcuKAmXMgY29udHJvbC4gVm90aW5nT2YBAQQFAPEJ2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBdASBBbGwgdm90ZXMgZm9yIGEgcGFydGljdWxhciB2b3Rlci4gV2Ugc3RvcmUgdGhlIGJhbGFuY2UgZm9yIHRoZSBudW1iZXIgb2Ygdm90ZXMgdGhhdCB3ZV0BIGhhdmUgcmVjb3JkZWQuIFRoZSBzZWNvbmQgaXRlbSBpcyB0aGUgdG90YWwgYW1vdW50IG9mIGRlbGVnYXRpb25zLCB0aGF0IHdpbGwgYmUgYWRkZWQuAOggVFdPWC1OT1RFOiBTQUZFIGFzIGBBY2NvdW50SWRgcyBhcmUgY3J5cHRvIGhhc2hlcyBhbnl3YXkuVExhc3RUYWJsZWRXYXNFeHRlcm5hbAEAIAQACFkBIFRydWUgaWYgdGhlIGxhc3QgcmVmZXJlbmR1bSB0YWJsZWQgd2FzIHN1Ym1pdHRlZCBleHRlcm5hbGx5LiBGYWxzZSBpZiBpdCB3YXMgYSBwdWJsaWMoIHByb3Bvc2FsLjBOZXh0RXh0ZXJuYWwAAAkKBAAQWQEgVGhlIHJlZmVyZW5kdW0gdG8gYmUgdGFibGVkIHdoZW5ldmVyIGl0IHdvdWxkIGJlIHZhbGlkIHRvIHRhYmxlIGFuIGV4dGVybmFsIHByb3Bvc2FsLlUBIFRoaXMgaGFwcGVucyB3aGVuIGEgcmVmZXJlbmR1bSBuZWVkcyB0byBiZSB0YWJsZWQgYW5kIG9uZSBvZiB0d28gY29uZGl0aW9ucyBhcmUgbWV0OqQgLSBgTGFzdFRhYmxlZFdhc0V4dGVybmFsYCBpcyBgZmFsc2VgOyBvcmggLSBgUHVibGljUHJvcHNgIGlzIGVtcHR5LiRCbGFja2xpc3QAAQQGNA0KBAAIUQEgQSByZWNvcmQgb2Ygd2hvIHZldG9lZCB3aGF0LiBNYXBzIHByb3Bvc2FsIGhhc2ggdG8gYSBwb3NzaWJsZSBleGlzdGVudCBibG9jayBudW1iZXLoICh1bnRpbCB3aGVuIGl0IG1heSBub3QgYmUgcmVzdWJtaXR0ZWQpIGFuZCB3aG8gdmV0b2VkIGl0LjRDYW5jZWxsYXRpb25zAQEEBjQgBAAEKQEgUmVjb3JkIG9mIGFsbCBwcm9wb3NhbHMgdGhhdCBoYXZlIGJlZW4gc3ViamVjdCB0byBlbWVyZ2VuY3kgY2FuY2VsbGF0aW9uLihNZXRhZGF0YU9mAAEEArg0BAAY7CBHZW5lcmFsIGluZm9ybWF0aW9uIGNvbmNlcm5pbmcgYW55IHByb3Bvc2FsIG9yIHJlZmVyZW5kdW0uSQEgVGhlIGBIYXNoYCByZWZlcnMgdG8gdGhlIHByZWltYWdlIG9mIHRoZSBgUHJlaW1hZ2VzYCBwcm92aWRlciB3aGljaCBjYW4gYmUgYSBKU09OiCBkdW1wIG9yIElQRlMgaGFzaCBvZiBhIEpTT04gZmlsZS4AdQEgQ29uc2lkZXIgYSBnYXJiYWdlIGNvbGxlY3Rpb24gZm9yIGEgbWV0YWRhdGEgb2YgZmluaXNoZWQgcmVmZXJlbmR1bXMgdG8gYHVucmVxdWVzdGAgKHJlbW92ZSlEIGxhcmdlIHByZWltYWdlcy4BfQIBqDA8RW5hY3RtZW50UGVyaW9kEBBAOAAAFOggVGhlIHBlcmlvZCBiZXR3ZWVuIGEgcHJvcG9zYWwgYmVpbmcgYXBwcm92ZWQgYW5kIGVuYWN0ZWQuADEBIEl0IHNob3VsZCBnZW5lcmFsbHkgYmUgYSBsaXR0bGUgbW9yZSB0aGFuIHRoZSB1bnN0YWtlIHBlcmlvZCB0byBlbnN1cmUgdGhhdFEBIHZvdGluZyBzdGFrZXJzIGhhdmUgYW4gb3Bwb3J0dW5pdHkgdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGUgc3lzdGVtIGluIHRoZSBjYXNltCB3aGVyZSB0aGV5IGFyZSBvbiB0aGUgbG9zaW5nIHNpZGUgb2YgYSB2b3RlLjBMYXVuY2hQZXJpb2QQEMCoAAAE5CBIb3cgb2Z0ZW4gKGluIGJsb2NrcykgbmV3IHB1YmxpYyByZWZlcmVuZGEgYXJlIGxhdW5jaGVkLjBWb3RpbmdQZXJpb2QQEMCoAAAEuCBIb3cgb2Z0ZW4gKGluIGJsb2NrcykgdG8gY2hlY2sgZm9yIG5ldyB2b3Rlcy5EVm90ZUxvY2tpbmdQZXJpb2QQEIBRAQAQkCBUaGUgbWluaW11bSBwZXJpb2Qgb2Ygdm90ZSBsb2NraW5nLgBlASBJdCBzaG91bGQgYmUgbm8gc2hvcnRlciB0aGFuIGVuYWN0bWVudCBwZXJpb2QgdG8gZW5zdXJlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXBwcm92YWwsSQEgdGhvc2Ugc3VjY2Vzc2Z1bCB2b3RlcnMgYXJlIGxvY2tlZCBpbnRvIHRoZSBjb25zZXF1ZW5jZXMgdGhhdCB0aGVpciB2b3RlcyBlbnRhaWwuOE1pbmltdW1EZXBvc2l0GEAAAIpdeEVjAQAAAAAAAAAABDUBIFRoZSBtaW5pbXVtIGFtb3VudCB0byBiZSB1c2VkIGFzIGEgZGVwb3NpdCBmb3IgYSBwdWJsaWMgcmVmZXJlbmR1bSBwcm9wb3NhbC44SW5zdGFudEFsbG93ZWQgBAEMVQEgSW5kaWNhdG9yIGZvciB3aGV0aGVyIGFuIGVtZXJnZW5jeSBvcmlnaW4gaXMgZXZlbiBhbGxvd2VkIHRvIGhhcHBlbi4gU29tZSBjaGFpbnMgbWF5YQEgd2FudCB0byBzZXQgdGhpcyBwZXJtYW5lbnRseSB0byBgZmFsc2VgLCBvdGhlcnMgbWF5IHdhbnQgdG8gY29uZGl0aW9uIGl0IG9uIHRoaW5ncyBzdWNooCBhcyBhbiB1cGdyYWRlIGhhdmluZyBoYXBwZW5lZCByZWNlbnRseS5URmFzdFRyYWNrVm90aW5nUGVyaW9kEBAIBwAABOwgTWluaW11bSB2b3RpbmcgcGVyaW9kIGFsbG93ZWQgZm9yIGEgZmFzdC10cmFjayByZWZlcmVuZHVtLjRDb29sb2ZmUGVyaW9kEBDAiQEABGEBIFBlcmlvZCBpbiBibG9ja3Mgd2hlcmUgYW4gZXh0ZXJuYWwgcHJvcG9zYWwgbWF5IG5vdCBiZSByZS1zdWJtaXR0ZWQgYWZ0ZXIgYmVpbmcgdmV0b2VkLiBNYXhWb3RlcxAQZAAAABCwIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2b3RlcyBmb3IgYW4gYWNjb3VudC4A1CBBbHNvIHVzZWQgdG8gY29tcHV0ZSB3ZWlnaHQsIGFuIG92ZXJseSBiaWcgdmFsdWUgY2FuFQEgbGVhZCB0byBleHRyaW5zaWMgd2l0aCB2ZXJ5IGJpZyB3ZWlnaHQ6IHNlZSBgZGVsZWdhdGVgIGZvciBpbnN0YW5jZS4wTWF4UHJvcG9zYWxzEBBkAAAABA0BIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwdWJsaWMgcHJvcG9zYWxzIHRoYXQgY2FuIGV4aXN0IGF0IGFueSB0aW1lLixNYXhEZXBvc2l0cxAQZAAAAAQdASBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVwb3NpdHMgYSBwdWJsaWMgcHJvcG9zYWwgbWF5IGhhdmUgYXQgYW55IHRpbWUuOE1heEJsYWNrbGlzdGVkEBBkAAAABNggVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHdoaWNoIGNhbiBiZSBibGFja2xpc3RlZC4BEQoTAEhUZWNobmljYWxDb21taXR0ZWUBSFRlY2huaWNhbENvbW1pdHRlZRgkUHJvcG9zYWxzAQAVCgQABJAgVGhlIGhhc2hlcyBvZiB0aGUgYWN0aXZlIHByb3Bvc2Fscy4oUHJvcG9zYWxPZgABBAY0EQEEAATMIEFjdHVhbCBwcm9wb3NhbCBmb3IgYSBnaXZlbiBoYXNoLCBpZiBpdCdzIGN1cnJlbnQuGFZvdGluZwABBAY0GQoEAAS0IFZvdGVzIG9uIGEgZ2l2ZW4gcHJvcG9zYWwsIGlmIGl0IGlzIG9uZ29pbmcuNFByb3Bvc2FsQ291bnQBABAQAAAAAARIIFByb3Bvc2FscyBzbyBmYXIuHE1lbWJlcnMBADEBBAAEOQEgVGhlIGN1cnJlbnQgbWVtYmVycyBvZiB0aGUgY29sbGVjdGl2ZS4gVGhpcyBpcyBzdG9yZWQgc29ydGVkIChqdXN0IGJ5IHZhbHVlKS4UUHJpbWUAAAAEAARhASBUaGUgcHJpbWUgbWVtYmVyIHRoYXQgaGVscHMgZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IHZvdGUgYmVoYXZpb3IgaW4gY2FzZSBvZiBhYnN0ZW50aW9ucy4BiQIBvARETWF4UHJvcG9zYWxXZWlnaHQoKAcAEKXU6AIAoAAEJQEgVGhlIG1heGltdW0gd2VpZ2h0IG9mIGEgZGlzcGF0Y2ggY2FsbCB0aGF0IGNhbiBiZSBwcm9wb3NlZCBhbmQgZXhlY3V0ZWQuAR0KGQAUUHJveHkBFFByb3h5CBxQcm94aWVzAQEEBQAhCkQAAAAAAAAAAAAAAAAAAAAAAAhFASBUaGUgc2V0IG9mIGFjY291bnQgcHJveGllcy4gTWFwcyB0aGUgYWNjb3VudCB3aGljaCBoYXMgZGVsZWdhdGVkIHRvIHRoZSBhY2NvdW50cyEBIHdoaWNoIGFyZSBiZWluZyBkZWxlZ2F0ZWQgdG8sIHRvZ2V0aGVyIHdpdGggdGhlIGFtb3VudCBoZWxkIG9uIGRlcG9zaXQuNEFubm91bmNlbWVudHMBAQQFADEKRAAAAAAAAAAAAAAAAAAAAAAABKwgVGhlIGFubm91bmNlbWVudHMgbWFkZSBieSB0aGUgcHJveHkgKGtleSkuAY0CAcAYQFByb3h5RGVwb3NpdEJhc2UYQADgEQIetgAAAAAAAAAAAAAQEQEgVGhlIGJhc2UgYW1vdW50IG9mIGN1cnJlbmN5IG5lZWRlZCB0byByZXNlcnZlIGZvciBjcmVhdGluZyBhIHByb3h5LgABASBUaGlzIGlzIGhlbGQgZm9yIGFuIGFkZGl0aW9uYWwgc3RvcmFnZSBpdGVtIHdob3NlIHZhbHVlIHNpemUgaXMlASBgc2l6ZW9mKEJhbGFuY2UpYCBieXRlcyBhbmQgd2hvc2Uga2V5IHNpemUgaXMgYHNpemVvZihBY2NvdW50SWQpYCBieXRlcy5IUHJveHlEZXBvc2l0RmFjdG9yGEAALJmA5gAAAAAAAAAAAAAAFLwgVGhlIGFtb3VudCBvZiBjdXJyZW5jeSBuZWVkZWQgcGVyIHByb3h5IGFkZGVkLgA1ASBUaGlzIGlzIGhlbGQgZm9yIGFkZGluZyAzMiBieXRlcyBwbHVzIGFuIGluc3RhbmNlIG9mIGBQcm94eVR5cGVgIG1vcmUgaW50byBhYQEgcHJlLWV4aXN0aW5nIHN0b3JhZ2UgdmFsdWUuIFRodXMsIHdoZW4gY29uZmlndXJpbmcgYFByb3h5RGVwb3NpdEZhY3RvcmAgb25lIHNob3VsZCB0YWtl9CBpbnRvIGFjY291bnQgYDMyICsgcHJveHlfdHlwZS5lbmNvZGUoKS5sZW4oKWAgYnl0ZXMgb2YgZGF0YS4oTWF4UHJveGllcxAQIAAAAATwIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBwcm94aWVzIGFsbG93ZWQgZm9yIGEgc2luZ2xlIGFjY291bnQuKE1heFBlbmRpbmcQECAAAAAERQEgVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUtZGVsYXllZCBhbm5vdW5jZW1lbnRzIHRoYXQgYXJlIGFsbG93ZWQgdG8gYmUgcGVuZGluZy5cQW5ub3VuY2VtZW50RGVwb3NpdEJhc2UYQADgEQIetgAAAAAAAAAAAAAQMQEgVGhlIGJhc2UgYW1vdW50IG9mIGN1cnJlbmN5IG5lZWRlZCB0byByZXNlcnZlIGZvciBjcmVhdGluZyBhbiBhbm5vdW5jZW1lbnQuAEkBIFRoaXMgaXMgaGVsZCB3aGVuIGEgbmV3IHN0b3JhZ2UgaXRlbSBob2xkaW5nIGEgYEJhbGFuY2VgIGlzIGNyZWF0ZWQgKHR5cGljYWxseSAxNiAgYnl0ZXMpLmRBbm5vdW5jZW1lbnREZXBvc2l0RmFjdG9yGEAAWDIBzQEAAAAAAAAAAAAAENQgVGhlIGFtb3VudCBvZiBjdXJyZW5jeSBuZWVkZWQgcGVyIGFubm91bmNlbWVudCBtYWRlLgBZASBUaGlzIGlzIGhlbGQgZm9yIGFkZGluZyBhbiBgQWNjb3VudElkYCwgYEhhc2hgIGFuZCBgQmxvY2tOdW1iZXJgICh0eXBpY2FsbHkgNjggYnl0ZXMpjCBpbnRvIGEgcHJlLWV4aXN0aW5nIHN0b3JhZ2UgdmFsdWUuAUEKHQAgTXVsdGlzaWcBIE11bHRpc2lnBCRNdWx0aXNpZ3MAAQgFAkUKSQoEAASUIFRoZSBzZXQgb2Ygb3BlbiBtdWx0aXNpZyBvcGVyYXRpb25zLgGVAgHMDCxEZXBvc2l0QmFzZRhAAKA3zUy4AAAAAAAAAAAAABhZASBUaGUgYmFzZSBhbW91bnQgb2YgY3VycmVuY3kgbmVlZGVkIHRvIHJlc2VydmUgZm9yIGNyZWF0aW5nIGEgbXVsdGlzaWcgZXhlY3V0aW9uIG9yIHRvhCBzdG9yZSBhIGRpc3BhdGNoIGNhbGwgZm9yIGxhdGVyLgABASBUaGlzIGlzIGhlbGQgZm9yIGFuIGFkZGl0aW9uYWwgc3RvcmFnZSBpdGVtIHdob3NlIHZhbHVlIHNpemUgaXMxASBgNCArIHNpemVvZigoQmxvY2tOdW1iZXIsIEJhbGFuY2UsIEFjY291bnRJZCkpYCBieXRlcyBhbmQgd2hvc2Uga2V5IHNpemUgaXOAIGAzMiArIHNpemVvZihBY2NvdW50SWQpYCBieXRlcy40RGVwb3NpdEZhY3RvchhAAIB1hN8AAAAAAAAAAAAAAAxVASBUaGUgYW1vdW50IG9mIGN1cnJlbmN5IG5lZWRlZCBwZXIgdW5pdCB0aHJlc2hvbGQgd2hlbiBjcmVhdGluZyBhIG11bHRpc2lnIGV4ZWN1dGlvbi4AJQEgVGhpcyBpcyBoZWxkIGZvciBhZGRpbmcgMzIgYnl0ZXMgbW9yZSBpbnRvIGEgcHJlLWV4aXN0aW5nIHN0b3JhZ2UgdmFsdWUuOE1heFNpZ25hdG9yaWVzEBBkAAAABOwgVGhlIG1heGltdW0gYW1vdW50IG9mIHNpZ25hdG9yaWVzIGFsbG93ZWQgaW4gdGhlIG11bHRpc2lnLgFRCh8AHFVuaXF1ZXMBHFVuaXF1ZXMoFENsYXNzAAEEAhhVCgQABGQgRGV0YWlscyBvZiBhIGNvbGxlY3Rpb24uTE93bmVyc2hpcEFjY2VwdGFuY2UAAQQCABgEAAQpASBUaGUgY29sbGVjdGlvbiwgaWYgYW55LCBvZiB3aGljaCBhbiBhY2NvdW50IGlzIHdpbGxpbmcgdG8gdGFrZSBvd25lcnNoaXAuHEFjY291bnQAAQwCAgJZCpAEAAhZASBUaGUgaXRlbXMgaGVsZCBieSBhbnkgZ2l2ZW4gYWNjb3VudDsgc2V0IG91dCB0aGlzIHdheSBzbyB0aGF0IGl0ZW1zIG93bmVkIGJ5IGEgc2luZ2xlbCBhY2NvdW50IGNhbiBiZSBlbnVtZXJhdGVkLjBDbGFzc0FjY291bnQAAQgCAm0JkAQACGkBIFRoZSBjb2xsZWN0aW9ucyBvd25lZCBieSBhbnkgZ2l2ZW4gYWNjb3VudDsgc2V0IG91dCB0aGlzIHdheSBzbyB0aGF0IGNvbGxlY3Rpb25zIG93bmVkIGJ5kCBhIHNpbmdsZSBhY2NvdW50IGNhbiBiZSBlbnVtZXJhdGVkLhRBc3NldAABCAICKQNdCgQABNAgVGhlIGl0ZW1zIGluIGV4aXN0ZW5jZSBhbmQgdGhlaXIgb3duZXJzaGlwIGRldGFpbHMuPENsYXNzTWV0YWRhdGFPZgABBAIYYQoEAARoIE1ldGFkYXRhIG9mIGEgY29sbGVjdGlvbi5ISW5zdGFuY2VNZXRhZGF0YU9mAAEIAgIpA2UKBAAEVCBNZXRhZGF0YSBvZiBhbiBpdGVtLiRBdHRyaWJ1dGUAAQwCAgJpCm0KBAAEcCBBdHRyaWJ1dGVzIG9mIGEgY29sbGVjdGlvbi4sSXRlbVByaWNlT2YAAQgCAikDcQoEAARwIFByaWNlIG9mIGFuIGFzc2V0IGluc3RhbmNlLkxDb2xsZWN0aW9uTWF4U3VwcGx5AAEEAhgQBAAE8CBLZWVwcyB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGEgY29sbGVjdGlvbiBtaWdodCBoYXZlLgGdAgHUIERDb2xsZWN0aW9uRGVwb3NpdBhAAAAAAAAAAAAAAAAAAAAAAAQBASBUaGUgYmFzaWMgYW1vdW50IG9mIGZ1bmRzIHRoYXQgbXVzdCBiZSByZXNlcnZlZCBmb3IgY29sbGVjdGlvbi4sSXRlbURlcG9zaXQYQAAAAAAAAAAAAAAAAAAAAAAE9CBUaGUgYmFzaWMgYW1vdW50IG9mIGZ1bmRzIHRoYXQgbXVzdCBiZSByZXNlcnZlZCBmb3IgYW4gaXRlbS5MTWV0YWRhdGFEZXBvc2l0QmFzZRhAAIDGpH6NAwAAAAAAAAAAAARNASBUaGUgYmFzaWMgYW1vdW50IG9mIGZ1bmRzIHRoYXQgbXVzdCBiZSByZXNlcnZlZCB3aGVuIGFkZGluZyBtZXRhZGF0YSB0byB5b3VyIGl0ZW0uUEF0dHJpYnV0ZURlcG9zaXRCYXNlGEAAEKXU6AAAAAAAAAAAAAAABFUBIFRoZSBiYXNpYyBhbW91bnQgb2YgZnVuZHMgdGhhdCBtdXN0IGJlIHJlc2VydmVkIHdoZW4gYWRkaW5nIGFuIGF0dHJpYnV0ZSB0byBhbiBpdGVtLjhEZXBvc2l0UGVyQnl0ZRhAABCl1OgAAAAAAAAAAAAAAAhZASBUaGUgYWRkaXRpb25hbCBmdW5kcyB0aGF0IG11c3QgYmUgcmVzZXJ2ZWQgZm9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgc3RvcmUgaW4gbWV0YWRhdGEswCBlaXRoZXIgIm5vcm1hbCIgbWV0YWRhdGEgb3IgYXR0cmlidXRlIG1ldGFkYXRhLixTdHJpbmdMaW1pdBAQSAAAAASwIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiBkYXRhIHN0b3JlZCBvbi1jaGFpbi4gS2V5TGltaXQQEAABAAAEoCBUaGUgbWF4aW11bSBsZW5ndGggb2YgYW4gYXR0cmlidXRlIGtleS4oVmFsdWVMaW1pdBAQAAQAAASoIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhdHRyaWJ1dGUgdmFsdWUuAXUKIABIU3RhdGVUcmllTWlncmF0aW9uAUhTdGF0ZVRyaWVNaWdyYXRpb24MQE1pZ3JhdGlvblByb2Nlc3MBALECOAAAAAAAAAAAAAAAAAAAEFAgTWlncmF0aW9uIHByb2dyZXNzLgBdASBUaGlzIHN0b3JlcyB0aGUgc25hcHNob3Qgb2YgdGhlIGxhc3QgbWlncmF0ZWQga2V5cy4gSXQgY2FuIGJlIHNldCBpbnRvIG1vdGlvbiBhbmQgbW92ZdQgZm9yd2FyZCBieSBhbnkgb2YgdGhlIG1lYW5zIHByb3ZpZGVkIGJ5IHRoaXMgcGFsbGV0LihBdXRvTGltaXRzAQCpAgQADNQgVGhlIGxpbWl0cyB0aGF0IGFyZSBpbXBvc2VkIG9uIGF1dG9tYXRpYyBtaWdyYXRpb25zLgDUIElmIHNldCB0byBOb25lLCB0aGVuIG5vIGF1dG9tYXRpYyBtaWdyYXRpb24gaGFwcGVucy5gU2lnbmVkTWlncmF0aW9uTWF4TGltaXRzAACtAgQADOAgVGhlIG1heGltdW0gbGltaXRzIHRoYXQgdGhlIHNpZ25lZCBtaWdyYXRpb24gY291bGQgdXNlLgC0IElmIG5vdCBzZXQsIG5vIHNpZ25lZCBzdWJtaXNzaW9uIGlzIGFsbG93ZWQuAaUCAfAEJE1heEtleUxlbhAQAAIAAFS0IE1heGltYWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgYSBrZXkgY2FuIGhhdmUuALAgRlJBTUUgaXRzZWxmIGRvZXMgbm90IGxpbWl0IHRoZSBrZXkgbGVuZ3RoLgEBIFRoZSBjb25jcmV0ZSB2YWx1ZSBtdXN0IHRoZXJlZm9yZSBkZXBlbmQgb24geW91ciBzdG9yYWdlIHVzYWdlLlkBIEEgW2BmcmFtZV9zdXBwb3J0OjpzdG9yYWdlOjpTdG9yYWdlTk1hcGBdIGZvciBleGFtcGxlIGNhbiBoYXZlIGFuIGFyYml0cmFyeSBudW1iZXIgb2ZFASBrZXlzIHdoaWNoIGFyZSB0aGVuIGhhc2hlZCBhbmQgY29uY2F0ZW5hdGVkLCByZXN1bHRpbmcgaW4gYXJiaXRyYXJpbHkgbG9uZyBrZXlzLgBBASBVc2UgdGhlICpzdGF0ZSBtaWdyYXRpb24gUlBDKiB0byByZXRyaWV2ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IGtleSBpbiB5b3VyAQEgc3RvcmFnZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJpdHl0ZWNoL3N1YnN0cmF0ZS9pc3N1ZXMvMTE2NDI+ACkBIFRoZSBtaWdyYXRpb24gd2lsbCBoYWx0IHdpdGggYSBgSGFsdGVkYCBldmVudCBpZiB0aGlzIHZhbHVlIGlzIHRvbyBzbWFsbC5JASBTaW5jZSB0aGVyZSBpcyBubyByZWFsIHBlbmFsdHkgZnJvbSBvdmVyLWVzdGltYXRpbmcsIGl0IGlzIGFkdmlzZWQgdG8gdXNlIGEgbGFyZ2WAIHZhbHVlLiBUaGUgZGVmYXVsdCBpcyA1MTIgYnl0ZS4AgCBTb21lIGtleSBsZW5ndGhzIGZvciByZWZlcmVuY2U60CAtIFtgZnJhbWVfc3VwcG9ydDo6c3RvcmFnZTo6U3RvcmFnZVZhbHVlYF06IDMyIGJ5dGXIIC0gW2BmcmFtZV9zdXBwb3J0OjpzdG9yYWdlOjpTdG9yYWdlTWFwYF06IDY0IGJ5dGXgIC0gW2BmcmFtZV9zdXBwb3J0OjpzdG9yYWdlOjpTdG9yYWdlRG91YmxlTWFwYF06IDk2IGJ5dGUASCBGb3IgbW9yZSBpbmZvIHNlZUkBIDxodHRwczovL3d3dy5zaGF3bnRhYnJpemkuY29tL2Jsb2cvc3Vic3RyYXRlL3F1ZXJ5aW5nLXN1YnN0cmF0ZS1zdG9yYWdlLXZpYS1ycGMvPgH4IwBAQ29udmljdGlvblZvdGluZwFAQ29udmljdGlvblZvdGluZwgkVm90aW5nRm9yAQEIBQV5Cn0K2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAh1ASBBbGwgdm90aW5nIGZvciBhIHBhcnRpY3VsYXIgdm90ZXIgaW4gYSBwYXJ0aWN1bGFyIHZvdGluZyBjbGFzcy4gV2Ugc3RvcmUgdGhlIGJhbGFuY2UgZm9yIHRoZZwgbnVtYmVyIG9mIHZvdGVzIHRoYXQgd2UgaGF2ZSByZWNvcmRlZC40Q2xhc3NMb2Nrc0ZvcgEBBAUAnQoEAAxpASBUaGUgdm90aW5nIGNsYXNzZXMgd2hpY2ggaGF2ZSBhIG5vbi16ZXJvIGxvY2sgcmVxdWlyZW1lbnQgYW5kIHRoZSBsb2NrIGFtb3VudHMgd2hpY2ggdGhleW0BIHJlcXVpcmUuIFRoZSBhY3R1YWwgYW1vdW50IGxvY2tlZCBvbiBiZWhhbGYgb2YgdGhpcyBwYWxsZXQgc2hvdWxkIGFsd2F5cyBiZSB0aGUgbWF4aW11bSBvZiwgdGhpcyBsaXN0LgG9AgH8CCBNYXhWb3RlcxAQGQAAABDwIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHZvdGVzIGFuIGFjY291bnQgbWF5IGhhdmUuAFUBIEFsc28gdXNlZCB0byBjb21wdXRlIHdlaWdodCwgYW4gb3Zlcmx5IGxhcmdlIHZhbHVlIGNhbiBsZWFkIHRvIGV4dHJpbnNpY3Mgd2l0aCBsYXJnZcAgd2VpZ2h0IGVzdGltYXRpb246IHNlZSBgZGVsZWdhdGVgIGZvciBpbnN0YW5jZS5EVm90ZUxvY2tpbmdQZXJpb2QQEMCJAQAQkCBUaGUgbWluaW11bSBwZXJpb2Qgb2Ygdm90ZSBsb2NraW5nLgBlASBJdCBzaG91bGQgYmUgbm8gc2hvcnRlciB0aGFuIGVuYWN0bWVudCBwZXJpb2QgdG8gZW5zdXJlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXBwcm92YWwsSQEgdGhvc2Ugc3VjY2Vzc2Z1bCB2b3RlcnMgYXJlIGxvY2tlZCBpbnRvIHRoZSBjb25zZXF1ZW5jZXMgdGhhdCB0aGVpciB2b3RlcyBlbnRhaWwuAakKJAAkUmVmZXJlbmRhASRSZWZlcmVuZGEUPFJlZmVyZW5kdW1Db3VudAEAEBAAAAAABDEBIFRoZSBuZXh0IGZyZWUgcmVmZXJlbmR1bSBpbmRleCwgYWthIHRoZSBudW1iZXIgb2YgcmVmZXJlbmRhIHN0YXJ0ZWQgc28gZmFyLkRSZWZlcmVuZHVtSW5mb0ZvcgABBAIQrQoEAAS0IEluZm9ybWF0aW9uIGNvbmNlcm5pbmcgYW55IGdpdmVuIHJlZmVyZW5kdW0uKFRyYWNrUXVldWUBAQQFyM0KBAAQXQEgVGhlIHNvcnRlZCBsaXN0IG9mIHJlZmVyZW5kYSByZWFkeSB0byBiZSBkZWNpZGVkIGJ1dCBub3QgeWV0IGJlaW5nIGRlY2lkZWQsIG9yZGVyZWQgYnl8IGNvbnZpY3Rpb24td2VpZ2h0ZWQgYXBwcm92YWxzLgBBASBUaGlzIHNob3VsZCBiZSBlbXB0eSBpZiBgRGVjaWRpbmdDb3VudGAgaXMgbGVzcyB0aGFuIGBUcmFja0luZm86Om1heF9kZWNpZGluZ2AuNERlY2lkaW5nQ291bnQBAQQFyBAQAAAAAATEIFRoZSBudW1iZXIgb2YgcmVmZXJlbmRhIGJlaW5nIGRlY2lkZWQgY3VycmVudGx5LihNZXRhZGF0YU9mAAEEAhA0BAAYBQEgVGhlIG1ldGFkYXRhIGlzIGEgZ2VuZXJhbCBpbmZvcm1hdGlvbiBjb25jZXJuaW5nIHRoZSByZWZlcmVuZHVtLkkBIFRoZSBgSGFzaGAgcmVmZXJzIHRvIHRoZSBwcmVpbWFnZSBvZiB0aGUgYFByZWltYWdlc2AgcHJvdmlkZXIgd2hpY2ggY2FuIGJlIGEgSlNPToggZHVtcCBvciBJUEZTIGhhc2ggb2YgYSBKU09OIGZpbGUuAHUBIENvbnNpZGVyIGEgZ2FyYmFnZSBjb2xsZWN0aW9uIGZvciBhIG1ldGFkYXRhIG9mIGZpbmlzaGVkIHJlZmVyZW5kdW1zIHRvIGB1bnJlcXVlc3RgIChyZW1vdmUpRCBsYXJnZSBwcmVpbWFnZXMuAckCAQkBFERTdWJtaXNzaW9uRGVwb3NpdBhAAEB6EPNaAAAAAAAAAAAAAAQ1ASBUaGUgbWluaW11bSBhbW91bnQgdG8gYmUgdXNlZCBhcyBhIGRlcG9zaXQgZm9yIGEgcHVibGljIHJlZmVyZW5kdW0gcHJvcG9zYWwuJE1heFF1ZXVlZBAQZAAAAATkIE1heGltdW0gc2l6ZSBvZiB0aGUgcmVmZXJlbmR1bSBxdWV1ZSBmb3IgYSBzaW5nbGUgdHJhY2suRFVuZGVjaWRpbmdUaW1lb3V0EBCAEwMACFUBIFRoZSBudW1iZXIgb2YgYmxvY2tzIGFmdGVyIHN1Ym1pc3Npb24gdGhhdCBhIHJlZmVyZW5kdW0gbXVzdCBiZWdpbiBiZWluZyBkZWNpZGVkIGJ5LuQgT25jZSB0aGlzIHBhc3NlcywgdGhlbiBhbnlvbmUgbWF5IGNhbmNlbCB0aGUgcmVmZXJlbmR1bS40QWxhcm1JbnRlcnZhbBAQAQAAAAxdASBRdWFudGl6YXRpb24gbGV2ZWwgZm9yIHRoZSByZWZlcmVuZHVtIHdha2V1cCBzY2hlZHVsZXIuIEEgaGlnaGVyIG51bWJlciB3aWxsIHJlc3VsdCBpbl0BIGZld2VyIHN0b3JhZ2UgcmVhZHMvd3JpdGVzIG5lZWRlZCBmb3Igc21hbGxlciB2b3RlcnMsIGJ1dCBhbHNvIHJlc3VsdCBpbiBkZWxheXMgdG8gdGhlVQEgYXV0b21hdGljIHJlZmVyZW5kdW0gc3RhdHVzIGNoYW5nZXMuIEV4cGxpY2l0IHNlcnZpY2luZyBpbnN0cnVjdGlvbnMgYXJlIHVuYWZmZWN0ZWQuGFRyYWNrc9EKmQ4oAAAQcm9vdAMAAAAAAGSns7bgDQAAAAAAAAAAWAIAAMCJAQAgHAAAZAAAAAKQ1z4NAAAAAFdD3hMAAAAAVEPeEwAAAAAAAMqaOwAAAAAAKnUVAQBId2hpdGVsaXN0ZWRfY2FsbGVyAwAAAAAAxS68orEAAAAAAAAAAABkAAAAwKgAAGAJAABkAAAAApDXPg0AAAAAV0PeEwAAAABUQ94TAAAAAALfxwUAAAAAAKIIDAAAAAAATGYrAQAAAAACAFByZWZlcmVuZHVtX2NhbmNlbGxlcgMAAAAAANnprC14AwAAAAAAAAAAWAIAAMCoAABYAgAAZAAAAADbTg8iAGXNHQDKmjsCHex6AAAAAABSIk4BAAAAADS2h///////AwBEcmVmZXJlbmR1bV9raWxsZXIDAAAAAACLvQaJaAoAAAAAAAAAAFgCAADAqAAAWAIAAGQAAAAA204PIgBlzR0Aypo7Ah3segAAAAAAUiJOAQAAAAA0tof//////wQANGdlbmVyYWxfYWRtaW4DAAAAAADZ6awteAMAAAAAAAAAAFgCAADAiQEACAcAAGQAAAACkNc+DQAAAABXQ94TAAAAAFRD3hMAAAAAAhgOxwEAAAAAy8CVBAAAAADqcln+/////wUAJHRyZWFzdXJlcgMAAAAAAIu9BoloCgAAAAAAAAAAWAIAAMCJAQAgHAAAZAAAAAKQ1z4NAAAAAFdD3hMAAAAAVEPeEwAAAAAAAMqaOwAAAAAAlboKBgAcc3BlbmRlcgMAAAAAAIpdeEVjAQAAAAAAAAAAWAIAAMCJAQAIBwAAZAAAAAAAypo7AGXNHQDKmjsCGA7HAQAAAADLwJUEAAAAAOpyWf7/////BwAYdGlwcGVyAwAAAAAAwW/yhiMAAAAAAAAAAABYAgAAwIkBAAgHAABkAAAAANtODyIAZc0dAMqaOwId7HoAAAAAAFIiTgEAAAAANLaH//////8IADhvbW5pcG9vbF9hZG1pbgMAAAAAANnprC14AwAAAAAAAAAAWAIAAMCJAQAIBwAAZAAAAAKQ1z4NAAAAAFdD3hMAAAAAVEPeEwAAAAACGA7HAQAAAADLwJUEAAAAAOpyWf7/////CQBMZWNvbm9taWNfcGFyYW1ldGVycwMAAAAAAIu9BoloCgAAAAAAAAAAWAIAAMCJAQAgHAAAZAAAAAKQ1z4NAAAAAFdD3hMAAAAAVEPeEwAAAAAAAMqaOwAAAAAAlboKBOAgSW5mb3JtYXRpb24gY29uY2VybmluZyB0aGUgZGlmZmVyZW50IHJlZmVyZW5kdW0gdHJhY2tzLgHpCiUAHE9yaWdpbnMAAAAAACYAJFdoaXRlbGlzdAEkV2hpdGVsaXN0BDxXaGl0ZWxpc3RlZENhbGwAAQQFNJAEAAAB0QIBUQcAAe0KJwAoRGlzcGF0Y2hlcgEoRGlzcGF0Y2hlcgxIQWF2ZU1hbmFnZXJBY2NvdW50AQAAgKp+AAAAAAAAAAAAAAAAAAAACqfgAAAAAAAAAAAAAAAAACBFeHRyYUdhcwEAMCAAAAAAAAAAAABUTGFzdEV2bUNhbGxFeGl0UmVhc29uAAD1BwQAAAHVAgFlBwAB8QooADRBc3NldFJlZ2lzdHJ5ATRBc3NldFJlZ2lzdHJ5HBhBc3NldHMAAQQCEPUKBAAEVCBEZXRhaWxzIG9mIGFuIGFzc2V0LixOZXh0QXNzZXRJZAEAEBABAAAABF0BIE5leHQgYXZhaWxhYmxlIGFzc2V0IGlkLiBUaGlzIGlzIHNlcXVlbnRpYWwgaWQgYXNzaWduZWQgZm9yIGVhY2ggbmV3IHJlZ2lzdGVyZWQgYXNzZXQuIEFzc2V0SWRzAAEEAuECEAQABKQgTWFwcGluZyBiZXR3ZWVuIGFzc2V0IG5hbWUgYW5kIGFzc2V0IGlkLjhBc3NldExvY2F0aW9ucwABBAIQ8QIEAAR0IE5hdGl2ZSBsb2NhdGlvbiBvZiBhbiBhc3NldC4wQmFubmVkQXNzZXRzAAEEAhCQBAAEsCBOb24tbmF0aXZlIGFzc2V0cyB3aGljaCB0cmFuc2ZlciBpcyBiYW5uZWQuOExvY2F0aW9uQXNzZXRzAAEEAvECEAQABIQgTG9jYWwgYXNzZXQgZm9yIG5hdGl2ZSBsb2NhdGlvbi5kRXhpc3RlbnRpYWxEZXBvc2l0Q291bnRlcgEAGEAAAAAAAAAAAAAAAAAAAAAACC0BIE51bWJlciBvZiBhY2NvdW50cyB0aGF0IHBhaWQgZXhpc3RlbnRpYWwgZGVwb3NpdHMgZm9yIGluc3VmZmljaWVudCBhc3NldHMusCBUaGlzIHN0b3JhZ2UgaXMgdXNlZCBieSBgU3VmZmljaWVuY3lDaGVja2AuAdkCAWkHEExTZXF1ZW50aWFsSWRTdGFydEF0EBBAQg8AACxTdHJpbmdMaW1pdBAQIAAAAATgIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIG5hbWUgb3Igc3ltYm9sIHN0b3JlZCBvbi1jaGFpbi44TWluU3RyaW5nTGltaXQQEAMAAAAE0CBUaGUgbWluIGxlbmd0aCBvZiBhIG5hbWUgb3Igc3ltYm9sIHN0b3JlZCBvbi1jaGFpbi5sUmVnRXh0ZXJuYWxXZWlnaHRNdWx0aXBsaWVyMCAKAAAAAAAAAATQIFdlaWdodCBtdWx0aXBsaWVyIGZvciBgcmVnaXN0ZXJfZXh0ZXJuYWxgIGV4dHJpbnNpYwH5CjMAGENsYWltcwEYQ2xhaW1zBBhDbGFpbXMBAQQCcQcYQAAAAAAAAAAAAAAAAAAAAAAEnCBBc3NldCBpZCBzdG9yYWdlIGZvciBlYWNoIHNoYXJlZCB0b2tlbgERAwFtBwAB/Qo1ADhHZW5lc2lzSGlzdG9yeQE4R2VuZXNpc0hpc3RvcnkENFByZXZpb3VzQ2hhaW4BAAELAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZAwAAADcAPENvbGxhdG9yUmV3YXJkcwE8Q29sbGF0b3JSZXdhcmRzBCRDb2xsYXRvcnMBAQQFEAULBAAEqCBTdG9yZXMgdGhlIGNvbGxhdG9ycyBwZXIgc2Vzc2lvbiAoaW5kZXgpLgABdQcMRFJld2FyZFBlckNvbGxhdG9yGEB4+ot1KJ4BAAAAAAAAAAAABIAgUmV3YXJkIGFtb3VudCBwZXIgb25lIGNvbGxhdG9yLkBSZXdhcmRDdXJyZW5jeUlkEBAAAAAABEAgUmV3YXJkIEFzc2V0IElkKFJld2FyZHNCYWcAgG1vZGxweS90cnNyeQAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJCzkAIE9tbmlwb29sASBPbW5pcG9vbBAYQXNzZXRzAAEEAhANCwQABIggU3RhdGUgb2YgYW4gYXNzZXQgaW4gdGhlIG9tbmlwb29sTEh1YkFzc2V0VHJhZGFiaWxpdHkBACUDBAEEdCBUcmFkYWJsZSBzdGF0ZSBvZiBodWIgYXNzZXQuJFBvc2l0aW9ucwABBAIYEQsEAAT0IExQIHBvc2l0aW9ucy4gTWFwcyBORlQgaW5zdGFuY2UgaWQgdG8gY29ycmVzcG9uZGluZyBwb3NpdGlvbjhOZXh0UG9zaXRpb25JZAEAGEAAAAAAAAAAAAAAAAAAAAAABFwgUG9zaXRpb24gaWRzIHNlcXVlbmNlcgEdAwF5ByQoSGR4QXNzZXRJZBAQAAAAAARAIE5hdGl2ZSBBc3NldCBJRChIdWJBc3NldElkEBABAAAABDQgSHViIEFzc2V0IElEQE1pbldpdGhkcmF3YWxGZWUhAxBkAAAABFwgTWluaW11bSB3aXRoZHJhd2FsIGZlZUxNaW5pbXVtVHJhZGluZ0xpbWl0GEDoAwAAAAAAAAAAAAAAAAAABFggTWluaW11bSB0cmFkaW5nIGxpbWl0UE1pbmltdW1Qb29sTGlxdWlkaXR5GEBAQg8AAAAAAAAAAAAAAAAABKggTWluaW11bSBwb29sIGxpcXVpZGl0eSB3aGljaCBjYW4gYmUgYWRkZWQoTWF4SW5SYXRpbxhAAwAAAAAAAAAAAAAAAAAAAATwIE1heCBmcmFjdGlvbiBvZiBhc3NldCByZXNlcnZlIHRvIHNlbGwgaW4gc2luZ2xlIHRyYW5zYWN0aW9uLE1heE91dFJhdGlvGEADAAAAAAAAAAAAAAAAAAAABOwgTWF4IGZyYWN0aW9uIG9mIGFzc2V0IHJlc2VydmUgdG8gYnV5IGluIHNpbmdsZSB0cmFuc2FjdGlvbjxORlRDb2xsZWN0aW9uSWQYQDkFAAAAAAAAAAAAAAAAAAAEWCBOb24gZnVuZ2libGUgY2xhc3MgaWQ8QnVyblByb3RvY29sRmVlIQMQIKEHAAABFQs7AEBUcmFuc2FjdGlvblBhdXNlAUBUcmFuc2FjdGlvblBhdXNlBEhQYXVzZWRUcmFuc2FjdGlvbnMAAQQFGQuQBAAMbCBUaGUgcGF1c2VkIHRyYW5zYWN0aW9uIG1hcADcIG1hcCAoUGFsbGV0TmFtZUJ5dGVzLCBGdW5jdGlvbk5hbWVCeXRlcykgPT4gT3B0aW9uPCgpPgEtAwF9BwABIQs8ABhEdXN0ZXIBGER1c3RlcgRAQWNjb3VudFdoaXRlbGlzdAABBAIAkAQABIAgQWNjb3VudHMgZXhjbHVkZWQgZnJvbSBkdXN0aW5nLgExAwGBBwREVHJlYXN1cnlBY2NvdW50SWQAgG1vZGxweS90cnNyeQAAAAAAAAAAAAAAAAAAAAAAAAAABKwgVHJlYXN1cnkgYWNjb3VudCwgd2hpY2ggcmVjZWl2ZXMgdGhlIGR1c3QuASULPQBMT21uaXBvb2xXYXJlaG91c2VMTQFMT21uaXBvb2xXYXJlaG91c2VMTRg0RmFybVNlcXVlbmNlcgEAEBAAAAAABLwgSWQgc2VxdWVuY2VyIGZvciBgR2xvYmFsRmFybWAgYW5kIGBZaWVsZEZhcm1gLkBEZXBvc2l0U2VxdWVuY2VyAQAYQAAAAAAAAAAAAAAAAAAAAAAAKEdsb2JhbEZhcm0AAQQCECkLBAAAJFlpZWxkRmFybQABDAICAjELNQsEAARQIFlpZWxkIGZhcm0gZGV0YWlscy4cRGVwb3NpdAABBAUYOQsEAAREIERlcG9zaXQgZGV0YWlscy48QWN0aXZlWWllbGRGYXJtAAEIAgJNAxAEAAT4IEFjdGl2ZShmYXJtcyBhYmxlIHRvIHJlY2VpdmUgTFAgc2hhcmVzIGRlcG9zaXRzKSB5aWVsZCBmYXJtcy4BNQMBhQcYIFBhbGxldElkXQkgT21uaVdoTE0ELCBQYWxsZXQgaWQuRFRyZWFzdXJ5QWNjb3VudElkAIBtb2RscHkvdHJzcnkAAAAAAAAAAAAAAAAAAAAAAAAAAAToIFRyZWFzdXJ5IGFjY291bnQgdG8gcmVjZWl2ZSBjbGFpbWVkIHJld2FyZHMgbG93ZXIgdGhhbiBFRExNaW5Ub3RhbEZhcm1SZXdhcmRzGEAAEKXU6AAAAAAAAAAAAAAABDkBIE1pbmltdW0gdG90YWwgcmV3YXJkcyB0byBkaXN0cmlidXRlIGZyb20gZ2xvYmFsIGZhcm0gZHVyaW5nIGxpcXVpZGl0eSBtaW5pbmcuZE1pblBsYW5uZWRZaWVsZGluZ1BlcmlvZHMQEGg4AAAE7CBNaW5pbXVtIG51bWJlciBvZiBwZXJpb2RzIHRvIHJ1biBsaXF1aWRpdHkgbWluaW5nIHByb2dyYW0uYE1heEZhcm1FbnRyaWVzUGVyRGVwb3NpdBAQBQAAAAhlASBNYXhpbXVtIG51bWJlciBvZiB5aWVsZCBmYXJtcyBzYW1lIExQIHNoYXJlcyBjYW4gYmUgcmUvZGVwb3NpdGVkIGludG8uIFRoaXMgdmFsdWUgYWx3YXlzXCBNVVNUIEJFID49IDEuICAgICAgICAgaE1heFlpZWxkRmFybXNQZXJHbG9iYWxGYXJtEBAyAAAACE0BIE1heCBudW1iZXIgb2YgeWllbGQgZmFybXMgY2FuIGV4aXN0IGluIGdsb2JhbCBmYXJtLiBUaGlzIGluY2x1ZGVzIGFsbCBmYXJtcyBpbiB0aGWYIHN0b3JhZ2UoYWN0aXZlLCBzdG9wcGVkLCB0ZXJtaW5hdGVkKS4BSQs+AFxPbW5pcG9vbExpcXVpZGl0eU1pbmluZwFcT21uaXBvb2xMaXF1aWRpdHlNaW5pbmcEOE9tbmlQb3NpdGlvbklkAAEEAhgYBAAE0CBNYXAgb2Ygb21uaXBvb2wgcG9zaXRpb24ncyBpZHMgdG8gTE0ncyBkZXBvc2l0IGlkcy4BOQMBiQcMPE5GVENvbGxlY3Rpb25JZBhAGAoAAAAAAAAAAAAAAAAAAATcIE5GVCBjb2xsZWN0aW9uIGlkIGZvciBsaXF1aWRpdHkgbWluaW5nJ3MgZGVwb3NpdCBuZnRzLjBPcmFjbGVTb3VyY2X9ASBvbW5pcG9vbASEIElkZW50aWZpZXIgb2Ygb3JhY2xlIGRhdGEgc29ydWNlME9yYWNsZVBlcmlvZLkDBAIEjCBPcmFjbGUncyBwcmljZSBhZ2dyZWdhdGlvbiBwZXJpb2QuAVELPwAMT1RDAQxPVEMILE5leHRPcmRlcklkAQAQEAAAAAAEYCBJRCBzZXF1ZW5jZXIgZm9yIE9yZGVycxhPcmRlcnMAAQQCEFkLBAAAAW0DAY0HDHBFeGlzdGVudGlhbERlcG9zaXRNdWx0aXBsaWVyCAQFBEEBIE11bHRpcGxpZXIgdXNlZCB0byBjb21wdXRlIG1pbmltYWwgYW1vdW50cyBvZiBhc3NldF9pbiBhbmQgYXNzZXRfb3V0IGluIGFuIE9UQy4MRmVlIQMQ6AMAAAR4IEZlZSBkZWR1Y3RlZCBmcm9tIGFtb3VudF9vdXQuLEZlZVJlY2VpdmVyAIBtb2RscHkvdHJzcnkAAAAAAAAAAAAAAAAAAAAAAAAAAAQ4IEZlZSByZWNlaXZlci4BXQtAADhDaXJjdWl0QnJlYWtlcgE4Q2lyY3VpdEJyZWFrZXIcYFRyYWRlVm9sdW1lTGltaXRQZXJBc3NldAEBBAIQTQMgiBMAABAnAAAI9CBUcmFkZSB2b2x1bWUgbGltaXRzIG9mIGFzc2V0cyBzZXQgYnkgc2V0X3RyYWRlX3ZvbHVtZV9saW1pdC6cIElmIG5vdCBzZXQsIHJldHVybnMgdGhlIGRlZmF1bHQgbGltaXQufEFsbG93ZWRUcmFkZVZvbHVtZUxpbWl0UGVyQXNzZXQAAQQCEGELBAAEYCBUcmFkZSB2b2x1bWVzIHBlciBhc3NldGRMaXF1aWRpdHlBZGRMaW1pdFBlckFzc2V0AQEEAhB1AyQB9AEAABAnAAAIxCBMaXF1aWRpdHkgbGltaXRzIG9mIGFzc2V0cyBmb3IgYWRkaW5nIGxpcXVpZGl0eS6cIElmIG5vdCBzZXQsIHJldHVybnMgdGhlIGRlZmF1bHQgbGltaXQuhEFsbG93ZWRBZGRMaXF1aWRpdHlBbW91bnRQZXJBc3NldAABBAIQZQsEAASAIEFkZCBsaXF1aWRpdHkgdm9sdW1lcyBwZXIgYXNzZXRIQXNzZXRMb2NrZG93blN0YXRlAAEEAhBpCwQAAHBMaXF1aWRpdHlSZW1vdmVMaW1pdFBlckFzc2V0AQEEAhB1AyQB9AEAABAnAAAIzCBMaXF1aWRpdHkgbGltaXRzIG9mIGFzc2V0cyBmb3IgcmVtb3ZpbmcgbGlxdWlkaXR5LpwgSWYgbm90IHNldCwgcmV0dXJucyB0aGUgZGVmYXVsdCBsaW1pdC6QQWxsb3dlZFJlbW92ZUxpcXVpZGl0eUFtb3VudFBlckFzc2V0AAEEAhBlCwQABIwgUmVtb3ZlIGxpcXVpZGl0eSB2b2x1bWVzIHBlciBhc3NldAFxAwGRBwyURGVmYXVsdE1heE5ldFRyYWRlVm9sdW1lTGltaXRQZXJCbG9ja00DIIgTAAAQJwAACDEBIFRoZSBtYXhpbXVtIHBlcmNlbnRhZ2Ugb2YgYSBwb29sJ3MgbGlxdWlkaXR5IHRoYXQgY2FuIGJlIHRyYWRlZCBpbiBhIGJsb2NrLnUBIFJlcHJlc2VudGVkIGFzIGEgbm9uLXplcm8gZnJhY3Rpb24gKG5vbWluYXRvciwgZGVub21pbmF0b3IpIHdpdGggdGhlIG1heCB2YWx1ZSBiZWluZyAxMF8wMDAujERlZmF1bHRNYXhBZGRMaXF1aWRpdHlMaW1pdFBlckJsb2NrdQMkAfQBAAAQJwAADC0BIFRoZSBtYXhpbXVtIHBlcmNlbnRhZ2Ugb2YgYSBwb29sJ3MgbGlxdWlkaXR5IHRoYXQgY2FuIGJlIGFkZGVkIGluIGEgYmxvY2sunQEgUmVwcmVzZW50ZWQgYXMgYW4gb3B0aW9uYWwgbm9uLXplcm8gZnJhY3Rpb24gKG5vbWluYXRvciwgZGVub21pbmF0b3IpIHdpdGggdGhlIG1heCB2YWx1ZSBiZWluZyAxMF8wMDAutCBJZiBzZXQgdG8gTm9uZSwgdGhlIGxpbWl0cyBhcmUgbm90IGVuZm9yY2VkLphEZWZhdWx0TWF4UmVtb3ZlTGlxdWlkaXR5TGltaXRQZXJCbG9ja3UDJAH0AQAAECcAAAw1ASBUaGUgbWF4aW11bSBwZXJjZW50YWdlIG9mIGEgcG9vbCdzIGxpcXVpZGl0eSB0aGF0IGNhbiBiZSByZW1vdmVkIGluIGEgYmxvY2sunQEgUmVwcmVzZW50ZWQgYXMgYW4gb3B0aW9uYWwgbm9uLXplcm8gZnJhY3Rpb24gKG5vbWluYXRvciwgZGVub21pbmF0b3IpIHdpdGggdGhlIG1heCB2YWx1ZSBiZWluZyAxMF8wMDAutCBJZiBzZXQgdG8gTm9uZSwgdGhlIGxpbWl0cyBhcmUgbm90IGVuZm9yY2VkLgFtC0EAGFJvdXRlcgEYUm91dGVyBBhSb3V0ZXMAAQQCjQN9AwQABHwgU3RvcmluZyByb3V0ZXMgZm9yIGFzc2V0IHBhaXJzAXkDAZUHCDROYXRpdmVBc3NldElkEBAAAAAABEAgTmF0aXZlIEFzc2V0IElkME9yYWNsZVBlcmlvZLkDBAIEjCBPcmFjbGUncyBwcmljZSBhZ2dyZWdhdGlvbiBwZXJpb2QuAXELQwAsRHluYW1pY0ZlZXMBLER5bmFtaWNGZWVzCCBBc3NldEZlZQABBAUQdQsEAAhJASBTdG9yZXMgbGFzdCBjYWxjdWxhdGVkIGZlZSBvZiBhbiBhc3NldCBhbmQgYmxvY2sgbnVtYmVyIGluIHdoaWNoIGl0IHdhcyBjaGFuZ2VkLi7IIFN0b3JlZCBhcyAoQXNzZXQgZmVlLCBQcm90b2NvbCBmZWUsIEJsb2NrIG51bWJlcilUQXNzZXRGZWVDb25maWd1cmF0aW9uAAEEBRCVAwQABNggU3RvcmVzIHBlci1hc3NldCBmZWUgY29uZmlndXJhdGlvbiAoRml4ZWQgb3IgRHluYW1pYykBkQMBmQcISEFzc2V0RmVlUGFyYW1ldGVyc5kDoMQJAABQwwAAACA9iHktAAAAAAAAAAAAAAAAyE5nbcEbAAAAAAAAAAAAVFByb3RvY29sRmVlUGFyYW1ldGVyc5kDoPQBAADECQAAAJAexLwWAAAAAAAAAAAAAAAAZKeztuANAAAAAAAAAAAAAXkLRAAcU3Rha2luZwEcU3Rha2luZyAcU3Rha2luZwEAfQvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFggR2xvYmFsIHN0YWtpbmcgc3RhdGUuJFBvc2l0aW9ucwABBAIYgQsEAARcIFVzZXIncyBwb3NpdGlvbiBzdGF0ZS44TmV4dFBvc2l0aW9uSWQBABhAAAAAAAAAAAAAAAAAAAAAAARgIFBvc2l0aW9uIGlkcyBzZXF1ZW5jZXIuFFZvdGVzAQEEAhiFCwQABGAgTGlzdCBvZiBwb3NpdGlvbiB2b3Rlcy40Vm90ZXNSZXdhcmRlZAABCAICyQmRCwQABJ0BIExpc3Qgb2YgcHJvY2Vzc2VkIHZvdGUuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2b3RlIHNob3VsZCBiZSBsb2NrZWQgaW4gY2FzZSBvZiB2b3Rpbmcgbm90IGluIGZhdm9yLjRQb3NpdGlvblZvdGVzAQEEAhiFCwQABGkBIExlZ2FjeSBzdG9yYWdlISAtIFVzZWQgdG8gaGFuZGxlIGRlbW9jcmFjeSB2b3RlcyB1bnRpbCBkZW1vY3JhY3kgcGFsbGV0IGlzIGZ1bGx5IHJlbW92ZWQuOFByb2Nlc3NlZFZvdGVzAAEIAgLJCZELBAAEkQEgTGVnYWN5IHN0b3JhZ2UhIC0gVXNlZCB0byBoYW5kbGUgZGVtb2NyYWN5IHByb2Nlc3NlZCB2b3RlcyB1bnRpbCBkZW1vY3JhY3kgcGFsbGV0IGlzIGZ1bGx5IHJlbW92ZWQuRFNpeFNlY0Jsb2Nrc1NpbmNlAQAQEP////8EwCBCbG9jayBudW1iZXIgd2hlbiB3ZSBzd2l0Y2hlZCB0byA2IHNlYy4gYmxvY2tzLgGdAwGdBywwUGVyaW9kTGVuZ3RoEBAgHAAABIQgU3Rha2luZyBwZXJpb2QgbGVuZ3RoIGluIGJsb2Nrcy4gUGFsbGV0SWRdCSBzdGFraW5nIwQsIFBhbGxldCBpZC40TmF0aXZlQXNzZXRJZBAQAAAAAAREIE5hdGl2ZSBBc3NldCBJRC4gTWluU3Rha2UYQACAxqR+jQMAAAAAAAAAAAAEcCBNaW4gYW1vdW50IHVzZXIgbXVzdCBzdGFrZS5AVGltZVBvaW50c1dlaWdodCEDEEBCDwAE4CBXZWlnaHQgb2YgdGhlIHRpbWUgcG9pbnRzIGluIHRvdGFsIHBvaW50cyBjYWxjdWxhdGlvbnMuSEFjdGlvblBvaW50c1dlaWdodMEDEADC6wsE6CBXZWlnaHQgb2YgdGhlIGFjdGlvbiBwb2ludHMgaW4gdG90YWwgcG9pbnRzIGNhbGN1bGF0aW9ucy5MVGltZVBvaW50c1BlclBlcmlvZAgEAQTUIE51bWJlciBvZiB0aW1lIHBvaW50cyB1c2VycyByZWNlaXZlIGZvciBlYWNoIHBlcmlvZC5IVW5jbGFpbWFibGVQZXJpb2RzGEABAAAAAAAAAAAAAAAAAAAACHUBIE51bWJlciBvZiBwZXJpb2RzIHVzZXIgY2FuJ3QgY2xhaW0gcmV3YXJkcyBmb3IuIFVzZXIgY2FuIGV4aXQgYnV0IHdvbid0IHJlY2VpdmUgYW55IHJld2FyZHMucQEgSWYgaGUgc3RheSBsb25nZXIgdGhhbiBgVW5jbGFpbWFibGVQZXJpb2RzYCBoZSB3aWxsIHJlY2VpdmUgcmV3YXJkcyBhbHNvIGZvciB0aGVzZSBwZXJpb2RzLkhDdXJyZW50U3Rha2VXZWlnaHQIBAIEsQEgV2VpZ2h0IG9mIHRoZSBhY3R1YWwgc3Rha2UgaW4gc2xhc2ggcG9pbnRzIGNhbGN1bGF0aW9uLiBCaWdnZXIgdGhlIHZhbHVlIGxvd2VyIHRoZSBjYWxjdWxhdGVkIHNsYXNoIHBvaW50cy4gTWF4Vm90ZXMQEBkAAAAEzCBNYXggYW1vdW50IG9mIHZvdGVzIHRoZSB1c2VyIGNhbiBoYXZlIGF0IGFueSB0aW1lLjxORlRDb2xsZWN0aW9uSWQYQK4IAAAAAAAAAAAAAAAAAAAETCBORlQgY29sbGVjdGlvbiBpZC4BnQtFAChTdGFibGVzd2FwAShTdGFibGVzd2FwEBRQb29scwABBAIQpQsEAAQ8IEV4aXN0aW5nIHBvb2xzIFBvb2xQZWdzAAEEAhCtBwQABDwgUG9vbCBwZWcgaW5mby5AQXNzZXRUcmFkYWJpbGl0eQEBCAICTQOpAwQPBIggVHJhZGFiaWxpdHkgc3RhdGUgb2YgcG9vbCBhc3NldHMuNFBvb2xTbmFwc2hvdHMAAQQCEKkLBAAEOQEgVGVtcG9yYXJ5IHBvb2wgc3RhdGUgc3RvcmFnZS4gVXNlZCB0byBzYXZlIGEgc3RhdGUgb2YgcG9vbCBpbiBhIHNpbmdsZSBibG9jay4BoQMBoQcMQE1pblBvb2xMaXF1aWRpdHkYQEBCDwAAAAAAAAAAAAAAAAAEXCBNaW5pbXVtIHBvb2wgbGlxdWlkaXR5PE1pblRyYWRpbmdMaW1pdBhA6AMAAAAAAAAAAAAAAAAAAARcIE1pbmltdW0gdHJhZGluZyBhbW91bnRIQW1wbGlmaWNhdGlvblJhbmdluQsQAgAQJwQ9ASBBbXBsaWZpY2F0aW9uIGluY2x1c2l2ZSByYW5nZS4gUG9vbCdzIGFtcCBjYW4gYmUgc2VsZWN0ZWQgZnJvbSB0aGUgcmFuZ2Ugb25seS4BvQtGABRCb25kcwEUQm9uZHMIHEJvbmRJZHMAAQQCwQsQBAAIVCBSZWdpc3RlcmVkIGJvbmQgaWRzLsAgTWFwcyAodW5kZXJseWluZyBhc3NldCBJRCwgbWF0dXJpdHkpIC0+IGJvbmQgSUQUQm9uZHMAAQQCEMELBAAISCBSZWdpc3RlcmVkIGJvbmRzLsAgTWFwcyBib25kIElEIC0+ICh1bmRlcmx5aW5nIGFzc2V0IElELCBtYXR1cml0eSkBxQMBuQcMIFBhbGxldElkXQkgcGx0Ym9uZHME7CBUaGUgcGFsbGV0IGlkLCB1c2VkIGZvciBkZXJpdmluZyBpdHMgc292ZXJlaWduIGFjY291bnQgSUQuLFByb3RvY29sRmVlIQMQIE4AAAQ4IFByb3RvY29sIGZlZS4sRmVlUmVjZWl2ZXIAgG1vZGxweS90cnNyeQAAAAAAAAAAAAAAAAAAAAAAAAAABFwgUHJvdG9jb2wgZmVlIHJlY2VpdmVyLgHFC0cAOE90Y1NldHRsZW1lbnRzAAHJAwG9BxQ4UHJvZml0UmVjZWl2ZXIAgG1vZGxweS90cnNyeQAAAAAAAAAAAAAAAAAAAAAAAAAABIQgQWNjb3VudCB3aG8gcmVjZWl2ZXMgdGhlIHByb2ZpdC5MTWluUHJvZml0UGVyY2VudGFnZcEDEBAnAAAEnCBNaW5pbXVtIHByb2ZpdCBpbiB0ZXJtcyBvZiBwZXJjZW50YWdlLjhQcmljZVByZWNpc2lvbj0BQAAAwW/yhiMAAAAAAAAAAAAE0CBEZXRlcm1pbmVzIHdoZW4gd2UgY29uc2lkZXIgYW4gYXJiaXRyYWdlIGFzIGNsb3NlZC48TWluVHJhZGluZ0xpbWl0GEDoAwAAAAAAAAAAAAAAAAAABFwgTWluaW11bSB0cmFkaW5nIGxpbWl0LjRNYXhJdGVyYXRpb25zEBAoAAAABG0BIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdXNlZCBpbiB0aGUgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0gdG8gZmluZCB0aGUgdHJhZGUgYW1vdW50LgHJC0gADExCUAEMTEJQCCBQb29sRGF0YQABBAIAxQcEAARMIERldGFpbHMgb2YgYSBwb29sLlRGZWVDb2xsZWN0b3JXaXRoQXNzZXQBAQgCAskJIAQACMggU3RvcmFnZSB1c2VkIGZvciB0cmFja2luZyBleGlzdGluZyBmZWUgY29sbGVjdG9yc8wgTm90IG1vcmUgdGhhbiBvbmUgZmVlIGNvbGxlY3RvciBwZXIgYXNzZXQgcG9zc2libGUBzQMBwQcUPE1pblRyYWRpbmdMaW1pdBhA6AMAAAAAAAAAAAAAAAAAAAQhASBNaW5pbXVtIHRyYWRpbmcgbGltaXQsIHNvbGUgcHVycG9zZSBvZiB0aGlzIGlzIHRvIGtlZXAgdGhlIG1hdGggd29ya2luZ0BNaW5Qb29sTGlxdWlkaXR5GEBAQg8AAAAAAAAAAAAAAAAABCUBIE1pbmltdW0gcG9vbCBsaXF1aWRpdHksIHNvbGUgcHVycG9zZSBvZiB0aGlzIGlzIHRvIGtlZXAgdGhlIG1hdGggd29ya2luZyhNYXhJblJhdGlvGEADAAAAAAAAAAAAAAAAAAAABMwgTWF4IGZyYWN0aW9uIG9mIHBvb2wgdG8gc2VsbCBpbiBzaW5nbGUgdHJhbnNhY3Rpb24sTWF4T3V0UmF0aW8YQAMAAAAAAAAAAAAAAAAAAAAEyCBNYXggZnJhY3Rpb24gb2YgcG9vbCB0byBidXkgaW4gc2luZ2xlIHRyYW5zYWN0aW9uJHJlcGF5X2ZlZU0DIAIAAAAKAAAAAAHNC0kADFhZSwEMWFlLDChTaGFyZVRva2VuAQEEAgAQEAAAAAAEoCBBc3NldCBpZCBzdG9yYWdlIGZvciBzaGFyZWQgcG9vbCB0b2tlbnM4VG90YWxMaXF1aWRpdHkBAQQCABhAAAAAAAAAAAAAAAAAAAAAAARsIFRvdGFsIGxpcXVpZGl0eSBpbiBhIHBvb2wuKFBvb2xBc3NldHMAAQQCAE0DBAAEWCBBc3NldCBwYWlyIGluIGEgcG9vbC4B2QMByQccNE5hdGl2ZUFzc2V0SWQQEAAAAAAEQCBOYXRpdmUgQXNzZXQgSWQ4R2V0RXhjaGFuZ2VGZWVNAyADAAAA6AMAAAREIFRyYWRpbmcgZmVlIHJhdGU8TWluVHJhZGluZ0xpbWl0GEDoAwAAAAAAAAAAAAAAAAAABFggTWluaW11bSB0cmFkaW5nIGxpbWl0QE1pblBvb2xMaXF1aWRpdHkYQEBCDwAAAAAAAAAAAAAAAAAEXCBNaW5pbXVtIHBvb2wgbGlxdWlkaXR5KE1heEluUmF0aW8YQAMAAAAAAAAAAAAAAAAAAAAEzCBNYXggZnJhY3Rpb24gb2YgcG9vbCB0byBzZWxsIGluIHNpbmdsZSB0cmFuc2FjdGlvbixNYXhPdXRSYXRpbxhAAwAAAAAAAAAAAAAAAAAAAATIIE1heCBmcmFjdGlvbiBvZiBwb29sIHRvIGJ1eSBpbiBzaW5nbGUgdHJhbnNhY3Rpb24wT3JhY2xlU291cmNl/QEgaHlkcmF4eWsEqCBPcmFjbGUgc291cmNlIGlkZW50aWZpZXIgZm9yIHRoaXMgcGFsbGV0LgHRC0oAJFJlZmVycmFscwEkUmVmZXJyYWxzKDRSZWZlcnJhbENvZGVzAAEEAuEDAAQACDwgUmVmZXJyYWwgY29kZXOQIE1hcHMgYSByZWZlcnJhbCBjb2RlIHRvIGFuIGFjY291bnQuQFJlZmVycmFsQWNjb3VudHMAAQQCAOEDBAAISCBSZWZlcnJhbCBhY2NvdW50c5AgTWFwcyBhbiBhY2NvdW50IHRvIGEgcmVmZXJyYWwgY29kZS44TGlua2VkQWNjb3VudHMAAQQCAAAEAAhEIExpbmtlZCBhY2NvdW50cy6cIE1hcHMgYW4gYWNjb3VudCB0byBhIHJlZmVycmFsIGFjY291bnQuOFJlZmVycmVyU2hhcmVzAQEEAgAYQAAAAAAAAAAAAAAAAAAAAAAEdCBTaGFyZXMgb2YgYSByZWZlcnJhbCBhY2NvdW50MFRyYWRlclNoYXJlcwEBBAIAGEAAAAAAAAAAAAAAAAAAAAAABGwgU2hhcmVzIG9mIGEgdHJhZGVyIGFjY291bnQsVG90YWxTaGFyZXMBABhAAAAAAAAAAAAAAAAAAAAAAARYIFRvdGFsIHNoYXJlIGlzc3VhbmNlLiBSZWZlcnJlcgABBAIA1QsEAAzcIFJlZmVyZXIgbGV2ZWwgYW5kIHRvdGFsIGFjY3VtdWxhdGVkIHJld2FyZHMgb3ZlciB0aW1lLtUBIE1hcHMgcmVmZXJyZXIgYWNjb3VudCB0byAoTGV2ZWwsIEJhbGFuY2UpLiBMZXZlbCBpbmRpY2F0ZXMgY3VycmVudCByZXdhcmRzIGFuZCBCYWxhbmNlIGlzIHVzZWQgdG8gdW5sb2NrIG5leHQgbGV2ZWwuuQEgRGV2IG5vdGU6IHdlIHVzZSBPcHRpb25RdWVyeSBoZXJlIGJlY2F1c2UgdGhpcyBoZWxwcyB0byBlYXNpbHkgZGV0ZXJtaW5lIHRoYXQgYW4gYWNjb3VudCBpZiByZWZlcnJlciBhY2NvdW50LjBBc3NldFJld2FyZHMAAQgCAtkL6QMEAAiwIEFzc2V0IGZlZSBkaXN0cmlidXRpb24gcmV3YXJkcyBpbmZvcm1hdGlvbi7QIE1hcHMgKGFzc2V0X2lkLCBsZXZlbCkgdG8gYXNzZXQgcmV3YXJkIHBlcmNlbnRhZ2VzLkhQZW5kaW5nQ29udmVyc2lvbnMAAQQCEJAEAAgBASBJbmZvcm1hdGlvbiBhYm91dCBhc3NldHMgdGhhdCBhcmUgY3VycmVudGx5IGluIHRoZSByZXdhcmRzIHBvdC4NASBVc2VkIHRvIGVhc2lseSBkZXRlcm1pbmUgbGlzdCBvZiBhc3NldHMgdGhhdCBuZWVkIHRvIGJlIGNvbnZlcnRlZC5wQ291bnRlckZvclBlbmRpbmdDb252ZXJzaW9ucwEAEBAAAAAABKxDb3VudGVyIGZvciB0aGUgcmVsYXRlZCBjb3VudGVkIHN0b3JhZ2UgbWFwAd0DAc0HGCxSZXdhcmRBc3NldBAQAAAAAATYIElEIG9mIGFuIGFzc2V0IHRoYXQgaXMgdXNlZCB0byBkaXN0cmlidXRlIHJld2FyZHMgaW4uIFBhbGxldElkXQkgcmVmZXJyYWwERQEgUGFsbGV0IGlkLiBEZXRlcm1pbmVzIGFjY291bnQgd2hpY2ggaG9sZHMgYWNjdW11bGF0ZWQgcmV3YXJkcyBpbiB2YXJpb3VzIGFzc2V0cy48UmVnaXN0cmF0aW9uRmVl3QvQAAAAAADgI2foyQAAAAAAAAAAAABtb2RscHkvdHJzcnkAAAAAAAAAAAAAAAAAAAAAAAAAAAhoIFJlZ2lzdHJhdGlvbiBmZWUgZGV0YWlscy4lASAoSUQgb2YgYW4gYXNzZXQgd2hpY2ggZmVlIGlzIHRvIGJlIHBhaWQgaW4sIEFtb3VudCwgQmVuZWZpY2lhcnkgYWNjb3VudCkoQ29kZUxlbmd0aBAQCgAAAAR4IE1heGltdW0gcmVmZXJyYWwgY29kZSBsZW5ndGguNE1pbkNvZGVMZW5ndGgQEAQAAAAEeCBNaW5pbXVtIHJlZmVycmFsIGNvZGUgbGVuZ3RoLkBTZWVkTmF0aXZlQW1vdW50GEAAoHJOGAkAAAAAAAAAAAAABLQgU2VlZCBhbW91bnQgdGhhdCB3YXMgc2VudCB0byB0aGUgcmV3YXJkIHBvdC4B4QtLACxMaXF1aWRhdGlvbgEsTGlxdWlkYXRpb24EREJvcnJvd2luZ0NvbnRyYWN0AQBBAVAbAuBRaDtc+sWSnCXoStsm7Ph7OASIIEJvcnJvd2luZyBtYXJrZXQgY29udHJhY3QgYWRkcmVzcwHtAwHVBwwgR2FzTGltaXQwIAAJPQAAAAAABOQgVGhlIGdhcyBsaW1pdCBmb3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlxdWlkYXRpb24gY2FsbC44UHJvZml0UmVjZWl2ZXIAgEVUSADlJWf/BqzWy+e6lNx3ejEm4YC22QAAAAAAAAAABIQgQWNjb3VudCB3aG8gcmVjZWl2ZXMgdGhlIHByb2ZpdC4gSG9sbGFySWQQEN4AAAAETCBBc3NldCBJRCBvZiBIb2xsYXIB5QtMAAxIU00BDEhTTQwsQ29sbGF0ZXJhbHMAAQQCEOkLBAAU6CBMaXN0IG9mIGFwcHJvdmVkIGFzc2V0cyB0aGF0IEhvbGxhciBjYW4gYmUgcHVyY2hhc2VkIHdpdGgALQEgVGhpcyBzdG9yYWdlIG1hcHMgYXNzZXQgSURzIHRvIHRoZWlyIGNvbGxhdGVyYWwgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbi4pASBPbmx5IGFzc2V0cyBpbiB0aGlzIG1hcCBjYW4gYmUgdXNlZCB0byBtaW50IG9yIHJlZGVlbSBIb2xsYXIgdGhyb3VnaCBIU00uUQEgRWFjaCBjb2xsYXRlcmFsIGhhcyBzcGVjaWZpYyBwYXJhbWV0ZXJzIGNvbnRyb2xsaW5nIGl0cyB1c2FnZSBpbiB0aGUgSFNNIG1lY2hhbmlzbS5QSG9sbGFyQW1vdW50UmVjZWl2ZWQBAQQCEBhAAAAAAAAAAAAAAAAAAAAAABTgIEFtb3VudCBvZiBIb2xsYXIgYm91Z2h0IHdpdGggYW4gYXNzZXQgaW4gYSBzaW5nbGUgYmxvY2sAUQEgVGhpcyBzdG9yYWdlIHRyYWNrcyBob3cgbXVjaCBIb2xsYXIgaGFzIGJlZW4gYm91Z2h0IGJhY2sgYnkgSFNNIGZvciBlYWNoIGNvbGxhdGVyYWx1ASBhc3NldCB3aXRoaW4gdGhlIGN1cnJlbnQgYmxvY2suIFRoaXMgaXMgdXNlZCB0byBlbmZvcmNlIHJhdGUgbGltaXRpbmcgb24gSG9sbGFyIHJlZGVtcHRpb25zLgkBIFZhbHVlcyBhcmUgcmVzZXQgdG8gemVybyBhdCB0aGUgZW5kIG9mIGVhY2ggYmxvY2sgaW4gb25fZmluYWxpemUuLEZsYXNoTWludGVyAABBAQQABJAgQWRkcmVzcyBvZiB0aGUgZmxhc2ggbG9hbiByZWNlaXZlci4B8QMB2QcUIEhvbGxhcklkEBDeAAAABEwgQXNzZXQgSUQgb2YgSG9sbGFyIFBhbGxldElkXQkgcHkvaHNtb2QEjCBQYWxsZXQgSUQgdG8gZGV0ZXJtaW5lIEhTTSBhY2NvdW50SE1pbkFyYml0cmFnZUFtb3VudBhAAABkp7O24A0AAAAAAAAAAABERmxhc2hMb2FuUmVjZWl2ZXJBAVAAAAAAAAAAAAAAAAAAAAAAAAAJCgAgR2FzTGltaXQwIIAaBgAAAAAABLQgVGhlIGdhcyBsaW1pdCBmb3IgdGhlIGV4ZWN1dGlvbiBvZiBFVk0gY2FsbHMB7QtSAChQYXJhbWV0ZXJzAShQYXJhbWV0ZXJzBCRJc1Rlc3RuZXQBACAEAAAAAAAAUwAYVG9rZW5zARhUb2tlbnMQNFRvdGFsSXNzdWFuY2UBAQQFEBhAAAAAAAAAAAAAAAAAAAAAAASQIFRoZSB0b3RhbCBpc3N1YW5jZSBvZiBhIHRva2VuIHR5cGUuFExvY2tzAQEIAgXJCfELBAAI2CBBbnkgbGlxdWlkaXR5IGxvY2tzIG9mIGEgdG9rZW4gdHlwZSB1bmRlciBhbiBhY2NvdW50LiUBIE5PVEU6IFNob3VsZCBvbmx5IGJlIGFjY2Vzc2VkIHdoZW4gc2V0dGluZywgY2hhbmdpbmcgYW5kIGZyZWVpbmcgYSBsb2NrLiBBY2NvdW50cwEBCAIFyQn9C8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYuCBUaGUgYmFsYW5jZSBvZiBhIHRva2VuIHR5cGUgdW5kZXIgYW4gYWNjb3VudC4A/CBOT1RFOiBJZiB0aGUgdG90YWwgaXMgZXZlciB6ZXJvLCBkZWNyZWFzZSBhY2NvdW50IHJlZiBhY2NvdW50LgAZASBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgY2FzZSB0aGF0IHRoaXMgbW9kdWxlIGlzIHVzZWQgdG8gc3RvcmUoIGJhbGFuY2VzLiBSZXNlcnZlcwEBCAIFyQkBDAQABKQgTmFtZWQgcmVzZXJ2ZXMgb24gc29tZSBhY2NvdW50IGJhbGFuY2VzLgENBAHdBwggTWF4TG9ja3MQEDIAAAAALE1heFJlc2VydmVzEBAyAAAABA0BIFRoZSBtYXhpbXVtIG51bWJlciBvZiBuYW1lZCByZXNlcnZlcyB0aGF0IGNhbiBleGlzdCBvbiBhbiBhY2NvdW50LgENDE0AKEN1cnJlbmNpZXMAAREEAeEHCDhSZXNlcnZlQWNjb3VudACAbW9kbGN1cnJlc2VyAAAAAAAAAAAAAAAAAAAAAAAAAAAATEdldE5hdGl2ZUN1cnJlbmN5SWQQEAAAAAAAAREMTwAcVmVzdGluZwEcVmVzdGluZwRAVmVzdGluZ1NjaGVkdWxlcwEBBAIAFQwEAAyEIFZlc3Rpbmcgc2NoZWR1bGVzIG9mIGFuIGFjY291bnQuAOAgVmVzdGluZ1NjaGVkdWxlczogbWFwIEFjY291bnRJZCA9PiBWZWM8VmVzdGluZ1NjaGVkdWxlPgEZBAHlBwRETWluVmVzdGVkVHJhbnNmZXIYQGQAAAAAAAAAAAAAAAAAAAAE6CBUaGUgbWluaW11bSBhbW91bnQgdHJhbnNmZXJyZWQgdG8gY2FsbCBgdmVzdGVkX3RyYW5zZmVyYC4BGQxRAAxFVk0BDEVWTRAwQWNjb3VudENvZGVzAQEEAkEBOAQAAFBBY2NvdW50Q29kZXNNZXRhZGF0YQABBAJBAR0MBAAAPEFjY291bnRTdG9yYWdlcwEBCAICIQw0gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBTdWljaWRlZAABBAJBAZAEAAABJQQB6QcAASUMWgAoRVZNQ2hhaW5JZAEoRVZNQ2hhaW5JZAQcQ2hhaW5JZAEAMCAAAAAAAAAAAARIIFRoZSBFVk0gY2hhaW4gSUQuAAAAAFsAIEV0aGVyZXVtASBFdGhlcmV1bRgcUGVuZGluZwABBAYQKQwEAATQIEN1cnJlbnQgYnVpbGRpbmcgYmxvY2sncyB0cmFuc2FjdGlvbnMgYW5kIHJlY2VpcHRzLkRDb3VudGVyRm9yUGVuZGluZwEAEBAAAAAABKxDb3VudGVyIGZvciB0aGUgcmVsYXRlZCBjb3VudGVkIHN0b3JhZ2UgbWFwMEN1cnJlbnRCbG9jawAASQwEAARwIFRoZSBjdXJyZW50IEV0aGVyZXVtIGJsb2NrLjxDdXJyZW50UmVjZWlwdHMAAF0MBAAEfCBUaGUgY3VycmVudCBFdGhlcmV1bSByZWNlaXB0cy5oQ3VycmVudFRyYW5zYWN0aW9uU3RhdHVzZXMAAGEMBAAEiCBUaGUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0dXNlcy4kQmxvY2tIYXNoAQEEBUkBNIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNQQB8QcAAWUMXAAsRVZNQWNjb3VudHMBLEVWTUFjY291bnRzDEBBY2NvdW50RXh0ZW5zaW9uAAEEAkEBDQIEAAQFASBNYXBzIGFuIEVWTSBhZGRyZXNzIHRvIHRoZSBsYXN0IDEyIGJ5dGVzIG9mIGEgc3Vic3RyYXRlIGFjY291bnQuQENvbnRyYWN0RGVwbG95ZXIAAQQCQQGQBAAECQEgV2hpdGVsaXN0ZWQgYWRkcmVzc2VzIHRoYXQgYXJlIGFsbG93ZWQgdG8gZGVwbG95IHNtYXJ0IGNvbnRyYWN0cy5AQXBwcm92ZWRDb250cmFjdAABBAJBAZAEAAQZASBXaGl0ZWxpc3RlZCBjb250cmFjdHMgdGhhdCBhcmUgYWxsb3dlZCB0byBtYW5hZ2UgYmFsYW5jZXMgYW5kIHRva2Vucy4BXQQBFQgENEZlZU11bHRpcGxpZXIQEDIAAAAEtCBGZWUgbXVsdGlwbGllciBmb3IgdGhlIGJpbmRpbmcgb2YgYWRkcmVzc2VzLgFpDF0ANER5bmFtaWNFdm1GZWUBNER5bmFtaWNFdm1GZWUENEJhc2VGZWVQZXJHYXMBAEkBgMDh5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEQgQmFzZSBmZWUgcGVyIGdhcwAABCxXZXRoQXNzZXRJZBAQFAAAAAQ4IFdFVEggQXNzZXQgSWQAXgBIWFlLTGlxdWlkaXR5TWluaW5nAAFhBAEZCAw8TkZUQ29sbGVjdGlvbklkGEANFQAAAAAAAAAAAAAAAAAABNwgTkZUIGNvbGxlY3Rpb24gaWQgZm9yIGxpcXVpZGl0eSBtaW5pbmcncyBkZXBvc2l0IG5mdHMuME9yYWNsZVNvdXJjZf0BIGh5ZHJheHlrBKggT3JhY2xlIHNvdXJjZSBpZGVudGlmaWVyIGZvciB0aGlzIHBhbGxldC4wT3JhY2xlUGVyaW9kuQMEAgScIE9yYWNsZSdzIGxpcXVpZGl0eSBhZ2dyZWdhdGlvbiBwZXJpb2QuAW0MXwA4WFlLV2FyZWhvdXNlTE0BOFhZS1dhcmVob3VzZUxNGDRGYXJtU2VxdWVuY2VyAQAQEAAAAAAEvCBJZCBzZXF1ZW5jZXIgZm9yIGBHbG9iYWxGYXJtYCBhbmQgYFlpZWxkRmFybWAuQERlcG9zaXRTZXF1ZW5jZXIBABhAAAAAAAAAAAAAAAAAAAAAAAAoR2xvYmFsRmFybQABBAIQcQwEAAAkWWllbGRGYXJtAAEMAgICdQx5DAQABFAgWWllbGQgZmFybSBkZXRhaWxzLhxEZXBvc2l0AAEEBRh9DAQABEQgRGVwb3NpdCBkZXRhaWxzLjxBY3RpdmVZaWVsZEZhcm0AAQgCAskJEAQABPggQWN0aXZlKGZhcm1zIGFibGUgdG8gcmVjZWl2ZSBMUCBzaGFyZXMgZGVwb3NpdHMpIHlpZWxkIGZhcm1zLgFxBAEdCBggUGFsbGV0SWRdCSB4eWtMTXBJRAQsIFBhbGxldCBpZC5EVHJlYXN1cnlBY2NvdW50SWQAgG1vZGxweS90cnNyeQAAAAAAAAAAAAAAAAAAAAAAAAAABOggVHJlYXN1cnkgYWNjb3VudCB0byByZWNlaXZlIGNsYWltZWQgcmV3YXJkcyBsb3dlciB0aGFuIEVETE1pblRvdGFsRmFybVJld2FyZHMYQAAQpdToAAAAAAAAAAAAAAAEOQEgTWluaW11bSB0b3RhbCByZXdhcmRzIHRvIGRpc3RyaWJ1dGUgZnJvbSBnbG9iYWwgZmFybSBkdXJpbmcgbGlxdWlkaXR5IG1pbmluZy5kTWluUGxhbm5lZFlpZWxkaW5nUGVyaW9kcxAQaDgAAATsIE1pbmltdW0gbnVtYmVyIG9mIHBlcmlvZHMgdG8gcnVuIGxpcXVpZGl0eSBtaW5pbmcgcHJvZ3JhbS5gTWF4RmFybUVudHJpZXNQZXJEZXBvc2l0EBAFAAAACGUBIE1heGltdW0gbnVtYmVyIG9mIHlpZWxkIGZhcm1zIHNhbWUgTFAgc2hhcmVzIGNhbiBiZSByZS9kZXBvc2l0ZWQgaW50by4gVGhpcyB2YWx1ZSBhbHdheXNcIE1VU1QgQkUgPj0gMS4gICAgICAgICBoTWF4WWllbGRGYXJtc1Blckdsb2JhbEZhcm0QEDIAAAAITQEgTWF4IG51bWJlciBvZiB5aWVsZCBmYXJtcyBjYW4gZXhpc3QgaW4gZ2xvYmFsIGZhcm0uIFRoaXMgaW5jbHVkZXMgYWxsIGZhcm1zIGluIHRoZZggc3RvcmFnZShhY3RpdmUsIHN0b3BwZWQsIHRlcm1pbmF0ZWQpLgGNDGAAOFJlbGF5Q2hhaW5JbmZvAAF1BAEhCAABkQzJAAxEQ0EBDERDQRxMU2NoZWR1bGVJZFNlcXVlbmNlcgEAEBAAAAAABGwgSWQgc2VxdWVuY2VyIGZvciBzY2hlZHVsZXMkU2NoZWR1bGVzAAEEAhB9BAQABGQgU3RvcmluZyBzY2hlZHVsZSBkZXRhaWxzRFNjaGVkdWxlT3duZXJzaGlwAAEIAgXJCZAEAARsIFN0b3Jpbmcgc2NoZWR1bGUgb3duZXJzaGlwQFJlbWFpbmluZ0Ftb3VudHMAAQQCEBgEAAT8IEtlZXAgdHJhY2tpbmcgdGhlIHJlbWFpbmluZyBhbW91bnRzIHRvIHNwZW5kIGZvciBEQ0Egc2NoZWR1bGVzOFJldHJpZXNPbkVycm9yAQEEAhAIBAAE4CBLZWVwIHRyYWNraW5nIHRoZSByZXRyeSBvbiBlcnJvciBmbGFnIGZvciBEQ0Egc2NoZWR1bGVzWFNjaGVkdWxlRXhlY3V0aW9uQmxvY2sAAQQCEBAEAAQpASBLZWVwIHRyYWNraW5nIHRoZSBibG9ja251bWJlciB3aGVuIHRoZSBzY2hlZHVsZSBpcyBwbGFubmVkIHRvIGJlIGV4ZWN1dGVkTFNjaGVkdWxlSWRzUGVyQmxvY2sBAQQCEJUMBAAE+CBLZWVwIHRyYWNraW5nIG9mIHRoZSBzY2hlZHVsZSBpZHMgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIGJsb2NrAXkEASUIMHxNYXhQcmljZURpZmZlcmVuY2VCZXR3ZWVuQmxvY2tzIQMQmDoAAASsTWF4IHByaWNlIGRpZmZlcmVuY2UgYWxsb3dlZCBiZXR3ZWVuIGJsb2Nrc6xNYXhDb25maWd1cmFibGVQcmljZURpZmZlcmVuY2VCZXR3ZWVuQmxvY2tzIQMQUMMAAATgTWF4IGNvbmZpZ3VyYWJsZSBwcmljZSBkaWZmZXJlbmNlIGFsbG93ZWQgYmV0d2VlbiBibG9ja3NMTWF4U2NoZWR1bGVQZXJCbG9jaxAQBgAAAATQVGhlIG51bWJlciBvZiBtYXggc2NoZWR1bGVzIHRvIGJlIGV4ZWN1dGVkIHBlciBibG9ja2RNYXhOdW1iZXJPZlJldHJpZXNPbkVycm9yCAQDBNhUaGUgbnVtYmVyIG9mIG1heCByZXRyaWVzIGluIGNhc2Ugb2YgdHJhZGUgbGltaXQgZXJyb3I0TWluaW1hbFBlcmlvZBAQBQAAAASETWluaW1hbCBwZXJpb2QgYmV0d2VlbiBleGVjdXRpb25zKEJ1bXBDaGFuY2WZDAQRBIRDaGFuY2Ugb2YgdGhlIHJhbmRvbSByZXNjaGVkdWxpbmdMTWluaW11bVRyYWRpbmdMaW1pdBhA6AMAAAAAAAAAAAAAAAAAAASkIE1pbmltdW0gdHJhZGluZyBsaW1pdCBmb3IgYSBzaW5nbGUgdHJhZGU0TmF0aXZlQXNzZXRJZBAQAAAAAARAIE5hdGl2ZSBBc3NldCBJZFRQb2xrYWRvdE5hdGl2ZUFzc2V0SWQQEAUAAAAEfCBQb2xrYWRvdCBOYXRpdmUgQXNzZXQgSWQgKERPVClkTWluQnVkZ2V0SW5OYXRpdmVDdXJyZW5jeRhAAIDGpH6NAwAAAAAAAAAAAAQlAU1pbmltdW0gYnVkZ2V0IHRvIGJlIGFibGUgdG8gc2NoZWR1bGUgYSBEQ0EsIHNwZWNpZmllZCBpbiBuYXRpdmUgY3VycmVuY3ksRmVlUmVjZWl2ZXIAgG1vZGxweS90cnNyeQAAAAAAAAAAAAAAAAAAAAAAAAAABJRUaGUgZmVlIHJlY2VpdmVyIGZvciB0cmFuc2FjdGlvbiBmZWVzOE5hbWVkUmVzZXJ2ZUlk/QEgZGNhb3JkZXIEKQEgTmFtZWQgcmVzZXJ2ZSBpZGVudGlmaWVyIHRvIHN0b3JlIG5hbWVkIHJlc2VydmVzIGZvciBvcmRlcnMgb2YgZWFjaCB1c2VycwGdDEIAJFNjaGVkdWxlcgEkU2NoZWR1bGVyEDxJbmNvbXBsZXRlU2luY2UAABAEAAAYQWdlbmRhAQEEBRChDAQABE0BIEl0ZW1zIHRvIGJlIGV4ZWN1dGVkLCBpbmRleGVkIGJ5IHRoZSBibG9jayBudW1iZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBleGVjdXRlZCBvbi4cUmV0cmllcwABBAJNA7EMBAAEIQEgUmV0cnkgY29uZmlndXJhdGlvbnMgZm9yIGl0ZW1zIHRvIGJlIGV4ZWN1dGVkLCBpbmRleGVkIGJ5IHRhc2sgYWRkcmVzcy4YTG9va3VwAAEEBQRNAwQAEPggTG9va3VwIGZyb20gYSBuYW1lIHRvIHRoZSBibG9jayBudW1iZXIgYW5kIGluZGV4IG9mIHRoZSB0YXNrLgBZASBGb3IgdjMgLT4gdjQgdGhlIHByZXZpb3VzbHkgdW5ib3VuZGVkIGlkZW50aXRpZXMgYXJlIEJsYWtlMi0yNTYgaGFzaGVkIHRvIGZvcm0gdGhlIHY0MCBpZGVudGl0aWVzLgGFBAEpCAg0TWF4aW11bVdlaWdodCgsCwCAbod0AQIAAAEEKQEgVGhlIG1heGltdW0gd2VpZ2h0IHRoYXQgbWF5IGJlIHNjaGVkdWxlZCBwZXIgYmxvY2sgZm9yIGFueSBkaXNwYXRjaGFibGVzLlBNYXhTY2hlZHVsZWRQZXJCbG9jaxAQMgAAABQdASBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2NoZWR1bGVkIGNhbGxzIGluIHRoZSBxdWV1ZSBmb3IgYSBzaW5nbGUgYmxvY2suABggTk9URTpRASArIERlcGVuZGVudCBwYWxsZXRzJyBiZW5jaG1hcmtzIG1pZ2h0IHJlcXVpcmUgYSBoaWdoZXIgbGltaXQgZm9yIHRoZSBzZXR0aW5nLiBTZXQgYcQgaGlnaGVyIGxpbWl0IHVuZGVyIGBydW50aW1lLWJlbmNobWFya3NgIGZlYXR1cmUuAbUMBQA8UGFyYWNoYWluU3lzdGVtATxQYXJhY2hhaW5TeXN0ZW1gRFVuaW5jbHVkZWRTZWdtZW50AQC5DAQAGEkBIExhdGVzdCBpbmNsdWRlZCBibG9jayBkZXNjZW5kYW50cyB0aGUgcnVudGltZSBhY2NlcHRlZC4gSW4gb3RoZXIgd29yZHMsIHRoZXNlIGFyZWEBIGFuY2VzdG9ycyBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBibG9jayB3aGljaCBoYXZlIG5vdCBiZWVuIGluY2x1ZGVkIGluIHRoZSBvYnNlcnZlZEwgcmVsYXktY2hhaW4gc3RhdGUuAHUBIFRoZSBzZWdtZW50IGxlbmd0aCBpcyBsaW1pdGVkIGJ5IHRoZSBjYXBhY2l0eSByZXR1cm5lZCBmcm9tIHRoZSBbYENvbnNlbnN1c0hvb2tgXSBjb25maWd1cmVkPCBpbiB0aGUgcGFsbGV0LmxBZ2dyZWdhdGVkVW5pbmNsdWRlZFNlZ21lbnQAAN0MBAAMaQEgU3RvcmFnZSBmaWVsZCB0aGF0IGtlZXBzIHRyYWNrIG9mIGJhbmR3aWR0aCB1c2VkIGJ5IHRoZSB1bmluY2x1ZGVkIHNlZ21lbnQgYWxvbmcgd2l0aCB0aGUtASBsYXRlc3QgSFJNUCB3YXRlcm1hcmsuIFVzZWQgZm9yIGxpbWl0aW5nIHRoZSBhY2NlcHRhbmNlIG9mIG5ldyBibG9ja3Mgd2l0aJAgcmVzcGVjdCB0byByZWxheSBjaGFpbiBjb25zdHJhaW50cy5UUGVuZGluZ1ZhbGlkYXRpb25Db2RlAQA4BAAYWQEgSW4gY2FzZSBvZiBhIHNjaGVkdWxlZCB1cGdyYWRlLCB0aGlzIHN0b3JhZ2UgZmllbGQgY29udGFpbnMgdGhlIHZhbGlkYXRpb24gY29kZSB0byBiZSQgYXBwbGllZC4APQEgQXMgc29vbiBhcyB0aGUgcmVsYXkgY2hhaW4gZ2l2ZXMgdXMgdGhlIGdvLWFoZWFkIHNpZ25hbCwgd2Ugd2lsbCBvdmVyd3JpdGUgdGhlcQEgW2A6Y29kZWBdW3NwX2NvcmU6OnN0b3JhZ2U6OndlbGxfa25vd25fa2V5czo6Q09ERV0gd2hpY2ggd2lsbCByZXN1bHQgdGhlIG5leHQgYmxvY2sgcHJvY2VzcwkBIHdpdGggdGhlIG5ldyB2YWxpZGF0aW9uIGNvZGUuIFRoaXMgY29uY2x1ZGVzIHRoZSB1cGdyYWRlIHByb2Nlc3MuRE5ld1ZhbGlkYXRpb25Db2RlAAA4BAAUXQEgVmFsaWRhdGlvbiBjb2RlIHRoYXQgaXMgc2V0IGJ5IHRoZSBwYXJhY2hhaW4gYW5kIGlzIHRvIGJlIGNvbW11bmljYXRlZCB0byBjb2xsYXRvciBhbmR4IGNvbnNlcXVlbnRseSB0aGUgcmVsYXktY2hhaW4uAGUBIFRoaXMgd2lsbCBiZSBjbGVhcmVkIGluIGBvbl9pbml0aWFsaXplYCBvZiBlYWNoIG5ldyBibG9jayBpZiBubyBvdGhlciBwYWxsZXQgYWxyZWFkeSBzZXQsIHRoZSB2YWx1ZS44VmFsaWRhdGlvbkRhdGEAAJEEBAAM0CBUaGUgW2BQZXJzaXN0ZWRWYWxpZGF0aW9uRGF0YWBdIHNldCBmb3IgdGhpcyBibG9jay4tASBUaGlzIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIHNldCBvbmx5IG9uY2UgcGVyIGJsb2NrIGFuZCBpdCdzIG5ldmVyIHN0b3JlZDQgaW4gdGhlIHRyaWUuUERpZFNldFZhbGlkYXRpb25Db2RlAQAgBAAE4CBXZXJlIHRoZSB2YWxpZGF0aW9uIGRhdGEgc2V0IHRvIG5vdGlmeSB0aGUgcmVsYXkgY2hhaW4/ZExhc3RSZWxheUNoYWluQmxvY2tOdW1iZXIBABAQAAAAAAwdASBUaGUgcmVsYXkgY2hhaW4gYmxvY2sgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGFzdCBwYXJhY2hhaW4gYmxvY2suAIggVGhpcyBpcyB1cGRhdGVkIGluIGBvbl9maW5hbGl6ZWAuYFVwZ3JhZGVSZXN0cmljdGlvblNpZ25hbAEA4QwEABx1ASBBbiBvcHRpb24gd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSByZWxheS1jaGFpbiByZXN0cmljdHMgc2lnbmFsbGluZyBhIHZhbGlkYXRpb24gY29kZSB1cGdyYWRlLmEBIEluIG90aGVyIHdvcmRzLCBpZiB0aGlzIGlzIGBTb21lYCBhbmQgW2BOZXdWYWxpZGF0aW9uQ29kZWBdIGlzIGBTb21lYCB0aGVuIHRoZSBwcm9kdWNlZGwgY2FuZGlkYXRlIHdpbGwgYmUgaW52YWxpZC4AcQEgVGhpcyBzdG9yYWdlIGl0ZW0gaXMgYSBtaXJyb3Igb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHBhcmFjaGFpbiBmcm9tIHRoZW0BIHJlbGF5LWNoYWluLiBUaGlzIHZhbHVlIGlzIGVwaGVtZXJhbCB3aGljaCBtZWFucyBpdCBkb2Vzbid0IGhpdCB0aGUgc3RvcmFnZS4gVGhpcyB2YWx1ZSBpc2Agc2V0IGFmdGVyIHRoZSBpbmhlcmVudC44VXBncmFkZUdvQWhlYWQBANUMBAAU3CBPcHRpb25hbCB1cGdyYWRlIGdvLWFoZWFkIHNpZ25hbCBmcm9tIHRoZSByZWxheS1jaGFpbi4AcQEgVGhpcyBzdG9yYWdlIGl0ZW0gaXMgYSBtaXJyb3Igb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHBhcmFjaGFpbiBmcm9tIHRoZW0BIHJlbGF5LWNoYWluLiBUaGlzIHZhbHVlIGlzIGVwaGVtZXJhbCB3aGljaCBtZWFucyBpdCBkb2Vzbid0IGhpdCB0aGUgc3RvcmFnZS4gVGhpcyB2YWx1ZSBpc2Agc2V0IGFmdGVyIHRoZSBpbmhlcmVudC48UmVsYXlTdGF0ZVByb29mAACZBAQAGMQgVGhlIHN0YXRlIHByb29mIGZvciB0aGUgbGFzdCByZWxheSBwYXJlbnQgYmxvY2suAG0BIFRoaXMgZmllbGQgaXMgbWVhbnQgdG8gYmUgdXBkYXRlZCBlYWNoIGJsb2NrIHdpdGggdGhlIHZhbGlkYXRpb24gZGF0YSBpbmhlcmVudC4gVGhlcmVmb3JlLE0BIGJlZm9yZSBwcm9jZXNzaW5nIG9mIHRoZSBpbmhlcmVudCwgZS5nLiBpbiBgb25faW5pdGlhbGl6ZWAgdGhpcyBkYXRhIG1heSBiZSBzdGFsZS4ArCBUaGlzIGRhdGEgaXMgYWxzbyBhYnNlbnQgZnJvbSB0aGUgZ2VuZXNpcy5YUmVsZXZhbnRNZXNzYWdpbmdTdGF0ZQAA6QwEABxlASBUaGUgc25hcHNob3Qgb2Ygc29tZSBzdGF0ZSByZWxhdGVkIHRvIG1lc3NhZ2luZyByZWxldmFudCB0byB0aGUgY3VycmVudCBwYXJhY2hhaW4gYXMgcGVySCB0aGUgcmVsYXkgcGFyZW50LgBtASBUaGlzIGZpZWxkIGlzIG1lYW50IHRvIGJlIHVwZGF0ZWQgZWFjaCBibG9jayB3aXRoIHRoZSB2YWxpZGF0aW9uIGRhdGEgaW5oZXJlbnQuIFRoZXJlZm9yZSxNASBiZWZvcmUgcHJvY2Vzc2luZyBvZiB0aGUgaW5oZXJlbnQsIGUuZy4gaW4gYG9uX2luaXRpYWxpemVgIHRoaXMgZGF0YSBtYXkgYmUgc3RhbGUuAKwgVGhpcyBkYXRhIGlzIGFsc28gYWJzZW50IGZyb20gdGhlIGdlbmVzaXMuREhvc3RDb25maWd1cmF0aW9uAAD9DAQAGCkBIFRoZSBwYXJhY2hhaW4gaG9zdCBjb25maWd1cmF0aW9uIHRoYXQgd2FzIG9idGFpbmVkIGZyb20gdGhlIHJlbGF5IHBhcmVudC4AbQEgVGhpcyBmaWVsZCBpcyBtZWFudCB0byBiZSB1cGRhdGVkIGVhY2ggYmxvY2sgd2l0aCB0aGUgdmFsaWRhdGlvbiBkYXRhIGluaGVyZW50LiBUaGVyZWZvcmUsTQEgYmVmb3JlIHByb2Nlc3Npbmcgb2YgdGhlIGluaGVyZW50LCBlLmcuIGluIGBvbl9pbml0aWFsaXplYCB0aGlzIGRhdGEgbWF5IGJlIHN0YWxlLgCsIFRoaXMgZGF0YSBpcyBhbHNvIGFic2VudCBmcm9tIHRoZSBnZW5lc2lzLjhMYXN0RG1xTXFjSGVhZAEABQ2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ9CBUaGUgbGFzdCBkb3dud2FyZCBtZXNzYWdlIHF1ZXVlIGNoYWluIGhlYWQgd2UgaGF2ZSBvYnNlcnZlZC4AZQEgVGhpcyB2YWx1ZSBpcyBsb2FkZWQgYmVmb3JlIGFuZCBzYXZlZCBhZnRlciBwcm9jZXNzaW5nIGluYm91bmQgZG93bndhcmQgbWVzc2FnZXMgY2FycmllZGAgYnkgdGhlIHN5c3RlbSBpbmhlcmVudC5ATGFzdEhybXBNcWNIZWFkcwEACQ0EABBJASBUaGUgbWVzc2FnZSBxdWV1ZSBjaGFpbiBoZWFkcyB3ZSBoYXZlIG9ic2VydmVkIHBlciBlYWNoIGNoYW5uZWwgaW5jb21pbmcgY2hhbm5lbC4AZQEgVGhpcyB2YWx1ZSBpcyBsb2FkZWQgYmVmb3JlIGFuZCBzYXZlZCBhZnRlciBwcm9jZXNzaW5nIGluYm91bmQgZG93bndhcmQgbWVzc2FnZXMgY2FycmllZGAgYnkgdGhlIHN5c3RlbSBpbmhlcmVudC5kUHJvY2Vzc2VkRG93bndhcmRNZXNzYWdlcwEAEBAAAAAADMggTnVtYmVyIG9mIGRvd253YXJkIG1lc3NhZ2VzIHByb2Nlc3NlZCBpbiBhIGJsb2NrLgDsIFRoaXMgd2lsbCBiZSBjbGVhcmVkIGluIGBvbl9pbml0aWFsaXplYCBvZiBlYWNoIG5ldyBibG9jay40SHJtcFdhdGVybWFyawEAEBAAAAAADKAgSFJNUCB3YXRlcm1hcmsgdGhhdCB3YXMgc2V0IGluIGEgYmxvY2suAOwgVGhpcyB3aWxsIGJlIGNsZWFyZWQgaW4gYG9uX2luaXRpYWxpemVgIG9mIGVhY2ggbmV3IGJsb2NrLlBIcm1wT3V0Ym91bmRNZXNzYWdlcwEAFQ0EAAykIEhSTVAgbWVzc2FnZXMgdGhhdCB3ZXJlIHNlbnQgaW4gYSBibG9jay4A7CBUaGlzIHdpbGwgYmUgY2xlYXJlZCBpbiBgb25faW5pdGlhbGl6ZWAgb2YgZWFjaCBuZXcgYmxvY2suOFVwd2FyZE1lc3NhZ2VzAQAhAQQADKwgVXB3YXJkIG1lc3NhZ2VzIHRoYXQgd2VyZSBzZW50IGluIGEgYmxvY2suAOwgVGhpcyB3aWxsIGJlIGNsZWFyZWQgaW4gYG9uX2luaXRpYWxpemVgIG9mIGVhY2ggbmV3IGJsb2NrLlRQZW5kaW5nVXB3YXJkTWVzc2FnZXMBACEBBAAEMQEgVXB3YXJkIG1lc3NhZ2VzIHRoYXQgYXJlIHN0aWxsIHBlbmRpbmcgYW5kIG5vdCB5ZXQgc2VuZCB0byB0aGUgcmVsYXkgY2hhaW4uXFVwd2FyZERlbGl2ZXJ5RmVlRmFjdG9yAQA9AUAAAGSns7bgDQAAAAAAAAAABOQgVGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgYmFzZSBkZWxpdmVyeSBmZWUgYnkgZm9yIFVNUC6EQW5ub3VuY2VkSHJtcE1lc3NhZ2VzUGVyQ2FuZGlkYXRlAQAQEAAAAAAIZQEgVGhlIG51bWJlciBvZiBIUk1QIG1lc3NhZ2VzIHdlIG9ic2VydmVkIGluIGBvbl9pbml0aWFsaXplYCBhbmQgdGh1cyB1c2VkIHRoYXQgbnVtYmVyIGZvcvAgYW5ub3VuY2luZyB0aGUgd2VpZ2h0IG9mIGBvbl9pbml0aWFsaXplYCBhbmQgYG9uX2ZpbmFsaXplYC5oUmVzZXJ2ZWRYY21wV2VpZ2h0T3ZlcnJpZGUAACgEAAhdASBUaGUgd2VpZ2h0IHdlIHJlc2VydmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYmxvY2sgZm9yIHByb2Nlc3NpbmcgWENNUCBtZXNzYWdlcy4gVGhpc7ggb3ZlcnJpZGVzIHRoZSBhbW91bnQgc2V0IGluIHRoZSBDb25maWcgdHJhaXQuZFJlc2VydmVkRG1wV2VpZ2h0T3ZlcnJpZGUAACgEAAhZASBUaGUgd2VpZ2h0IHdlIHJlc2VydmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYmxvY2sgZm9yIHByb2Nlc3NpbmcgRE1QIG1lc3NhZ2VzLiBUaGlzuCBvdmVycmlkZXMgdGhlIGFtb3VudCBzZXQgaW4gdGhlIENvbmZpZyB0cmFpdC5gQ3VzdG9tVmFsaWRhdGlvbkhlYWREYXRhAAA4BAAMKQEgQSBjdXN0b20gaGVhZCBkYXRhIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIGFzIHJlc3VsdCBvZiBgdmFsaWRhdGVfYmxvY2tgLgARASBTZWUgYFBhbGxldDo6c2V0X2N1c3RvbV92YWxpZGF0aW9uX2hlYWRfZGF0YWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uAYkEATEIBChTZWxmUGFyYUlkvQEQ8gcAAAS4IFJldHVybnMgdGhlIHBhcmFjaGFpbiBJRCB3ZSBhcmUgcnVubmluZyB3aXRoLgEdDWcANFBhcmFjaGFpbkluZm8BNFBhcmFjaGFpbkluZm8ELFBhcmFjaGFpbklkAQC9ARBkAAAAAAG9BAAAAGkALFBvbGthZG90WGNtASxQb2xrYWRvdFhjbTgwUXVlcnlDb3VudGVyAQAwIAAAAAAAAAAABIggVGhlIGxhdGVzdCBhdmFpbGFibGUgcXVlcnkgaW5kZXguHFF1ZXJpZXMAAQQCMCENBAAEVCBUaGUgb25nb2luZyBxdWVyaWVzLihBc3NldFRyYXBzAQEEBjQQEAAAAAAQaCBUaGUgZXhpc3RpbmcgYXNzZXQgdHJhcHMuAGEBIEtleSBpcyB0aGUgYmxha2UyIDI1NiBoYXNoIG9mIChvcmlnaW4sIHZlcnNpb25lZCBgQXNzZXRzYCkgcGFpci4gVmFsdWUgaXMgdGhlIG51bWJlciBvZh0BIHRpbWVzIHRoaXMgcGFpciBoYXMgYmVlbiB0cmFwcGVkICh1c3VhbGx5IGp1c3QgMSBpZiBpdCBleGlzdHMgYXQgYWxsKS44U2FmZVhjbVZlcnNpb24AABAEAAhhASBEZWZhdWx0IHZlcnNpb24gdG8gZW5jb2RlIFhDTSB3aGVuIGxhdGVzdCB2ZXJzaW9uIG9mIGRlc3RpbmF0aW9uIGlzIHVua25vd24uIElmIGBOb25lYCw9ASB0aGVuIHRoZSBkZXN0aW5hdGlvbnMgd2hvc2UgWENNIHZlcnNpb24gaXMgdW5rbm93biBhcmUgY29uc2lkZXJlZCB1bnJlYWNoYWJsZS5AU3VwcG9ydGVkVmVyc2lvbgABCAUCNQ0QBAAE8CBUaGUgTGF0ZXN0IHZlcnNpb25zIHRoYXQgd2Uga25vdyB2YXJpb3VzIGxvY2F0aW9ucyBzdXBwb3J0LkBWZXJzaW9uTm90aWZpZXJzAAEIBQI1DTAEAAQFASBBbGwgbG9jYXRpb25zIHRoYXQgd2UgaGF2ZSByZXF1ZXN0ZWQgdmVyc2lvbiBub3RpZmljYXRpb25zIGZyb20uUFZlcnNpb25Ob3RpZnlUYXJnZXRzAAEIBQI1DTkNBAAIcQEgVGhlIHRhcmdldCBsb2NhdGlvbnMgdGhhdCBhcmUgc3Vic2NyaWJlZCB0byBvdXIgdmVyc2lvbiBjaGFuZ2VzLCBhcyB3ZWxsIGFzIHRoZSBtb3N0IHJlY2VudJQgb2Ygb3VyIHZlcnNpb25zIHdlIGluZm9ybWVkIHRoZW0gb2YuVFZlcnNpb25EaXNjb3ZlcnlRdWV1ZQEAPQ0EAAxlASBEZXN0aW5hdGlvbnMgd2hvc2UgbGF0ZXN0IFhDTSB2ZXJzaW9uIHdlIHdvdWxkIGxpa2UgdG8ga25vdy4gRHVwbGljYXRlcyBub3QgYWxsb3dlZCwgYW5kcQEgdGhlIGB1MzJgIGNvdW50ZXIgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IGEgc2VuZCB0byB0aGUgZGVzdGluYXRpb24gaGFzIGJlZW4gYXR0ZW1wdGVkLIwgd2hpY2ggaXMgdXNlZCBhcyBhIHByaW9yaXRpemF0aW9uLkBDdXJyZW50TWlncmF0aW9uAABJDQQABJwgVGhlIGN1cnJlbnQgbWlncmF0aW9uJ3Mgc3RhZ2UsIGlmIGFueS5UUmVtb3RlTG9ja2VkRnVuZ2libGVzAAEMBQICTQ1RDQQABPAgRnVuZ2libGUgYXNzZXRzIHdoaWNoIHdlIGtub3cgYXJlIGxvY2tlZCBvbiBhIHJlbW90ZSBjaGFpbi48TG9ja2VkRnVuZ2libGVzAAEEAgBhDQQABOAgRnVuZ2libGUgYXNzZXRzIHdoaWNoIHdlIGtub3cgYXJlIGxvY2tlZCBvbiB0aGlzIGNoYWluLlRYY21FeGVjdXRpb25TdXNwZW5kZWQBACAEAAS0IEdsb2JhbCBzdXNwZW5zaW9uIHN0YXRlIG9mIHRoZSBYQ00gZXhlY3V0b3IuPFNob3VsZFJlY29yZFhjbQEAIAQAHFkBIFdoZXRoZXIgb3Igbm90IGluY29taW5nIFhDTXMgKGJvdGggZXhlY3V0ZWQgbG9jYWxseSBhbmQgcmVjZWl2ZWQpIHNob3VsZCBiZSByZWNvcmRlZC7EIE9ubHkgb25lIFhDTSBwcm9ncmFtIHdpbGwgYmUgcmVjb3JkZWQgYXQgYSB0aW1lLikBIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBydW50aW1lIEFQSXMsIGFuZCBpdCdzIGFkdmlzZWQgaXQgc3RheXMgZmFsc2UNASBmb3IgYWxsIG90aGVyIHVzZSBjYXNlcywgc28gYXMgdG8gbm90IGRlZ3JhZGUgcmVndWxhciBwZXJmb3JtYW5jZS4AWQEgT25seSByZWxldmFudCBpZiB0aGlzIHBhbGxldCBpcyBiZWluZyB1c2VkIGFzIHRoZSBbYHhjbV9leGVjdXRvcjo6dHJhaXRzOjpSZWNvcmRYY21gXcggaW1wbGVtZW50YXRpb24gaW4gdGhlIFhDTSBleGVjdXRvciBjb25maWd1cmF0aW9uLixSZWNvcmRlZFhjbQAAnQUEABhJASBJZiBbYFNob3VsZFJlY29yZFhjbWBdIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZSBsYXN0IFhDTSBwcm9ncmFtIGV4ZWN1dGVkIGxvY2FsbHlUIHdpbGwgYmUgc3RvcmVkIGhlcmUuKQEgUnVudGltZSBBUElzIGNhbiBmZXRjaCB0aGUgWENNIHRoYXQgd2FzIGV4ZWN1dGVkIGJ5IGFjY2Vzc2luZyB0aGlzIHZhbHVlLgBZASBPbmx5IHJlbGV2YW50IGlmIHRoaXMgcGFsbGV0IGlzIGJlaW5nIHVzZWQgYXMgdGhlIFtgeGNtX2V4ZWN1dG9yOjp0cmFpdHM6OlJlY29yZFhjbWBdyCBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgWENNIGV4ZWN1dG9yIGNvbmZpZ3VyYXRpb24uAcEEATUIAAFtDWsAKEN1bXVsdXNYY20AASEGAT0IAABtACRYY21wUXVldWUBJFhjbXBRdWV1ZRxQSW5ib3VuZFhjbXBTdXNwZW5kZWQBAHENBAAgDQEgVGhlIHN1c3BlbmRlZCBpbmJvdW5kIFhDTVAgY2hhbm5lbHMuIEFsbCBvdGhlcnMgYXJlIG5vdCBzdXNwZW5kZWQuAHEBIFRoaXMgaXMgYSBgU3RvcmFnZVZhbHVlYCBpbnN0ZWFkIG9mIGEgYFN0b3JhZ2VNYXBgIHNpbmNlIHdlIGV4cGVjdCBtdWx0aXBsZSByZWFkcyBwZXIgYmxvY2tpASB0byBkaWZmZXJlbnQga2V5cyB3aXRoIGEgb25lIGJ5dGUgcGF5bG9hZC4gVGhlIGFjY2VzcyB0byBgQm91bmRlZEJUcmVlU2V0YCB3aWxsIGJlIGNhY2hlZBUBIHdpdGhpbiB0aGUgYmxvY2sgYW5kIHRoZXJlZm9yZSBvbmx5IGluY2x1ZGVkIG9uY2UgaW4gdGhlIHByb29mIHNpemUuAGUBIE5PVEU6IFRoZSBQb1YgYmVuY2htYXJraW5nIGNhbm5vdCBrbm93IHRoaXMgYW5kIHdpbGwgb3Zlci1lc3RpbWF0ZSwgYnV0IHRoZSBhY3R1YWwgcHJvb2ZEIHdpbGwgYmUgc21hbGxlci5IT3V0Ym91bmRYY21wU3RhdHVzAQB9DQQAGF0BIFRoZSBub24tZW1wdHkgWENNUCBjaGFubmVscyBpbiBvcmRlciBvZiBiZWNvbWluZyBub24tZW1wdHksIGFuZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0UQEgYW5kIGxhc3Qgb3V0Ym91bmQgbWVzc2FnZS4gSWYgdGhlIHR3byBpbmRpY2VzIGFyZSBlcXVhbCwgdGhlbiBpdCBpbmRpY2F0ZXMgYW4gZW1wdHlZASBxdWV1ZSBhbmQgdGhlcmUgbXVzdCBiZSBhIG5vbi1gT2tgIGBPdXRib3VuZFN0YXR1c2AuIFdlIGFzc3VtZSBxdWV1ZXMgZ3JvdyBubyBncmVhdGVyWQEgdGhhbiA2NTUzNSBpdGVtcy4gUXVldWUgaW5kaWNlcyBmb3Igbm9ybWFsIG1lc3NhZ2VzIGJlZ2luIGF0IG9uZTsgemVybyBpcyByZXNlcnZlZCBpbhEBIGNhc2Ugb2YgdGhlIG5lZWQgdG8gc2VuZCBhIGhpZ2gtcHJpb3JpdHkgc2lnbmFsIG1lc3NhZ2UgdGhpcyBibG9jay4JASBUaGUgYm9vbCBpcyB0cnVlIGlmIHRoZXJlIGlzIGEgc2lnbmFsIG1lc3NhZ2Ugd2FpdGluZyB0byBiZSBzZW50LlBPdXRib3VuZFhjbXBNZXNzYWdlcwEBCAIFjQ2RDQQABLwgVGhlIG1lc3NhZ2VzIG91dGJvdW5kIGluIGEgZ2l2ZW4gWENNUCBjaGFubmVsLjhTaWduYWxNZXNzYWdlcwEBBAK9AZENBAAEoCBBbnkgc2lnbmFsIG1lc3NhZ2VzIHdhaXRpbmcgdG8gYmUgc2VudC4sUXVldWVDb25maWcBAJUNMCAAAAAwAAAACAAAAAQVASBUaGUgY29uZmlndXJhdGlvbiB3aGljaCBjb250cm9scyB0aGUgZHluYW1pY3Mgb2YgdGhlIG91dGJvdW5kIHF1ZXVlLjhRdWV1ZVN1c3BlbmRlZAEAIAQABEEBIFdoZXRoZXIgb3Igbm90IHRoZSBYQ01QIHF1ZXVlIGlzIHN1c3BlbmRlZCBmcm9tIGV4ZWN1dGluZyBpbmNvbWluZyBYQ01zIG9yIG5vdC5ERGVsaXZlcnlGZWVGYWN0b3IBAQQFvQE9AUAAAGSns7bgDQAAAAAAAAAABMQgVGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgYmFzZSBkZWxpdmVyeSBmZWUgYnkuAAFBCAxMTWF4SW5ib3VuZFN1c3BlbmRlZBAQ6AMAABRJASBUaGUgbWF4aW11bSBudW1iZXIgb2YgaW5ib3VuZCBYQ01QIGNoYW5uZWxzIHRoYXQgY2FuIGJlIHN1c3BlbmRlZCBzaW11bHRhbmVvdXNseS4AXQEgQW55IGZ1cnRoZXIgY2hhbm5lbCBzdXNwZW5zaW9ucyB3aWxsIGZhaWwgYW5kIG1lc3NhZ2VzIG1heSBnZXQgZHJvcHBlZCB3aXRob3V0IGZ1cnRoZXJFASBub3RpY2UuIENob29zaW5nIGEgaGlnaCB2YWx1ZSAoMTAwMCkgaXMgb2theTsgdGhlIHRyYWRlLW9mZiB0aGF0IGlzIGRlc2NyaWJlZCBpbtggW2BJbmJvdW5kWGNtcFN1c3BlbmRlZGBdIHN0aWxsIGFwcGxpZXMgYXQgdGhhdCBzY2FsZS5kTWF4QWN0aXZlT3V0Ym91bmRDaGFubmVscxAQgAAAACBlASBNYXhpbWFsIG51bWJlciBvZiBvdXRib3VuZCBYQ01QIGNoYW5uZWxzIHRoYXQgY2FuIGhhdmUgbWVzc2FnZXMgcXVldWVkIGF0IHRoZSBzYW1lIHRpbWUuAFUBIElmIHRoaXMgaXMgcmVhY2hlZCwgdGhlbiBubyBmdXJ0aGVyIG1lc3NhZ2VzIGNhbiBiZSBzZW50IHRvIGNoYW5uZWxzIHRoYXQgZG8gbm90IHlldF0BIGhhdmUgYSBtZXNzYWdlIHF1ZXVlZC4gVGhpcyBzaG91bGQgYmUgc2V0IHRvIHRoZSBleHBlY3RlZCBtYXhpbXVtIG9mIG91dGJvdW5kIGNoYW5uZWxzYQEgd2hpY2ggaXMgZGV0ZXJtaW5lZCBieSBbYFNlbGY6OkNoYW5uZWxJbmZvYF0uIEl0IGlzIGltcG9ydGFudCB0byBzZXQgdGhpcyBsYXJnZSBlbm91Z2gsXQEgc2luY2Ugb3RoZXJ3aXNlIHRoZSBjb25nZXN0aW9uIGNvbnRyb2wgcHJvdG9jb2wgd2lsbCBub3Qgd29yayBhcyBpbnRlbmRlZCBhbmQgbWVzc2FnZXNRASBtYXkgYmUgZHJvcHBlZC4gVGhpcyB2YWx1ZSBpbmNyZWFzZXMgdGhlIFBvViBhbmQgc2hvdWxkIHRoZXJlZm9yZSBub3QgYmUgcGlja2VkIHRvb00BIGhpZ2guIEdvdmVybmFuY2UgbmVlZHMgdG8gcGF5IGF0dGVudGlvbiB0byBub3Qgb3BlbiBtb3JlIGNoYW5uZWxzIHRoYW4gdGhpcyB2YWx1ZS4sTWF4UGFnZVNpemUQEAAAAgAUuCBUaGUgbWF4aW1hbCBwYWdlIHNpemUgZm9yIEhSTVAgbWVzc2FnZSBwYWdlcy4AYQEgQSBsb3dlciBsaW1pdCBjYW4gYmUgc2V0IGR5bmFtaWNhbGx5LCBidXQgdGhpcyBpcyB0aGUgaGFyZC1saW1pdCBmb3IgdGhlIFBvViB3b3JzdCBjYXNlVQEgYmVuY2htYXJraW5nLiBUaGUgbGltaXQgZm9yIHRoZSBzaXplIG9mIGEgbWVzc2FnZSBpcyBzbGlnaHRseSBiZWxvdyB0aGlzLCBzaW5jZSBzb21luCBvdmVyaGVhZCBpcyBpbmN1cnJlZCBmb3IgZW5jb2RpbmcgdGhlIGZvcm1hdC4BmQ1vADBNZXNzYWdlUXVldWUBME1lc3NhZ2VRdWV1ZQwwQm9va1N0YXRlRm9yAQEEBSkGnQ10AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEzCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGFuZCBsYXN0IChub24tZW1wdHkpIHBhZ2VzLixTZXJ2aWNlSGVhZAAAKQYEAAS8IFRoZSBvcmlnaW4gYXQgd2hpY2ggd2Ugc2hvdWxkIGJlZ2luIHNlcnZpY2luZy4UUGFnZXMAAQgFBakNrQ0EAASIIFRoZSBtYXAgb2YgcGFnZSBpbmRpY2VzIHRvIHBhZ2VzLgElBgFFCBAgSGVhcFNpemUQEAAMAgAUPQEgVGhlIHNpemUgb2YgdGhlIHBhZ2U7IHRoaXMgaW1wbGllcyB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgd2hpY2ggY2FuIGJlIHNlbnQuAFkBIEEgZ29vZCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSBleHBlY3RlZCBtZXNzYWdlIHNpemVzLCB0aGVpciB3ZWlnaHRzLCB0aGUgd2VpZ2h0IHRoYXQgaXNdASBhdmFpbGFibGUgZm9yIHByb2Nlc3NpbmcgdGhlbSBhbmQgdGhlIG1heGltYWwgbmVlZGVkIG1lc3NhZ2Ugc2l6ZS4gVGhlIG1heGltYWwgbWVzc2FnZREBIHNpemUgaXMgc2xpZ2h0bHkgbG93ZXIgdGhhbiB0aGlzIGFzIGRlZmluZWQgYnkgW2BNYXhNZXNzYWdlTGVuT2ZgXS4gTWF4U3RhbGUQEAgAAAAMXQEgVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YWxlIHBhZ2VzIChpLmUuIG9mIG92ZXJ3ZWlnaHQgbWVzc2FnZXMpIGFsbG93ZWQgYmVmb3JlIGN1bGxpbmdRASBjYW4gaGFwcGVuLiBPbmNlIHRoZXJlIGFyZSBtb3JlIHN0YWxlIHBhZ2VzIHRoYW4gdGhpcywgdGhlbiBoaXN0b3JpY2FsIHBhZ2VzIG1heSBiZfwgZHJvcHBlZCwgZXZlbiBpZiB0aGV5IGNvbnRhaW4gdW5wcm9jZXNzZWQgb3ZlcndlaWdodCBtZXNzYWdlcy40U2VydmljZVdlaWdodF0HLAEHAKDbIV0CAEAAGEEBIFRoZSBhbW91bnQgb2Ygd2VpZ2h0IChpZiBhbnkpIHdoaWNoIHNob3VsZCBiZSBwcm92aWRlZCB0byB0aGUgbWVzc2FnZSBxdWV1ZSBmb3KoIHNlcnZpY2luZyBlbnF1ZXVlZCBpdGVtcyBgb25faW5pdGlhbGl6ZWAuAPwgVGhpcyBtYXkgYmUgbGVnaXRpbWF0ZWx5IGBOb25lYCBpbiB0aGUgY2FzZSB0aGF0IHlvdSB3aWxsIGNhbGxdASBgU2VydmljZVF1ZXVlczo6c2VydmljZV9xdWV1ZXNgIG1hbnVhbGx5IG9yIHNldCBbYFNlbGY6OklkbGVNYXhTZXJ2aWNlV2VpZ2h0YF0gdG8gaGF2ZVQgaXQgcnVuIGluIGBvbl9pZGxlYC5QSWRsZU1heFNlcnZpY2VXZWlnaHRdBwQAFF0BIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB3ZWlnaHQgKGlmIGFueSkgdG8gYmUgdXNlZCBmcm9tIHJlbWFpbmluZyB3ZWlnaHQgYG9uX2lkbGVgIHdoaWNoQQEgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIHRoZSBtZXNzYWdlIHF1ZXVlIGZvciBzZXJ2aWNpbmcgZW5xdWV1ZWQgaXRlbXMgYG9uX2lkbGVgLj0BIFVzZWZ1bCBmb3IgcGFyYWNoYWlucyB0byBwcm9jZXNzIG1lc3NhZ2VzIGF0IHRoZSBzYW1lIGJsb2NrIHRoZXkgYXJlIHJlY2VpdmVkLgApASBJZiBgTm9uZWAsIGl0IHdpbGwgbm90IGNhbGwgYFNlcnZpY2VRdWV1ZXM6OnNlcnZpY2VfcXVldWVzYCBpbiBgb25faWRsZWAuAbUNcgAcT3JtbFhjbQABLQYBTQgAAbkNhwAcWFRva2VucwABMQYBUQgMMFNlbGZMb2NhdGlvbn0BFAEBAMkfBFQgU2VsZiBjaGFpbiBsb2NhdGlvbi40QmFzZVhjbVdlaWdodCgUAoTXFwAQRCBCYXNlIFhDTSB3ZWlnaHQuAPggVGhlIGFjdHVhbGx5IHdlaWdodCBmb3IgYW4gWENNIG1lc3NhZ2UgaXMgYFQ6OkJhc2VYY21XZWlnaHQgK2wgVDo6V2VpZ2hlcjo6d2VpZ2h0KCZtc2cpYC40UmF0ZUxpbWl0ZXJJZJAABGwgVGhlIGlkIG9mIHRoZSBSYXRlTGltaXRlci4BvQ2JADRVbmtub3duVG9rZW5zATRVbmtub3duVG9rZW5zCGBDb25jcmV0ZUZ1bmdpYmxlQmFsYW5jZXMBAQgCAsENGEAAAAAAAAAAAAAAAAAAAAAAEAUBIENvbmNyZXRlIGZ1bmdpYmxlIGJhbGFuY2VzIHVuZGVyIGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGEgY29uY3JldGU0IGZ1bmdpYmxlIGlkLgCIIGRvdWJsZV9tYXA6IHdobywgYXNzZXRfaWQgPT4gdTEyOGBBYnN0cmFjdEZ1bmdpYmxlQmFsYW5jZXMBAQgCAsUNGEAAAAAAAAAAAAAAAAAAAAAAEAUBIEFic3RyYWN0IGZ1bmdpYmxlIGJhbGFuY2VzIHVuZGVyIGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGEgYWJzdHJhY3Q0IGZ1bmdpYmxlIGlkLgCIIGRvdWJsZV9tYXA6IHdobywgYXNzZXRfaWQgPT4gdTEyOAABVQgAAckNiwAoQXV0aG9yc2hpcAEoQXV0aG9yc2hpcAQYQXV0aG9yAAAABAAEZCBBdXRob3Igb2YgY3VycmVudCBibG9jay4AAAAAoQBEQ29sbGF0b3JTZWxlY3Rpb24BRENvbGxhdG9yU2VsZWN0aW9uFDRJbnZ1bG5lcmFibGVzAQAFCwQABBEBIFRoZSBpbnZ1bG5lcmFibGUsIHBlcm1pc3Npb25lZCBjb2xsYXRvcnMuIFRoaXMgbGlzdCBtdXN0IGJlIHNvcnRlZC40Q2FuZGlkYXRlTGlzdAEAzQ0EABRpASBUaGUgKGNvbW11bml0eSwgbGltaXRlZCkgY29sbGF0aW9uIGNhbmRpZGF0ZXMuIGBDYW5kaWRhdGVzYCBhbmQgYEludnVsbmVyYWJsZXNgIHNob3VsZCBiZVAgbXV0dWFsbHkgZXhjbHVzaXZlLgB1ASBUaGlzIGxpc3QgaXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSBkZXBvc2l0IGFuZCB3aGVuIHRoZSBkZXBvc2l0cyBhcmUgZXF1YWwsIHRoZSBsZWFzdKAgcmVjZW50bHkgdXBkYXRlZCBpcyBjb25zaWRlcmVkIGdyZWF0ZXIuRExhc3RBdXRob3JlZEJsb2NrAQEEBQAQEAAAAAAEhCBMYXN0IGJsb2NrIGF1dGhvcmVkIGJ5IGNvbGxhdG9yLkREZXNpcmVkQ2FuZGlkYXRlcwEAEBAAAAAADHggRGVzaXJlZCBudW1iZXIgb2YgY2FuZGlkYXRlcy4AdQEgVGhpcyBzaG91bGQgaWRlYWxseSBhbHdheXMgYmUgbGVzcyB0aGFuIFtgQ29uZmlnOjpNYXhDYW5kaWRhdGVzYF0gZm9yIHdlaWdodHMgdG8gYmUgY29ycmVjdC40Q2FuZGlkYWN5Qm9uZAEAGEAAAAAAAAAAAAAAAAAAAAAADLggRml4ZWQgYW1vdW50IHRvIGRlcG9zaXQgdG8gYmVjb21lIGEgY29sbGF0b3IuAEEBIFdoZW4gYSBjb2xsYXRvciBjYWxscyBgbGVhdmVfaW50ZW50YCB0aGV5IGltbWVkaWF0ZWx5IHJlY2VpdmUgdGhlIGRlcG9zaXQgYmFjay4BPQYBWQgAAdkNowAcU2Vzc2lvbgEcU2Vzc2lvbhwoVmFsaWRhdG9ycwEAMQEEAAR8IFRoZSBjdXJyZW50IHNldCBvZiB2YWxpZGF0b3JzLjBDdXJyZW50SW5kZXgBABAQAAAAAAR4IEN1cnJlbnQgaW5kZXggb2YgdGhlIHNlc3Npb24uNFF1ZXVlZENoYW5nZWQBACAEAAg5ASBUcnVlIGlmIHRoZSB1bmRlcmx5aW5nIGVjb25vbWljIGlkZW50aXRpZXMgb3Igd2VpZ2h0aW5nIGJlaGluZCB0aGUgdmFsaWRhdG9yc6QgaGFzIGNoYW5nZWQgaW4gdGhlIHF1ZXVlZCB2YWxpZGF0b3Igc2V0LihRdWV1ZWRLZXlzAQDdDQQACD0BIFRoZSBxdWV1ZWQga2V5cyBmb3IgdGhlIG5leHQgc2Vzc2lvbi4gV2hlbiB0aGUgbmV4dCBzZXNzaW9uIGJlZ2lucywgdGhlc2Uga2V5c+Agd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgdmFsaWRhdG9yJ3Mgc2Vzc2lvbiBrZXlzLkhEaXNhYmxlZFZhbGlkYXRvcnMBAFkDBAAUgCBJbmRpY2VzIG9mIGRpc2FibGVkIHZhbGlkYXRvcnMuAD0BIFRoZSB2ZWMgaXMgYWx3YXlzIGtlcHQgc29ydGVkIHNvIHRoYXQgd2UgY2FuIGZpbmQgd2hldGhlciBhIGdpdmVuIHZhbGlkYXRvciBpcz0BIGRpc2FibGVkIHVzaW5nIGJpbmFyeSBzZWFyY2guIEl0IGdldHMgY2xlYXJlZCB3aGVuIGBvbl9zZXNzaW9uX2VuZGluZ2AgcmV0dXJuc2QgYSBuZXcgc2V0IG9mIGlkZW50aXRpZXMuIE5leHRLZXlzAAEEBQBFBgQABJwgVGhlIG5leHQgc2Vzc2lvbiBrZXlzIGZvciBhIHZhbGlkYXRvci4gS2V5T3duZXIAAQQF5Q0ABAAECQEgVGhlIG93bmVyIG9mIGEga2V5LiBUaGUga2V5IGlzIHRoZSBgS2V5VHlwZUlkYCArIHRoZSBlbmNvZGVkIGtleS4BQQYBXQgAAe0NpQAQQXVyYQEQQXVyYQgsQXV0aG9yaXRpZXMBAPENBAAEbCBUaGUgY3VycmVudCBhdXRob3JpdHkgc2V0LixDdXJyZW50U2xvdAEA+Q0gAAAAAAAAAAAMgCBUaGUgY3VycmVudCBzbG90IG9mIHRoaXMgYmxvY2suAJQgVGhpcyB3aWxsIGJlIHNldCBpbiBgb25faW5pdGlhbGl6ZWAuAAAEMFNsb3REdXJhdGlvbjAgcBcAAAAAAAAQDQEgVGhlIHNsb3QgZHVyYXRpb24gQXVyYSBzaG91bGQgcnVuIHdpdGgsIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMuPQEgVGhlIGVmZmVjdGl2ZSB2YWx1ZSBvZiB0aGlzIHR5cGUgc2hvdWxkIG5vdCBjaGFuZ2Ugd2hpbGUgdGhlIGNoYWluIGlzIHJ1bm5pbmcuADUBIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBlaXRoZXIgdXNlIFtgTWluaW11bVBlcmlvZFRpbWVzVHdvYF0gb3IgYSBjb25zdC4ApwAcQXVyYUV4dAEcQXVyYUV4dAgsQXV0aG9yaXRpZXMBAPENBAAUlCBTZXJ2ZXMgYXMgY2FjaGUgZm9yIHRoZSBhdXRob3JpdGllcy4AcQEgVGhlIGF1dGhvcml0aWVzIGluIEF1UmEgYXJlIG92ZXJ3cml0dGVuIGluIGBvbl9pbml0aWFsaXplYCB3aGVuIHdlIHN3aXRjaCB0byBhIG5ldyBzZXNzaW9uLF0BIGJ1dCB3ZSByZXF1aXJlIHRoZSBvbGQgYXV0aG9yaXRpZXMgdG8gdmVyaWZ5IHRoZSBzZWFsIHdoZW4gdmFsaWRhdGluZyBhIFBvVi4gVGhpcyB3aWxsDQEgYWx3YXlzIGJlIHVwZGF0ZWQgdG8gdGhlIGxhdGVzdCBBdVJhIGF1dGhvcml0aWVzIGluIGBvbl9maW5hbGl6ZWAuIFNsb3RJbmZvAAD9DQQADNggQ3VycmVudCBzbG90IHBhaXJlZCB3aXRoIGEgbnVtYmVyIG9mIGF1dGhvcmVkIGJsb2Nrcy4AmCBVcGRhdGVkIG9uIGVhY2ggYmxvY2sgaW5pdGlhbGl6YXRpb24uAAAAAKkAEElzbXABEElzbXAwQFN0YXRlQ29tbWl0bWVudHMAAQQCdQbRBgQACFkBIEhvbGRzIGEgbWFwIG9mIHN0YXRlIG1hY2hpbmUgaGVpZ2h0cyB0byB0aGVpciB2ZXJpZmllZCBzdGF0ZSBjb21taXRtZW50cy4gVGhlc2Ugc3RhdGVRASBjb21taXRtZW50cyBlbmQgdXAgaGVyZSBhZnRlciB0aGV5IGFyZSBzdWNjZXNzZnVsbHkgdmVyaWZpZWQgYnkgYSBgQ29uc2Vuc3VzQ2xpZW50YDxDb25zZW5zdXNTdGF0ZXMAAQQFSDgEAAQVASBIb2xkcyBhIG1hcCBvZiBjb25zZW5zdXMgc3RhdGUgaWRlbnRpZmllcnMgdG8gdGhlaXIgY29uc2Vuc3VzIHN0YXRlLlBDb25zZW5zdXNTdGF0ZUNsaWVudAABBAJISAQABF0BIEEgbWFwcGluZyBvZiBjb25zZW5zdXMgc3RhdGUgaWRlbnRpZmllciB0byBpdCdzIGFzc29jaWF0ZWQgY29uc2Vuc3VzIGNsaWVudCBpZGVudGlmaWVyPFVuYm9uZGluZ1BlcmlvZAABBAJIMAQABBEBIEEgbWFwcGluZyBvZiBjb25zZW5zdXMgc3RhdGUgaWRlbnRpZmllcnMgdG8gdGhlaXIgdW5ib25kaW5nIHBlcmlvZHM8Q2hhbGxlbmdlUGVyaW9kAAEEAnkGMAQABOggQSBtYXBwaW5nIG9mIHN0YXRlIG1hY2hpbmUgSWRzIHRvIHRoZWlyIGNoYWxsZW5nZSBwZXJpb2RzWEZyb3plbkNvbnNlbnN1c0NsaWVudHMBAQQCSCAEAAjkIEhvbGRzIGEgbWFwIG9mIGNvbnNlbnN1cyBjbGllbnRzIGZyb3plbiBkdWUgdG8gYnl6YW50aW5lKCBiZWhhdmlvdXJgTGF0ZXN0U3RhdGVNYWNoaW5lSGVpZ2h0AAEEAnkGMAQABLwgVGhlIGxhdGVzdCB2ZXJpZmllZCBoZWlnaHQgZm9yIGEgc3RhdGUgbWFjaGluZWRDb25zZW5zdXNDbGllbnRVcGRhdGVUaW1lAAEEBUgwBAAIGQEgSG9sZHMgdGhlIHRpbWVzdGFtcCBhdCB3aGljaCBhIGNvbnNlbnN1cyBjbGllbnQgd2FzIHJlY2VudGx5IHVwZGF0ZWQu/CBVc2VkIGluIGVuc3VyaW5nIHRoYXQgdGhlIGNvbmZpZ3VyZWQgY2hhbGxlbmdlIHBlcmlvZCBlbGFwc2VzLlhTdGF0ZU1hY2hpbmVVcGRhdGVUaW1lAAEEBXUGMAQACAUBIEhvbGRzIHRoZSB0aW1lc3RhbXAgYXQgd2hpY2ggYSBzdGF0ZSBtYWNoaW5lIGhlaWdodCB3YXMgdXBkYXRlZC78IFVzZWQgaW4gZW5zdXJpbmcgdGhhdCB0aGUgY29uZmlndXJlZCBjaGFsbGVuZ2UgcGVyaW9kIGVsYXBzZXMuJFJlc3BvbmRlZAEBBAY0IAQACLAgVHJhY2tzIHJlcXVlc3RzIHRoYXQgaGF2ZSBiZWVuIHJlc3BvbmRlZCB0b4ggVGhlIGtleSBpcyB0aGUgcmVxdWVzdCBjb21taXRtZW50FE5vbmNlAQAwIAAAAAAAAAAABLwgTGF0ZXN0IG5vbmNlIGZvciBtZXNzYWdlcyBzZW50IGZyb20gdGhpcyBjaGFpbjRDaGlsZFRyaWVSb290AQA0gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAgVGhlIGNoaWxkIHRyaWUgcm9vdCBvZiBtZXNzYWdlcwFNBgFhCAABAQ60ADRJc21wUGFyYWNoYWluATRJc21wUGFyYWNoYWluDGhSZWxheUNoYWluU3RhdGVDb21taXRtZW50cwABBAIQNAQADHEBIE1hcHBpbmcgb2YgcmVsYXkgY2hhaW4gaGVpZ2h0cyB0byBpdCdzIHN0YXRlIGNvbW1pdG1lbnQuIFRoZSBzdGF0ZSBjb21taXRtZW50IG9mIHRoZSBwYXJlbnRhASByZWxheSBibG9jayBpcyBpbnNlcnRlZCBhdCBldmVyeSBibG9jayBpbiBgb25fZmluYWxpemVgLiBUaGlzIGNvbW1pdG1lbnQgaXMgZ290dGVuIGZyb21IIHBhcmFjaGFpbi1zeXN0ZW0uQENvbnNlbnN1c1VwZGF0ZWQAACAEAAQxASBUcmFja3Mgd2hldGhlciB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhlIGB1cGRhdGVfcGFyYWNoYWluX2NvbnNlbnN1c2AgaW5oZXJlbnQoUGFyYWNoYWlucwABBAYQMAQABPQgTGlzdCBvZiBwYXJhY2hhaW5zIHRoYXQgdGhpcyBzdGF0ZSBtYWNoaW5lIGlzIGludGVyZXN0ZWQgaW4uAeUGAX0IAAEFDrUALEh5cGVyYnJpZGdlASxIeXBlcmJyaWRnZQQoSG9zdFBhcmFtcwEAhQiIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS8IFRoZSBob3N0IHBhcmFtZXRlcnMgb2YgdGhlIHBhbGxldC1oeXBlcmJyaWRnZS4AAYEIAAEJDrYAMFRva2VuR2F0ZXdheQEwVG9rZW5HYXRld2F5FDxTdXBwb3J0ZWRBc3NldHMAAQQCEDQEAAjMIEFzc2V0cyBzdXBwb3J0ZWQgYnkgdGhpcyBpbnN0YW5jZSBvZiB0b2tlbiBnYXRld2F56CBBIG1hcCBvZiB0aGUgbG9jYWwgYXNzZXQgaWQgdG8gdGhlIHRva2VuIGdhdGV3YXkgYXNzZXQgaWQwTmF0aXZlQXNzZXRzAQEEAhAgBAAEmCBBc3NldHMgdGhhdCBvcmlnaW5hdGUgZnJvbSB0aGlzIGNoYWluLExvY2FsQXNzZXRzAAEEBjQQBAAIzCBBc3NldHMgc3VwcG9ydGVkIGJ5IHRoaXMgaW5zdGFuY2Ugb2YgdG9rZW4gZ2F0ZXdheeggQSBtYXAgb2YgdGhlIHRva2VuIGdhdGV3YXkgYXNzZXQgaWQgdG8gdGhlIGxvY2FsIGFzc2V0IGlkKFByZWNpc2lvbnMAAQgCAg0OCAQABNwgVGhlIGRlY2ltYWxzIHVzZWQgYnkgdGhlIEVWTSBjb3VudGVycGFydCBvZiB0aGlzIGFzc2V0VFRva2VuR2F0ZXdheUFkZHJlc3NlcwABBAJtBjgEAAS8IFRoZSB0b2tlbiBnYXRld2F5IGFkcmVzc2VzIG9uIGRpZmZlcmVudCBjaGFpbnMB8QYBmQgEIERlY2ltYWxzCAQMBJAgVGhlIGRlY2ltYWxzIG9mIHRoZSBuYXRpdmUgY3VycmVuY3kBEQ63ACRFbWFPcmFjbGUBJEVtYU9yYWNsZQwsQWNjdW11bGF0b3IBABUOBAAEcQEgQWNjdW11bGF0b3IgZm9yIG9yYWNsZSBkYXRhIGluIGN1cnJlbnQgYmxvY2sgdGhhdCB3aWxsIGJlIHJlY29yZGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJsb2NrLhxPcmFjbGVzAAEMBQUFOQ49DgQADHUBIE9yYWNsZSBzdG9yYWdlIGtleWVkIGJ5IGRhdGEgc291cmNlLCBpbnZvbHZlZCBhc3NldCBpZHMgYW5kIHRoZSBwZXJpb2QgbGVuZ3RoIG9mIHRoZSBvcmFjbGUuAGUBIFN0b3JlcyB0aGUgZGF0YSBlbnRyeSBhcyB3ZWxsIGFzIHRoZSBibG9jayBudW1iZXIgd2hlbiB0aGUgb3JhY2xlIHdhcyBmaXJzdCBpbml0aWFsaXplZC5EV2hpdGVsaXN0ZWRBc3NldHMBAEEOBAAE3CBBc3NldHMgdGhhdCBhcmUgd2hpdGVsaXN0ZWQgYW5kIHRyYWNrZWQgYnkgdGhlIHBhbGxldC4BPQcBnQgIZE1heEFsbG93ZWRQcmljZURpZmZlcmVuY2UhAxCghgEABBkBIE1heGltdW0gYWxsb3dlZCBwZXJjZW50YWdlIGRpZmZlcmVuY2UgZm9yIGJpZnJvc3Qgb3JhY2xlIHByaWNlIHVwZGF0ZUBNYXhVbmlxdWVFbnRyaWVzEBAoAAAABPwgTWF4aW11bSBudW1iZXIgb2YgdW5pcXVlIG9yYWNsZSBlbnRyaWVzIGV4cGVjdGVkIGluIG9uZSBibG9jay4BTQ7KACRCcm9hZGNhc3QBJEJyb2FkY2FzdAw0SW5jcmVtZW50YWxJZAEAEBAAAAAABHggTmV4dCBhdmFpbGFibGUgaW5jcmVtZW50YWwgSURARXhlY3V0aW9uQ29udGV4dAEAUQ4EAAQNASBFeGVjdXRpb24gY29udGV4dCB0byBmaWd1cmUgb3V0IHdoZXJlIHRoZSB0cmFkZSBpcyBvcmlnaW5hdGVkIGZyb20cU3dhcHBlcgAAAAQABKUBSWYgZmlsbGVkLCB3ZSBvdmVyd3JpdGUgdGhlIG9yaWdpbmFsIHN3YXBwZXIuIE1haW5seSB1c2VkIGluIHJvdXRlciB0byBub3QgdG8gdXNlIHRlbXBvcmFyeSB0cmFkZSBhY2NvdW50AUEHAaEIAAFVDswABAARAXECWQ4sSENoZWNrTm9uWmVyb1NlbmRlcl0OkEBDaGVja1NwZWNWZXJzaW9uYQ4QOENoZWNrVHhWZXJzaW9uZQ4QMENoZWNrR2VuZXNpc2kONDhDaGVja01vcnRhbGl0eW0ONChDaGVja05vbmNldQ6QLENoZWNrV2VpZ2h0eQ6QYENoYXJnZVRyYW5zYWN0aW9uUGF5bWVudH0OkDRWYWxpZGF0ZUNsYWltgQ6QRENoZWNrTWV0YWRhdGFIYXNohQ4tCFBTdG9yYWdlV2VpZ2h0UmVjbGFpbY0OkJEOYBBDb3JlDBx2ZXJzaW9uAO0IBJAgUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgcnVudGltZS40ZXhlY3V0ZV9ibG9jawQUYmxvY2uVDpAEZCBFeGVjdXRlIHRoZSBnaXZlbiBibG9jay5AaW5pdGlhbGl6ZV9ibG9jawQYaGVhZGVymQ6pDgRBASBJbml0aWFsaXplIGEgYmxvY2sgd2l0aCB0aGUgZ2l2ZW4gaGVhZGVyIGFuZCByZXR1cm4gdGhlIHJ1bnRpbWUgZXhlY3V0aXZlIG1vZGUuBCEBIFRoZSBgQ29yZWAgcnVudGltZSBhcGkgdGhhdCBldmVyeSBTdWJzdHJhdGUgcnVudGltZSBuZWVkcyB0byBpbXBsZW1lbnQuIE1ldGFkYXRhDCBtZXRhZGF0YQCtDgSMIFJldHVybnMgdGhlIG1ldGFkYXRhIG9mIGEgcnVudGltZS5MbWV0YWRhdGFfYXRfdmVyc2lvbgQcdmVyc2lvbhCxDhCkIFJldHVybnMgdGhlIG1ldGFkYXRhIGF0IGEgZ2l2ZW4gdmVyc2lvbi4ABQEgSWYgdGhlIGdpdmVuIGB2ZXJzaW9uYCBpc24ndCBzdXBwb3J0ZWQsIHRoaXMgd2lsbCByZXR1cm4gYE5vbmVgLnUBIFVzZSBbYFNlbGY6Om1ldGFkYXRhX3ZlcnNpb25zYF0gdG8gZmluZCBvdXQgYWJvdXQgc3VwcG9ydGVkIG1ldGFkYXRhIHZlcnNpb24gb2YgdGhlIHJ1bnRpbWUuRG1ldGFkYXRhX3ZlcnNpb25zAFkDDKQgUmV0dXJucyB0aGUgc3VwcG9ydGVkIG1ldGFkYXRhIHZlcnNpb25zLgDAIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBgbWV0YWRhdGFfYXRfdmVyc2lvbmAuBAEBIFRoZSBgTWV0YWRhdGFgIGFwaSB0cmFpdCB0aGF0IHJldHVybnMgbWV0YWRhdGEgZm9yIHRoZSBydW50aW1lLjBCbG9ja0J1aWxkZXIQPGFwcGx5X2V4dHJpbnNpYwQkZXh0cmluc2ljnQ61DhBsIEFwcGx5IHRoZSBnaXZlbiBleHRyaW5zaWMuADkBIFJldHVybnMgYW4gaW5jbHVzaW9uIG91dGNvbWUgd2hpY2ggc3BlY2lmaWVzIGlmIHRoaXMgZXh0cmluc2ljIGlzIGluY2x1ZGVkIGluTCB0aGlzIGJsb2NrIG9yIG5vdC44ZmluYWxpemVfYmxvY2sAmQ4EaCBGaW5pc2ggdGhlIGN1cnJlbnQgYmxvY2suTGluaGVyZW50X2V4dHJpbnNpY3MEIGluaGVyZW50xQ6lDgQ9ASBHZW5lcmF0ZSBpbmhlcmVudCBleHRyaW5zaWNzLiBUaGUgaW5oZXJlbnQgZGF0YSB3aWxsIHZhcnkgZnJvbSBjaGFpbiB0byBjaGFpbi48Y2hlY2tfaW5oZXJlbnRzCBRibG9ja5UOEGRhdGHFDtUOBFUBIENoZWNrIHRoYXQgdGhlIGluaGVyZW50cyBhcmUgdmFsaWQuIFRoZSBpbmhlcmVudCBkYXRhIHdpbGwgdmFyeSBmcm9tIGNoYWluIHRvIGNoYWluLgRxASBUaGUgYEJsb2NrQnVpbGRlcmAgYXBpIHRyYWl0IHRoYXQgcHJvdmlkZXMgdGhlIHJlcXVpcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGJ1aWxkaW5nIGEgYmxvY2suWFRhZ2dlZFRyYW5zYWN0aW9uUXVldWUEUHZhbGlkYXRlX3RyYW5zYWN0aW9uDBhzb3VyY2XZDgh0eJ0OKGJsb2NrX2hhc2g03Q4kaCBWYWxpZGF0ZSB0aGUgdHJhbnNhY3Rpb24uAGUBIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYnkgdGhlIHRyYW5zYWN0aW9uIHBvb2wgdG8gbGVhcm4gZGV0YWlscyBhYm91dCBnaXZlbiB0cmFuc2FjdGlvbi5FASBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIG1ha2Ugc3VyZSB0byB2ZXJpZnkgdGhlIGNvcnJlY3RuZXNzIG9mIHRoZSB0cmFuc2FjdGlvbk0BIGFnYWluc3QgY3VycmVudCBzdGF0ZS4gVGhlIGdpdmVuIGBibG9ja19oYXNoYCBjb3JyZXNwb25kcyB0byB0aGUgaGFzaCBvZiB0aGUgYmxvY2t8IHRoYXQgaXMgdXNlZCBhcyBjdXJyZW50IHN0YXRlLgBFASBOb3RlIHRoYXQgdGhpcyBjYWxsIG1heSBiZSBwZXJmb3JtZWQgYnkgdGhlIHBvb2wgbXVsdGlwbGUgdGltZXMgYW5kIHRyYW5zYWN0aW9uc6QgbWlnaHQgYmUgdmVyaWZpZWQgaW4gYW55IHBvc3NpYmxlIG9yZGVyLgRNASBUaGUgYFRhZ2dlZFRyYW5zYWN0aW9uUXVldWVgIGFwaSB0cmFpdCBmb3IgaW50ZXJmZXJpbmcgd2l0aCB0aGUgdHJhbnNhY3Rpb24gcXVldWUuRE9mZmNoYWluV29ya2VyQXBpBDxvZmZjaGFpbl93b3JrZXIEGGhlYWRlcpkOkATIIFN0YXJ0cyB0aGUgb2ZmLWNoYWluIHRhc2sgZm9yIGdpdmVuIGJsb2NrIGhlYWRlci4EZCBUaGUgb2ZmY2hhaW4gd29ya2VyIGFwaS4sU2Vzc2lvbktleXMIVGdlbmVyYXRlX3Nlc3Npb25fa2V5cwQQc2VlZKkGOBwVASBHZW5lcmF0ZSBhIHNldCBvZiBzZXNzaW9uIGtleXMgd2l0aCBvcHRpb25hbGx5IHVzaW5nIHRoZSBnaXZlbiBzZWVkLgkBIFRoZSBrZXlzIHNob3VsZCBiZSBzdG9yZWQgd2l0aGluIHRoZSBrZXlzdG9yZSBleHBvc2VkIHZpYSBydW50aW1lPCBleHRlcm5hbGl0aWVzLgCwIFRoZSBzZWVkIG5lZWRzIHRvIGJlIGEgdmFsaWQgYHV0ZjhgIHN0cmluZy4A0CBSZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgU0NBTEUgZW5jb2RlZCBwdWJsaWMga2V5cy5MZGVjb2RlX3Nlc3Npb25fa2V5cwQcZW5jb2RlZDjlDgyYIERlY29kZSB0aGUgZ2l2ZW4gcHVibGljIHNlc3Npb24ga2V5cy4A3CBSZXR1cm5zIHRoZSBsaXN0IG9mIHB1YmxpYyByYXcgcHVibGljIGtleXMgKyBrZXkgdHlwZS4EaCBTZXNzaW9uIGtleXMgcnVudGltZSBhcGkuHEF1cmFBcGkINHNsb3RfZHVyYXRpb24A8Q4MkCBSZXR1cm5zIHRoZSBzbG90IGR1cmF0aW9uIGZvciBBdXJhLgAlASBDdXJyZW50bHksIG9ubHkgdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IHRoaXMgdHlwZSBhdCBnZW5lc2lzIHdpbGwgYmUgdXNlZC4sYXV0aG9yaXRpZXMA9Q0EnCBSZXR1cm4gdGhlIGN1cnJlbnQgc2V0IG9mIGF1dGhvcml0aWVzLgS4IEFQSSBuZWNlc3NhcnkgZm9yIGJsb2NrIGF1dGhvcnNoaXAgd2l0aCBhdXJhLlBDb2xsZWN0Q29sbGF0aW9uSW5mbwRYY29sbGVjdF9jb2xsYXRpb25faW5mbwQYaGVhZGVymQ71DhCcIENvbGxlY3QgaW5mb3JtYXRpb24gYWJvdXQgYSBjb2xsYXRpb24uAPQgVGhlIGdpdmVuIGBoZWFkZXJgIGlzIHRoZSBoZWFkZXIgb2YgdGhlIGJ1aWx0IGJsb2NrIGZvciB0aGF0qCB3ZSBhcmUgY29sbGVjdGluZyB0aGUgY29sbGF0aW9uIGluZm8gZm9yLgTYIFJ1bnRpbWUgYXBpIHRvIGNvbGxlY3QgaW5mb3JtYXRpb24gYWJvdXQgYSBjb2xsYXRpb24uNEN1cnJlbmNpZXNBcGkQHGFjY291bnQIIGFzc2V0X2lkEAx3aG8AAQ8AIGFjY291bnRzBAx3aG8ABQ8AMGZyZWVfYmFsYW5jZQggYXNzZXRfaWQQDHdobwAYADxtaW5pbXVtX2JhbGFuY2UEIGFzc2V0X2lkEBgAADxBY2NvdW50Tm9uY2VBcGkENGFjY291bnRfbm9uY2UEHGFjY291bnQAEATAIEdldCBjdXJyZW50IGFjY291bnQgbm9uY2Ugb2YgZ2l2ZW4gYEFjY291bnRJZGAuBIAgVGhlIEFQSSB0byBxdWVyeSBhY2NvdW50IG5vbmNlLlRUcmFuc2FjdGlvblBheW1lbnRBcGkQKHF1ZXJ5X2luZm8IDHV4dJ0ODGxlbhANDwBEcXVlcnlfZmVlX2RldGFpbHMIDHV4dJ0ODGxlbhARDwBMcXVlcnlfd2VpZ2h0X3RvX2ZlZQQYd2VpZ2h0KBgATHF1ZXJ5X2xlbmd0aF90b19mZWUEGGxlbmd0aBAYAABURXRoZXJldW1SdW50aW1lUlBDQXBpRCBjaGFpbl9pZAAwBLQgUmV0dXJucyBydW50aW1lIGRlZmluZWQgcGFsbGV0X2V2bTo6Q2hhaW5JZC40YWNjb3VudF9iYXNpYwQcYWRkcmVzc0EBHQ8EpCBSZXR1cm5zIHBhbGxldF9ldm06OkFjY291bnRzIGJ5IGFkZHJlc3MuJGdhc19wcmljZQBJAQSUIFJldHVybnMgRml4ZWRHYXNQcmljZTo6bWluX2dhc19wcmljZTxhY2NvdW50X2NvZGVfYXQEHGFkZHJlc3NBATgE/CBGb3IgYSBnaXZlbiBhY2NvdW50IGFkZHJlc3MsIHJldHVybnMgcGFsbGV0X2V2bTo6QWNjb3VudENvZGVzLhhhdXRob3IAQQEE8CBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgRmluZEF1dGhvcjo6ZmluZF9hdXRob3IgYXV0aG9yaXR5IGlkLihzdG9yYWdlX2F0CBxhZGRyZXNzQQEUaW5kZXhJATQEMQEgRm9yIGEgZ2l2ZW4gYWNjb3VudCBhZGRyZXNzIGFuZCBpbmRleCwgcmV0dXJucyBwYWxsZXRfZXZtOjpBY2NvdW50U3RvcmFnZXMuEGNhbGwoEGZyb21BAQh0b0EBEGRhdGE4FHZhbHVlSQEkZ2FzX2xpbWl0SQE8bWF4X2ZlZV9wZXJfZ2FzKQRgbWF4X3ByaW9yaXR5X2ZlZV9wZXJfZ2FzKQQUbm9uY2UpBCBlc3RpbWF0ZSAsYWNjZXNzX2xpc3QhDyUPABhjcmVhdGUkEGZyb21BARBkYXRhOBR2YWx1ZUkBJGdhc19saW1pdEkBPG1heF9mZWVfcGVyX2dhcykEYG1heF9wcmlvcml0eV9mZWVfcGVyX2dhcykEFG5vbmNlKQQgZXN0aW1hdGUgLGFjY2Vzc19saXN0IQ85DwA0Y3VycmVudF9ibG9jawBBDwRoIFJldHVybiB0aGUgY3VycmVudCBibG9jay5AY3VycmVudF9yZWNlaXB0cwBFDwRwIFJldHVybiB0aGUgY3VycmVudCByZWNlaXB0LnBjdXJyZW50X3RyYW5zYWN0aW9uX3N0YXR1c2VzAEkPBJwgUmV0dXJuIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXR1cy4sY3VycmVudF9hbGwATQ8AQGV4dHJpbnNpY19maWx0ZXIEDHh0c6UOVQwENQEgUmVjZWl2ZXMgYSBgVmVjPE9wYXF1ZUV4dHJpbnNpYz5gIGFuZCBmaWx0ZXJzIGFsbCB0aGUgZXRoZXJldW0gdHJhbnNhY3Rpb25zLihlbGFzdGljaXR5APUDBIggUmV0dXJuIHRoZSBlbGFzdGljaXR5IG11bHRpcGxpZXIucGdhc19saW1pdF9tdWx0aXBsaWVyX3N1cHBvcnQAkAh1ASBVc2VkIHRvIGRldGVybWluZSBpZiBnYXMgbGltaXQgbXVsdGlwbGllciBmb3Igbm9uLXRyYW5zYWN0aW9uYWwgY2FsbHMgKGV0aF9jYWxsL2VzdGltYXRlR2FzKTggaXMgc3VwcG9ydGVkLjRwZW5kaW5nX2Jsb2NrBAx4dHOlDlEPBGggUmV0dXJuIHRoZSBwZW5kaW5nIGJsb2NrLmBpbml0aWFsaXplX3BlbmRpbmdfYmxvY2sEGGhlYWRlcpkOkBR4IEluaXRpYWxpemUgdGhlIHBlbmRpbmcgYmxvY2suNQEgVGhlIGJlaGF2aW9yIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcnVudGltZSBhcGkgQ29yZV9pbml0aWFsaXplX2Jsb2NrIGJ1dFwgZm9yIGEgInBlbmRpbmciIGJsb2NrLmEBIElmIHlvdXIgcHJvamVjdCBkb24ndCBuZWVkIHRvIGhhdmUgYSBkaWZmZXJlbnQgYmVoYXZpb3IgdG8gaW5pdGlhbGl6ZSAicGVuZGluZyIgYmxvY2tzLOAgeW91IGNhbiBjb3B5IHlvdXIgQ29yZV9pbml0aWFsaXplX2Jsb2NrIGltcGxlbWVudGF0aW9uLgTAIEFQSSBuZWNlc3NhcnkgZm9yIEV0aGVyZXVtLWNvbXBhdGliaWxpdHkgbGF5ZXIucENvbnZlcnRUcmFuc2FjdGlvblJ1bnRpbWVBcGkETGNvbnZlcnRfdHJhbnNhY3Rpb24ELHRyYW5zYWN0aW9uOQSdDgAAOEV2bUFjY291bnRzQXBpDCxldm1fYWRkcmVzcwQoYWNjb3VudF9pZABBAQTAIGdldCB0aGUgRVZNIGFkZHJlc3MgZnJvbSB0aGUgc3Vic3RyYXRlIGFkZHJlc3MuQGJvdW5kX2FjY291bnRfaWQELGV2bV9hZGRyZXNzQQHsBFUBIFJldHVybiB0aGUgU3Vic3RyYXRlIGFkZHJlc3MgYm91bmQgdG8gdGhlIEVWTSBhY2NvdW50LiBJZiBub3QgYm91bmQsIHJldHVybnMgYE5vbmVgLihhY2NvdW50X2lkBCxldm1fYWRkcmVzc0EBAAjAIEdldCB0aGUgU3Vic3RyYXRlIGFkZHJlc3MgZnJvbSB0aGUgRVZNIGFkZHJlc3MuJQEgUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHZlcnNpb24gb2YgdGhlIGFkZHJlc3MgaWYgdGhlIGFkZHJlc3Mgd2Fzbid0IGJpbmQuBKggVGhlIEFQSSB0byBxdWVyeSBFVk0gYWNjb3VudCBjb252ZXJzaW9ucy48RXJjMjBNYXBwaW5nQXBpCDRhc3NldF9hZGRyZXNzBCBhc3NldF9pZBBBAQSIIEdldCB0aGUgRVZNIGFkZHJlc3Mgb2YgdGhlIGFzc2V0LkBhZGRyZXNzX3RvX2Fzc2V0BBxhZGRyZXNzQQFZAQQ1ASBHZXQgdGhlIGFzc2V0IGlkIGNvcnJlc3BvbmRpbmcgdG8gRVZNIGFkZHJlc3MuIElmIG5vdCBmb3VuZCwgcmV0dXJucyBgTm9uZWAuBNggVGhlIEFQSSB0byBxdWVyeSBBc3NldElkIDwtPiBFVk0gYWRkcmVzcyBjb252ZXJzaW9ucy40WGNtUGF5bWVudEFwaRB8cXVlcnlfYWNjZXB0YWJsZV9wYXltZW50X2Fzc2V0cwQseGNtX3ZlcnNpb24QVQ8UtCBSZXR1cm5zIGEgbGlzdCBvZiBhY2NlcHRhYmxlIHBheW1lbnQgYXNzZXRzLgAwICMgQXJndW1lbnRzAGggKiBgeGNtX3ZlcnNpb25gOiBWZXJzaW9uLkBxdWVyeV94Y21fd2VpZ2h0BBxtZXNzYWdl5QRhDxSoIFJldHVybnMgYSB3ZWlnaHQgbmVlZGVkIHRvIGV4ZWN1dGUgYSBYQ00uADAgIyBBcmd1bWVudHMAdCAqIGBtZXNzYWdlYDogYFZlcnNpb25lZFhjbWAuZHF1ZXJ5X3dlaWdodF90b19hc3NldF9mZWUIGHdlaWdodCgUYXNzZXQdBmUPGOggQ29udmVydHMgYSB3ZWlnaHQgaW50byBhIGZlZSBmb3IgdGhlIHNwZWNpZmllZCBgQXNzZXRJZGAuADAgIyBBcmd1bWVudHMAiCAqIGB3ZWlnaHRgOiBjb252ZXJ0aWJsZSBgV2VpZ2h0YC58ICogYGFzc2V0YDogYFZlcnNpb25lZEFzc2V0SWRgLkxxdWVyeV9kZWxpdmVyeV9mZWVzCCxkZXN0aW5hdGlvbsUEHG1lc3NhZ2XlBGkPIB0BIEdldCBkZWxpdmVyeSBmZWVzIGZvciBzZW5kaW5nIGEgc3BlY2lmaWMgYG1lc3NhZ2VgIHRvIGEgYGRlc3RpbmF0aW9uYC70IFRoZXNlIGFsd2F5cyBjb21lIGluIGEgc3BlY2lmaWMgYXNzZXQsIGRlZmluZWQgYnkgdGhlIGNoYWluLgAwICMgQXJndW1lbnRzgQEgKiBgbWVzc2FnZWA6IFRoZSBtZXNzYWdlIHRoYXQnbGwgYmUgc2VudCwgbmVjZXNzYXJ5IGJlY2F1c2UgbW9zdCBkZWxpdmVyeSBmZWVzIGFyZSBiYXNlZCBvbiB0aGVcICAgc2l6ZSBvZiB0aGUgbWVzc2FnZS5hASAqIGBkZXN0aW5hdGlvbmA6IFRoZSBkZXN0aW5hdGlvbiB0byBzZW5kIHRoZSBtZXNzYWdlIHRvLiBEaWZmZXJlbnQgZGVzdGluYXRpb25zIG1heSB1c2XAICAgZGlmZmVyZW50IHNlbmRlcnMgdGhhdCBjaGFyZ2UgZGlmZmVyZW50IGZlZXMuLHAgQSB0cmFpdCBvZiBYQ00gcGF5bWVudCBBUEkuAKggQVBJIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG9idGFpbmluZzoAxCAqIHRoZSB3ZWlnaHQgcmVxdWlyZWQgdG8gZXhlY3V0ZSBhbiBYQ00gbWVzc2FnZSwFASAqIGEgbGlzdCBvZiBhY2NlcHRhYmxlIGBBc3NldElkYHMgZm9yIG1lc3NhZ2UgZXhlY3V0aW9uIHBheW1lbnQsAQEgKiB0aGUgY29zdCBvZiB0aGUgd2VpZ2h0IGluIHRoZSBzcGVjaWZpZWQgYWNjZXB0YWJsZSBgQXNzZXRJZGAuoCAqIHRoZSBmZWVzIGZvciBhbiBYQ00gbWVzc2FnZSBkZWxpdmVyeS4A8CBUbyBkZXRlcm1pbmUgdGhlIGV4ZWN1dGlvbiB3ZWlnaHQgb2YgdGhlIGNhbGxzIHJlcXVpcmVkIGZvcnUBIFtgeGNtOjpsYXRlc3Q6Okluc3RydWN0aW9uOjpUcmFuc2FjdGBdIGluc3RydWN0aW9uLCBgVHJhbnNhY3Rpb25QYXltZW50Q2FsbEFwaWAgY2FuIGJlIHVzZWQuYEF1cmFVbmluY2x1ZGVkU2VnbWVudEFwaQQ4Y2FuX2J1aWxkX3Vwb24INGluY2x1ZGVkX2hhc2g0EHNsb3T5DSAoOQEgV2hldGhlciBpdCBpcyBsZWdhbCB0byBleHRlbmQgdGhlIGNoYWluLCBhc3N1bWluZyB0aGUgZ2l2ZW4gYmxvY2sgaXMgdGhlIG1vc3Q1ASByZWNlbnRseSBpbmNsdWRlZCBvbmUgYXMtb2YgdGhlIHJlbGF5IHBhcmVudCB0aGF0IHdpbGwgYmUgYnVpbHQgYWdhaW5zdCwgYW5kQCB0aGUgZ2l2ZW4gc2xvdC4AUQEgVGhpcyBzaG91bGQgYmUgY29uc2lzdGVudCB3aXRoIHRoZSBsb2dpYyB0aGUgcnVudGltZSB1c2VzIHdoZW4gdmFsaWRhdGluZyBibG9ja3MgdG84IGF2b2lkIGlzc3Vlcy4AYQEgV2hlbiB0aGUgdW5pbmNsdWRlZCBzZWdtZW50IGlzIGVtcHR5LCBpLmUuIGBpbmNsdWRlZF9oYXNoID09IGF0YCwgd2hlcmUgYXQgaXMgdGhlIGJsb2NrYQEgd2hvc2Ugc3RhdGUgd2UgYXJlIHF1ZXJ5aW5nIGFnYWluc3QsIHRoaXMgbXVzdCBhbHdheXMgcmV0dXJuIGB0cnVlYCBhcyBsb25nIGFzIHRoZSBzbG90vCBpcyBtb3JlIHJlY2VudCB0aGFuIHRoZSBpbmNsdWRlZCBibG9jayBpdHNlbGYuKDUBIFRoaXMgcnVudGltZSBBUEkgaXMgdXNlZCB0byBpbmZvcm0gcG90ZW50aWFsIGJsb2NrIGF1dGhvcnMgd2hldGhlciB0aGV5IHdpbGwlASBoYXZlIHRoZSByaWdodCB0byBhdXRob3IgYXQgYSBzbG90LCBhc3N1bWluZyB0aGV5IGhhdmUgY2xhaW1lZCB0aGUgc2xvdC4AdQEgSW4gcGFydGljdWxhciwgdGhpcyBBUEkgYWxsb3dzIEF1cmEtYmFzZWQgcGFyYWNoYWlucyB0byByZWd1bGF0ZSB0aGVpciAidW5pbmNsdWRlZCBzZWdtZW50IixtASB3aGljaCBpcyB0aGUgc2VjdGlvbiBvZiB0aGUgaGVhZCBvZiB0aGUgY2hhaW4gd2hpY2ggaGFzIG5vdCB5ZXQgYmVlbiBtYWRlIGF2YWlsYWJsZSBpbiB0aGU0IHJlbGF5IGNoYWluLgBhASBXaGVuIHRoZSB1bmluY2x1ZGVkIHNlZ21lbnQgaXMgc2hvcnQsIEF1cmEgY2hhaW5zIHdpbGwgYWxsb3cgYXV0aG9ycyB0byBjcmVhdGUgbXVsdGlwbGVdASBibG9ja3MgcGVyIHNsb3QgaW4gb3JkZXIgdG8gYnVpbGQgYSBiYWNrbG9nLiBXaGVuIGl0IGlzIHNhdHVyYXRlZCwgdGhpcyBBUEkgd2lsbCBsaW1pdKggdGhlIGFtb3VudCBvZiBibG9ja3MgdGhhdCBjYW4gYmUgY3JlYXRlZC4kRHJ5UnVuQXBpCDBkcnlfcnVuX2NhbGwIGG9yaWdpbmUBEGNhbGwRAW0PBDggRHJ5IHJ1biBjYWxsLixkcnlfcnVuX3hjbQg8b3JpZ2luX2xvY2F0aW9uxQQMeGNt7QWNDwRQIERyeSBydW4gWENNIHByb2dyYW0ksQEgQVBJIGZvciBkcnktcnVubmluZyBleHRyaW5zaWNzIGFuZCBYQ00gcHJvZ3JhbXMgdG8gZ2V0IHRoZSBwcm9ncmFtcyB0aGF0IG5lZWQgdG8gYmUgcGFzc2VkIHRvIHRoZSBmZWVzIEFQSS4AgQEgQWxsIGNhbGxzIHJldHVybiBhIHZlY3RvciBvZiB0dXBsZXMgKGxvY2F0aW9uLCB4Y20pIHdoZXJlIGVhY2ggInhjbSIgaXMgZXhlY3V0ZWQgaW4gImxvY2F0aW9uIi7kIElmIHRoZXJlJ3MgbG9jYWwgZXhlY3V0aW9uLCB0aGUgbG9jYXRpb24gd2lsbCBiZSAiSGVyZSIuHQEgVGhpcyB2ZWN0b3IgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGJvdGggZXhlY3V0aW9uIGFuZCBkZWxpdmVyeSBmZWVzLgCZASBDYWxscyBvciBYQ01zIG1pZ2h0IGZhaWwgd2hlbiBleGVjdXRlZCwgdGhpcyBkb2Vzbid0IG1lYW4gdGhlIHJlc3VsdCBvZiB0aGVzZSBjYWxscyB3aWxsIGJlIGFuIGBFcnJgLmUBIEluIHRob3NlIGNhc2VzLCB0aGVyZSBtaWdodCBzdGlsbCBiZSBhIHZhbGlkIHJlc3VsdCwgd2l0aCB0aGUgZXhlY3V0aW9uIGVycm9yIGluc2lkZSBpdC5lASBUaGUgb25seSByZWFzb25zIHdoeSB0aGVzZSBjYWxscyBtaWdodCByZXR1cm4gYW4gZXJyb3IgYXJlIGxpc3RlZCBpbiB0aGUgW2BFcnJvcmBdIGVudW0uUExvY2F0aW9uVG9BY2NvdW50QXBpBEBjb252ZXJ0X2xvY2F0aW9uBCBsb2NhdGlvbsUElQ8EkCBDb252ZXJ0cyBgTG9jYXRpb25gIHRvIGBBY2NvdW50SWRgLgQNASBBUEkgZm9yIHVzZWZ1bCBjb252ZXJzaW9ucyBiZXR3ZWVuIFhDTSBgTG9jYXRpb25gIGFuZCBgQWNjb3VudElkYC5MQ2hhaW5saW5rQWRhcHRlckFwaQhUZW5jb2RlX29yYWNsZV9hZGRyZXNzEChhc3NldF9pZF9hEChhc3NldF9pZF9iEBhwZXJpb2S5Axhzb3VyY2X9AUEBAFRkZWNvZGVfb3JhY2xlX2FkZHJlc3MEOG9yYWNsZV9hZGRyZXNzQQGdDwAEqCBUaGUgQVBJIHRvIHF1ZXJ5IEVWTSBhY2NvdW50IGNvbnZlcnNpb25zLkRBYXZlVHJhZGVFeGVjdXRvchAUcGFpcnMAUQMAPGxpcXVpZGl0eV9kZXB0aAggYXNzZXRfaW4QJGFzc2V0X291dBDgABBwb29sCBxyZXNlcnZlEBhhdG9rZW4QpQ8AFHBvb2xzAKkPAAA4SXNtcFJ1bnRpbWVBcGkkSGhvc3Rfc3RhdGVfbWFjaGluZQBtBgTIIFNob3VsZCByZXR1cm4gdGhlIGhvc3QncyBzdGF0ZSBtYWNoaW5lIGlkZW50aWZpZXIwYmxvY2tfZXZlbnRzAK0PBFggRmV0Y2ggYWxsIElTTVAgZXZlbnRzaGJsb2NrX2V2ZW50c193aXRoX21ldGFkYXRhAL0PBMwgRmV0Y2ggYWxsIElTTVAgZXZlbnRzIGFuZCB0aGVpciBleHRyaW5zaWMgbWV0YWRhdGE8Y29uc2Vuc3VzX3N0YXRlBAhpZEipBgSkIFJldHVybiB0aGUgc2NhbGUgZW5jb2RlZCBjb25zZW5zdXMgc3RhdGVkc3RhdGVfbWFjaGluZV91cGRhdGVfdGltZQQIaWR1BtkGBPQgUmV0dXJuIHRoZSB0aW1lc3RhbXAgdGhpcyBjbGllbnQgd2FzIGxhc3QgdXBkYXRlZCBpbiBzZWNvbmRzQGNoYWxsZW5nZV9wZXJpb2QECGlkeQbZBgSYIFJldHVybiB0aGUgY2hhbGxlbmdlIHBlcmlvZCB0aW1lc3RhbXBsbGF0ZXN0X3N0YXRlX21hY2hpbmVfaGVpZ2h0BAhpZHkG2QYEuCBSZXR1cm4gdGhlIGxhdGVzdCBoZWlnaHQgb2YgdGhlIHN0YXRlIG1hY2hpbmUgcmVxdWVzdHMETHJlcXVlc3RfY29tbWl0bWVudHPJAYUGBLggRmV0Y2ggdGhlIHJlcXVlc3RzIGZvciB0aGUgZ2l2ZW4gY29tbWl0bWVudHMuJHJlc3BvbnNlcwRQcmVzcG9uc2VfY29tbWl0bWVudHPJAZEGBLwgRmV0Y2ggdGhlIHJlc3BvbnNlcyBmb3IgdGhlIGdpdmVuIGNvbW1pdG1lbnRzLgQBASBSZXF1aXJlZCBydW50aW1lIEFQSXMgbmVlZGVkIGZvciBjbGllbnQgc3Vic3lzdGVtcyBsaWtlIHRoZSBSUENASXNtcFBhcmFjaGFpbkFwaQggcGFyYV9pZHMAWQMEVQEgUmV0dXJuIGFsbCB0aGUgcGFyYV9pZHMgdGhpcyBydW50aW1lIGlzIGludGVyZXN0ZWQgaW4uIFVzZWQgYnkgdGhlIGluaGVyZW50IHByb3ZpZGVyZGN1cnJlbnRfcmVsYXlfY2hhaW5fc3RhdGUAxQ8EmCBSZXR1cm4gdGhlIGN1cnJlbnQgcmVsYXkgY2hhaW4gc3RhdGUuBLQgSXNtcCBQYXJhY2hhaW4gY29uc2Vuc3VzIGNsaWVudCBydW50aW1lIEFQSXM4R2VuZXNpc0J1aWxkZXIMLGJ1aWxkX3N0YXRlBBBqc29uOMkPJGUBIEJ1aWxkIGBSdW50aW1lR2VuZXNpc0NvbmZpZ2AgZnJvbSBhIEpTT04gYmxvYiBub3QgdXNpbmcgYW55IGRlZmF1bHRzIGFuZCBzdG9yZSBpdCBpbiB0aGUkIHN0b3JhZ2UuAPkBIEluIHRoZSBjYXNlIG9mIGEgRlJBTUUtYmFzZWQgcnVudGltZSwgdGhpcyBmdW5jdGlvbiBkZXNlcmlhbGl6ZXMgdGhlIGZ1bGwgYFJ1bnRpbWVHZW5lc2lzQ29uZmlnYCBmcm9tIHRoZSBnaXZlbiBKU09OIGJsb2IgYW5kWQEgcHV0cyBpdCBpbnRvIHRoZSBzdG9yYWdlLiBJZiB0aGUgcHJvdmlkZWQgSlNPTiBibG9iIGlzIGluY29ycmVjdCBvciBpbmNvbXBsZXRlIG9yIHRoZbQgZGVzZXJpYWxpemF0aW9uIGZhaWxzLCBhbiBlcnJvciBpcyByZXR1cm5lZC4AXQEgUGxlYXNlIG5vdGUgdGhhdCBwcm92aWRlZCBKU09OIGJsb2IgbXVzdCBjb250YWluIGFsbCBgUnVudGltZUdlbmVzaXNDb25maWdgIGZpZWxkcywgbm9cIGRlZmF1bHRzIHdpbGwgYmUgdXNlZC4oZ2V0X3ByZXNldAQIaWTND6kGOGEBIFJldHVybnMgYSBKU09OIGJsb2IgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ1aWx0LWluIGBSdW50aW1lR2VuZXNpc0NvbmZpZ2AgaWRlbnRpZmllZCBieRggYGlkYC4APQEgSWYgYGlkYCBpcyBgTm9uZWAgdGhlIGZ1bmN0aW9uIHJldHVybnMgSlNPTiBibG9iIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZWZhdWx0SQEgYFJ1bnRpbWVHZW5lc2lzQ29uZmlnYCBzdHJ1Y3Qgb2YgdGhlIHJ1bnRpbWUuIEltcGxlbWVudGF0aW9uIG11c3QgcHJvdmlkZSBkZWZhdWx0YCBgUnVudGltZUdlbmVzaXNDb25maWdgLgAhASBPdGhlcndpc2UgZnVuY3Rpb24gcmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ1aWx0LWluLCBuYW1lZFEBIGBSdW50aW1lR2VuZXNpc0NvbmZpZ2AgcHJlc2V0IGlkZW50aWZpZWQgYnkgYGlkYCwgb3IgYE5vbmVgIGlmIHN1Y2ggcHJlc2V0IGRvZXMgbm90YQEgZXhpc3QuIFJldHVybmVkIGBWZWM8dTg+YCBjb250YWlucyBieXRlcyBvZiBKU09OIGJsb2IgKHBhdGNoKSB3aGljaCBjb21wcmlzZXMgYSBsaXN0IG9mTQEgKHBvdGVudGlhbGx5IG5lc3RlZCkga2V5LXZhbHVlIHBhaXJzIHRoYXQgYXJlIGludGVuZGVkIGZvciBjdXN0b21pemluZyB0aGUgZGVmYXVsdGUBIHJ1bnRpbWUgZ2VuZXNpcyBjb25maWcuIFRoZSBwYXRjaCBzaGFsbCBiZSBtZXJnZWQgKHJmYzczODYpIHdpdGggdGhlIEpTT04gcmVwcmVzZW50YXRpb25hASBvZiB0aGUgZGVmYXVsdCBgUnVudGltZUdlbmVzaXNDb25maWdgIHRvIGNyZWF0ZSBhIGNvbXByZWhlbnNpdmUgZ2VuZXNpcyBjb25maWcgdGhhdCBjYW6EIGJlIHVzZWQgaW4gYGJ1aWxkX3N0YXRlYCBtZXRob2QuMHByZXNldF9uYW1lcwDRDxBRASBSZXR1cm5zIGEgbGlzdCBvZiBpZGVudGlmaWVycyBmb3IgYXZhaWxhYmxlIGJ1aWx0aW4gYFJ1bnRpbWVHZW5lc2lzQ29uZmlnYCBwcmVzZXRzLgBhASBUaGUgcHJlc2V0cyBmcm9tIHRoZSBsaXN0IGNhbiBiZSBxdWVyaWVkIHdpdGggW2BHZW5lc2lzQnVpbGRlcjo6Z2V0X3ByZXNldGBdIG1ldGhvZC4gSWYBASBubyBuYW1lZCBwcmVzZXRzIGFyZSBwcm92aWRlZCBieSB0aGUgcnVudGltZSB0aGUgbGlzdCBpcyBlbXB0eS4E6CBBUEkgdG8gaW50ZXJhY3Qgd2l0aCBSdW50aW1lR2VuZXNpc0NvbmZpZyBmb3IgdGhlIHJ1bnRpbWURAVTVDwA=";
    hydration_metadata_default = binMeta;
  }
});

// node_modules/.pnpm/@galacticcouncil+descriptors@1.8.0/node_modules/@galacticcouncil/descriptors/build/index.mjs
var table = new Uint8Array(128);
for (let i = 0; i < 64; i++) table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
var toBinary = (base64) => {
  const n = base64.length, bytes = new Uint8Array((n - Number(base64[n - 1] === "=") - Number(base64[n - 2] === "=")) * 3 / 4 | 0);
  for (let i2 = 0, j = 0; i2 < n; ) {
    const c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
    const c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
    bytes[j++] = c0 << 2 | c1 >> 4;
    bytes[j++] = c1 << 4 | c2 >> 2;
    bytes[j++] = c2 << 6 | c3;
  }
  return bytes;
};
var descriptorValues = Promise.resolve().then(() => (init_descriptors_XM6FUHC6(), descriptors_XM6FUHC6_exports)).then((module) => module["Hydration"]);
var metadataTypes = Promise.resolve().then(() => (init_metadataTypes_FWGCMXKE(), metadataTypes_FWGCMXKE_exports)).then(
  (module) => toBinary("default" in module ? module.default : module)
);
var asset = {};
var extensions = {};
var getMetadata = () => Promise.resolve().then(() => (init_hydration_metadata_KGTJ7Y2K(), hydration_metadata_KGTJ7Y2K_exports)).then(
  (module) => toBinary("default" in module ? module.default : module)
);
var genesis = "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d";
var _allDescriptors = { descriptors: descriptorValues, metadataTypes, asset, extensions, getMetadata, genesis };
var hydration_default = _allDescriptors;
var descriptorValues2 = Promise.resolve().then(() => (init_descriptors_XM6FUHC6(), descriptors_XM6FUHC6_exports)).then((module) => module["Hub"]);
var metadataTypes2 = Promise.resolve().then(() => (init_metadataTypes_FWGCMXKE(), metadataTypes_FWGCMXKE_exports)).then(
  (module) => toBinary("default" in module ? module.default : module)
);
var discriminant = {
  is(value2, type) {
    return value2.type === type;
  },
  as(value2, type) {
    if (type !== value2.type)
      throw new Error(
        `Enum.as(enum, ${type}) used with actual type ${value2.type}`
      );
    return value2;
  }
};
var Enum = Object.assign((type, value2) => {
  return {
    type,
    value: value2
  };
}, discriminant);
var _Enum = new Proxy(
  {},
  {
    get(_, prop) {
      return (value2) => Enum(prop, value2);
    }
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/index.mjs
var esm_exports = {};
__export(esm_exports, {
  AccountId: () => AccountId,
  Bin: () => Bin,
  Binary: () => Binary,
  BitSeq: () => BitSeq,
  Blake2128: () => Blake2128,
  Blake2128Concat: () => Blake2128Concat,
  Blake2256: () => Blake2256,
  Blake3256: () => Blake3256,
  Blake3256Concat: () => Blake3256Concat,
  Bytes: () => Bytes,
  Enum: () => Enum3,
  FixedSizeBinary: () => FixedSizeBinary,
  Hex: () => Hex,
  Identity: () => Identity,
  Keccak256: () => Keccak256,
  Option: () => Option2,
  Result: () => Result2,
  ScaleEnum: () => ScaleEnum,
  Self: () => Self,
  Storage: () => Storage,
  Struct: () => Struct2,
  TrieNodeHeaders: () => TrieNodeHeaders,
  TrieNodeWithHash: () => TrieNodeWithHash,
  Tuple: () => Tuple2,
  Twox128: () => Twox128,
  Twox256: () => Twox256,
  Twox64Concat: () => Twox64Concat,
  Variant: () => Variant,
  Vector: () => Vector2,
  _Enum: () => _Enum2,
  _void: () => _void,
  bitSequence: () => bitSequence$1,
  blockHeader: () => blockHeader,
  bool: () => bool,
  char: () => char,
  compact: () => compact,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  createCodec: () => createCodec,
  createDecoder: () => createDecoder,
  decAnyMetadata: () => decAnyMetadata,
  enhanceCodec: () => enhanceCodec,
  enhanceDecoder: () => enhanceDecoder,
  enhanceEncoder: () => enhanceEncoder,
  ethAccount: () => ethAccount,
  extrinsicFormat: () => extrinsicFormat,
  fixedStr: () => fixedStr,
  fromBufferToBase58: () => fromBufferToBase58,
  getMultisigAccountId: () => getMultisigAccountId,
  getSs58AddressInfo: () => getSs58AddressInfo,
  h64: () => h64,
  i128: () => i128,
  i16: () => i16,
  i256: () => i256,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  sortMultisigSignatories: () => sortMultisigSignatories,
  str: () => str,
  trieNodeDec: () => trieNodeDec,
  u128: () => u128,
  u16: () => u16,
  u256: () => u256,
  u32: () => u32,
  u64: () => u64,
  u8: () => u8,
  unifyMetadata: () => unifyMetadata,
  v14: () => v14,
  v14Lookup: () => lookup,
  v15: () => v15,
  v16: () => v16,
  validateProofs: () => validateProofs
});

// node_modules/.pnpm/scale-ts@1.6.1/node_modules/scale-ts/dist/scale-ts.js
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var HEX_MAP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd)
    bytes[0] = 0 | HEX_MAP[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP[hexString[idx]];
    const b = HEX_MAP[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}
var InternalUint8Array = class extends Uint8Array {
  constructor(buffer) {
    super(buffer);
    __publicField(this, "i", 0);
    __publicField(this, "v");
    this.v = new DataView(buffer);
  }
};
var toInternalBytes = (fn) => (buffer) => fn(buffer instanceof InternalUint8Array ? buffer : new InternalUint8Array(buffer instanceof Uint8Array ? buffer.buffer : typeof buffer === "string" ? fromHex(buffer).buffer : buffer));
var mergeUint8 = (inputs) => {
  const len = inputs.length;
  let totalLen = 0;
  for (let i = 0; i < len; i++)
    totalLen += inputs[i].length;
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < len; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};
function mapObject(input, mapper) {
  const keys = Object.keys(input);
  const len = keys.length;
  const result = {};
  for (let i = 0; i < len; i++) {
    const key = keys[i];
    result[key] = mapper(input[key], key);
  }
  return result;
}
var createDecoder = toInternalBytes;
var createCodec = (encoder, decoder) => {
  const result = [encoder, decoder];
  result.enc = encoder;
  result.dec = decoder;
  return result;
};
var enhanceEncoder = (encoder, mapper) => (value2) => encoder(mapper(value2));
var enhanceDecoder = (decoder, mapper) => (value2) => mapper(decoder(value2));
var enhanceCodec = ([encoder, decoder], toFrom, fromTo) => createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo));
function decodeInt(nBytes, getter) {
  return toInternalBytes((bytes) => {
    const result = bytes.v[getter](bytes.i, true);
    bytes.i += nBytes;
    return result;
  });
}
function encodeInt(nBytes, setter) {
  return (input) => {
    const result = new Uint8Array(nBytes);
    const dv = new DataView(result.buffer);
    dv[setter](0, input, true);
    return result;
  };
}
function intCodec(nBytes, getter, setter) {
  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter));
}
var u8 = intCodec(1, "getUint8", "setUint8");
var u16 = intCodec(2, "getUint16", "setUint16");
var u32 = intCodec(4, "getUint32", "setUint32");
var u64 = intCodec(8, "getBigUint64", "setBigUint64");
var i8 = intCodec(1, "getInt8", "setInt8");
var i16 = intCodec(2, "getInt16", "setInt16");
var i32 = intCodec(4, "getInt32", "setInt32");
var i64 = intCodec(8, "getBigInt64", "setBigInt64");
var x128Enc = (value2) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value2, true);
  dv.setBigInt64(8, value2 >> 64n, true);
  return result;
};
var create128Dec = (method) => toInternalBytes((input) => {
  const { v, i } = input;
  const right = v.getBigUint64(i, true);
  const left = v[method](i + 8, true);
  input.i += 16;
  return left << 64n | right;
});
var u128 = createCodec(x128Enc, create128Dec("getBigUint64"));
var i128 = createCodec(x128Enc, create128Dec("getBigInt64"));
var x256Enc = (value2) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value2, true);
  dv.setBigInt64(8, value2 >> 64n, true);
  dv.setBigInt64(16, value2 >> 128n, true);
  dv.setBigInt64(24, value2 >> 192n, true);
  return result;
};
var create256Dec = (method) => toInternalBytes((input) => {
  let result = input.v.getBigUint64(input.i, true);
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 64n;
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 128n;
  input.i += 8;
  result |= input.v[method](input.i, true) << 192n;
  input.i += 8;
  return result;
});
var u256 = createCodec(x256Enc, create256Dec("getBigUint64"));
var i256 = createCodec(x256Enc, create256Dec("getBigInt64"));
var bool = enhanceCodec(u8, (value2) => value2 ? 1 : 0, Boolean);
var decoders = [u8[1], u16[1], u32[1]];
var compactDec = toInternalBytes((bytes) => {
  const init = bytes[bytes.i];
  const kind = init & 3;
  if (kind < 3)
    return decoders[kind](bytes) >>> 2;
  const nBytes = (init >>> 2) + 4;
  bytes.i++;
  let result = 0n;
  const nU64 = nBytes / 8 | 0;
  let shift = 0n;
  for (let i = 0; i < nU64; i++) {
    result = u64[1](bytes) << shift | result;
    shift += 64n;
  }
  let nReminders = nBytes % 8;
  if (nReminders > 3) {
    result = BigInt(u32[1](bytes)) << shift | result;
    shift += 32n;
    nReminders -= 4;
  }
  if (nReminders > 1) {
    result = BigInt(u16[1](bytes)) << shift | result;
    shift += 16n;
    nReminders -= 2;
  }
  if (nReminders)
    result = BigInt(u8[1](bytes)) << shift | result;
  return result;
});
var MIN_U64 = 1n << 56n;
var MIN_U32 = 1 << 24;
var MIN_U16 = 256;
var U32_MASK = 4294967295n;
var SINGLE_BYTE_MODE_LIMIT = 1 << 6;
var TWO_BYTE_MODE_LIMIT = 1 << 14;
var FOUR_BYTE_MODE_LIMIT = 1 << 30;
var compactEnc = (input) => {
  if (input < 0)
    throw new Error(`Wrong compact input (${input})`);
  const nInput = Number(input) << 2;
  if (input < SINGLE_BYTE_MODE_LIMIT)
    return u8[0](nInput);
  if (input < TWO_BYTE_MODE_LIMIT)
    return u16[0](nInput | 1);
  if (input < FOUR_BYTE_MODE_LIMIT)
    return u32[0](nInput | 2);
  let buffers = [new Uint8Array(1)];
  let bigValue = BigInt(input);
  while (bigValue >= MIN_U64) {
    buffers.push(u64[0](bigValue));
    bigValue >>= 64n;
  }
  if (bigValue >= MIN_U32) {
    buffers.push(u32[0](Number(bigValue & U32_MASK)));
    bigValue >>= 32n;
  }
  let smValue = Number(bigValue);
  if (smValue >= MIN_U16) {
    buffers.push(u16[0](smValue));
    smValue >>= 16;
  }
  smValue && buffers.push(u8[0](smValue));
  const result = mergeUint8(buffers);
  result[0] = result.length - 5 << 2 | 3;
  return result;
};
var compact = createCodec(compactEnc, compactDec);
var textEncoder = new TextEncoder();
var strEnc = (str2) => {
  const val = textEncoder.encode(str2);
  return mergeUint8([compact.enc(val.length), val]);
};
var textDecoder = new TextDecoder();
var strDec = toInternalBytes((bytes) => {
  let nElements = compact.dec(bytes);
  const dv = new DataView(bytes.buffer, bytes.i, nElements);
  bytes.i += nElements;
  return textDecoder.decode(dv);
});
var str = createCodec(strEnc, strDec);
var noop = () => {
};
var emptyArr = new Uint8Array(0);
var _void = createCodec(() => emptyArr, noop);
var BytesEnc = (nBytes) => nBytes === void 0 ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes]) : (bytes) => bytes.length === nBytes ? bytes : bytes.slice(0, nBytes);
var BytesDec = (nBytes) => toInternalBytes((bytes) => {
  const len = nBytes === void 0 ? compact.dec(bytes) : nBytes !== Infinity ? nBytes : bytes.byteLength - bytes.i;
  const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len));
  bytes.i += len;
  return result;
});
var Bytes = (nBytes) => createCodec(BytesEnc(nBytes), BytesDec(nBytes));
Bytes.enc = BytesEnc;
Bytes.dec = BytesDec;
var enumEnc = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map(x?.map((actualIdx, idx) => [keys[idx], actualIdx]) ?? keys.map((key, idx) => [key, idx]));
  const getKey = (key) => mappedKeys.get(key);
  return ({ tag, value: value2 }) => mergeUint8([u8.enc(getKey(tag)), inner[tag](value2)]);
};
var enumDec = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map(x?.map((actualIdx, idx) => [actualIdx, keys[idx]]) ?? keys.map((key, idx) => [idx, key]));
  return toInternalBytes((bytes) => {
    const idx = u8.dec(bytes);
    const tag = mappedKeys.get(idx);
    const innerDecoder = inner[tag];
    return {
      tag,
      value: innerDecoder(bytes)
    };
  });
};
var Enum2 = (inner, ...args) => createCodec(enumEnc(mapObject(inner, ([encoder]) => encoder), ...args), enumDec(mapObject(inner, ([, decoder]) => decoder), ...args));
Enum2.enc = enumEnc;
Enum2.dec = enumDec;
var OptionDec = (inner) => toInternalBytes((bytes) => u8[1](bytes) > 0 ? inner(bytes) : void 0);
var OptionEnc = (inner) => (value2) => {
  const result = new Uint8Array(1);
  if (value2 === void 0)
    return result;
  result[0] = 1;
  return mergeUint8([result, inner(value2)]);
};
var Option = (inner) => createCodec(OptionEnc(inner[0]), OptionDec(inner[1]));
Option.enc = OptionEnc;
Option.dec = OptionDec;
var ResultDec = (okDecoder, koDecoder) => toInternalBytes((bytes) => {
  const success = u8[1](bytes) === 0;
  const decoder = success ? okDecoder : koDecoder;
  const value2 = decoder(bytes);
  return { success, value: value2 };
});
var ResultEnc = (okEncoder, koEncoder) => ({ success, value: value2 }) => mergeUint8([
  u8[0](success ? 0 : 1),
  (success ? okEncoder : koEncoder)(value2)
]);
var Result = (okCodec, koCodec) => createCodec(ResultEnc(okCodec[0], koCodec[0]), ResultDec(okCodec[1], koCodec[1]));
Result.dec = ResultDec;
Result.enc = ResultEnc;
var TupleDec = (...decoders2) => toInternalBytes((bytes) => decoders2.map((decoder) => decoder(bytes)));
var TupleEnc = (...encoders) => (values) => mergeUint8(encoders.map((enc2, idx) => enc2(values[idx])));
var Tuple = (...codecs) => createCodec(TupleEnc(...codecs.map(([encoder]) => encoder)), TupleDec(...codecs.map(([, decoder]) => decoder)));
Tuple.enc = TupleEnc;
Tuple.dec = TupleDec;
var StructEnc = (encoders) => {
  const keys = Object.keys(encoders);
  return enhanceEncoder(Tuple.enc(...Object.values(encoders)), (input) => keys.map((k) => input[k]));
};
var StructDec = (decoders2) => {
  const keys = Object.keys(decoders2);
  return enhanceDecoder(Tuple.dec(...Object.values(decoders2)), (tuple) => Object.fromEntries(tuple.map((value2, idx) => [keys[idx], value2])));
};
var Struct = (codecs) => createCodec(StructEnc(mapObject(codecs, (x) => x[0])), StructDec(mapObject(codecs, (x) => x[1])));
Struct.enc = StructEnc;
Struct.dec = StructDec;
var VectorEnc = (inner, size) => size >= 0 ? (value2) => mergeUint8(value2.map(inner)) : (value2) => mergeUint8([compact.enc(value2.length), mergeUint8(value2.map(inner))]);
var VectorDec = (getter, size) => toInternalBytes((bytes) => {
  const nElements = size >= 0 ? size : compact.dec(bytes);
  const result = new Array(nElements);
  for (let i = 0; i < nElements; i++) {
    result[i] = getter(bytes);
  }
  return result;
});
var Vector = (inner, size) => createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size));
Vector.enc = VectorEnc;
Vector.dec = VectorDec;

// node_modules/.pnpm/@scure+base@2.0.0/node_modules/@scure/base/index.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString, arr2) {
  if (!Array.isArray(arr2))
    return false;
  if (arr2.length === 0)
    return true;
  if (isString) {
    return arr2.every((item) => typeof item === "string");
  } else {
    return arr2.every((item) => Number.isSafeInteger(item));
  }
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from2) => {
      astrArr("join.decode", from2);
      return from2.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function convertRadix(data, from2, to) {
  if (from2 < 2)
    throw new Error(`convertRadix: invalid from=${from2}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber(d);
    if (d < 0 || d >= from2)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from2 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from2 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/utils.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber2(n, title = "") {
  if (!Number.isSafeInteger(n) || n < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n}`);
  }
}
function abytes(value2, length, title = "") {
  const bytes = isBytes2(value2);
  const len = value2?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function u82(arr2) {
  return new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength);
}
function u322(arr2) {
  return new Uint32Array(arr2.buffer, arr2.byteOffset, Math.floor(arr2.byteLength / 4));
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
var swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
function byteSwap32(arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr2[i] = byteSwap(arr2[i]);
  }
  return arr2;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/_blake.js
var BSIGMA = /* @__PURE__ */ Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
function G1s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 16);
  c = c + d | 0;
  b = rotr(b ^ c, 12);
  return { a, b, c, d };
}
function G2s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 8);
  c = c + d | 0;
  b = rotr(b ^ c, 7);
  return { a, b, c, d };
}

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/_md.js
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/blake2.js
var B2B_IV = /* @__PURE__ */ Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = /* @__PURE__ */ new Uint32Array(32);
function G1b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber2(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error('"key" expected to be undefined or of length=1..' + keyLen);
  if (salt !== void 0)
    abytes(salt, saltLen, "salt");
  if (personalization !== void 0)
    abytes(personalization, persLen, "personalization");
}
var _BLAKE2 = class {
  buffer;
  buffer32;
  finished = false;
  destroyed = false;
  length = 0;
  pos = 0;
  blockLen;
  outputLen;
  constructor(blockLen, outputLen) {
    anumber2(blockLen);
    anumber2(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u322(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { blockLen, buffer, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take2 = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take2 === blockLen && !(dataOffset % 4) && pos + take2 < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      this.length += take2;
      pos += take2;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u322(out);
    this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to ||= new this.constructor({ dkLen: outputLen });
    to.set(...this.get());
    to.buffer.set(buffer);
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    to.outputLen = outputLen;
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var _BLAKE2b = class extends _BLAKE2 {
  // Same as SHA-512, but LE
  v0l = B2B_IV[0] | 0;
  v0h = B2B_IV[1] | 0;
  v1l = B2B_IV[2] | 0;
  v1h = B2B_IV[3] | 0;
  v2l = B2B_IV[4] | 0;
  v2h = B2B_IV[5] | 0;
  v3l = B2B_IV[6] | 0;
  v3h = B2B_IV[7] | 0;
  v4l = B2B_IV[8] | 0;
  v4h = B2B_IV[9] | 0;
  v5l = B2B_IV[10] | 0;
  v5h = B2B_IV[11] | 0;
  v6l = B2B_IV[12] | 0;
  v6h = B2B_IV[13] | 0;
  v7l = B2B_IV[14] | 0;
  v7h = B2B_IV[15] | 0;
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      abytes(key, void 0, "key");
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      abytes(salt, void 0, "salt");
      const slt = u322(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      abytes(personalization, void 0, "personalization");
      const pers = u322(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BBUF[i] = v);
    BBUF.set(B2B_IV, 16);
    let { h, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = BSIGMA;
    for (let i = 0; i < 12; i++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = /* @__PURE__ */ createHasher((opts) => new _BLAKE2b(opts));
function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v142, v152) {
  let j = 0;
  for (let i = 0; i < rounds; i++) {
    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));
    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v142 } = G1s(v2, v6, v10, v142, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v142 } = G2s(v2, v6, v10, v142, msg[offset + s[j++]]));
    ({ a: v3, b: v7, c: v11, d: v152 } = G1s(v3, v7, v11, v152, msg[offset + s[j++]]));
    ({ a: v3, b: v7, c: v11, d: v152 } = G2s(v3, v7, v11, v152, msg[offset + s[j++]]));
    ({ a: v0, b: v5, c: v10, d: v152 } = G1s(v0, v5, v10, v152, msg[offset + s[j++]]));
    ({ a: v0, b: v5, c: v10, d: v152 } = G2s(v0, v5, v10, v152, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v3, b: v4, c: v9, d: v142 } = G1s(v3, v4, v9, v142, msg[offset + s[j++]]));
    ({ a: v3, b: v4, c: v9, d: v142 } = G2s(v3, v4, v9, v142, msg[offset + s[j++]]));
  }
  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 };
}

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/utils/ss58-util.mjs
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var getSs58AddressInfo = (address) => {
  try {
    const decoded = base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    const isChecksumValid = checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1];
    if (!isChecksumValid) return { isValid: false };
    return {
      isValid: true,
      ss58Format: prefixBytesToNumber(prefixBytes),
      publicKey: publicKey.slice()
    };
  } catch (_) {
    return { isValid: false };
  }
};
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};
var withSs58Cache = (fn) => {
  let cache = {};
  let activityCount = 0;
  let latestCount = 0;
  const checkActivity = () => {
    if (activityCount === latestCount) {
      cache = {};
      activityCount = latestCount = 0;
    } else {
      latestCount = activityCount;
      setTimeout(checkActivity, 0);
    }
  };
  return (publicKey) => {
    var _a, _b;
    if (++activityCount === 1) checkActivity();
    let entry2 = cache;
    const lastIdx = publicKey.length - 1;
    for (let i = 0; i <= lastIdx; i++) entry2 = entry2[_a = publicKey[i]] || (entry2[_a] = {});
    return entry2[_b = publicKey[lastIdx]] || (entry2[_b] = fn(publicKey));
  };
};
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return withSs58Cache((publicKey) => {
    const checksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  });
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/AccountId.mjs
function fromBase58ToBuffer(nBytes, _ss58Format) {
  return (address) => {
    const info = getSs58AddressInfo(address);
    if (!info.isValid) throw new Error("Invalid checksum");
    const { publicKey } = info;
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    return publicKey;
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => enhanceCodec(
  Bytes(nBytes),
  fromBase58ToBuffer(nBytes),
  fromBufferToBase58(ss58Format)
);

// node_modules/.pnpm/@polkadot-api+utils@0.2.0/node_modules/@polkadot-api/utils/dist/esm/hex.mjs
var HEX_STR = "0123456789abcdef";
function toHex(bytes) {
  const result = new Array(bytes.length + 1);
  result[0] = "0x";
  for (let i = 0; i < bytes.length; ) {
    const b = bytes[i++];
    result[i] = HEX_STR[b >> 4] + HEX_STR[b & 15];
  }
  return result.join("");
}
var HEX_MAP2 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex2(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd) bytes[0] = 0 | HEX_MAP2[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP2[hexString[idx]];
    const b = HEX_MAP2[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}

// node_modules/.pnpm/@polkadot-api+utils@0.2.0/node_modules/@polkadot-api/utils/dist/esm/mapObject.mjs
function mapObject2(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(
      ([key, value2]) => [key, mapper(value2, key)]
    )
  );
}

// node_modules/.pnpm/@polkadot-api+utils@0.2.0/node_modules/@polkadot-api/utils/dist/esm/mergeUint8.mjs
var mergeUint82 = (...i) => {
  const inputs = Array.isArray(i[0]) ? i[0] : i;
  const totalLen = inputs.reduce((acc, a) => acc + a.byteLength, 0);
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < inputs.length; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};

// node_modules/.pnpm/@polkadot-api+utils@0.2.0/node_modules/@polkadot-api/utils/dist/esm/noop.mjs
var noop2 = Function.prototype;

// node_modules/.pnpm/@polkadot-api+utils@0.2.0/node_modules/@polkadot-api/utils/dist/esm/AbortError.mjs
var AbortError = class extends Error {
  constructor() {
    super("Abort Error");
    this.name = "AbortError";
  }
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Binary.mjs
var __defProp3 = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField2 = (obj, key, value2) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value2), value2);
var _bytes;
var _opaqueBytes;
var _hex;
var _opaqueHex;
var _str;
var textEncoder$3 = new TextEncoder();
var textDecoder$2 = new TextDecoder();
var opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1];
var Binary = class {
  constructor(data, opaque = false) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _opaqueBytes, null);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _opaqueHex, null);
    __privateAdd(this, _str, null);
    __publicField2(this, "asText", () => __privateGet(this, _str) ?? __privateSet(this, _str, textDecoder$2.decode(__privateGet(this, _bytes))));
    __publicField2(this, "asHex", () => __privateGet(this, _hex) ?? __privateSet(this, _hex, toHex(__privateGet(this, _bytes))));
    __publicField2(this, "asOpaqueHex", () => __privateGet(this, _opaqueHex) ?? __privateSet(this, _opaqueHex, toHex(this.asOpaqueBytes())));
    __publicField2(this, "asBytes", () => __privateGet(this, _bytes));
    __publicField2(this, "asOpaqueBytes", () => __privateGet(this, _opaqueBytes) ?? __privateSet(this, _opaqueBytes, mergeUint82([
      compact[0](__privateGet(this, _bytes).length),
      __privateGet(this, _bytes)
    ])));
    if (opaque) {
      try {
        const [len, bytes] = opaqueBytesDec(data);
        if (len === bytes.length) {
          __privateSet(this, _bytes, bytes);
          __privateSet(this, _opaqueBytes, data);
          return;
        }
      } catch (_) {
      }
      throw new Error("Invalid opaque bytes");
    } else __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new this(textEncoder$3.encode(input));
  }
  static fromHex(input) {
    return new this(fromHex2(input));
  }
  static fromOpaqueHex(input) {
    return new this(fromHex2(input), true);
  }
  static fromBytes(input) {
    return new this(input);
  }
  static fromOpaqueBytes(input) {
    return new this(input, true);
  }
};
_bytes = /* @__PURE__ */ new WeakMap();
_opaqueBytes = /* @__PURE__ */ new WeakMap();
_hex = /* @__PURE__ */ new WeakMap();
_opaqueHex = /* @__PURE__ */ new WeakMap();
_str = /* @__PURE__ */ new WeakMap();
var [accountIdEncoder] = AccountId();
var FixedSizeBinary = class extends Binary {
  constructor(data) {
    super(data);
  }
  static fromArray(input) {
    return new this(new Uint8Array(input));
  }
  static fromAccountId32(input) {
    return new this(accountIdEncoder(input));
  }
};
var enc$2 = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value2) => _enc(value2.asBytes());
};
var dec$2 = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  const Bin2 = nBytes == null ? Binary : FixedSizeBinary;
  return (value2) => Bin2.fromBytes(_dec(value2));
};
var Bin = (nBytes) => createCodec(enc$2(nBytes), dec$2(nBytes));
Bin.enc = enc$2;
Bin.dec = dec$2;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/compact.mjs
var compactNumber = enhanceCodec(compact, (v) => v, Number);
var compactBn = enhanceCodec(compact, (v) => v, BigInt);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/bitSequence.mjs
var bitSequenceDecoder = createDecoder((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence$1 = createCodec(bitSequenceEncoder, bitSequenceDecoder);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/char.mjs
var char = enhanceCodec(
  u8,
  (str2) => str2.charCodeAt(0),
  String.fromCharCode
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Hex.mjs
var enc$1 = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value2) => _enc(fromHex2(value2));
};
var dec$1 = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  return (value2) => toHex(_dec(value2));
};
var Hex = (nBytes) => createCodec(enc$1(nBytes), dec$1(nBytes));
Hex.enc = enc$1;
Hex.dec = dec$1;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/fixed-str.mjs
var textEncoder$2 = new TextEncoder();
var textDecoder$1 = new TextDecoder();
var fixedStr = (nBytes) => enhanceCodec(
  Bytes(nBytes),
  (str2) => textEncoder$2.encode(str2),
  (bytes) => textDecoder$1.decode(bytes)
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Self.mjs
var selfEncoder = (value2) => {
  let cache = (x) => {
    const encoder = value2();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value2) => {
  let cache = (x) => {
    const decoder = value2();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value2) => createCodec(
  selfEncoder(() => value2().enc),
  selfDecoder(() => value2().dec)
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/types/enum.mjs
var discriminant2 = {
  is(value2, type) {
    return value2.type === type;
  },
  as(value2, type) {
    if (type !== value2.type)
      throw new Error(
        `Enum.as(enum, ${type}) used with actual type ${value2.type}`
      );
    return value2;
  }
};
var Enum3 = Object.assign((type, value2) => {
  return {
    type,
    value: value2
  };
}, discriminant2);
var _Enum2 = new Proxy(
  {},
  {
    get(_, prop) {
      return (value2) => Enum3(prop, value2);
    }
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/with-inner.mjs
var withInner = (codec, inner) => {
  const result = codec;
  result.inner = inner;
  return result;
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/Variant.mjs
var VariantEnc = (...args) => {
  const enc2 = Enum2.enc(...args);
  return withInner((v) => enc2({ tag: v.type, value: v.value }), args[0]);
};
var VariantDec = (...args) => {
  const dec2 = Enum2.dec(...args);
  return withInner((v) => {
    const { tag, value: value2 } = dec2(v);
    return Enum3(tag, value2);
  }, args[0]);
};
var Variant = (inner, ...args) => withInner(
  createCodec(
    VariantEnc(
      mapObject2(inner, ([encoder]) => encoder),
      ...args
    ),
    VariantDec(
      mapObject2(inner, ([, decoder]) => decoder),
      ...args
    )
  ),
  inner
);
Variant.enc = VariantEnc;
Variant.dec = VariantDec;
var ScaleEnum = (inner, ...args) => withInner(Enum2(inner, ...args), inner);
ScaleEnum.enc = (inner, ...rest) => withInner(Enum2.enc(inner, ...rest), inner);
ScaleEnum.dec = (inner, ...rest) => withInner(Enum2.dec(inner, ...rest), inner);

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = /* @__PURE__ */ SHA256_IV.slice();
var B3_SIGMA = /* @__PURE__ */ (() => {
  const Id = Array.from({ length: 16 }, (_, i) => i);
  const permute = (arr2) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr2[i]);
  const res = [];
  for (let i = 0, v = Id; i < 7; i++, v = permute(v))
    res.push(...v);
  return Uint8Array.from(res);
})();
var _BLAKE3 = class __BLAKE3 extends _BLAKE2 {
  chunkPos = 0;
  // Position of current block in chunk
  chunksDone = 0;
  // How many chunks we already have
  flags = 0 | 0;
  IV;
  state;
  stack = [];
  // Output
  posOut = 0;
  bufferOut32 = new Uint32Array(16);
  bufferOut;
  chunkOut = 0;
  // index of output chunk
  enableXOF = true;
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
    const { key, context: context2 } = opts;
    const hasContext = context2 !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      abytes(key, 32, "key");
      const k = key.slice();
      this.IV = u322(k);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      abytes(context2, void 0, "context");
      const ctx = context2;
      const contextKey = new __BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u322(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u82(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter, flags, buf, bufPos = 0) {
    const { state: s, pos } = this;
    const { h, l } = fromBig(BigInt(counter), true);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
    s[0] = v0 ^ v8;
    s[1] = v1 ^ v9;
    s[2] = v2 ^ v10;
    s[3] = v3 ^ v11;
    s[4] = v4 ^ v12;
    s[5] = v5 ^ v13;
    s[6] = v6 ^ v142;
    s[7] = v7 ^ v152;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last2, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last2 = this.stack.pop()))
          break;
        this.buffer32.set(last2, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to) {
    to = super._cloneInto(to);
    const { IV, flags, state: state3, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to.state.set(state3.slice());
    to.stack = stack.map((i) => Uint32Array.from(i));
    to.IV.set(IV);
    to.flags = flags;
    to.chunkPos = chunkPos;
    to.chunksDone = chunksDone;
    to.posOut = posOut;
    to.chunkOut = chunkOut;
    to.enableXOF = this.enableXOF;
    to.bufferOut32.set(this.bufferOut32);
    return to;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h, l } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14: v142, v15: v152 } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v3 ^ v11;
    out32[4] = v4 ^ v12;
    out32[5] = v5 ^ v13;
    out32[6] = v6 ^ v142;
    out32[7] = v7 ^ v152;
    out32[8] = s[0] ^ v8;
    out32[9] = s[1] ^ v9;
    out32[10] = s[2] ^ v10;
    out32[11] = s[3] ^ v11;
    out32[12] = s[4] ^ v12;
    out32[13] = s[5] ^ v13;
    out32[14] = s[6] ^ v142;
    out32[15] = s[7] ^ v152;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take2 = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber2(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = /* @__PURE__ */ createHasher((opts = {}) => new _BLAKE3(opts));

// node_modules/.pnpm/@noble+hashes@2.0.1/node_modules/@noble/hashes/sha3.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
var Keccak = class _Keccak {
  state;
  pos = 0;
  posOut = 0;
  finished = false;
  state32;
  destroyed = false;
  blockLen;
  suffix;
  outputLen;
  enableXOF = false;
  rounds;
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber2(outputLen, "outputLen");
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { blockLen, state: state3 } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take2; i++)
        state3[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state3, suffix, pos, blockLen } = this;
    state3[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state3[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take2 = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber2(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to ||= new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds);
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var genKeccak = (suffix, blockLen, outputLen, info = {}) => createHasher(() => new Keccak(blockLen, suffix, outputLen), info);
var keccak_256 = /* @__PURE__ */ genKeccak(1, 136, 32);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/keccak.mjs
var Keccak256 = keccak_256;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/ethAccount.mjs
var getFormattedAddress = (hexAddress) => {
  const nonChecksum = hexAddress.slice(2);
  const hashedAddress = toHex(Keccak256(textEncoder$2.encode(nonChecksum))).slice(
    2
  );
  const result = new Array(40);
  for (let i = 0; i < 40; i++) {
    const checksumVal = parseInt(hashedAddress[i], 16);
    const char2 = nonChecksum[i];
    result[i] = checksumVal > 7 ? char2.toUpperCase() : char2;
  }
  return `0x${result.join("")}`;
};
var bytes20Dec = Bytes(20)[1];
var ethAccount = createCodec(
  (input) => {
    const bytes = fromHex2(input);
    if (bytes.length !== 20)
      throw new Error(`Invalid length found on EthAddress(${input})`);
    const hexAddress = toHex(bytes);
    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes;
    if (getFormattedAddress(hexAddress) !== input)
      throw new Error(`Invalid checksum found on EthAddress(${input})`);
    return bytes;
  },
  createDecoder((bytes) => getFormattedAddress(toHex(bytes20Dec(bytes))))
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/shaped.mjs
var Struct2 = (codecs) => withInner(Struct(codecs), codecs);
Struct2.enc = (x) => withInner(Struct.enc(x), x);
Struct2.dec = (x) => withInner(Struct.dec(x), x);
var Tuple2 = (...inner) => withInner(Tuple(...inner), inner);
Tuple2.enc = (...inner) => withInner(Tuple.enc(...inner), inner);
Tuple2.dec = (...inner) => withInner(Tuple.dec(...inner), inner);
var Vector2 = (inner, ...rest) => withInner(Vector(inner, ...rest), inner);
Vector2.enc = (inner, ...rest) => withInner(Vector.enc(inner, ...rest), inner);
Vector2.dec = (inner, ...rest) => withInner(Vector.dec(inner, ...rest), inner);
var Result2 = (ok, ko) => withInner(Result(ok, ko), { ok, ko });
Result2.enc = (ok, ko) => withInner(Result.enc(ok, ko), { ok, ko });
Result2.dec = (ok, ko) => withInner(Result.dec(ok, ko), { ok, ko });
var Option2 = (inner) => withInner(Option(inner), inner);
Option2.enc = (inner) => withInner(Option.enc(inner), inner);
Option2.dec = (inner) => withInner(Option.dec(inner), inner);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/scale/BitSeq.mjs
var dec = (isLsb = true) => createDecoder((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes(bytesLen).dec(data);
  const result = new Array(bitsLen);
  let resultIdx = 0;
  bytes.forEach((val) => {
    for (let i = 0; i < 8 && resultIdx < bitsLen; i++) {
      const actualIdx = isLsb ? i : 7 - i;
      result[resultIdx++] = val >> actualIdx & 1;
    }
  });
  return result;
});
var enc = (isLsb = true) => (input) => {
  const lenEncoded = compactNumber.enc(input.length);
  const nBytes = Math.ceil(input.length / 8);
  const bytes = new Uint8Array(nBytes);
  for (let byteIdx = 0; byteIdx < nBytes; byteIdx++) {
    let inputIdx = byteIdx * 8;
    let byte2 = 0;
    for (let i = 0; i < 8 && inputIdx < input.length; i++, inputIdx++)
      byte2 |= input[inputIdx] << (isLsb ? i : 7 - i);
    bytes[byteIdx] = byte2;
  }
  return mergeUint82([lenEncoded, bytes]);
};
var BitSeq = (isLsb) => createCodec(enc(isLsb), dec(isLsb));
BitSeq.enc = enc;
BitSeq.dec = dec;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/blockHeader.mjs
var textEncoder$1 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var fourChars = enhanceCodec(
  Bytes(4),
  textEncoder$1.encode.bind(textEncoder$1),
  textDecoder2.decode.bind(textDecoder2)
);
var diggestVal = Struct2({
  engine: fourChars,
  payload: Hex()
});
var diggest = Variant(
  {
    other: Bytes(),
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: _void
  },
  [0, 4, 5, 6, 8]
);
var hex32$1 = Hex(32);
var blockHeader = Struct2({
  parentHash: hex32$1,
  number: compactNumber,
  stateRoot: hex32$1,
  extrinsicRoot: hex32$1,
  digests: Vector2(diggest)
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/docs.mjs
var docs = Vector(str);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/lookup.mjs
var oStr = Option(str);
var primitive = Enum2({
  bool: _void,
  char: _void,
  str: _void,
  u8: _void,
  u16: _void,
  u32: _void,
  u64: _void,
  u128: _void,
  u256: _void,
  i8: _void,
  i16: _void,
  i32: _void,
  i64: _void,
  i128: _void,
  i256: _void
});
var fields = Vector(
  Struct({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs
  })
);
var arr = Struct({
  len: u32,
  type: compactNumber
});
var bitSequence = Struct({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = Vector(
  Struct({
    name: str,
    fields,
    index: u8,
    docs
  })
);
var def = Enum2({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: Vector(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence
});
var param = Struct({
  name: str,
  type: Option(compactNumber)
});
var params = Vector(param);
var entry = Struct({
  id: compactNumber,
  path: docs,
  params,
  def,
  docs
});
var lookup = Vector(entry);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/deprecation.mjs
var itemDeprecation = Enum2({
  NotDeprecated: _void,
  DeprecatedWithoutNote: _void,
  Deprecated: Struct({
    note: str,
    since: Option(str)
  })
});
var variantDeprecation = Vector(
  Struct({
    index: u8,
    deprecation: Enum2(
      {
        DeprecatedWithoutNote: _void,
        Deprecated: Struct({
          note: str,
          since: Option(str)
        })
      },
      [1, 2]
    )
  })
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/runtime-api.mjs
var runtimeApiMethod = {
  name: str,
  inputs: Vector(
    Struct({
      name: str,
      type: compactNumber
    })
  ),
  output: compactNumber,
  docs
};
var runtimeApiV15 = Struct({
  name: str,
  methods: Vector(Struct(runtimeApiMethod)),
  docs
});
var runtimeApi = Struct({
  name: str,
  methods: Vector(
    Struct({ ...runtimeApiMethod, deprecationInfo: itemDeprecation })
  ),
  docs,
  version: compactNumber,
  deprecationInfo: itemDeprecation
});
var viewFunction = Struct({
  id: Hex(32),
  ...runtimeApiMethod,
  deprecationInfo: itemDeprecation
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/pallets.mjs
var hashType = Enum2({
  Blake2128: _void,
  Blake2256: _void,
  Blake2128Concat: _void,
  Twox128: _void,
  Twox256: _void,
  Twox64Concat: _void,
  Identity: _void
});
var hashers$1 = Vector(hashType);
var storageMap = Struct({
  hashers: hashers$1,
  key: compactNumber,
  value: compactNumber
});
var storageItem = {
  name: str,
  modifier: u8,
  type: Enum2({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs
};
var enumRefV14 = Option(compactNumber);
var v14Pallet = {
  name: str,
  storage: Option(
    Struct({
      prefix: str,
      items: Vector(Struct(storageItem))
    })
  ),
  calls: enumRefV14,
  events: enumRefV14,
  constants: Vector(
    Struct({
      name: str,
      type: compactNumber,
      value: Hex(),
      docs
    })
  ),
  errors: enumRefV14,
  index: u8
};
var v15Pallet = {
  ...v14Pallet,
  docs
};
var enumRef = Option(
  Struct({ type: compactNumber, deprecationInfo: variantDeprecation })
);
var v16Pallet = {
  name: str,
  storage: Option(
    Struct({
      prefix: str,
      items: Vector(
        Struct({
          ...storageItem,
          deprecationInfo: itemDeprecation
        })
      )
    })
  ),
  calls: enumRef,
  events: enumRef,
  constants: Vector(
    Struct({
      name: str,
      type: compactNumber,
      value: Hex(),
      docs,
      deprecationInfo: itemDeprecation
    })
  ),
  errors: enumRef,
  associatedTypes: Vector(
    Struct({
      name: str,
      type: compactNumber,
      docs
    })
  ),
  viewFns: Vector(viewFunction),
  index: u8,
  docs,
  deprecationInfo: itemDeprecation
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v14.mjs
var empty = new Uint8Array();
var Always = (value2) => createCodec(
  () => empty,
  () => value2
);
var extrinsic$2 = Struct({
  type: compactNumber,
  version: u8,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = Struct({
  lookup,
  pallets: Vector(Struct({ ...v14Pallet, docs: Always([]) })),
  extrinsic: extrinsic$2,
  type: compactNumber,
  apis: Always([])
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v15.mjs
var extrinsic$1 = Struct({
  version: u8,
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  extra: compactNumber,
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v15 = Struct({
  lookup,
  pallets: Vector(Struct(v15Pallet)),
  extrinsic: extrinsic$1,
  type: compactNumber,
  apis: Vector(runtimeApiV15),
  outerEnums: Struct({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector(Tuple(str, Struct({ type: compactNumber, value: Hex() })))
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/v16.mjs
var extrinsic = Struct({
  version: Vector(u8),
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  signedExtensionsByVersion: Vector(Tuple(u8, Vector(compactNumber))),
  signedExtensions: Vector(
    Struct({
      identifier: str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v16 = Struct({
  lookup,
  pallets: Vector(Struct(v16Pallet)),
  extrinsic,
  apis: Vector(runtimeApi),
  outerEnums: Struct({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector(Tuple(str, Struct({ type: compactNumber, value: Hex() })))
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/metadata.mjs
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = createCodec(
  unsupportedFn,
  unsupportedFn
);
var metadata = Struct({
  magicNumber: u32,
  metadata: Enum2({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14,
    v15,
    v16
  })
});
var opaqueBytes = Bytes();
var optionOpaque = Option(opaqueBytes);
var opaqueOpaqueBytes = Tuple(compact, opaqueBytes);
var decAnyMetadata = (input) => {
  try {
    return metadata.dec(input);
  } catch (_) {
  }
  try {
    return metadata.dec(optionOpaque.dec(input));
  } catch (_) {
  }
  try {
    return metadata.dec(opaqueBytes.dec(input));
  } catch (_) {
  }
  try {
    return metadata.dec(opaqueOpaqueBytes.dec(input)[1]);
  } catch (_) {
  }
  throw null;
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/codecs/metadata/unified.mjs
var unifyMetadata = (metadata2) => {
  if ("magicNumber" in metadata2) metadata2 = metadata2.metadata;
  if ("tag" in metadata2) {
    if (metadata2.tag !== "v14" && metadata2.tag !== "v15" && metadata2.tag !== "v16")
      throw new Error("Only metadata 14, 15, and 16 are supported");
    metadata2 = metadata2.value;
  }
  if ("signedExtensionsByVersion" in metadata2.extrinsic) {
    return { version: 16, ...metadata2 };
  }
  if ("custom" in metadata2) {
    const { lookup: lookup22, extrinsic: extrinsic22, custom, apis, pallets: pallets2, outerEnums } = metadata2;
    return {
      version: 15,
      lookup: lookup22,
      pallets: pallets2.map((p) => ({
        ...p,
        calls: p.calls != null ? { type: p.calls } : void 0,
        events: p.events != null ? { type: p.events } : void 0,
        errors: p.errors != null ? { type: p.errors } : void 0,
        viewFns: [],
        associatedTypes: []
      })),
      extrinsic: { ...extrinsic22, version: [extrinsic22.version] },
      apis,
      outerEnums,
      custom
    };
  }
  const { lookup: lookup2, extrinsic: extrinsic2, pallets } = metadata2;
  return {
    version: 14,
    lookup: lookup2,
    pallets: pallets.map((p) => ({
      ...p,
      calls: p.calls != null ? { type: p.calls } : void 0,
      events: p.events != null ? { type: p.events } : void 0,
      errors: p.errors != null ? { type: p.errors } : void 0,
      viewFns: [],
      associatedTypes: []
    })),
    extrinsic: { ...extrinsic2, version: [extrinsic2.version] },
    apis: []
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/extrinsics/extrinsic-format.mjs
var TYPES = {
  bare: 0,
  0: "bare",
  general: 1,
  1: "general",
  signed: 2,
  2: "signed"
};
var extrinsicFormat = enhanceCodec(
  u8,
  ({ version, type }) => version + (TYPES[type] << 6),
  (v) => {
    const version = v & 63;
    const type = v >> 6;
    if (version === 4 && (type === TYPES.bare || type === TYPES.signed))
      return { version, type: TYPES[type] };
    if (version === 5 && (type === TYPES.bare || type === TYPES.general))
      return { version, type: TYPES[type] };
    throw new Error(`ExtrinsicFormat ${v} not valid`);
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/blake2.mjs
var len32$1 = { dkLen: 32 };
var Blake2256 = (encoded) => blake2b(encoded, len32$1);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => blake2b(encoded, len16);
var Blake2128Concat = (encoded) => mergeUint82([Blake2128(encoded), encoded]);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/blake3.mjs
var len32 = { dkLen: 32 };
var Blake3256 = (encoded) => blake3(encoded, len32);
var Blake3256Concat = (encoded) => mergeUint82([Blake3256(encoded), encoded]);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/identity.mjs
var Identity = (encoded) => encoded;

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/h64.mjs
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add2 = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add2(add2(seed, PRIME64_1), PRIME64_2);
  let v2 = add2(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen) return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add2(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add2(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add2(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add2(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add2(result, rotl(v2, 7n));
    result = add2(result, rotl(v3, 12n));
    result = add2(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add2(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add2(seed, PRIME64_5);
  }
  result = add2(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add2(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add2(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/hashes/twoX.mjs
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => mergeUint82([u64.enc(h64(encoded)), encoded]);

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/storage.mjs
var textEncoder2 = new TextEncoder();
var hashers = /* @__PURE__ */ new Map([
  [Identity, 0],
  [Twox64Concat, 8],
  [Blake2128Concat, 16],
  [Blake2128, -16],
  [Blake2256, -32],
  [Twox128, -16],
  [Twox256, -32]
]);
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder2.encode(pallet));
  return (name, ...encoders) => {
    const palletItemEncoded = mergeUint82([
      palledEncoded,
      Twox128(textEncoder2.encode(name))
    ]);
    const palletItemEncodedHex = toHex(palletItemEncoded);
    const dec2 = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (encoders.length === 0) return [];
      const argsKey = fromHex2(key.slice(palletItemEncodedHex.length));
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < encoders.length; i++) {
        const [codec, hasher] = encoders[i];
        const hBytes = hashers.get(hasher);
        if (hBytes == null) throw new Error("Unknown hasher");
        if (hBytes < 0) {
          const opaqueBytes3 = hBytes * -1;
          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes3));
          cur += opaqueBytes3;
        } else {
          cur += hBytes;
          result[i] = codec.dec(argsKey.slice(cur));
          cur += codec.enc(result[i]).length;
        }
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc22 }, hash]) => (val) => hash(enc22(val))
    );
    const enc2 = (...args) => toHex(
      mergeUint82([
        palletItemEncoded,
        ...args.map((val, idx) => fns[idx](val))
      ])
    );
    return {
      enc: enc2,
      dec: dec2
    };
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/utils/multisig.mjs
var PREFIX = Binary.fromText("modlpy/utilisuba").asBytes();
var getMultisigAccountId = ({
  threshold,
  signatories
}) => {
  const sortedSignatories = sortMultisigSignatories(signatories);
  const payload = mergeUint82([
    PREFIX,
    compact.enc(sortedSignatories.length),
    ...sortedSignatories,
    u16.enc(threshold)
  ]);
  return Blake2256(payload);
};
var sortMultisigSignatories = (signatories) => signatories.slice().sort((a, b) => {
  for (let i = 0; ; i++) {
    const overA = i >= a.length;
    const overB = i >= b.length;
    if (overA && overB) return 0;
    else if (overA) return -1;
    else if (overB) return 1;
    else if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  }
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/trie/types.mjs
var TrieNodeHeaders = {
  Leaf: "Leaf",
  Branch: "Branch",
  BranchWithVal: "BranchWithVal",
  LeafWithHash: "LeafWithHash",
  BranchWithHash: "BranchWithHash",
  Empty: "Empty",
  Reserved: "Reserved"
};

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/trie/node-decoder.mjs
var varHex = Hex().dec;
var allHex = Hex(Infinity).dec;
var hex32 = Hex(32).dec;
var byte = u8.dec;
var getHeader = (bytes) => {
  const firstByte = byte(bytes);
  let bitsLeft = 6;
  const typeId = firstByte >> bitsLeft;
  const type = typeId ? typeId === 1 ? TrieNodeHeaders.Leaf : typeId === 2 ? TrieNodeHeaders.Branch : TrieNodeHeaders.BranchWithVal : firstByte >> --bitsLeft ? TrieNodeHeaders.LeafWithHash : firstByte >> --bitsLeft ? TrieNodeHeaders.BranchWithHash : firstByte ? TrieNodeHeaders.Reserved : TrieNodeHeaders.Empty;
  let nNibles = firstByte & 255 >> 8 - bitsLeft;
  if (nNibles === 2 ** bitsLeft - 1) {
    let current;
    do
      nNibles += current = byte(bytes);
    while (current === 255);
  }
  return {
    type,
    partialKey: Hex(Math.ceil(nNibles / 2)).dec(bytes).slice(nNibles % 2 ? 3 : 2)
  };
};
var trieNodeDec = createDecoder((bytes) => {
  const header = getHeader(bytes);
  const { type } = header;
  if (type === "Empty" || type === "Reserved") return header;
  if (type === "Leaf" || type === "LeafWithHash")
    return {
      ...header,
      value: allHex(bytes)
    };
  const bitmap = u16.dec(bytes);
  const keys = [];
  for (let i = 0; i < 16; i++) if (bitmap >> i & 1) keys.push(i.toString(16));
  let value2 = null;
  if (type === "BranchWithVal") value2 = varHex(bytes);
  if (type === "BranchWithHash") value2 = hex32(bytes);
  const result = {
    ...header,
    children: Object.fromEntries(keys.map((key) => [key, varHex(bytes)]))
  };
  if (value2 !== null) result.value = value2;
  return result;
});

// node_modules/.pnpm/@polkadot-api+substrate-bindings@0.16.6/node_modules/@polkadot-api/substrate-bindings/dist/esm/trie/proofs.mjs
var TrieNodeWithHash = (hasher) => createDecoder((input) => {
  const hash = toHex(hasher(new Uint8Array(input.buffer)));
  try {
    return {
      hash,
      ...trieNodeDec(input)
    };
  } catch {
    return { type: "Raw", hash, value: "" };
  }
});
var validateProofs = (proofs, hasher = Blake2256) => {
  const proofsList = proofs.map(TrieNodeWithHash(hasher));
  const proofsRecord = Object.fromEntries(proofsList.map((p) => [p.hash, p]));
  const hashes = proofsList.map((p) => p.hash);
  const roots = new Set(hashes);
  const setRawValue = (input) => {
    if (input.value) return;
    const val = proofs[hashes.indexOf(input.hash)];
    input.value = typeof val === "string" ? val : toHex(val);
  };
  proofsList.forEach((p) => {
    if ("children" in p) {
      Object.values(p.children).forEach((hash) => {
        const child = proofsRecord[hash];
        if (child) {
          child.parent = p.hash;
          roots.delete(hash);
        }
      });
    }
    if (p.type === "BranchWithHash" || p.type === "LeafWithHash") {
      const childHash = p.value;
      const child = proofsRecord[childHash];
      if (!child) return;
      roots.delete(childHash);
      if (child.type !== "Raw") {
        Object.keys(child).forEach((k) => delete child[k]);
        child.type = "Raw";
        child.hash = childHash;
      }
      child.parent = p.hash;
      setRawValue(child);
    }
    if (p.type === "Raw") setRawValue(p);
  });
  return roots.size === 1 ? { rootHash: roots.values().next().value, proofs: proofsRecord } : null;
};

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.4.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/typedef.mjs
var smallCompact = compactNumber;
var StructCodec = Vector2(Tuple2(str, smallCompact));
var Primitive = {
  bool: "boolean",
  str: "string",
  num: "number",
  big: "bigint",
  bits: "bitseq",
  void: "void"
};
var TerminalCodec = Variant(
  Object.fromEntries(
    Object.values(Primitive).map((p) => [p, _void])
  )
);
var EnumCodec = Vector2(
  Tuple2(
    str,
    Variant({
      inline: Self(() => TypedefCodec),
      lookup: smallCompact
    })
  )
);
var TupleCodec = Vector2(smallCompact);
var ArrayCodec = Struct2({
  typeRef: smallCompact,
  length: Option2(smallCompact)
});
var BinaryCodec = Option2(smallCompact);
var OptionCodec = smallCompact;
var ResultCodec = Struct2({
  ok: smallCompact,
  ko: smallCompact
});
var TypedefCodec = Variant({
  struct: StructCodec,
  terminal: TerminalCodec,
  enum: EnumCodec,
  tuple: TupleCodec,
  array: ArrayCodec,
  binary: BinaryCodec,
  option: OptionCodec,
  result: ResultCodec
});
var primitiveToTerminal = {
  i256: Primitive.big,
  i128: Primitive.big,
  i64: Primitive.big,
  i32: Primitive.num,
  i16: Primitive.num,
  i8: Primitive.num,
  u256: Primitive.big,
  u128: Primitive.big,
  u64: Primitive.big,
  u32: Primitive.num,
  u16: Primitive.num,
  u8: Primitive.num,
  bool: Primitive.bool,
  char: Primitive.str,
  str: Primitive.str
};
var terminal = (type) => ({
  type: "terminal",
  value: { type }
});
function mapLookupToTypedef(entry2, resolve = () => {
}) {
  switch (entry2.type) {
    case "AccountId20":
    case "AccountId32":
      return terminal(Primitive.str);
    case "array":
      if (entry2.value.type === "primitive" && entry2.value.value === "u8") {
        return { type: "binary", value: entry2.len };
      }
      resolve(entry2.value.id);
      return {
        type: "array",
        value: {
          typeRef: entry2.value.id,
          length: entry2.len
        }
      };
    case "bitSequence":
      return terminal(Primitive.bits);
    case "compact":
      return terminal(entry2.isBig ? Primitive.big : Primitive.num);
    case "enum":
      return {
        type: "enum",
        value: Object.entries(entry2.value).map(
          ([key, params2]) => {
            if (params2.type !== "lookupEntry")
              return [
                key,
                { type: "inline", value: mapLookupToTypedef(params2, resolve) }
              ];
            resolve(params2.value.id);
            return [
              key,
              {
                type: "lookup",
                value: params2.value.id
              }
            ];
          }
        )
      };
    case "struct": {
      const value2 = Object.entries(entry2.value).map(
        ([key, prop]) => [key, prop.id]
      );
      value2.forEach(([, v]) => resolve(v));
      return {
        type: "struct",
        value: value2
      };
    }
    case "tuple": {
      const value2 = entry2.value.map((v) => v.id);
      value2.forEach(resolve);
      return {
        type: "tuple",
        value: value2
      };
    }
    case "option":
      resolve(entry2.value.id);
      return {
        type: "option",
        value: entry2.value.id
      };
    case "primitive":
      return terminal(primitiveToTerminal[entry2.value]);
    case "result":
      resolve(entry2.value.ok.id);
      resolve(entry2.value.ko.id);
      return {
        type: "result",
        value: {
          ok: entry2.value.ok.id,
          ko: entry2.value.ko.id
        }
      };
    case "sequence":
      if (entry2.value.type === "primitive" && entry2.value.value === "u8") {
        return { type: "binary", value: void 0 };
      }
      resolve(entry2.value.id);
      return {
        type: "array",
        value: { typeRef: entry2.value.id }
      };
    case "void":
      return terminal(Primitive.void);
  }
}

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.4.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/isCompatible.mjs
function isCompatible(value2, destNode, getNode) {
  if (destNode.type === "option" && value2 == null) {
    return true;
  }
  const nextCall = (value22, destNode2) => isCompatible(value22, destNode2, getNode);
  const checkTerminal = (terminal2) => {
    switch (terminal2.value.type) {
      case Primitive.str:
      case Primitive.big:
      case Primitive.bool:
      case Primitive.num:
        return typeof value2 === terminal2.value.type;
      case Primitive.bits:
        return typeof value2 === "object" && value2 != null && typeof value2.bitsLen === "number" && value2.bytes instanceof Uint8Array;
      case Primitive.void:
        return true;
    }
  };
  switch (destNode.type) {
    case "terminal":
      return checkTerminal(destNode);
    case "binary":
      return value2 != null && typeof value2.asBytes === "function" && (destNode.value == null || value2.asBytes().length >= destNode.value);
    case "array":
      if (!Array.isArray(value2)) return false;
      const valueArr = value2;
      if (destNode.value.length != null && valueArr.length < destNode.value.length) {
        return false;
      }
      return valueArr.slice(0, destNode.value.length).every((value22) => nextCall(value22, getNode(destNode.value.typeRef)));
    case "enum":
      if (!value2) return false;
      const valueEnum = value2;
      const destVariants = Object.fromEntries(destNode.value);
      if (!(valueEnum.type in destVariants)) {
        return false;
      }
      const variantValue = destVariants[valueEnum.type];
      if (variantValue == null) {
        return true;
      }
      return nextCall(
        valueEnum.value,
        variantValue.type === "inline" ? variantValue.value : getNode(variantValue.value)
      );
    case "option":
      if (value2 == null) {
        return true;
      }
      return nextCall(value2, getNode(destNode.value));
    case "struct":
      if (!value2) return false;
      return destNode.value.every(
        ([key, typeRef]) => nextCall(value2[key], getNode(typeRef))
      );
    case "tuple":
      if (!value2) return false;
      return destNode.value.every(
        (typeRef, idx) => nextCall(value2[idx], getNode(typeRef))
      );
    case "result":
      if (!("success" in value2 && "value" in value2)) return false;
      return nextCall(
        value2.value,
        getNode(value2.success ? destNode.value.ok : destNode.value.ko)
      );
  }
}
function isStorageKeyCompatible(keys, destArgsLen, destNode, getNode) {
  if (keys.length > destArgsLen) return false;
  let keyNodes = [destNode];
  if (destArgsLen > 1) {
    if (destNode.type === "tuple") {
      keyNodes = destNode.value.map(getNode);
    } else if (destNode.type === "array" && destNode.value.length) {
      keyNodes = new Array(destNode.value.length).fill(
        getNode(destNode.value.typeRef)
      );
    }
  }
  return keys.every((key, i) => isCompatible(key, keyNodes[i], getNode));
}

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.4.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/doubleSet.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value2) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField3 = (obj, key, value2) => __defNormalProp3(obj, key + "", value2);
var DoubleSet = class {
  constructor(values = []) {
    __publicField3(this, "value", /* @__PURE__ */ new Map());
    values.forEach(([a, b]) => this.add(a, b));
  }
  has(a, b) {
    return this.value.get(a)?.has(b) ?? false;
  }
  add(a, b) {
    if (!this.value.has(a)) {
      this.value.set(a, /* @__PURE__ */ new Set());
    }
    this.value.get(a).add(b);
  }
  addAll(values) {
    values.forEach(([a, b]) => this.add(a, b));
  }
  delete(a, b) {
    if (!this.value.has(a)) return;
    const set = this.value.get(a);
    set.delete(b);
    if (!set.size) {
      this.value.delete(a);
    }
  }
  isEmpty() {
    return !this.value.size;
  }
  get values() {
    return Array.from(this.value).flatMap(
      ([a, values]) => Array.from(values).map((b) => [a, b])
    );
  }
};

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.4.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/isStaticCompatible.mjs
var CompatibilityLevel = /* @__PURE__ */ ((CompatibilityLevel2) => {
  CompatibilityLevel2[CompatibilityLevel2["Incompatible"] = 0] = "Incompatible";
  CompatibilityLevel2[CompatibilityLevel2["Partial"] = 1] = "Partial";
  CompatibilityLevel2[CompatibilityLevel2["BackwardsCompatible"] = 2] = "BackwardsCompatible";
  CompatibilityLevel2[CompatibilityLevel2["Identical"] = 3] = "Identical";
  return CompatibilityLevel2;
})(CompatibilityLevel || {});
function isStaticCompatible(originNode, getOriginNode, destNode, getDestNode, cache, deep = false) {
  if (!destNode && !originNode) {
    return unconditional(3, []);
  }
  if (!destNode)
    return unconditional(2, []);
  if (!originNode)
    return unconditional(
      destNode.type === "option" ? 2 : 0,
      []
    );
  if (!cache.has(destNode)) {
    cache.set(destNode, /* @__PURE__ */ new Map());
  }
  const destNodeCache = cache.get(destNode);
  if (destNodeCache.has(originNode)) {
    const result2 = destNodeCache.get(originNode);
    if (result2 == null) {
      return {
        level: 3,
        changes: [],
        assumptions: new DoubleSet([[originNode, destNode]])
      };
    }
    return unconditional(result2.level, result2.changes);
  }
  destNodeCache.set(originNode, null);
  const result = getIsStaticCompatible(
    originNode,
    destNode,
    (originNode2, destNode2) => isStaticCompatible(
      typeof originNode2 === "number" ? getOriginNode(originNode2) : originNode2,
      getOriginNode,
      typeof destNode2 === "number" ? getDestNode(destNode2) : destNode2,
      getDestNode,
      cache
    ),
    deep
  );
  result.assumptions.delete(originNode, destNode);
  if (result.assumptions.isEmpty() || result.level === 0) {
    destNodeCache.set(originNode, result);
  } else {
    destNodeCache.delete(originNode);
  }
  return result;
}
function getIsStaticCompatible(originNode, destNode, next, deep) {
  const nextCall = (originNode2, destNode2, path) => {
    const result = next(originNode2, destNode2);
    return {
      ...result,
      changes: result.level < 3 ? [
        {
          id: [
            typeof originNode2 === "number" ? originNode2 : null,
            typeof destNode2 === "number" ? destNode2 : null
          ],
          level: result.level,
          path
        }
      ] : []
    };
  };
  if (originNode.type !== destNode.type) {
    if (destNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode, destNode.value, "some"),
        2
        /* BackwardsCompatible */
      );
    }
    if (originNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode.value, destNode, "some"),
        1
        /* Partial */
      );
    }
    return unconditional(0, []);
  }
  switch (destNode.type) {
    case "terminal":
      return unconditional(
        destNode.value.type === originNode.value.type ? 3 : 0,
        []
      );
    case "binary":
      const binaryOrigin = originNode;
      return lengthChange(
        compareOptionalLengths(binaryOrigin.value, destNode.value)
      );
    case "array":
      const arrayOrigin = originNode;
      const lengthCheck = lengthChange(
        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length)
      );
      return strictMerge(
        [
          lengthCheck,
          () => nextCall(
            arrayOrigin.value.typeRef,
            destNode.value.typeRef,
            "value"
          )
        ],
        deep
      );
    case "enum": {
      const enumOrigin = originNode;
      const destVariants = Object.fromEntries(
        destNode.value.map(([key, value2]) => [key, value2.value])
      );
      let enumResults = mergeResults(
        enumOrigin.value.map(
          ([type, value2]) => () => type in destVariants ? nextCall(value2.value, destVariants[type], type) : unconditional(0, [
            {
              id: [
                typeof value2.value === "number" ? value2.value : null,
                null
              ],
              level: 0,
              path: type
            }
          ])
        )
      );
      if (enumOrigin.value.length === destNode.value.length) return enumResults;
      enumResults = withMaxLevel(
        enumResults,
        2
        /* BackwardsCompatible */
      );
      const enumOriginVariants = new Set(enumOrigin.value.map(([key]) => key));
      enumResults.changes = [
        ...enumResults.changes,
        ...destNode.value.filter(([key]) => !enumOriginVariants.has(key)).map(
          ([key, value2]) => ({
            id: [null, typeof value2 === "number" ? value2 : null],
            level: 0,
            path: key
          })
        )
      ];
      return enumResults;
    }
    case "option":
      return withMinLevel(
        nextCall(originNode.value, destNode.value, "some"),
        1
        /* Partial */
      );
    case "struct":
      const structOrigin = originNode;
      const originProperties = Object.fromEntries(structOrigin.value);
      const maxLevel = structOrigin.value.length === destNode.value.length ? 3 : 2;
      return withMaxLevel(
        strictMerge(
          destNode.value.map(
            ([key, value2]) => () => nextCall(originProperties[key], value2, key)
          ),
          deep
        ),
        maxLevel
      );
    case "tuple": {
      const tupleOrigin = originNode;
      const lengthCheck2 = lengthChange(
        compareArrayLengths(tupleOrigin.value, destNode.value)
      );
      return strictMerge(
        [
          lengthCheck2,
          ...destNode.value.map(
            (value2, idx) => () => nextCall(tupleOrigin.value[idx], value2, String(idx))
          )
        ],
        deep
      );
    }
    case "result":
      const resultOrigin = originNode;
      return mergeResults([
        nextCall(resultOrigin.value.ok, destNode.value.ok, "ok"),
        nextCall(resultOrigin.value.ko, destNode.value.ko, "ko")
      ]);
  }
}
var withMaxLevel = (result, level) => ({
  // Changes stay the same. Use case: Option<Incompatible>, the option should show up as Partial, but the change should indicate that the inner one is incompatible.
  ...result,
  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result
  level: Math.min(result.level, level)
});
var withMinLevel = (result, level) => ({
  ...result,
  level: Math.max(result.level, level)
});
var noAssumptions = new DoubleSet();
var unconditional = (level, changes) => ({
  level,
  changes,
  assumptions: noAssumptions
});
var strictMerge = (results, deep) => {
  let merged = unconditional(3, []);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (!deep && result.level === 0) return result;
    if (result.level !== 3)
      merged.changes = [...merged.changes, ...result.changes];
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return merged;
};
var mergeResults = (results) => {
  if (!results.length) return unconditional(3, []);
  let hasCompatibles = false;
  let merged = unconditional(3, []);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level !== 3)
      merged.changes = [...merged.changes, ...result.changes];
    if (result.level === 0) {
      merged.level = Math.min(
        merged.level,
        1
        /* Partial */
      );
      continue;
    }
    hasCompatibles = true;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return hasCompatibles ? merged : unconditional(0, merged.changes);
};
var lengthChange = (level) => ({
  assumptions: noAssumptions,
  changes: level === 3 ? [] : [
    {
      id: [null, null],
      level,
      path: "length"
    }
  ],
  level
});
var compareArrayLengths = (origin, dest) => dest.length === origin.length ? 3 : origin.length >= dest.length ? 2 : 0;
var compareOptionalLengths = (origin, dest) => dest === origin ? 3 : dest == null || origin >= dest ? 2 : origin == null ? 1 : 0;

// node_modules/.pnpm/@polkadot-api+metadata-compatibility@0.4.3/node_modules/@polkadot-api/metadata-compatibility/dist/esm/entryPoint.mjs
var EntryPointNodeCodec = Variant({
  lookup: compactNumber,
  typedef: TypedefCodec
});
var lookupNode = (value2) => ({
  type: "lookup",
  value: value2
});
var typedefNode = (value2) => ({
  type: "typedef",
  value: value2
});
var voidEntryPointNode = typedefNode({
  type: "terminal",
  value: { type: Primitive.void }
});
var EntryPointCodec = Struct2({
  args: EntryPointNodeCodec,
  values: EntryPointNodeCodec
});
function storageEntryPoint(storageEntry) {
  if (storageEntry.type.tag === "plain")
    return {
      args: voidEntryPointNode,
      values: lookupNode(storageEntry.type.value)
    };
  const { key, value: value2 } = storageEntry.type.value;
  return {
    args: lookupNode(key),
    values: lookupNode(value2)
  };
}
function runtimeCallEntryPoint(entry2) {
  return {
    args: typedefNode({
      type: "tuple",
      value: entry2.inputs.map((v) => v.type)
    }),
    values: lookupNode(entry2.output)
  };
}
function enumValueEntryPointNode(entry2) {
  return entry2.type === "lookupEntry" ? lookupNode(entry2.value.id) : typedefNode(mapLookupToTypedef(entry2));
}
function singleValueEntryPoint(value2) {
  return {
    args: voidEntryPointNode,
    values: lookupNode(value2)
  };
}
function entryPointsAreCompatible(descriptorEntry, getDescriptorNode, runtimeEntry, getRuntimeNode, cache, deep) {
  const resolveNode = (node, getTypedef) => node.type === "lookup" ? getTypedef(node.value) : node.value;
  return {
    args: isStaticCompatible(
      resolveNode(descriptorEntry.args, getDescriptorNode),
      getDescriptorNode,
      resolveNode(runtimeEntry.args, getRuntimeNode),
      getRuntimeNode,
      cache,
      deep
    ),
    values: isStaticCompatible(
      resolveNode(runtimeEntry.values, getRuntimeNode),
      getRuntimeNode,
      resolveNode(descriptorEntry.values, getDescriptorNode),
      getDescriptorNode,
      cache,
      deep
    )
  };
}
function valueIsCompatibleWithDest(dest, getDestNode, value2) {
  const node = dest.type === "lookup" ? getDestNode(dest.value) : dest.value;
  return isCompatible(value2, node, getDestNode);
}

// node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value2) {
  return typeof value2 === "function";
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr2, item) {
  if (arr2) {
    var index = arr2.indexOf(item);
    0 <= index && arr2.splice(index, 1);
  }
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = (function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function() {
    var empty3 = new Subscription2();
    empty3.closed = true;
    return empty3;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value2) {
  return value2 instanceof Subscription || value2 && "closed" in value2 && isFunction(value2.remove) && isFunction(value2.add) && isFunction(value2.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop3() {
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (function() {
  return createNotification("C", void 0, void 0);
})();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value2) {
  return createNotification("N", value2, void 0);
}
function createNotification(kind, value2, error) {
  return {
    kind,
    value: value2,
    error
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = (function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value2) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value2), this);
    } else {
      this._next(value2);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value2) {
    this.destination.next(value2);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
})(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value2) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value2);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop3,
  error: defaultErrorHandler,
  complete: noop3
};

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = (function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
})();

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = (function() {
  function Observable3(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable3.prototype.lift = function(operator) {
    var observable2 = new Observable3();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable3.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable3.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value2) {
          try {
            next(value2);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable3.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable3.prototype[observable] = function() {
    return this;
  };
  Observable3.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable3.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value2;
      _this.subscribe(function(x) {
        return value2 = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value2);
      });
    });
  };
  Observable3.create = function(subscribe) {
    return new Observable3(subscribe);
  };
  return Observable3;
})();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value2) {
  return value2 && isFunction(value2.next) && isFunction(value2.error) && isFunction(value2.complete);
}
function isSubscriber(value2) {
  return value2 && value2 instanceof Subscriber || isObserver(value2) && isSubscription(value2);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value2) {
      try {
        onNext(value2);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = (function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value2) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value2) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value2);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = (function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value2) {
    _super.prototype.next.call(this, this._value = value2);
  };
  return BehaviorSubject2;
})(Subject);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = (function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value2) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value2);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value2);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
})(Subject);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = (function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state3, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
})(Subscription);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = (function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state3, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state3;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state3, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state3, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state3, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state3);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
})(Action);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = (function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state3) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state3, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
})();

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = (function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
})(Scheduler);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value2) {
  return value2 && isFunction(value2.schedule);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr2) {
  return arr2[arr2.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = (function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
});

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value2) {
  return isFunction(value2 === null || value2 === void 0 ? void 0 : value2.then);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value2, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value2 = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value2)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value2) {
      if (!subscriber.closed) {
        subscriber.next(value2);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value2 = iterable_1_1.value;
        subscriber.next(value2);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value2, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value2 = asyncIterable_1_1.value;
          subscriber.next(value2);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value2);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value2;
        var done;
        try {
          _a = iterator2.next(), value2 = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value2);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value2) {
        _value = value2;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value2) {
        resolve(value2);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value2) {
  return value2 instanceof Date && !isNaN(value2);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      subscriber.next(project.call(thisArg, value2, index++));
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
            values[i2] = value2;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value2) {
    return active < concurrent ? doInnerSub(value2) : buffer.push(value2);
  };
  var doInnerSub = function(value2) {
    expand && subscriber.next(value2);
    active++;
    var innerComplete = false;
    innerFrom(project(value2, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop3);

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      return predicate.call(thisArg, value2, index++) && subscriber.next(value2);
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/race.js
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value2) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value2);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state3 = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var i = index++;
      state3 = hasState ? accumulator(state3, value2, i) : (hasState = true, value2);
      emitOnNext && subscriber.next(state3);
    }, emitBeforeComplete && (function() {
      hasState && subscriber.next(state3);
      subscriber.complete();
    })));
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      if (++seen <= count2) {
        subscriber.next(value2);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop3));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value2) {
  return map(function() {
    return value2;
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value2, index) {
    return innerFrom(delayDurationSelector(value2, index)).pipe(take(1), mapTo(value2));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/delay.js
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration = timer(due, scheduler);
  return delayWhen(function() {
    return duration;
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var key = keySelector ? keySelector(value2) : value2;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value2);
      }
    }));
    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop3));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var currentKey = keySelector(value2);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value2);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/endWith.js
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
  };
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a, i) {
        return innerFrom(project(a, i)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
function pairwise() {
  return operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var p = prev;
      prev = value2;
      hasPrev && subscriber.next([p, value2]);
      hasPrev = true;
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount > 0) {
        connection = new SafeSubscriber({
          next: function(value2) {
            return dest.next(value2);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value2, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value2, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop3));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var result = predicate(value2, index++);
      (result || inclusive) && subscriber.next(value2);
      !result && subscriber.complete();
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value2);
      subscriber.next(value2);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value2) {
        otherValues[i2] = value2;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop3));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value2) {
      if (ready) {
        var values = __spreadArray([value2], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/.pnpm/@polkadot-api+raw-client@0.1.1/node_modules/@polkadot-api/raw-client/dist/esm/RpcError.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value2) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField4 = (obj, key, value2) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value2);
var RpcError = class extends Error {
  constructor(e) {
    super(e.message);
    __publicField4(this, "code");
    __publicField4(this, "data");
    this.code = e.code;
    this.data = e.data;
    this.name = "RpcError";
  }
};

// node_modules/.pnpm/@polkadot-api+raw-client@0.1.1/node_modules/@polkadot-api/raw-client/dist/esm/subscriptions-manager.mjs
var getSubscriptionsManager = () => {
  const subscriptions = /* @__PURE__ */ new Map();
  return {
    has: subscriptions.has.bind(subscriptions),
    subscribe(id, subscriber) {
      subscriptions.set(id, subscriber);
    },
    unsubscribe(id) {
      subscriptions.delete(id);
    },
    next(id, data) {
      subscriptions.get(id)?.next(data);
    },
    error(id, e) {
      const subscriber = subscriptions.get(id);
      if (subscriber) {
        subscriptions.delete(id);
        subscriber.error(e);
      }
    },
    errorAll(e) {
      const subscribers = [...subscriptions.values()];
      subscriptions.clear();
      subscribers.forEach((s) => {
        s.error(e);
      });
    }
  };
};

// node_modules/.pnpm/@polkadot-api+raw-client@0.1.1/node_modules/@polkadot-api/raw-client/dist/esm/DestroyedError.mjs
var DestroyedError = class extends Error {
  constructor() {
    super("Client destroyed");
    this.name = "DestroyedError";
  }
};

// node_modules/.pnpm/@polkadot-api+raw-client@0.1.1/node_modules/@polkadot-api/raw-client/dist/esm/createClient.mjs
var nextClientId = 1;
var createClient = (gProvider) => {
  let clientId = nextClientId++;
  const responses = /* @__PURE__ */ new Map();
  const subscriptions = getSubscriptionsManager();
  let connection = null;
  const send = (id, method, params2) => {
    connection.send(
      JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params: params2
      })
    );
  };
  function onMessage(message) {
    try {
      let id, result, error, params2, subscription;
      const parsed = JSON.parse(message);
      ({ id, result, error, params: params2 } = parsed);
      if (id === null) throw new Error(params2?.error?.message ?? "id null");
      if (id != null) {
        const cb = responses.get(id);
        if (!cb) return;
        responses.delete(id);
        return error ? cb.onError(new RpcError(error)) : cb.onSuccess(result, (opaqueId, subscriber) => {
          const subscriptionId2 = opaqueId;
          subscriptions.subscribe(subscriptionId2, subscriber);
          return () => {
            subscriptions.unsubscribe(subscriptionId2);
          };
        });
      }
      ;
      ({ subscription, result, error } = params2);
      if (!subscription || !error && !Object.hasOwn(params2, "result")) throw 0;
      const subscriptionId = subscription;
      if (error) {
        subscriptions.error(subscriptionId, new RpcError(error));
      } else {
        subscriptions.next(subscriptionId, result);
      }
    } catch (e) {
      console.warn("Error parsing incomming message: " + message);
      console.error(e);
    }
  }
  connection = gProvider(onMessage);
  const disconnect = () => {
    connection?.disconnect();
    connection = null;
    subscriptions.errorAll(new DestroyedError());
    responses.forEach((r) => r.onError(new DestroyedError()));
    responses.clear();
  };
  let nextId = 1;
  const request = (method, params2, cb) => {
    if (!connection) throw new Error("Not connected");
    const id = `${clientId}-${nextId++}`;
    if (cb) responses.set(id, cb);
    send(id, method, params2);
    return () => {
      responses.delete(id);
    };
  };
  return {
    request,
    disconnect
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/errors.mjs
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value2) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField$1 = (obj, key, value2) => __defNormalProp$1(obj, key + "", value2);
var _StopError = class _StopError2 extends Error {
  constructor() {
    super("ChainHead stopped");
    this.name = _StopError2.errorName;
  }
};
__publicField$1(_StopError, "errorName", "StopError");
var StopError = _StopError;
var _DisjointError = class _DisjointError2 extends Error {
  constructor() {
    super("ChainHead disjointed");
    this.name = _DisjointError2.errorName;
  }
};
__publicField$1(_DisjointError, "errorName", "DisjointError");
var DisjointError = _DisjointError;
var _OperationLimitError = class _OperationLimitError2 extends Error {
  constructor() {
    super("ChainHead operations limit reached");
    this.name = _OperationLimitError2.errorName;
  }
};
__publicField$1(_OperationLimitError, "errorName", "OperationLimitError");
var OperationLimitError = _OperationLimitError;
var _OperationError = class _OperationError2 extends Error {
  constructor(error) {
    super(error);
    this.name = _OperationError2.errorName;
  }
};
__publicField$1(_OperationError, "errorName", "OperationError");
var OperationError = _OperationError;
var _OperationInaccessibleError = class _OperationInaccessibleError2 extends Error {
  constructor() {
    super("ChainHead operation inaccessible");
    this.name = _OperationInaccessibleError2.errorName;
  }
};
__publicField$1(_OperationInaccessibleError, "errorName", "OperationInaccessibleError");
var OperationInaccessibleError = _OperationInaccessibleError;

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/methods.mjs
var chainHead = {
  body: "",
  call: "",
  continue: "",
  follow: "",
  header: "",
  stopOperation: "",
  storage: "",
  unfollow: "",
  unpin: "",
  followEvent: ""
};
var chainSpec = {
  chainName: "",
  genesisHash: "",
  properties: ""
};
var transaction = {
  broadcast: "",
  stop: ""
};
Object.entries({ chainHead, chainSpec, transaction }).forEach(
  ([fnGroupName, methods2]) => {
    Object.keys(methods2).forEach((methodName) => {
      methods2[methodName] = `${fnGroupName}_v1_${methodName}`;
    });
  }
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/archive/errors.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value2) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField5 = (obj, key, value2) => __defNormalProp5(obj, key + "", value2);
var _BlockHashNotFoundError = class _BlockHashNotFoundError2 extends Error {
  constructor(hash) {
    super(`Invalid BlockHash: ${hash}`);
    this.name = _BlockHashNotFoundError2.errorName;
  }
};
__publicField5(_BlockHashNotFoundError, "errorName", "BlockHashNotFoundError");
var BlockHashNotFoundError = _BlockHashNotFoundError;
var _StorageError = class _StorageError2 extends Error {
  constructor(message) {
    super(`Storage Error: ${message}`);
    this.name = _StorageError2.errorName;
  }
};
__publicField5(_StorageError, "errorName", "StorageError");
var StorageError = _StorageError;
var _CallError = class _CallError2 extends Error {
  constructor(message) {
    super(`Call Error: ${message}`);
    this.name = _CallError2.errorName;
  }
};
__publicField5(_CallError, "errorName", "CallError");
var CallError = _CallError;

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/noop.mjs
var noop4 = () => {
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/transaction/transaction.mjs
var getTransaction = (request) => (tx, error) => {
  let isDone = false;
  let cancel = () => {
    isDone = true;
  };
  request(transaction.broadcast, [tx], {
    onSuccess: (subscriptionId) => {
      if (subscriptionId !== null) {
        cancel = () => {
          request(transaction.stop, [subscriptionId]);
          cancel = noop4;
        };
        if (isDone) cancel();
      } else if (!isDone) {
        error(new Error("Max # of broadcasted transactions has been reached"));
      }
    },
    onError: error
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/deferred-promise.mjs
function deferred() {
  let res = () => {
  };
  let rej = () => {
  };
  const promise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  return { promise, res, rej };
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/internal-utils/abortablePromiseFn.mjs
var abortablePromiseFn = (fn) => (...args) => new Promise((res, rej) => {
  let cancel = noop2;
  const [actualArgs, abortSignal] = args[args.length - 1] instanceof AbortSignal ? [args.slice(0, args.length - 1), args[args.length - 1]] : [args];
  const onAbort = () => {
    cancel();
    rej(new AbortError());
  };
  abortSignal?.addEventListener("abort", onAbort, { once: true });
  const withCleanup = (fn2) => (x) => {
    cancel = noop2;
    abortSignal?.removeEventListener("abort", onAbort);
    fn2(x);
  };
  cancel = fn(...[withCleanup(res), withCleanup(rej), ...actualArgs]);
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/operation-promise.mjs
var createOperationPromise = (operationName, factory) => (request) => abortablePromiseFn((res, rej, ...args) => {
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  const [requestArgs, logicCb] = factory(...args);
  request(operationName, requestArgs, {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached")
        return rej(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      let done = noop4;
      const _res = (x) => {
        isRunning = false;
        done();
        res(x);
      };
      const _rej = (x) => {
        isRunning = false;
        done();
        rej(x);
      };
      done = followSubscription(operationId, {
        next: (e) => {
          const _e = e;
          if (_e.event === "operationError")
            rej(new OperationError(_e.error));
          else if (_e.event === "operationInaccessible")
            rej(new OperationInaccessibleError());
          else logicCb(e, _res, _rej);
        },
        error: _rej
      });
      cancel = () => {
        if (isRunning) {
          done();
          stopOperation();
        }
      };
    },
    onError: rej
  });
  return () => {
    cancel();
  };
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/body.mjs
var createBodyFn = createOperationPromise(
  chainHead.body,
  (hash) => [
    [hash],
    (e, res) => {
      res(e.value);
    }
  ]
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/call.mjs
var createCallFn = createOperationPromise(
  chainHead.call,
  (hash, fnName, callParameters) => [
    [hash, fnName, callParameters],
    (e, res) => {
      res(e.output);
    }
  ]
);

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/header.mjs
var createHeaderFn = (request) => (hash) => new Promise((res, rej) => {
  request(chainHead.header, [hash], {
    onSuccess: res,
    onError: rej
  });
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/storage-subscription.mjs
var createStorageCb$1 = (request) => (hash, inputs, childTrie, onItems, onError, onDone, onDiscardedItems) => {
  if (inputs.length === 0) {
    onDone();
    return noop2;
  }
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  request(chainHead.storage, [hash, inputs, childTrie], {
    onSuccess: (response, followSubscription) => {
      if (response.result === "limitReached" || response.discardedItems === inputs.length)
        return onError(new OperationLimitError());
      const { operationId } = response;
      const stopOperation = () => {
        request(chainHead.stopOperation, [operationId]);
      };
      if (!isRunning) return stopOperation();
      const doneListening = followSubscription(response.operationId, {
        next: (event) => {
          switch (event.event) {
            case "operationStorageItems": {
              onItems(event.items);
              break;
            }
            case "operationStorageDone": {
              _onDone();
              break;
            }
            case "operationError": {
              _onError(new OperationError(event.error));
              break;
            }
            case "operationInaccessible": {
              _onError(new OperationInaccessibleError());
              break;
            }
            default:
              request(chainHead.continue, [event.operationId]);
          }
        },
        error: onError
      });
      cancel = () => {
        doneListening();
        request(chainHead.stopOperation, [response.operationId]);
      };
      const _onError = (e) => {
        cancel = noop2;
        doneListening();
        onError(e);
      };
      const _onDone = () => {
        cancel = noop2;
        doneListening();
        onDone();
      };
      onDiscardedItems(response.discardedItems);
    },
    onError
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/storage.mjs
var createStorageFn$1 = (request) => {
  const cbStore = createStorageCb$1(request);
  return abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
    const isDescendants = type.startsWith("descendants");
    let result = isDescendants ? [] : null;
    const onItems = isDescendants ? (items) => {
      result.push(items);
    } : (items) => {
      result = items[0]?.[type];
    };
    const cancel = cbStore(
      hash,
      [{ key, type }],
      childTrie ?? null,
      onItems,
      reject,
      () => {
        try {
          resolve(isDescendants ? result.flat() : result);
        } catch (e) {
          reject(e);
        }
      },
      (nDiscarded) => {
        if (nDiscarded > 0) {
          cancel();
          reject(new OperationLimitError());
        }
      }
    );
    return cancel;
  });
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/unpin.mjs
var createUnpinFn = (request) => (hashes) => hashes.length > 0 ? new Promise((res, rej) => {
  request(chainHead.unpin, [hashes], {
    onSuccess() {
      res();
    },
    onError: rej
  });
}) : Promise.resolve();

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainhead/chainhead.mjs
function isOperationEvent(event) {
  return event.operationId !== void 0;
}
function getChainHead(request) {
  return (withRuntime, onFollowEvent, onFollowError) => {
    const subscriptions = getSubscriptionsManager();
    const ongoingRequests = /* @__PURE__ */ new Set();
    const deferredFollow = deferred();
    let followSubscription = deferredFollow.promise;
    let stopListeningToFollowEvents = noop4;
    const unfollowRequest = (subscriptionId) => {
      request(chainHead.unfollow, [subscriptionId]);
    };
    const stopEverything = (sendUnfollow) => {
      stopListeningToFollowEvents();
      if (followSubscription === null) return;
      if (sendUnfollow) {
        if (followSubscription instanceof Promise) {
          followSubscription.then((x) => {
            if (typeof x === "string") unfollowRequest(x);
          });
        } else unfollowRequest(followSubscription);
      }
      followSubscription = null;
      ongoingRequests.forEach((cb) => {
        cb();
      });
      ongoingRequests.clear();
      subscriptions.errorAll(new DisjointError());
    };
    const onAllFollowEventsNext = (event) => {
      if (isOperationEvent(event))
        return subscriptions.next(event.operationId, event);
      switch (event.event) {
        case "stop":
          onFollowError(new StopError());
          return stopEverything(false);
        case "initialized":
        case "newBlock":
        case "bestBlockChanged":
        case "finalized":
          const { event: type, ...rest } = event;
          return onFollowEvent({ type, ...rest });
      }
    };
    const onAllFollowEventsError = (error) => {
      onFollowError(error);
      stopEverything(!(error instanceof DestroyedError));
    };
    request(chainHead.follow, [withRuntime], {
      onSuccess: (subscriptionId, follow) => {
        if (followSubscription instanceof Promise) {
          followSubscription = subscriptionId;
          stopListeningToFollowEvents = follow(subscriptionId, {
            next: onAllFollowEventsNext,
            error: onAllFollowEventsError
          });
        }
        deferredFollow.res(subscriptionId);
      },
      onError: (e) => {
        followSubscription = null;
        deferredFollow.res(e);
        onFollowError(e);
      }
    });
    const fRequest = (method, params2, cb) => {
      const disjoint = () => {
        cb?.onError(new DisjointError());
      };
      if (followSubscription === null) {
        disjoint();
        return noop4;
      }
      const onSubscription = (subscription) => {
        if (!cb) return request(method, [subscription, ...params2]);
        ongoingRequests.add(disjoint);
        const onSubscribeOperation = (operationId, subscriber) => {
          if (followSubscription === null) {
            subscriber.error(new DisjointError());
            return noop4;
          }
          subscriptions.subscribe(operationId, subscriber);
          return () => {
            subscriptions.unsubscribe(operationId);
          };
        };
        const cleanup = request(method, [subscription, ...params2], {
          onSuccess: (response) => {
            ongoingRequests.delete(disjoint);
            cb.onSuccess(response, onSubscribeOperation);
          },
          onError: (e) => {
            ongoingRequests.delete(disjoint);
            cb.onError(e);
          }
        });
        return () => {
          ongoingRequests.delete(disjoint);
          cleanup();
        };
      };
      if (typeof followSubscription === "string")
        return onSubscription(followSubscription);
      let onCancel = noop4;
      followSubscription.then((x) => {
        if (x instanceof Error) return disjoint();
        if (followSubscription) onCancel = onSubscription(x);
      });
      return () => {
        onCancel();
      };
    };
    return {
      unfollow() {
        stopEverything(true);
      },
      body: createBodyFn(fRequest),
      call: createCallFn(fRequest),
      header: createHeaderFn(fRequest),
      storage: createStorageFn$1(fRequest),
      storageSubscription: createStorageCb$1(fRequest),
      unpin: createUnpinFn(fRequest),
      _request: fRequest
    };
  };
}

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/chainspec.mjs
var createGetChainSpec = (clientRequest) => {
  const request = abortablePromiseFn(
    (onSuccess, onError, method, params2) => clientRequest(method, params2, { onSuccess, onError })
  );
  let cachedPromise = null;
  return async () => {
    if (cachedPromise) return cachedPromise;
    return cachedPromise = Promise.all([
      request(chainSpec.chainName, []),
      request(chainSpec.genesisHash, []),
      request(chainSpec.properties, [])
    ]).then(([name, genesisHash, properties]) => ({
      name,
      genesisHash,
      properties
    }));
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/archive/storage-subscription.mjs
var createStorageCb = (archiveRequest) => (hash, inputs, childTrie, onItem, onError, onDone) => {
  if (inputs.length === 0) {
    onDone();
    return noop2;
  }
  let isRunning = true;
  let cancel = () => {
    isRunning = false;
  };
  archiveRequest("storage", [hash, inputs, childTrie], {
    onSuccess: (operationId, followSubscription) => {
      const stopOperation = () => {
        archiveRequest("stopStorage", [operationId]);
      };
      if (!isRunning) return stopOperation();
      const doneListening = followSubscription(operationId, {
        next: (event) => {
          const { event: type } = event;
          if (type === "storage") {
            const { event: _, ...item } = event;
            onItem(item);
          } else if (type === "storageDone") _onDone();
          else _onError(new StorageError(event.error));
        },
        error: onError
      });
      const tearDown = () => {
        cancel = noop2;
        doneListening();
      };
      cancel = () => {
        tearDown();
        stopOperation();
      };
      const _onError = (e) => {
        tearDown();
        onError(e);
      };
      const _onDone = () => {
        tearDown();
        onDone();
      };
    },
    onError
  });
  return () => {
    cancel();
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/archive/storage.mjs
var createStorageFn = (cbStore) => abortablePromiseFn((resolve, reject, hash, type, key, childTrie) => {
  const isDescendants = type.startsWith("descendants");
  let result = isDescendants ? [] : null;
  const onItem = isDescendants ? result.push.bind(result) : ({ [type]: res }) => {
    result = res;
  };
  return cbStore(
    hash,
    [{ key, type }],
    childTrie,
    onItem,
    (e) => {
      reject(e);
      result = null;
    },
    () => {
      resolve(result);
      result = null;
    }
  );
});

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/archive/archive.mjs
var identity2 = () => (x) => x;
var handleInvalidBlockHash = () => (result, hash) => {
  if (result === null) throw new BlockHashNotFoundError(hash);
  return result;
};
var getArchive = (request) => {
  const archiveRequest = (method, ...rest) => request(`archive_v1_${method}`, ...rest);
  const fnCreator = (method) => (mapper) => abortablePromiseFn(
    (res, rej, ...args) => archiveRequest(method, args, {
      onSuccess: (x) => {
        try {
          res(mapper(x, ...args));
        } catch (e) {
          rej(e);
        }
      },
      onError: rej
    })
  );
  const header = fnCreator("header")(
    handleInvalidBlockHash()
  );
  const body = fnCreator("body")(
    handleInvalidBlockHash()
  );
  const storageSubscription = createStorageCb(archiveRequest);
  const storage = createStorageFn(storageSubscription);
  const call = fnCreator("call")((x, hash) => {
    if (!x) throw new BlockHashNotFoundError(hash);
    if (!x.success) throw new CallError(x.error);
    return x.value;
  });
  const finalizedHeight = fnCreator("finalizedHeight")(identity2());
  const hashByHeight = fnCreator("hashByHeight")(identity2());
  return {
    header,
    body,
    storageSubscription,
    storage,
    call,
    finalizedHeight,
    hashByHeight
  };
};

// node_modules/.pnpm/@polkadot-api+substrate-client@0.5.0/node_modules/@polkadot-api/substrate-client/dist/esm/substrate-client.mjs
var createClient2 = (provider) => {
  const { request, disconnect } = createClient(provider);
  return {
    archive: getArchive(request),
    chainHead: getChainHead(request),
    transaction: getTransaction(request),
    getChainSpecData: createGetChainSpec(request),
    destroy: disconnect,
    request: abortablePromiseFn(
      (onSuccess, onError, method, params2) => request(method, params2, { onSuccess, onError })
    ),
    _request: request
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/operationLimitRecovery.mjs
var __defProp7 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value2) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField6 = (obj, key, value2) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value2);
var PendingTaskQueue = class {
  constructor() {
    __publicField6(this, "first");
    __publicField6(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value2) {
    const newNode = { value: value2 };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value2) {
    this.first = { value: value2, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable2, cb) => {
    tearDownOperations.set(observable2, () => {
      tearDownOperations.delete(observable2);
      cb();
    });
  };
  const teardown = (observable2) => {
    tearDownOperations.get(observable2)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data) return;
    tearDownOperations.delete(data.source$);
    process2(data);
  };
  const process2 = (data) => {
    const { source$, observer } = data;
    let isOperationLimit = false;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        (isOperationLimit = e instanceof Error && e.name === OperationLimitError.errorName) ? addTask(data, true) : observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (!subscription.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
        onEmptySlot();
      });
    } else if (!isOperationLimit) onEmptySlot();
  };
  const withRecovery2 = (topPriority = false) => (source$) => new Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process2(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery2();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery: withRecovery2, withRecoveryFn };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/errors.mjs
var BlockNotPinnedError = class extends Error {
  constructor(hash, label) {
    super(`Block ${hash} is not pinned (${label})`);
    this.name = "BlockNotPinnedError";
  }
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/operation-inaccessible-retry.mjs
var withOperationInaccessibleRetry = (source$) => {
  const result = source$.pipe(
    catchError(
      (e) => e instanceof Error && e.name === OperationInaccessibleError.errorName ? timer(750).pipe(concatMap(() => result)) : throwError(() => e)
    )
  );
  return result;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/optionalHash.mjs
var dynamicBlocks = /* @__PURE__ */ new Set(["best", "finalized", null]);
var getWithOptionalHash$ = (finalized$, best$, usingBlock) => {
  return (fn) => (hash, ...args) => {
    if (!dynamicBlocks.has(hash))
      return withOperationInaccessibleRetry(fn(hash, ...args)).pipe(
        usingBlock(hash)
      );
    const hash$ = hash === "best" ? best$ : finalized$;
    const result$ = hash$.pipe(
      take(1),
      mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),
      catchError((e) => {
        return e instanceof BlockNotPinnedError ? result$ : throwError(() => e);
      })
    );
    return withOperationInaccessibleRetry(result$);
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/fromAbortControllerFn.mjs
var fromAbortControllerFn = (fn) => (...args) => new Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value2) => {
      observer.next(value2);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/lazyFollower.mjs
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/pinned-blocks-types.mjs
var PinnedBlockState = /* @__PURE__ */ ((PinnedBlockState2) => {
  PinnedBlockState2[PinnedBlockState2["Initializing"] = 0] = "Initializing";
  PinnedBlockState2[PinnedBlockState2["Ready"] = 1] = "Ready";
  PinnedBlockState2[PinnedBlockState2["RecoveringInit"] = 2] = "RecoveringInit";
  PinnedBlockState2[PinnedBlockState2["RecoveringFin"] = 3] = "RecoveringFin";
  return PinnedBlockState2;
})(PinnedBlockState || {});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/enhancers/withStopRecovery.mjs
function withStopRecovery(pinned$, fn, label) {
  return (hash, ...args) => {
    let block;
    const getNonPinnedError = () => new BlockNotPinnedError(hash, label);
    const inner$ = fn(hash, ...args).pipe(
      map((value2) => ({ type: "val", value: value2 })),
      endWith({ type: "end" })
    );
    const waitForIt$ = pinned$.pipe(
      takeWhile((x) => !x.blocks.has(hash)),
      map((x) => {
        if (x.blocks.get(x.finalized).number >= block.number)
          throw getNonPinnedError();
      }),
      ignoreElements()
    );
    return pinned$.pipe(
      map((x) => x.state.type === PinnedBlockState.Ready),
      distinctUntilChanged(),
      switchMap((isReady) => {
        if (!isReady) return NEVER;
        block || (block = pinned$.state.blocks.get(hash));
        return block ? concat(waitForIt$, inner$) : throwError(getNonPinnedError);
      }),
      takeWhile((x) => x.type === "val"),
      map((x) => x.value)
    );
  };
}

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/storage-queries.mjs
var getRecoveralStorage$ = (getFollower, withRecovery2) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded > 0)
          observer.next(
            recoveralStorage$(
              hash,
              queries.slice(-nDiscarded),
              childTrie,
              true
            )
          );
      }
    )
  ).pipe(mergeAll(), withRecovery2(isHighPriority));
  return recoveralStorage$;
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/hashers.mjs
var hashers2 = [Blake2256, Keccak256];
var getHasherFromHeader = (header, blockHash) => hashers2.find((h) => toHex(h(fromHex2(header))) === blockHash) || (() => {
  throw new Error("Unsupported hasher");
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/follow.mjs
var createGetRuntimeChanges = (getCodeHash) => {
  const getRuntimeChanges = (blocks, firstId, lastId) => {
    const firstBlock = blocks[firstId.idx];
    const lastBlock = blocks[lastId.idx];
    if (blocks.length === 2)
      return of([
        [firstBlock, firstId.id],
        [lastBlock, lastId.id]
      ]);
    const middleIdx = firstId.idx + Math.floor((lastId.idx - firstId.idx) / 2);
    return getCodeHash(blocks[middleIdx]).pipe(
      mergeMap((id) => {
        const middle = { id, idx: middleIdx };
        if (middle.id === firstId.id)
          return getRuntimeChanges(blocks, middle, lastId);
        return middle.id === lastId.id ? getRuntimeChanges(blocks, firstId, middle) : combineLatest([
          getRuntimeChanges(blocks, firstId, middle),
          getRuntimeChanges(blocks, middle, lastId)
        ]).pipe(map(([left, [_SKIP, ...right]]) => [...left, ...right]));
      })
    );
  };
  return (blocks) => {
    const [initialBlock] = blocks;
    if (blocks.length === 1)
      return getCodeHash(initialBlock).pipe(map((x) => [[initialBlock, x]]));
    const lastIdx = blocks.length - 1;
    return combineLatest([initialBlock, blocks[lastIdx]].map(getCodeHash)).pipe(
      mergeMap(
        ([firstId, lastId]) => firstId === lastId ? of([[initialBlock, firstId]]) : getRuntimeChanges(
          blocks,
          { idx: 0, id: firstId },
          { idx: lastIdx, id: lastId }
        )
      )
    );
  };
};
var withEnhancedFollow = (getFollower, getCodeHash, reset) => {
  const getRuntimeChanges = createGetRuntimeChanges(getCodeHash);
  const getRawHeader = (blockHash) => defer(() => getFollower().header(blockHash));
  const hasher$ = new ReplaySubject(1);
  const getInnerObservables = (event) => {
    if (event.type === "initialized") {
      const [blockHash] = event.finalizedBlockHashes;
      return combineLatest([
        getRawHeader(blockHash),
        getRuntimeChanges(event.finalizedBlockHashes)
      ]).pipe(
        map(([rawHeader, changes]) => {
          if (!hasher$.closed) {
            hasher$.next(getHasherFromHeader(rawHeader, blockHash));
            hasher$.complete();
          }
          const { number, parentHash, digests } = blockHeader.dec(rawHeader);
          return {
            type: "initialized",
            finalizedBlockHashes: event.finalizedBlockHashes,
            runtimeChanges: new Map(changes),
            number,
            parentHash,
            hasNewRuntime: digests.some((d) => d.type === "runtimeUpdated")
          };
        })
      );
    }
    if (event.type === "newBlock" && event.newRuntime)
      return getCodeHash(event.blockHash).pipe(
        map((codeHash) => ({
          ...event,
          codeHash
        }))
      );
  };
  const enhancer = (base) => new Observable(
    (observer) => {
      let pending = null;
      let inner;
      const next = (v) => pending?.push(v) || evaluateValue(v);
      const evaluateValue = (v) => {
        const obs = getInnerObservables(v);
        if (obs) {
          pending = [];
          inner = obs.subscribe({
            next: (o) => {
              const copy = [...pending];
              pending = null;
              observer.next(o);
              copy.forEach(next);
            },
            error: reset
          });
        } else observer.next(v);
      };
      const outter = base.subscribe((event) => {
        if (event.type === "stop-error") {
          inner?.unsubscribe();
          pending = null;
          observer.next(event);
        } else next(event);
      });
      return () => {
        inner?.unsubscribe();
        outter.unsubscribe();
      };
    }
  );
  return {
    getHeader: (blockHash) => getRawHeader(blockHash).pipe(map(blockHeader[1])),
    hasher$: hasher$.asObservable(),
    enhancer
  };
};
var getFollow$ = (chainHead2, withRecoveryFn) => {
  let follower = null;
  let isDone = false;
  let unfollow = () => {
    isDone = true;
  };
  const getFollower = () => {
    if (!follower) throw new Error("Missing chainHead subscription");
    return follower;
  };
  const getCodeHash = withRecoveryFn(
    fromAbortControllerFn(
      (blockHash, abortSignal) => (
        // ":code" => "0x3a636f6465"
        getFollower().storage(
          blockHash,
          "hash",
          "0x3a636f6465",
          null,
          abortSignal
        )
      )
    )
  );
  let reset = noop3;
  const { hasher$, enhancer, getHeader: getHeader2 } = withEnhancedFollow(
    getFollower,
    getCodeHash,
    () => reset()
  );
  const follow$ = new Observable((observer) => {
    if (isDone) return observer.complete();
    let token;
    const setFollower = () => {
      follower = chainHead2(
        true,
        (msg) => observer.next(msg),
        (e) => {
          follower = null;
          if (isDone) return;
          if (e instanceof Error && e.name === StopError.errorName) {
            setFollower();
            observer.next({ type: "stop-error" });
          } else {
            console.warn("ChainHead follow request failed, retrying\u2026", e);
            token = setTimeout(setFollower, 250);
          }
        }
      );
    };
    reset = () => {
      observer.next({ type: "stop-error" });
      clearTimeout(token);
      follower?.unfollow();
      setFollower();
    };
    setFollower();
    unfollow = () => {
      isDone = true;
      clearTimeout(token);
      observer.complete();
      follower?.unfollow();
    };
  }).pipe(enhancer, share());
  return {
    getHeader: getHeader2,
    hasher$,
    getFollower,
    follow$,
    unfollow: () => {
      unfollow();
    }
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/get-raw-metadta.mjs
var versionedArgs = (v) => toHex(u32.enc(v));
var opaqueBytes2 = Bytes();
var optionalOpaqueBytes = Option2(opaqueBytes2);
var u32ListDecoder = Vector2(u32).dec;
var getRawMetadata$ = (call$) => {
  const versions$ = call$("Metadata_metadata_versions", "").pipe(
    map(u32ListDecoder),
    catchError(() => of([14]))
  );
  const versioned$ = (availableVersions) => {
    const [v] = availableVersions.filter((x) => x > 13 && x < 17).sort((a, b) => b - a);
    return v === 14 ? call$("Metadata_metadata", "").pipe(map(opaqueBytes2.dec)) : call$("Metadata_metadata_at_version", versionedArgs(v)).pipe(
      map((x) => optionalOpaqueBytes.dec(x))
    );
  };
  return versions$.pipe(mergeMap(versioned$));
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.13.8/node_modules/@polkadot-api/metadata-builders/dist/esm/lookups.mjs
var isBytes3 = (value2, nBytes) => value2.type === "array" && value2.len === nBytes && value2.value.type === "primitive" && value2.value.value === "u8";
var _void2 = { type: "void" };
var _denormalizeLookup = (lookupData, customMap = () => null) => {
  const lookups = /* @__PURE__ */ new Map();
  const from2 = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry2 = lookups.get(id);
      if (entry2) return entry2;
      if (from2.has(id)) {
        const entry22 = {
          id
        };
        lookups.set(id, entry22);
        return entry22;
      }
      from2.add(id);
      const value2 = fn(id);
      entry2 = lookups.get(id);
      if (entry2) {
        Object.assign(entry2, value2);
      } else {
        entry2 = {
          id,
          ...value2
        };
        lookups.set(id, entry2);
      }
      from2.delete(id);
      return entry2;
    };
  };
  let isAccountId32SearchOn = true;
  let isAccountId20SearchOn = true;
  const getLookupEntryDef = withCache2((id) => {
    const custom = customMap(lookupData[id]);
    if (custom) return custom;
    const { def: def2, path, params: params2 } = lookupData[id];
    if (def2.tag === "composite") {
      if (def2.value.length === 0) return _void2;
      if (def2.value.length === 1) {
        const inner = getLookupEntryDef(def2.value[0].type);
        if (isAccountId32SearchOn && path.at(-1) === "AccountId32" && isBytes3(inner, 32)) {
          isAccountId32SearchOn = false;
          return { type: "AccountId32" };
        }
        if (isAccountId20SearchOn && path.at(-1) === "AccountId20" && isBytes3(inner, 20)) {
          isAccountId20SearchOn = false;
          return { type: "AccountId20" };
        }
        return inner;
      }
      return getComplexVar(def2.value);
    }
    if (def2.tag === "variant") {
      if (path.length === 1 && path[0] === "Option" && params2.length === 1 && params2[0].name === "T") {
        const value2 = getLookupEntryDef(params2[0].type);
        return value2.type === "void" ? (
          // Option<void> would return a Codec<undefined> which makes no sense
          // Therefore, we better treat it as a bool
          { type: "primitive", value: "bool" }
        ) : {
          type: "option",
          value: value2
        };
      }
      if (path.length === 1 && path[0] === "Result" && params2.length === 2 && params2[0].name === "T" && params2[1].name === "E") {
        return {
          type: "result",
          value: {
            ok: getLookupEntryDef(params2[0].type),
            ko: getLookupEntryDef(params2[1].type)
          }
        };
      }
      if (def2.value.length === 0) return _void2;
      const enumValue = {};
      const enumDocs = {};
      def2.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { ..._void2, idx: x.index };
          return;
        }
        if (x.fields.length === 1 && !x.fields[0].name) {
          enumValue[key] = {
            type: "lookupEntry",
            value: getLookupEntryDef(x.fields[0].type),
            idx: x.index
          };
          return;
        }
        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def2.tag === "sequence")
      return {
        type: "sequence",
        value: getLookupEntryDef(def2.value)
      };
    if (def2.tag === "array") {
      const { len } = def2.value;
      const value2 = getLookupEntryDef(def2.value.type);
      return !len || value2.type === "void" ? _void2 : len > 1 ? {
        type: "array",
        value: value2,
        len: def2.value.len
      } : value2;
    }
    if (def2.tag === "tuple") {
      if (def2.value.length === 0) return _void2;
      return def2.value.length > 1 ? getArrayOrTuple(
        def2.value.map((x) => getLookupEntryDef(x)),
        def2.value.map((x) => lookupData[x].docs)
      ) : getLookupEntryDef(def2.value[0]);
    }
    if (def2.tag === "primitive") {
      return {
        type: "primitive",
        value: def2.value.tag
      };
    }
    if (def2.tag === "compact") {
      const translated = getLookupEntryDef(def2.value);
      if (translated.type === "void") return _void2;
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig,
        size: translated.value
      };
    }
    return {
      type: def2.tag,
      isLSB: (lookupData[def2.value.bitOrderType].path.at(-1) ?? "LSB").toUpperCase().startsWith("LSB")
    };
  });
  const getComplexVar = (input) => {
    let allKey = true;
    const values = {};
    const innerDocs = {};
    input.forEach((x, idx) => {
      allKey = allKey && !!x.name;
      const key = x.name || idx;
      const value2 = getLookupEntryDef(x.type);
      if (value2.type !== "void") {
        values[key] = value2;
        innerDocs[key] = x.docs;
      }
    });
    return allKey ? {
      type: "struct",
      value: values,
      innerDocs
    } : getArrayOrTuple(Object.values(values), Object.values(innerDocs));
  };
  const getArrayOrTuple = (values, innerDocs) => {
    if (values.every((v) => v.id === values[0].id) && innerDocs.every((doc) => !doc.length)) {
      const [value2] = values;
      return value2.type === "void" ? _void2 : {
        type: "array",
        value: values[0],
        len: values.length
      };
    }
    return {
      type: "tuple",
      value: values,
      innerDocs
    };
  };
  return getLookupEntryDef;
};
var getLookupFn = (metadata2) => {
  const getLookupEntryDef = _denormalizeLookup(metadata2.lookup, ({ def: def2 }) => {
    if (def2.tag === "composite") {
      const moduleErrorLength = getModuleErrorLength(def2);
      if (moduleErrorLength) {
        return {
          type: "enum",
          innerDocs: {},
          value: Object.fromEntries(
            metadata2.pallets.map((p) => [
              p.name,
              p.errors == null ? { ..._void2, idx: p.index } : {
                type: "lookupEntry",
                value: getLookupEntryDef(p.errors.type),
                idx: p.index
              }
            ])
          ),
          byteLength: moduleErrorLength
        };
      }
    }
    return null;
  });
  function getModuleErrorLength(def2) {
    const preChecks = def2.value.length === 2 && def2.value[0].name === "index" && def2.value[1].name === "error";
    if (!preChecks) return null;
    const index = getLookupEntryDef(def2.value[0].type);
    const error = getLookupEntryDef(def2.value[1].type);
    return index.type === "primitive" && index.value === "u8" && error.type === "array" && error.value.type === "primitive" && error.value.value === "u8" ? 1 + error.len : null;
  }
  const getCall = () => {
    if ("call" in metadata2.extrinsic) {
      return metadata2.extrinsic.call;
    }
    const extrinsic2 = metadata2.lookup[metadata2.extrinsic.type];
    const call = extrinsic2?.params.find((p) => p.name === "Call");
    return call?.type ?? null;
  };
  return Object.assign(getLookupEntryDef, { metadata: metadata2, call: getCall() });
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.13.8/node_modules/@polkadot-api/metadata-builders/dist/esm/with-cache.mjs
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id)) return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.13.8/node_modules/@polkadot-api/metadata-builders/dist/esm/lookup-codec-builder.mjs
var _bytes2 = Bin();
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive") return esm_exports[input.value];
  if (input.type === "void") return _void;
  if (input.type === "AccountId32") return _accountId;
  if (input.type === "AccountId20") return ethAccount;
  if (input.type === "compact")
    return input.isBig ? compactBn : compactNumber;
  if (input.type === "bitSequence") return BitSeq(input.isLSB);
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? Vector2(innerCodec, len) : Vector2(innerCodec);
  };
  const buildTuple = (value2) => Tuple2(...value2.map(buildNextCodec));
  const buildStruct = (value2) => {
    const inner2 = Object.fromEntries(
      Object.entries(value2).map(([key, value22]) => [key, buildNextCodec(value22)])
    );
    return Struct2(inner2);
  };
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes2;
  }
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8")
      return Bin(input.len);
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence") return buildVector(input.value);
  if (input.type === "tuple") return buildTuple(input.value);
  if (input.type === "struct") return buildStruct(input.value);
  if (input.type === "option") return Option2(buildNextCodec(input.value));
  if (input.type === "result")
    return Result2(
      buildNextCodec(input.value.ok),
      buildNextCodec(input.value.ko)
    );
  const dependencies = Object.values(input.value).map((v) => {
    switch (v.type) {
      case "void":
        return _void;
      case "lookupEntry":
        return buildNextCodec(v.value);
      case "tuple":
        return buildTuple(v.value);
      case "struct":
        return buildStruct(v.value);
      case "array":
        return buildVector(v.value, v.len);
    }
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  const variantCodec = areIndexesSorted ? Variant(inner) : Variant(inner, indexes);
  return input.byteLength ? fixedSizeCodec(variantCodec, input.byteLength) : variantCodec;
};
var buildCodec = withCache(_buildCodec, Self, (res) => res);
var getLookupCodecBuilder = (lookup2, accountId = AccountId()) => {
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(lookup2(id), cache, /* @__PURE__ */ new Set(), accountId);
  return (id) => buildDefinition(id);
};
var fixedSizeCodec = (codec, size) => {
  const allBytes = Bytes(size);
  return createCodec(
    (value2) => allBytes.enc(codec.enc(value2)),
    (data) => codec.dec(allBytes.dec(data))
  );
};

// node_modules/.pnpm/@polkadot-api+metadata-builders@0.13.8/node_modules/@polkadot-api/metadata-builders/dist/esm/dynamic-builder.mjs
var nullCodec = enhanceCodec(
  _void,
  () => void 0,
  () => null
);
var getDynamicBuilder = (getLookupEntryDef) => {
  const { metadata: metadata2 } = getLookupEntryDef;
  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef);
  const prefix = metadata2.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        buildDefinition = getLookupCodecBuilder(
          getLookupEntryDef,
          AccountId(prefixVal)
        );
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry2) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = Storage(pallet));
    const storageEntry = metadata2.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry2);
    const withNullVoid = (codec) => codec === _void ? nullCodec : codec;
    const storageWithFallback = (len, value22, ...args) => {
      const keys = storagePallet(...args);
      const [, ...encodersWithHash] = args;
      return {
        args: Tuple2(...encodersWithHash.map(([codec]) => codec)),
        keys,
        value: value22,
        len,
        fallback: storageEntry.modifier === 1 ? value22.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        withNullVoid(buildDefinition(storageEntry.type.value)),
        entry2
      );
    const { key, value: value2, hashers: hashers3 } = storageEntry.type.value;
    const val = withNullVoid(buildDefinition(value2));
    const hashes = hashers3.map((x) => esm_exports[x.tag]);
    const hashArgs = (() => {
      if (hashes.length === 1) {
        return [[buildDefinition(key), hashes[0]]];
      }
      const keyDef = getLookupEntryDef(key);
      switch (keyDef.type) {
        case "array":
          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash]);
        case "tuple":
          return keyDef.value.map((x, idx) => [
            buildDefinition(x.id),
            hashes[idx]
          ]);
        default:
          throw new Error("Invalid key type");
      }
    })();
    return storageWithFallback(hashes.length, val, entry2, ...hashArgs);
  };
  const buildEnumEntry = (entry2) => {
    switch (entry2.type) {
      case "void":
        return _void;
      case "lookupEntry":
        return buildDefinition(entry2.value.id);
      case "tuple":
        return Tuple2(
          ...Object.values(entry2.value).map((l) => buildDefinition(l.id))
        );
      case "struct":
        return Struct2(
          mapObject2(entry2.value, (x) => buildDefinition(x.id))
        );
      case "array":
        return Vector2(buildDefinition(entry2.value.id), entry2.len);
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata2.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata2.pallets.find((x) => x.name === pallet);
    const lookup2 = getLookupEntryDef(palletEntry[type].type);
    if (lookup2.type !== "enum") throw null;
    const entry2 = lookup2.value[name];
    return {
      location: [palletEntry.index, entry2.idx],
      codec: buildEnumEntry(lookup2.value[name])
    };
  };
  const buildViewFn = (pallet, entry2) => {
    const fn = metadata2.pallets.find((x) => x.name === pallet)?.viewFns.find((x) => x.name === entry2);
    if (!fn) throw null;
    return {
      args: Tuple2(...fn.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(fn.output)
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry2 = metadata2.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry2) throw null;
    return {
      args: Tuple2(...entry2.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(entry2.output)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildViewFn,
    buildRuntimeCall,
    buildCall: buildVariant("calls"),
    buildConstant,
    ss58Prefix
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/create-metadata-ctx.mjs
var CHECK_MORTALITY = "CheckMortality";
var createRuntimeCtx = (metadata2, metadataRaw, codeHash) => {
  const lookup2 = getLookupFn(metadata2);
  const dynamicBuilder = getDynamicBuilder(lookup2);
  const events = dynamicBuilder.buildStorage("System", "Events");
  const assetPayment = metadata2.extrinsic.signedExtensions.find(
    (x) => x.identifier === "ChargeAssetTxPayment"
  );
  let assetId = null;
  if (assetPayment) {
    const assetTxPayment = lookup2(assetPayment.type);
    if (assetTxPayment.type === "struct") {
      const optionalAssetId = assetTxPayment.value.asset_id;
      if (optionalAssetId.type === "option") assetId = optionalAssetId.value.id;
    }
  }
  const extrinsicDecoder = getExtrinsicDecoder(lookup2.metadata, dynamicBuilder);
  const getMortalityFromTx = (tx) => {
    const decodedExt = extrinsicDecoder(tx);
    return "extra" in decodedExt && decodedExt.extra[CHECK_MORTALITY] || { mortal: false };
  };
  return {
    assetId,
    metadataRaw,
    codeHash,
    lookup: lookup2,
    dynamicBuilder,
    events: {
      key: events.keys.enc(),
      dec: events.value.dec
    },
    accountId: AccountId(dynamicBuilder.ss58Prefix),
    getMortalityFromTx,
    extVersions: metadata2.extrinsic.version
  };
};
var allBytesDec = Bytes(Infinity).dec;
var mortalDecoder = enhanceDecoder(u16[1], (input) => {
  const period = 2 << input % (1 << 4);
  const factor = Math.max(period >> 12, 1);
  const phase = (input >> 4) * factor;
  return { mortal: true, period, phase };
});
var mortalityDecoder = createDecoder((value2) => {
  const firstByte = u8.dec(value2);
  if (firstByte === 0) return { mortal: false };
  const secondByte = u8.dec(value2);
  return mortalDecoder(Uint8Array.from([firstByte, secondByte]));
});
var getExtrinsicDecoder = (metadata2, dynamicBuilder) => {
  const innerExtra = Object.fromEntries(
    metadata2.extrinsic.signedExtensions.map(
      (x) => [
        x.identifier,
        x.identifier === CHECK_MORTALITY ? mortalityDecoder : dynamicBuilder.buildDefinition(x.type)[1]
      ]
    )
  );
  let address;
  let signature;
  const { extrinsic: extrinsic2 } = metadata2;
  if ("address" in extrinsic2) {
    address = dynamicBuilder.buildDefinition(extrinsic2.address)[1];
    signature = dynamicBuilder.buildDefinition(extrinsic2.signature)[1];
  } else {
    const params2 = metadata2.lookup[extrinsic2.type]?.params;
    const _call = params2?.find((v) => v.name === "Call")?.type;
    const addr = params2?.find((v) => v.name === "Address")?.type;
    const sig = params2?.find((v) => v.name === "Signature")?.type;
    if (_call == null || addr == null || sig == null)
      throw new Error("Call, Address and/or signature not found");
    address = dynamicBuilder.buildDefinition(addr)[1];
    signature = dynamicBuilder.buildDefinition(sig)[1];
  }
  const v4Body = Struct2.dec({
    address,
    signature,
    extra: Struct2.dec(innerExtra),
    callData: allBytesDec
  });
  return createDecoder((data) => {
    const len = compactNumber.dec(data);
    const { type, version } = extrinsicFormat[1](data);
    if (type === "bare")
      return { len, version, type, callData: allBytesDec(data) };
    if (type === "signed") return { len, version, type, ...v4Body(data) };
    const extensionVersion = u8.dec(data);
    let extraDec;
    if (metadata2.version === 16) {
      const extensionsToApply = metadata2.extrinsic.signedExtensionsByVersion.find(
        ([x]) => x === extensionVersion
      );
      if (!extensionsToApply) throw new Error("Unexpected extension version");
      extraDec = Struct2.dec(
        Object.fromEntries(
          Object.entries(innerExtra).filter(
            (_, idx) => extensionsToApply[1].includes(idx)
          )
        )
      );
    } else extraDec = Struct2.dec(innerExtra);
    const extra = extraDec(data);
    return {
      len,
      type,
      version,
      extensionVersion,
      extra,
      callData: allBytesDec(data)
    };
  });
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/get-runtime-creator.mjs
var withRecovery = (getHash) => (fn) => {
  const result = (...args) => {
    let hash;
    try {
      hash = getHash();
    } catch (e) {
      return throwError(e);
    }
    return hash ? fn(hash, ...args).pipe(
      catchError((e) => {
        if (e instanceof BlockNotPinnedError) return result(...args);
        if (e instanceof Error && e.name === OperationInaccessibleError.errorName)
          return timer(750).pipe(mergeMap(() => result(...args)));
        throw e;
      })
    ) : EMPTY;
  };
  return result;
};
var getRuntimeCreator = (call$, getCachedMetadata, setCachedMetadata) => {
  const getMetadata$ = (codeHash, rawMetadata$) => getCachedMetadata(codeHash).pipe(
    catchError(() => of(null)),
    mergeMap(
      (metadataRaw) => metadataRaw ? of(metadataRaw) : rawMetadata$.pipe(
        tap((raw) => {
          setCachedMetadata(codeHash, raw);
        })
      )
    ),
    map((metadataRaw) => ({
      codeHash,
      metadataRaw,
      metadata: unifyMetadata(metadata.dec(metadataRaw))
    }))
  );
  return (codeHash, initialBlock) => {
    const usages = /* @__PURE__ */ new Set([initialBlock]);
    const done = {};
    const enhancer = withRecovery(() => {
      if (!usages.size) throw done;
      return usages.has(initialBlock) ? initialBlock : [...usages].at(-1);
    });
    const runtimeContext$ = getMetadata$(
      codeHash,
      getRawMetadata$(enhancer(call$)).pipe(
        catchError((err) => err === done ? EMPTY : throwError(() => err))
      )
    ).pipe(
      map(
        ({ metadata: metadata2, metadataRaw, codeHash: codeHash2 }) => createRuntimeCtx(metadata2, metadataRaw, codeHash2)
      ),
      shareReplay(1)
    );
    const result = {
      codeHash,
      runtime: runtimeContext$,
      addBlock: (block) => {
        usages.add(block);
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/shareLatest.mjs
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/pinned-blocks.mjs
var toBlockInfo = ({
  hash,
  number,
  parent,
  hasNewRuntime
}) => ({
  hash,
  number,
  parent,
  hasNewRuntime
});
var getPinnedBlocks$ = (follow$, call$, getCachedMetadata$, setCachedMetadata, blockUsage$, newBlocks$, onUnpin, deleteFromCache) => {
  const deleteBlocks = ({ blocks, runtimes }, toDelete) => {
    toDelete.forEach((blockHash) => {
      blocks.get(blocks.get(blockHash).parent)?.children.delete(blockHash);
      blocks.delete(blockHash);
      deleteFromCache(blockHash);
    });
    Object.entries(runtimes).map(([key, value2]) => ({
      key,
      usages: value2.deleteBlocks(toDelete)
    })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
      delete runtimes[unusedRuntime];
    });
  };
  const onNewBlock = (block) => {
    newBlocks$.next(toBlockInfo(block));
  };
  const setToReady = (acc) => {
    deleteBlocks(
      acc,
      [...acc.blocks.values()].filter((b) => b.recovering).map((b) => b.hash)
    );
    const pendingBlocks = "pendingBlocks" in acc.state ? acc.state.pendingBlocks : [];
    acc.state = { type: PinnedBlockState.Ready };
    pendingBlocks.forEach(onNewBlock);
  };
  const cleanup$ = new Subject();
  const cleanupEvt$ = cleanup$.pipe(
    exhaustMap(() => timer(0)),
    map(
      () => ({
        type: "cleanup"
      })
    )
  );
  const state3 = getInitialPinnedBlocks();
  const resetState = () => {
    deleteBlocks(
      state3,
      [...state3.blocks.values()].map((b) => b.hash)
    );
    return Object.assign(state3, getInitialPinnedBlocks());
  };
  const _pinnedBlocks$ = merge(
    blockUsage$,
    cleanupEvt$,
    follow$
  ).pipe(
    scan((acc, event) => {
      const unpinAndDelete = (toUnpin) => {
        deleteBlocks(acc, toUnpin);
        onUnpin(toUnpin);
      };
      const tryToUnpin = (...target) => {
        const finHeight = acc.blocks.get(acc.finalized)?.number ?? -1;
        const toRemove = target.filter(
          ({ refCount, recovering, number, pruned }) => !refCount && !recovering && (pruned || number < finHeight)
        ).map(({ hash }) => hash);
        toRemove.length && unpinAndDelete(toRemove);
      };
      switch (event.type) {
        case "initialized":
          if (acc.state.type !== PinnedBlockState.Initializing && acc.state.type !== PinnedBlockState.RecoveringInit)
            throw new Error("Initialized event out of order");
          if (acc.state.type === PinnedBlockState.RecoveringInit && !event.finalizedBlockHashes.some((hash) => acc.blocks.has(hash))) {
            resetState();
            newBlocks$.next(null);
          }
          const latestFinalizedHeight = acc.blocks.get(acc.finalized)?.number ?? -1;
          const lastIdx = event.finalizedBlockHashes.length - 1;
          const pendingBlocks = [];
          if (latestFinalizedHeight > event.number + lastIdx) {
            acc.state = {
              type: PinnedBlockState.RecoveringFin,
              target: latestFinalizedHeight,
              pendingBlocks
            };
          } else {
            acc.state = {
              type: PinnedBlockState.Initializing,
              pendingBlocks
            };
            acc.finalized = event.finalizedBlockHashes[lastIdx];
          }
          let latestRuntime = acc.finalizedRuntime.codeHash;
          event.finalizedBlockHashes.forEach((hash, i) => {
            const preexistingBlock = acc.blocks.get(hash);
            if (preexistingBlock) {
              preexistingBlock.recovering = false;
            } else {
              const number = event.number + i;
              const isNew = number > latestFinalizedHeight;
              const codeHash = event.runtimeChanges.get(hash);
              const requiresFromNewRuntime = codeHash && !acc.runtimes[codeHash] && isNew;
              if (requiresFromNewRuntime) latestRuntime = codeHash;
              const parent = i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1];
              const block = {
                hash,
                hasNewRuntime: i ? event.runtimeChanges.has(hash) : event.hasNewRuntime,
                parent,
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                pruned: false,
                runtime: latestRuntime,
                refCount: 0,
                number,
                recovering: false
              };
              acc.blocks.set(hash, block);
              if (requiresFromNewRuntime)
                acc.finalizedRuntime = acc.runtimes[codeHash] = getRuntime(
                  codeHash,
                  hash
                );
              acc.runtimes[latestRuntime].usages.add(hash);
              if (isNew) pendingBlocks.push(block);
            }
          });
          return acc;
        case "stop-error":
          if (acc.state.type === PinnedBlockState.Initializing)
            return resetState();
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.state = { type: PinnedBlockState.RecoveringInit };
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            const number = parentNode.number + 1;
            const block = {
              hash,
              number,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: parentNode.runtime,
              pruned: false,
              refCount: 0,
              recovering: false,
              hasNewRuntime: !!event.newRuntime
            };
            acc.blocks.set(hash, block);
            if (event.newRuntime) {
              const { codeHash } = event;
              block.runtime = codeHash;
              acc.runtimes[codeHash] = getRuntime(codeHash, hash);
            }
            acc.runtimes[block.runtime].addBlock(hash);
            if ("pendingBlocks" in acc.state)
              acc.state.pendingBlocks.push(block);
            else onNewBlock(block);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.state.type === PinnedBlockState.RecoveringFin) return acc;
          acc.best = event.bestBlockHash;
          if (acc.state.type === PinnedBlockState.Initializing) setToReady(acc);
          return acc;
        }
        case "finalized": {
          const finalized = event.finalizedBlockHashes.slice(-1)[0];
          let shouldBeSetToReady = false;
          if (acc.state.type === PinnedBlockState.RecoveringFin) {
            if (acc.blocks.get(finalized).number < acc.state.target) return acc;
            shouldBeSetToReady = true;
          }
          acc.finalized = finalized;
          const { blocks } = acc;
          if (blocks.get(acc.best).number < blocks.get(acc.finalized).number)
            acc.best = acc.finalized;
          acc.finalizedRuntime = acc.runtimes[blocks.get(acc.finalized).runtime];
          event.prunedBlockHashes.forEach((hash) => {
            const block = acc.blocks.get(hash);
            if (block) block.pruned = true;
          });
          if (shouldBeSetToReady) setToReady(acc);
          if (acc.state.type === PinnedBlockState.Ready) cleanup$.next();
          return acc;
        }
        case "cleanup": {
          tryToUnpin(...acc.blocks.values());
          return acc;
        }
        case "blockUsage": {
          const block = acc.blocks.get(event.value.hash);
          if (!block) return acc;
          block.refCount += event.value.type === "hold" ? 1 : -1;
          tryToUnpin(block);
          return acc;
        }
      }
    }, state3),
    map((x) => ({ ...x })),
    tap({
      error(e) {
        newBlocks$.error(e);
      }
    }),
    shareLatest
  );
  const pinnedBlocks$ = Object.assign(_pinnedBlocks$, { state: state3 });
  const getRuntime = getRuntimeCreator(
    withStopRecovery(pinnedBlocks$, call$, "pinned-blocks"),
    getCachedMetadata$,
    setCachedMetadata
  );
  return pinnedBlocks$;
};
var getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  state: { type: PinnedBlockState.Initializing, pendingBlocks: [] }
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/track-tx.mjs
var getTrackTx = (blocks$, newBlocks$, getBody, getIsValid, getEvents, hodl) => {
  const heldBlocks = /* @__PURE__ */ new Map();
  const release = (hash) => {
    heldBlocks.get(hash)?.();
    heldBlocks.delete(hash);
  };
  const hodl$ = new Observable((observer) => {
    const sub = newBlocks$.subscribe({
      next: ({ hash }) => {
        heldBlocks.set(hash, hodl(hash));
      },
      complete() {
        observer.error(new Error("Tracking stopped"));
      }
    });
    sub.add(
      blocks$.pipe(
        map((x) => x.finalized),
        distinctUntilChanged()
      ).subscribe(() => {
        blocks$.state.blocks.forEach(({ pruned, hash }) => {
          if (pruned) release(hash);
        });
      })
    );
    sub.add(() => [...heldBlocks.keys()].forEach(release));
    return sub;
  });
  const whileBlockActive = (hash) => takeUntil(
    blocks$.pipe(filter(({ blocks }) => blocks.get(hash)?.pruned ?? true))
  );
  const analyzeBlock = (hash, tx, alreadyPresent) => {
    if (alreadyPresent)
      return of({ hash, found: { type: false, validity: null } });
    const whilePresent = whileBlockActive(hash);
    return getBody(hash).pipe(
      mergeMap((txs) => {
        const index = txs.indexOf(tx);
        return index > -1 ? whilePresent(getEvents(hash)).pipe(
          map((events) => ({
            hash,
            found: {
              type: true,
              index,
              events
            }
          }))
        ) : getIsValid(hash, tx).pipe(
          map((validity) => ({
            hash,
            found: { type: false, validity }
          }))
        );
      }),
      whilePresent,
      finalize(() => release(hash))
    );
  };
  const releaseDescendants = (hash) => {
    const children = blocks$.state.blocks.get(hash)?.children.keys() ?? [];
    [...children].forEach(releaseDescendants);
    release(hash);
  };
  const findInBranch = (hash, tx, alreadyPresent) => analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(
    mergeMap((analyzed) => {
      const { found } = analyzed;
      const isSettled = found.type || found.validity?.success === false;
      if (isSettled) releaseDescendants(hash);
      return isSettled ? of(analyzed) : blocks$.pipe(
        whileBlockActive(hash),
        mergeMap((x) => x.blocks.get(hash).children),
        distinct(),
        mergeMap((hash2) => findInBranch(hash2, tx, alreadyPresent))
      );
    })
  );
  return (tx) => merge(
    hodl$,
    blocks$.pipe(
      take(1),
      mergeMap(
        (x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys()))
      )
    )
  );
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/validate-tx.mjs
var external = new Uint8Array([2]);
var getValidateTxArgs = (tx, hash) => toHex(mergeUint82([external, fromHex2(tx), fromHex2(hash)]));
var TaggedTransactionQueue = "TaggedTransactionQueue";
var validateTransaction = "validate_transaction";
var [, defaultInvalidTxDecoder] = Variant({
  InvalidTransaction: Variant({
    Call: _void,
    Payment: _void,
    Future: _void,
    Stale: _void,
    BadProof: _void,
    AncientBirthBlock: _void,
    ExhaustsResources: _void,
    Custom: u8,
    BadMandatory: _void,
    MandatoryValidation: _void,
    BadSigner: _void
  }),
  UnknownTransaction: Variant({
    CannotLookup: _void,
    NoUnsignedValidator: _void,
    Custom: u8
  })
});
var defaultValidateTxDecoder = createDecoder((input) => {
  const firstByte = u8.dec(input);
  if (firstByte > 1)
    throw new Error("Unable to decode validateTransaction result");
  if (!firstByte) return { success: true, value: void 0 };
  let value2;
  try {
    value2 = defaultInvalidTxDecoder(input);
  } catch (_) {
    value2 = {
      type: "UnknownInvalidTx"
    };
  }
  return { success: false, value: value2 };
});
var getValidateTx = (call$, getRuntimeContext) => (blockHash, tx) => {
  const decoder$ = getRuntimeContext(blockHash).pipe(
    map((ctx) => {
      try {
        return ctx.dynamicBuilder.buildRuntimeCall(
          TaggedTransactionQueue,
          validateTransaction
        ).value[1];
      } catch (_) {
        return defaultValidateTxDecoder;
      }
    })
  );
  return call$(
    blockHash,
    `${TaggedTransactionQueue}_${validateTransaction}`,
    getValidateTxArgs(tx, blockHash)
  ).pipe(
    withLatestFrom(decoder$),
    map(([result, decoder]) => decoder(result))
  );
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/with-default-value.mjs
var withDefaultValue = (defaultValue) => (source$) => new Observable((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited) observer.next(defaultValue);
  return subscription;
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/delay-unsubscription.mjs
var delayUnsubscription = (ms) => (source) => new Observable((observer) => {
  const subscription = source.subscribe({
    next(v) {
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  const unsubscribe = () => subscription.unsubscribe();
  return () => {
    Promise.resolve().then(unsubscribe);
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/concatMapEager.mjs
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    let isCompleted = false;
    let subscription = inner$.subscribe({
      next(x) {
        if (observerIdx === idx) {
          observer.next(x);
        } else {
          results.get(idx).push(x);
        }
      },
      complete() {
        isCompleted = true;
        innerSubscriptions.delete(idx);
        if (idx === observerIdx) {
          observerIdx++;
          while (results.has(observerIdx)) {
            results.get(observerIdx).forEach((x) => observer.next(x));
            results.delete(observerIdx);
            if (innerSubscriptions.has(observerIdx)) {
              break;
            }
            observerIdx++;
          }
        }
        nextSubscription();
      },
      error(e) {
        observer.error(e);
      }
    });
    if (!isCompleted) innerSubscriptions.set(idx, subscription);
  };
  topSubscription = new Subscription();
  topSubscription.add(
    source$.subscribe({
      next(outterValue) {
        const idx = mapperIdx++;
        queues.set(
          idx,
          defer(() => mapper(outterValue, idx))
        );
        if (innerSubscriptions.size < concurrent) {
          nextSubscription();
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (innerSubscriptions.size === 0) {
          observer.complete();
        }
      }
    })
  );
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/chainHead.mjs
var getChainHead$ = (chainHead2, getCachedMetadata, setCachedMetadata) => {
  const { withRecovery: withRecovery2, withRecoveryFn } = getWithRecovery();
  const { getFollower, unfollow, follow$, getHeader: getHeader2, hasher$ } = getFollow$(
    chainHead2,
    withRecoveryFn
  );
  const lazyFollower = withLazyFollower(getFollower);
  const blockUsage$ = new Subject();
  const usingBlock = (hash) => (base) => new Observable((observer) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    const subscription = base.subscribe(observer);
    subscription.add(() => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    });
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new Observable(
    (observer) => pinnedBlocks$.state.blocks.has(hash) ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label))
  );
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof Error && e.name === DisjointError.errorName) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => withInMemory(
    withRefcount(
      withStopRecovery(
        pinnedBlocks$,
        withRecoveryFn(fromAbortControllerFn(fn)),
        `stop-${label}`
      )
    ),
    label
  );
  const cache = /* @__PURE__ */ new Map();
  const _newBlocks$ = new Subject();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    getCachedMetadata,
    setCachedMetadata,
    blockUsage$,
    _newBlocks$,
    (blocks) => {
      unpin(blocks).catch((err) => {
        console.error("unpin", err);
      });
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withInMemory(
    withRefcount(
      (hash) => pinnedBlocks$.state.runtimes[pinnedBlocks$.state.blocks.get(hash).runtime].runtime
    ),
    "getRuntimeCtx"
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      share({
        connector: () => connector = new ReplaySubject()
      }),
      tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const readyBlocks$ = Object.assign(
    pinnedBlocks$.pipe(filter((x) => x.state.type === PinnedBlockState.Ready)),
    { state: pinnedBlocks$.state }
  );
  const finalized$ = readyBlocks$.pipe(
    distinctUntilChanged((a, b) => a.finalized === b.finalized),
    scan((acc, value2) => {
      let current = value2.blocks.get(value2.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value2.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    mergeAll(),
    map(toBlockInfo),
    shareLatest
  );
  const best$ = readyBlocks$.pipe(
    distinctUntilChanged((a, b) => a.best === b.best),
    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = readyBlocks$.pipe(
    distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = readyBlocks$.pipe(
    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map((x) => x?.lookup.metadata ?? null));
  const withOptionalHash$ = getWithOptionalHash$(
    finalized$.pipe(map((b) => b.hash)),
    best$.pipe(map((b) => b.hash)),
    usingBlock
  );
  const _body$ = commonEnhancer(lazyFollower("body"), "body");
  const body$ = (hash) => withOperationInaccessibleRetry(
    upsertCachedStream(hash, "body", _body$(hash))
  );
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    withInMemory(
      (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.state.runtimes[pinnedBlocks$.state.blocks.get(hash).runtime].runtime.pipe(
        mergeMap((ctx) => {
          const key = keyMapper(ctx);
          return upsertCachedStream(
            hash,
            `storage-${type}-${key}-${childTrie ?? ""}`,
            _storage$(hash, type, key, childTrie)
          ).pipe(mapper ? map((raw) => mapper(raw, ctx)) : identity);
        })
      ),
      "storage"
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery2);
  const storageQueries$ = withOptionalHash$(
    withInMemory(
      withStopRecovery(
        pinnedBlocks$,
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
        "storageQueries"
      ),
      "storageQueries"
    )
  );
  const header$ = withOptionalHash$(
    withInMemory(
      withStopRecovery(pinnedBlocks$, getHeader2, "header"),
      "header"
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, fn, args) => upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args))
  );
  const validateTx$ = getValidateTx(call$, getRuntimeContext$);
  const genesis$ = runtime$.pipe(
    filter(Boolean),
    take(1),
    mergeMap((runtime) => {
      const { enc: enc2 } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc2(0);
      } catch {
        key = enc2(0n);
      }
      return storage$(null, "value", () => key, null);
    }),
    shareReplay(1)
  );
  merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  const getRuntime$ = (codeHash) => pinnedBlocks$.state.runtimes[codeHash]?.runtime ?? of(null);
  const holdBlock = (blockHash, shouldThrow = false) => {
    let hash = blockHash || "finalized";
    hash = pinnedBlocks$.state[hash] || hash;
    if (!pinnedBlocks$.state.blocks.has(hash)) {
      if (shouldThrow) throw new BlockNotPinnedError(hash, "holdBlock");
      return noop3;
    }
    blockUsage$.next({
      type: "blockUsage",
      value: {
        type: "hold",
        hash
      }
    });
    let tearDown = () => {
      blockUsage$.next({
        type: "blockUsage",
        value: {
          type: "release",
          hash
        }
      });
      tearDown = noop3;
    };
    return () => {
      tearDown();
    };
  };
  const withHodl = (blockHash) => (base) => new Observable((observer) => {
    const subscription = base.subscribe(observer);
    if (!subscription.closed) subscription.add(holdBlock(blockHash));
    return subscription;
  });
  const newBlocks$ = _newBlocks$.pipe(takeWhile(Boolean));
  const trackTx$ = getTrackTx(
    readyBlocks$,
    newBlocks$,
    body$,
    validateTx$,
    eventsAt$,
    holdBlock
  );
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    newBlocks$,
    body$,
    validateTx$,
    () => of(),
    holdBlock
  );
  return {
    follow$,
    unfollow,
    finalized$,
    best$,
    bestBlocks$,
    newBlocks$: concat(
      readyBlocks$.pipe(
        take(1),
        mergeMap(({ blocks, finalized }) => {
          const blockAndChildren = (hash) => {
            const block = blocks.get(hash);
            return block ? [block, ...Array.from(block.children).flatMap(blockAndChildren)] : [];
          };
          return blockAndChildren(finalized);
        })
      ),
      newBlocks$
    ),
    runtime$,
    metadata$,
    genesis$,
    hasher$,
    getRuntime$,
    header$,
    body$,
    call$,
    storage$,
    storageQueries$,
    eventsAt$,
    withHodl,
    holdBlock,
    trackTx$,
    trackTxWithoutEvents$,
    validateTx$,
    pinnedBlocks$: readyBlocks$,
    withRuntime,
    getRuntimeContext$: withOptionalHash$(getRuntimeContext$)
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/tx.mjs
var getBroadcastTx$ = (baseTransaction) => (transaction2) => new Observable(
  (observer) => baseTransaction(transaction2, (e) => {
    observer.error(e);
  })
);

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/archive/archive.mjs
var getArchive2 = ({ storageSubscription, ...archive }) => (getRuntime) => {
  const runtimes = {};
  const rawStorage$ = fromAbortControllerFn(archive.storage);
  const call$ = fromAbortControllerFn(archive.call);
  const rawHeader$ = fromAbortControllerFn(archive.header);
  const body$ = fromAbortControllerFn(archive.body);
  const header$ = (blockHash) => rawHeader$(blockHash).pipe(map(blockHeader[1]));
  const getCodeHash = (blockHash) => (
    // ":code" => "0x3a636f6465"
    rawStorage$(blockHash, "hash", "0x3a636f6465", null).pipe(map((x) => x))
  );
  const getRuntime$ = (codeHash, blockHash) => getRuntime(codeHash).pipe(
    catchError(() => of(null)),
    mergeMap(
      (result) => result ? of(result) : getRawMetadata$((...args) => call$(blockHash, ...args)).pipe(
        map(
          (rawMetadata) => createRuntimeCtx(
            unifyMetadata(metadata.dec(rawMetadata)),
            rawMetadata,
            codeHash
          )
        )
      )
    ),
    tap((runtime) => {
      runtimes[codeHash] = runtime;
    })
  );
  const getRuntimeContext$ = (blockHash) => getCodeHash(blockHash).pipe(
    mergeMap((codeHash) => {
      const runtime = runtimes[codeHash];
      return runtime ? of(runtime) : getRuntime$(codeHash, blockHash);
    })
  );
  const storage$ = (hash, type, keyMapper, childTrie = null, mapper) => getRuntimeContext$(hash).pipe(
    mergeMap(
      (ctx) => rawStorage$(hash, type, keyMapper(ctx), childTrie).pipe(
        map((x) => mapper ? mapper(x, ctx) : x)
      )
    )
  );
  const storageQueries$ = (hash, queries, childTrie) => new Observable(
    (observer) => storageSubscription(
      hash,
      queries,
      childTrie || null,
      (item) => observer.next(item),
      (error) => observer.error(error),
      () => {
        observer.complete();
      }
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  return {
    body$,
    header$,
    storage$,
    storageQueries$,
    call$,
    eventsAt$,
    getRuntimeContext$
  };
};

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/getObservableClient.mjs
var ofNullFn = () => of(null);
var getObservableClient = (substrateClient, {
  getMetadata: getMetadata2,
  setMetadata
} = {}) => ({
  chainHead$: () => getChainHead$(
    substrateClient.chainHead,
    getMetadata2 || ofNullFn,
    setMetadata || noop3
  ),
  archive: getArchive2(substrateClient.archive),
  broadcastTx$: getBroadcastTx$(substrateClient.transaction),
  destroy: substrateClient.destroy
});

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/chainHead/streams/block-operations.mjs
var isBestOrFinalizedBlock = (blocks$, blockHash) => blocks$.pipe(
  takeWhile((b) => b.blocks.has(blockHash)),
  distinctUntilChanged(
    (a, b) => a.finalized === b.finalized && a.best === b.best
  ),
  map((pinned) => {
    if (pinned.blocks.get(blockHash).number > pinned.blocks.get(pinned.best).number)
      return null;
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized = isFinalized || pinned.finalized === current.hash;
    }
    if (isFinalized) return "finalized";
    return current.hash === blockHash ? "best" : null;
  }),
  distinctUntilChanged(),
  takeWhile((x) => x !== "finalized", true)
);

// node_modules/.pnpm/@polkadot-api+observable-client@0.17.2_rxjs@7.8.2/node_modules/@polkadot-api/observable-client/dist/esm/utils/with-archive.mjs
var withArchive = (chainHeadFn, archiveFn) => (blokHash, ...args) => chainHeadFn(blokHash, ...args).pipe(
  catchError((e) => {
    if (!(e instanceof BlockNotPinnedError)) throw e;
    return archiveFn(blokHash, ...args).pipe(
      catchError((actualErr) => {
        console.warn(actualErr);
        throw e;
      })
    );
  })
);

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/compatibility.mjs
var RuntimeToken = class {
  constructor() {
  }
  // @ts-ignore
  _runtime(value2) {
  }
};
var CompatibilityToken = class {
  constructor() {
  }
  // @ts-ignore
  _compatibility(value2) {
  }
};
var compatibilityTokenApi = /* @__PURE__ */ new WeakMap();
var runtimeTokenApi = /* @__PURE__ */ new WeakMap();
var getCompatibilityApi = (token) => token instanceof RuntimeToken ? runtimeTokenApi.get(token) : compatibilityTokenApi.get(token);
var OpType = /* @__PURE__ */ ((OpType2) => {
  OpType2["Storage"] = "storage";
  OpType2["Tx"] = "tx";
  OpType2["Event"] = "events";
  OpType2["Const"] = "constants";
  OpType2["ViewFns"] = "viewFns";
  OpType2["Api"] = "apis";
  return OpType2;
})(OpType || {});
var EntryPointsCodec = Vector2(EntryPointCodec);
var TypedefsCodec = Vector2(TypedefCodec);
var TypesCodec = Tuple2(EntryPointsCodec, TypedefsCodec);
var createCompatibilityToken = (chainDefinition, chainHead2) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead2.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = Promise.all([
    chainDefinition.metadataTypes.then(TypesCodec.dec),
    chainDefinition.descriptors,
    awaitedRuntime
  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {
    const token = new CompatibilityToken();
    compatibilityTokenApi.set(token, {
      runtime,
      getEntryPoint(opType, pallet, name) {
        const idx = descriptors[opType]?.[pallet]?.[name];
        if (idx == null)
          throw new Error(
            `Descriptor for ${opType} ${pallet}.${name} does not exist`
          );
        return entryPoints[idx];
      },
      typedefNodes
    });
    return token;
  });
  return promise;
};
var createRuntimeToken = (chainHead2) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead2.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = awaitedRuntime.then((runtime) => {
    const token = new RuntimeToken();
    runtimeTokenApi.set(token, {
      runtime
    });
    return token;
  });
  return promise;
};
var metadataCache = /* @__PURE__ */ new WeakMap();
var getMetadataCache = (ctx) => {
  if (!metadataCache.has(ctx.metadataRaw)) {
    metadataCache.set(ctx.metadataRaw, {
      compat: /* @__PURE__ */ new Map(),
      lookup: ctx.lookup,
      typeNodes: []
    });
  }
  return metadataCache.get(ctx.metadataRaw);
};
var compatibilityHelper = (descriptors, getDescriptorEntryPoint, getRuntimeEntryPoint) => {
  const getRuntimeTypedef = (ctx, id) => {
    var _a;
    const cache = getMetadataCache(ctx);
    return (_a = cache.typeNodes)[id] || (_a[id] = mapLookupToTypedef(cache.lookup(id)));
  };
  function getCompatibilityLevels(descriptors2, ctx) {
    if (descriptors2 instanceof RuntimeToken) {
      return {
        args: CompatibilityLevel.Identical,
        values: CompatibilityLevel.Identical
      };
    }
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    ctx || (ctx = compatibilityApi.runtime());
    const runtimeEntryPoint = getRuntimeEntryPoint(ctx);
    if (runtimeEntryPoint == null)
      return {
        args: CompatibilityLevel.Incompatible,
        values: CompatibilityLevel.Incompatible
      };
    const descriptorNodes = compatibilityApi.typedefNodes;
    const cache = getMetadataCache(ctx);
    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi);
    const result = entryPointsAreCompatible(
      descriptorEntryPoint,
      (id) => descriptorNodes[id],
      runtimeEntryPoint,
      (id) => getRuntimeTypedef(ctx, id),
      cache.compat
    );
    return {
      args: result.args.level,
      values: result.values.level
    };
  }
  const getCompatibilityLevel = withOptionalToken(
    descriptors,
    (runtime) => minCompatLevel(getCompatibilityLevels(runtime))
  );
  const isCompatible2 = withOptionalToken(
    descriptors,
    (threshold, runtime) => getCompatibilityLevel(runtime) >= threshold
  );
  const compatibleRuntime$ = (chainHead2, hash) => combineLatest([descriptors, chainHead2.getRuntimeContext$(hash)]);
  const withCompatibleRuntime = (chainHead2, mapper) => (source$) => combineLatest([
    source$.pipe(chainHead2.withRuntime(mapper)),
    descriptors
  ]).pipe(map(([[x, ctx], descriptors2]) => [x, descriptors2, ctx]));
  const argsAreCompatible = (descriptors2, ctx, args) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const levels = getCompatibilityLevels(descriptors2, ctx);
    if (levels.args === CompatibilityLevel.Incompatible) return false;
    if (levels.args > CompatibilityLevel.Partial) return true;
    if (levels.values === CompatibilityLevel.Incompatible) return false;
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    return valueIsCompatibleWithDest(
      entryPoint.args,
      (id) => getRuntimeTypedef(ctx, id),
      args
    );
  };
  const valuesAreCompatible = (descriptors2, ctx, values) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const level = getCompatibilityLevels(descriptors2, ctx).values;
    if (level === CompatibilityLevel.Incompatible) return false;
    if (level > CompatibilityLevel.Partial) return true;
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    const entryPoint = getDescriptorEntryPoint(compatibilityApi);
    return valueIsCompatibleWithDest(
      entryPoint.values,
      (id) => compatibilityApi.typedefNodes[id],
      values
    );
  };
  const storageKeysAreCompatible = (ctx, keys, nKeysDest) => {
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    const getNode = (id) => getRuntimeTypedef(ctx, id);
    const destNode = entryPoint.args.type === "lookup" ? getNode(entryPoint.args.value) : entryPoint.args.value;
    return isStorageKeyCompatible(keys, nKeysDest, destNode, getNode);
  };
  return {
    isCompatible: isCompatible2,
    getCompatibilityLevel,
    getCompatibilityLevels,
    descriptors,
    withCompatibleRuntime,
    compatibleRuntime$,
    argsAreCompatible,
    valuesAreCompatible,
    getRuntimeTypedef,
    storageKeysAreCompatible
  };
};
var minCompatLevel = (levels) => Math.min(levels.args, levels.values);
var withOptionalToken = (compatibilityToken, fn) => (...args) => {
  const lastElement = args.at(-1);
  if (lastElement instanceof CompatibilityToken || lastElement instanceof RuntimeToken) {
    return fn(...args);
  }
  return compatibilityToken.then((token) => fn(...args, token));
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/constants.mjs
var createConstantEntry = (palletName, name, {
  valuesAreCompatible,
  descriptors,
  isCompatible: isCompatible2,
  getCompatibilityLevel
}) => {
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.lookup.metadata.pallets.find(
      (p) => p.name === palletName
    );
    const constant = pallet?.constants.find((c) => c.name === name);
    if (constant == null)
      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (token) => {
    if (token) {
      const ctx = getCompatibilityApi(token).runtime();
      const value2 = getValueWithContext(ctx);
      if (!valuesAreCompatible(token, ctx, value2))
        throw new Error(
          `Incompatible runtime entry Constant(${palletName}.${name})`
        );
      return value2;
    }
    return descriptors.then(fn);
  };
  return Object.assign(fn, { isCompatible: isCompatible2, getCompatibilityLevel });
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/shareLatest.mjs
var shareLatest2 = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/event.mjs
var createEventEntry = (pallet, name, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  withCompatibleRuntime,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead2.finalized$.pipe(
    withCompatibleRuntime(chainHead2, (x) => x.hash),
    map(([block, runtime, ctx]) => {
      const eventsIdx = ctx.lookup.metadata.pallets.find(
        (p) => p.name === pallet
      )?.events?.type;
      if (eventsIdx == null || ctx.lookup.metadata.lookup[eventsIdx].def.tag !== "variant" || ctx.lookup.metadata.lookup[eventsIdx].def.value.find(
        (ev) => ev.name === name
      ) == null)
        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`);
      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError();
      return [block, runtime, ctx];
    }),
    concatMapEager(
      ([block, runtime, ctx]) => chainHead2.eventsAt$(block.hash).pipe(
        map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))
              throw compatibilityError();
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest2
  );
  const watch = (f) => shared$.pipe(mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom(shared$);
  const filter2 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter2, getCompatibilityLevel, isCompatible: isCompatible2 };
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/firstValueFromWithSignal.mjs
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription?.unsubscribe();
      reject(new AbortError());
    } : noop3;
    subscription = source.subscribe({
      next: (value2) => {
        resolve(value2);
        subscription?.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e);
        isDone = true;
      },
      complete: () => {
        signal?.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
        isDone = true;
      }
    });
    if (!isDone) signal?.addEventListener("abort", onAbort);
  });
}

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/optional-arg.mjs
var isOptionalArg = (lastArg) => typeof lastArg === "object" && lastArg !== null && Object.entries(lastArg).every(
  ([k, v]) => k === "at" && (v === void 0 || typeof v === "string") || k === "signal" && (v === void 0 || v instanceof AbortSignal)
);

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/runtime-call.mjs
var createRuntimeCallEntry = (api, method, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const callName = `${api}_${method}`;
  const compatibilityError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead2, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let codecs;
        try {
          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        } catch {
          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        return chainHead2.call$(at, callName, toHex(codecs.args.enc(args))).pipe(
          map(codecs.value.dec),
          map((value2) => {
            if (!valuesAreCompatible(runtime, ctx, value2))
              throw compatibilityError();
            return value2;
          })
        );
      }),
      chainHead2.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible: isCompatible2 });
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/lossLessExhaustMap.mjs
var EMPTY_VALUE = /* @__PURE__ */ Symbol("EMPTY_VALUE");
var lossLessExhaustMap = (mapper) => (source$) => new Observable((observer) => {
  let idx = 0;
  let innerSubscription = null;
  let queuedValue = EMPTY_VALUE;
  let isOutterDone = false;
  const setInnerSubscription = () => {
    const observable2 = mapper(queuedValue, idx++);
    queuedValue = EMPTY_VALUE;
    innerSubscription = observable2.subscribe({
      next(vv) {
        observer.next(vv);
      },
      error(ee) {
        observer.error(ee);
      },
      complete() {
        if (queuedValue !== EMPTY_VALUE) setInnerSubscription();
        else {
          innerSubscription = null;
          if (isOutterDone) observer.complete();
        }
      }
    });
  };
  const subscription = source$.subscribe({
    next(v) {
      queuedValue = v;
      if (!innerSubscription) setInnerSubscription();
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (!innerSubscription) observer.complete();
      isOutterDone = true;
    }
  });
  return () => {
    innerSubscription?.unsubscribe();
    subscription.unsubscribe();
  };
});

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/storage.mjs
var toMapped = map((x) => x.mapped);
var createStorageEntry = (pallet, name, chainHead2, getWatchEntries, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  storageKeysAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead2.runtime$.pipe(
    filter(Boolean),
    take(1),
    map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : identity
    ),
    shareReplay()
  );
  const bigIntOrNumber = pipe(
    combineLatestWith(sysNumberMapper$),
    map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead2[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead2.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!storageKeysAreCompatible(ctx, actualArgs, codecs.len))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const mapped = data === null ? codecs.fallback : codecs.value.dec(data);
            if (data !== null && !valuesAreCompatible(descriptors, ctx, mapped))
              throw incompatibleError();
            return { raw: data, mapped };
          }
        )
      ),
      chainHead2.withHodl(at)
    );
    if (isSystemNumber)
      return chainHead2.pinnedBlocks$.pipe(
        map((blocks) => {
          const hash = at === "finalized" || !at ? blocks.finalized : at === "best" ? blocks.best : at;
          const block = blocks.blocks.get(hash);
          if (!block) {
            throw new BlockNotPinnedError(hash, "System.Number");
          }
          return block.number;
        }),
        distinctUntilChanged(),
        bigIntOrNumber,
        map((mapped) => ({ raw: mapped.toString(), mapped })),
        catchError((e) => {
          if (e instanceof BlockNotPinnedError) return result$;
          throw e;
        })
      );
    return isBlockHash && Number(args[0]) === 0 ? chainHead2.genesis$.pipe(
      map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) }))
    ) : result$;
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead2.storage$(
          at,
          "descendantsValues",
          (ctx) => {
            const codecs = getCodec(ctx);
            if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === CompatibilityLevel.Incompatible)
              throw incompatibleError();
            if (args.length > codecs.len) throw invalidArgs(args);
            const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
            if (args.length === codecs.len && actualArgs === args)
              throw invalidArgs(args);
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (values, ctx) => {
            const codecs = getCodec(ctx);
            const decodedValues = values.map(({ key, value: value2 }) => ({
              keyArgs: codecs.keys.dec(key),
              value: codecs.value.dec(value2)
            }));
            if (decodedValues.some(
              ({ value: value2 }) => !valuesAreCompatible(descriptors, ctx, value2)
            ))
              throw incompatibleError();
            return decodedValues;
          }
        )
      ),
      chainHead2.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  const getKey = (...args) => {
    const token = args.at(-1);
    if (token instanceof CompatibilityToken || token instanceof RuntimeToken) {
      const actualArgs = args.slice(0, -1);
      const ctx = getCompatibilityApi(token).runtime();
      if (!argsAreCompatible(token, ctx, actualArgs)) throw incompatibleError();
      return getCodec(ctx).keys.enc(...actualArgs);
    }
    return descriptorsPromise.then((x) => getKey(...args, x));
  };
  return {
    isCompatible: isCompatible2,
    getCompatibilityLevel,
    getKey,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

// node_modules/.pnpm/@polkadot-api+signers-common@0.1.19/node_modules/@polkadot-api/signers-common/dist/esm/v4.mjs
var unkownSignerType = () => new Error("Unkown signer");
var getSignerType = (metadata2) => {
  const { extrinsic: extrinsic2 } = metadata2;
  const getLookup = getLookupFn(metadata2);
  let address;
  let signature;
  if ("address" in extrinsic2) {
    address = getLookup(extrinsic2.address);
    signature = getLookup(extrinsic2.signature);
  } else {
    const extProps = Object.fromEntries(
      metadata2.lookup[extrinsic2.type].params.filter((x) => x.type != null).map((x) => [x.name, getLookup(x.type)])
    );
    address = extProps["Address"];
    signature = extProps["Signature"];
    if (!address || !signature) throw unkownSignerType();
  }
  if (address.type === "AccountId20" && signature.type === "array" && signature.len === 65 && signature.value.type === "primitive" && signature.value.value === "u8")
    return [1, []];
  if (signature.type !== "enum" || ["Ecdsa", "Ed25519", "Sr25519"].some((x) => !(x in signature.value)))
    throw unkownSignerType();
  if (address.type === "enum") {
    const id = address.value["Id"];
    if (id.type === "lookupEntry" && id.value.type === "AccountId32")
      return [0, [id.idx]];
  } else if (address.type === "AccountId32") return [0, []];
  throw unkownSignerType();
};
var signingTypeId = {
  Ed25519: 0,
  Sr25519: 1,
  Ecdsa: 2
};
var createV4Tx = (metadata2, publicKey, signed, extra, callData, signingType) => {
  const [signerType, addressPrefix] = getSignerType(metadata2);
  const preResult = mergeUint82([
    extrinsicFormat.enc({ version: 4, type: "signed" }),
    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
    signerType === 1 ? publicKey : new Uint8Array([...addressPrefix, ...publicKey]),
    signerType === 1 || !signingType ? signed : new Uint8Array([signingTypeId[signingType], ...signed]),
    ...extra,
    callData
  ]);
  return mergeUint82([compact.enc(preResult.length), preResult]);
};

// node_modules/.pnpm/@polkadot-api+signers-common@0.1.19/node_modules/@polkadot-api/signers-common/dist/esm/sign-bytes.mjs
var [preBytes, postBytes] = ["<Bytes>", "</Bytes>"].map(
  (str2) => Binary.fromText(str2).asBytes()
);
var getSignBytes = (sign) => async (data) => {
  let isPadded = true;
  let i;
  for (i = 0; isPadded && i < preBytes.length; i++)
    isPadded = preBytes[i] === data[i];
  isPadded = isPadded && i === preBytes.length;
  const postDataStart = data.length - postBytes.length;
  for (i = 0; isPadded && i < postBytes.length; i++)
    isPadded = postBytes[i] === data[postDataStart + i];
  isPadded = isPadded && i === postBytes.length;
  return sign(isPadded ? data : mergeUint82([preBytes, data, postBytes]));
};

// node_modules/.pnpm/@polkadot-api+signer@0.2.12/node_modules/@polkadot-api/signer/dist/esm/from-raw-signer.mjs
function getPolkadotSigner(publicKey, signingType, sign) {
  const signTx = async (callData, signedExtensions, metadata2, _, hasher = Blake2256) => {
    const decMeta = unifyMetadata(decAnyMetadata(metadata2));
    const extra = [];
    const additionalSigned2 = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed extension`);
      extra.push(signedExtension.value);
      additionalSigned2.push(signedExtension.additionalSigned);
    });
    const toSign = mergeUint82([callData, ...extra, ...additionalSigned2]);
    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign);
    return createV4Tx(decMeta, publicKey, signed, extra, callData, signingType);
  };
  return {
    publicKey,
    signTx,
    signBytes: getSignBytes(sign)
  };
}
var oneU8 = Uint8Array.from([1]);

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/system-version.mjs
var getSystemVersionStruct = (lookupFn, dynamicBuilder) => {
  const constant = lookupFn.metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct") throw new Error("not a struct");
  return systemVersionDec(constant.value);
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/mortal-enc.mjs
function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
var nextPower = (n) => 1 << Math.ceil(Math.log2(n));
var mortal = enhanceEncoder(
  Bytes(2)[0],
  (value2) => {
    const period = Math.min(Math.max(nextPower(value2.period), 4), 1 << 16);
    const phase = value2.startAtBlock % period;
    const factor = Math.max(period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(period) - 1, 1), 15);
    const right = phase / factor << 4;
    return u16[0](left | right);
  }
);

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/charge-asset-tx-enc.mjs
var [ChargeAssetTxPaymentEnc] = Struct2({
  tip: compact,
  asset: Option2(Bytes(Infinity))
});

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/signed-extensions/sign-extensions.mjs
var empty2 = new Uint8Array();
var zero = Uint8Array.from([0]);
var value = (value2) => ({
  value: value2,
  additionalSigned: empty2
});
var additionalSigned = (additionalSigned2) => ({
  value: empty2,
  additionalSigned: additionalSigned2
});
var both = (value2, additionalSigned2) => ({
  value: value2,
  additionalSigned: additionalSigned2
});
var getSignExtensionsCreator = (genesis2, lookupFn, dynamicBuilder) => {
  const signedExtensionsEncoders = {};
  lookupFn.metadata.extrinsic.signedExtensions.forEach(
    ({ identifier, type, additionalSigned: additionalSigned2 }) => {
      signedExtensionsEncoders[identifier] = [type, additionalSigned2].map(
        (x) => dynamicBuilder.buildDefinition(x)[0]
      );
    }
  );
  return ({
    mortality,
    tip = 0n,
    nonce,
    customSignedExtensions = {},
    ...rest
  }) => {
    const invalidKeys = [];
    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder);
    const getFromCustomEntry = (key) => {
      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key];
      const customEntry = customSignedExtensions[key];
      try {
        return mapObject2(
          {
            value: valueEnc,
            additionalSigned: additionalEnc
          },
          (encoder, key2) => {
            const input = customEntry?.[key2];
            return input instanceof Uint8Array ? input : encoder(input);
          }
        );
      } catch {
        if (customEntry) throw new Error(`Wrong input received for ${key}`);
        invalidKeys.push(key);
        return null;
      }
    };
    const result = mapObject2(
      signedExtensionsEncoders,
      ([valueEnc, additionalEnc], key) => {
        if (customSignedExtensions[key]) return getFromCustomEntry(key);
        switch (key) {
          case "CheckNonce":
            return value(valueEnc(nonce));
          case "CheckMortality":
            return mortality.mortal ? both(
              mortal({
                period: mortality.period,
                startAtBlock: mortality.startAtBlock.height
              }),
              fromHex2(mortality.startAtBlock.hash)
            ) : both(zero, genesis2);
          case "ChargeTransactionPayment":
            return value(valueEnc(tip));
          case "ChargeAssetTxPayment":
            return value(
              ChargeAssetTxPaymentEnc({
                tip,
                asset: rest.asset
              })
            );
          case "CheckGenesis":
            return additionalSigned(genesis2);
          case "CheckMetadataHash":
            return both(zero, zero);
          case "CheckSpecVersion":
            return additionalSigned(
              additionalEnc(systemVersion["spec_version"])
            );
          case "CheckTxVersion":
            return additionalSigned(
              additionalEnc(systemVersion["transaction_version"])
            );
          default:
            return getFromCustomEntry(key);
        }
      }
    );
    invalidKeys.forEach((key) => {
      delete result[key];
    });
    return mapObject2(result, (x, identifier) => ({ ...x, identifier }));
  };
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/create-tx.mjs
var NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
var lenToDecoder = {
  1: u8.dec,
  2: u16.dec,
  4: u32.dec,
  8: u64.dec
};
var getNonceAtBlock$ = (call$, from2, at) => call$(at, NONCE_RUNTIME_CALL, from2).pipe(
  map((result) => {
    const bytes = fromHex2(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return decoder(bytes);
  })
);
var createTx = (chainHead2, signer, callData, atBlock, customSignedExtensions, hinted = {}) => combineLatest([
  hinted.nonce ? of(hinted.nonce) : getNonce$(chainHead2, toHex(signer.publicKey)),
  chainHead2.getRuntimeContext$(atBlock.hash),
  chainHead2.genesis$
]).pipe(
  take(1),
  mergeMap(([nonce, ctx, genesis2]) => {
    const signExtCreator = getSignExtensionsCreator(
      fromHex2(genesis2),
      ctx.lookup,
      ctx.dynamicBuilder
    );
    const mortality = hinted.mortality ?? { period: 64, mortal: true };
    const signExtensions = signExtCreator({
      nonce,
      tip: hinted.tip ?? 0n,
      mortality: mortality.mortal ? {
        mortal: true,
        period: mortality.period,
        startAtBlock: {
          height: atBlock.number,
          hash: atBlock.hash
        }
      } : { mortal: false },
      customSignedExtensions,
      asset: hinted.asset
    });
    return signer.signTx(
      callData,
      signExtensions,
      ctx.metadataRaw,
      atBlock.number
    );
  })
);
var getNonce$ = (chainHead2, from2) => {
  const followHead$ = (head) => chainHead2.newBlocks$.pipe(
    scan((acc, block) => block.parent === acc ? block.hash : acc, head),
    startWith(head),
    distinctUntilChanged()
  );
  const followNonce$ = (head) => followHead$(head).pipe(
    take(2),
    switchMap((hash) => getNonceAtBlock$(chainHead2.call$, from2, hash))
  );
  const getHeadsNonce$ = (heads) => combineLatest(
    heads.map(
      (head) => followNonce$(head).pipe(
        map((value2) => ({
          success: true,
          value: value2
        })),
        catchError(
          (err) => of({
            success: false,
            value: err
          })
        )
      )
    )
  ).pipe(take(1));
  return chainHead2.pinnedBlocks$.pipe(
    take(1),
    map(({ blocks, best }) => {
      const bestBlock = blocks.get(best);
      return [...blocks.values()].filter(
        (v) => !v.pruned && v.children.size === 0 && v.number >= bestBlock.number
      ).map((v) => v.hash);
    }),
    switchMap(getHeadsNonce$),
    map((result) => {
      const winner = result.reduce(
        (acc, v) => v.success ? v.value >= (acc ?? 0) ? v.value : acc : acc,
        null
      );
      if (winner == null) {
        throw result[0].value;
      }
      return winner;
    })
  );
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/continue-with.mjs
var NOTIN = {};
var continueWith = (mapper) => (source) => new Observable((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN) observer.complete();
      else subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/submit-fns.mjs
var __defProp8 = Object.defineProperty;
var __defNormalProp7 = (obj, key, value2) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField7 = (obj, key, value2) => __defNormalProp7(obj, key + "", value2);
var computeState = (analized$, blocks$) => new Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    let analyzedNumber = pinnedBlocks.blocks.get(current).number;
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block) break;
      analyzed = analyzedBlocks.get(current = block.parent);
      analyzedNumber--;
    }
    if (!analyzed) return;
    const isFinalized = analyzedNumber <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && latestState?.found && latestState.hash === analyzed.hash) {
      if (isFinalized) observer.complete();
      return;
    }
    observer.next(
      latestState = analyzed.found.type ? {
        found,
        hash: analyzed.hash,
        number: analyzedNumber,
        index: analyzed.found.index,
        events: analyzed.found.events
      } : {
        found,
        validity: analyzed.found.validity
      }
    );
    if (isFinalized) {
      if (found) observer.complete();
      else if (analyzed.found.validity?.success === false)
        observer.error(new InvalidTxError(analyzed.found.validity.value));
    }
  };
  const subscription = blocks$.pipe(
    distinctUntilChanged(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0) return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(distinctUntilChanged((a, b) => a === b));
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => ({ ...x.event, topics: x.topics }));
  const lastEvent = events[events.length - 1];
  if (lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicFailed") {
    return {
      ok: false,
      events,
      dispatchError: lastEvent.value.value.dispatch_error
    };
  }
  return { ok: true, events };
};
var InvalidTxError = class extends Error {
  // likely to be a `TransactionValidityError`
  constructor(e) {
    super(
      JSON.stringify(
        e,
        (_, value2) => {
          if (typeof value2 === "bigint") return value2.toString();
          return value2 instanceof Binary ? value2.asHex() : value2;
        },
        2
      )
    );
    __publicField7(this, "error");
    this.name = "InvalidTxError";
    this.error = e;
  }
};
var submit$ = (chainHead2, broadcastTx$, tx, emitSign = false) => chainHead2.hasher$.pipe(
  mergeMap((hasher) => {
    const txHash = toHex(hasher(fromHex2(tx)));
    const getTxEvent = (type, rest) => ({
      type,
      txHash,
      ...rest
    });
    const pinnedBlocks = chainHead2.pinnedBlocks$.state;
    const getHeightFromMortality = (mortality) => {
      if (!mortality.mortal) return 0;
      const { phase, period } = mortality;
      const topNumber = pinnedBlocks.blocks.get(pinnedBlocks.best).number;
      return Math.floor((Math.max(topNumber, phase) - phase) / period) * period + phase;
    };
    const getTipsFromHeight = (height) => {
      let tips = [...pinnedBlocks.blocks.values()].filter(
        (block) => !block.pruned && !block.children.size
      );
      const higherTip = Math.max(...tips.map(({ number }) => number));
      tips = tips.filter(({ number }) => number >= higherTip - 1);
      const finalized = pinnedBlocks.blocks.get(pinnedBlocks.finalized);
      tips = finalized.children ? [finalized, ...tips] : tips;
      return tips.filter((x) => x.number >= height);
    };
    const validateTxAt$ = ({ hash }) => chainHead2.validateTx$(hash, tx);
    const validate$ = defer(
      () => pinnedBlocks.finalizedRuntime.runtime.pipe(
        map((r) => r.getMortalityFromTx(tx)),
        map(getHeightFromMortality),
        map(getTipsFromHeight),
        mergeMap((blocksToValidate) => {
          let err;
          return merge(
            ...blocksToValidate.map(
              (b) => race(
                validateTxAt$(b),
                chainHead2.finalized$.pipe(
                  takeWhile((finalized) => {
                    if (finalized.number < b.number) return true;
                    let curr = finalized;
                    while (curr.number > b.number) {
                      const parent = pinnedBlocks.blocks.get(curr.parent);
                      if (!parent) return false;
                      curr = parent;
                    }
                    return curr.hash === finalized.hash;
                  }),
                  ignoreElements(),
                  endWith({ success: null })
                )
              )
            )
          ).pipe(
            filter((v, idx) => {
              if (v.success === false) err ?? (err = new InvalidTxError(v.value));
              if (v.success) return true;
              if (idx === blocksToValidate.length - 1 && err) throw err;
              return false;
            }),
            take(1)
          );
        }),
        ignoreElements()
      )
    );
    const track$ = new Observable((observer) => {
      const subscription = chainHead2.trackTx$(tx).subscribe(observer);
      subscription.add(
        broadcastTx$(tx).subscribe({
          error(e) {
            observer.error(e);
          }
        })
      );
      return subscription;
    });
    const bestBlockState$ = computeState(
      track$,
      chainHead2.pinnedBlocks$
    ).pipe(
      map((x) => {
        if (!x.found)
          return getTxEvent("txBestBlocksState", {
            found: false,
            isValid: x.validity?.success !== false
          });
        return getTxEvent("txBestBlocksState", {
          found: true,
          block: {
            index: x.index,
            number: x.number,
            hash: x.hash
          },
          ...getTxSuccessFromSystemEvents(x.events, x.index)
        });
      })
    );
    return concat(
      emitSign ? of(getTxEvent("signed", {})) : EMPTY,
      validate$,
      of(getTxEvent("broadcasted", {})),
      bestBlockState$.pipe(
        continueWith(
          ({ found, type, ...rest }) => found ? of(getTxEvent("finalized", rest)) : EMPTY
        )
      )
    );
  })
);
var submit = async (chainHead2, broadcastTx$, transaction2, _at) => lastValueFrom(submit$(chainHead2, broadcastTx$, transaction2)).then((x) => {
  if (x.type !== "finalized") throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/tx/tx.mjs
var accountIdEnc = AccountId().enc;
var fakeSignature = new Uint8Array(64);
var fakeSignatureEth = new Uint8Array(65);
var getFakeSignature = (isEth) => () => isEth ? fakeSignatureEth : fakeSignature;
var [, queryInfoDecFallback] = Struct2({
  weight: Struct2({
    ref_time: compactBn,
    proof_size: compactBn
  }),
  class: Variant({
    Normal: _void,
    Operational: _void,
    Mandatory: _void
  }),
  partial_fee: u128
});
var createTxEntry = (pallet, name, chainHead2, broadcast, {
  isCompatible: isCompatibleHelper,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  getRuntimeTypedef
}, checkCompatibility) => {
  const fn = (arg) => {
    const getCallDataWithContext = (runtime, arg2, txOptions = {}) => {
      const ctx = getCompatibilityApi(runtime).runtime();
      const { dynamicBuilder, assetId, lookup: lookup2, extVersions } = ctx;
      let codecs;
      try {
        codecs = dynamicBuilder.buildCall(pallet, name);
      } catch {
        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
      }
      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg2))
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetId == null || !isCompatible(
          txOptions.asset,
          mapLookupToTypedef(lookup2(assetId)),
          (id) => getRuntimeTypedef(ctx, id)
        ))
          throw new Error(`Incompatible runtime asset`);
        returnOptions = {
          ...txOptions,
          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset)
        };
      }
      const { location, codec } = codecs;
      const callData = mergeUint82([new Uint8Array(location), codec.enc(arg2)]);
      return {
        callData: Binary.fromBytes(callData),
        bare: toHex(
          mergeUint82(
            compact.enc(callData.length + 1),
            new Uint8Array(extVersions.slice(-1)),
            callData
          )
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead2, null).pipe(
      map(([runtime]) => getCallDataWithContext(runtime, arg2, options))
    );
    const getEncodedData = (token) => {
      if (!token)
        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)));
      return getCallDataWithContext(token, arg).callData;
    };
    const getBareTx = (token) => {
      if (!token)
        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.bare)));
      return getCallDataWithContext(token, arg).bare;
    };
    const sign$ = (from2, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      mergeMap(
        ({ callData, options }) => createTx(
          chainHead2,
          from2,
          callData.asBytes(),
          atBlock,
          _options.customSignedExtensions || {},
          options
        )
      )
    );
    const _sign = (from2, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead2.finalized$ : at === "best" ? chainHead2.best$ : chainHead2.bestBlocks$.pipe(
        map((x) => x.find((b) => b.hash === at))
      )).pipe(
        take(1),
        mergeMap(
          (atBlock) => atBlock ? sign$(from2, _options, atBlock).pipe(
            map((signed) => ({
              tx: toHex(signed),
              block: atBlock
            }))
          ) : throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from2, options) => firstValueFrom(_sign(from2, options)).then((x) => x.tx);
    const signAndSubmit = (from2, _options) => firstValueFrom(_sign(from2, _options)).then(
      ({ tx, block }) => submit(chainHead2, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from2, _options) => _sign(from2, _options).pipe(
      mergeMap(({ tx }) => submit$(chainHead2, broadcast, tx, true))
    );
    const getPaymentInfo = async (from2, _options) => {
      if (typeof from2 === "string")
        from2 = from2.startsWith("0x") ? fromHex2(from2) : accountIdEnc(from2);
      const isEth = from2.length === 20;
      const fakeSigner = getPolkadotSigner(
        from2,
        isEth ? "Ecdsa" : "Sr25519",
        getFakeSignature(isEth)
      );
      const encoded = fromHex2(await sign(fakeSigner, _options));
      const args = toHex(mergeUint82([encoded, u32.enc(encoded.length)]));
      const decoder$ = chainHead2.getRuntimeContext$(null).pipe(
        map((ctx) => {
          try {
            return ctx.dynamicBuilder.buildRuntimeCall(
              "TransactionPaymentApi",
              "query_info"
            ).value[1];
          } catch {
            return queryInfoDecFallback;
          }
        })
      );
      const call$ = chainHead2.call$(
        null,
        "TransactionPaymentApi_query_info",
        args
      );
      return firstValueFrom(
        combineLatest([call$, decoder$]).pipe(
          map(([result, decoder]) => decoder(result))
        )
      );
    };
    const getEstimatedFees = async (from2, _options) => (await getPaymentInfo(from2, _options)).partial_fee;
    return {
      getPaymentInfo,
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: Enum3(name, arg)
      },
      getEncodedData,
      getBareTx,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, {
    getCompatibilityLevel,
    isCompatible: isCompatibleHelper
  });
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/utils/self-dependent.mjs
var selfDependent = () => {
  const activeSubject = new BehaviorSubject(
    new Subject()
  );
  return [
    activeSubject.pipe(switchAll()),
    () => tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new Subject());
      }
    })
  ];
};

// node_modules/.pnpm/@rx-state+core@0.1.4_rxjs@7.8.2/node_modules/@rx-state/core/dist/rxstate.core.es2017.js
var __defProp9 = Object.defineProperty;
var __defNormalProp8 = (obj, key, value2) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField8 = (obj, key, value2) => {
  __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var SUSPENSE = Symbol("SUSPENSE");
var StatePromise = class extends Promise {
  constructor(cb) {
    super(cb);
  }
};
var NoSubscribersError = class extends Error {
  constructor() {
    super();
    this.name = "NoSubscribersError";
  }
};
var EmptyObservableError = class extends Error {
  constructor() {
    super();
    this.name = "EmptyObservableError";
  }
};
var EMPTY_VALUE2 = {};
var StateObservable = class extends Observable {
  constructor(source$, defaultValue, teardown = noop3) {
    super((subscriber) => {
      const subscriberWithoutComplete = new Subscriber({
        next: subscriber.next.bind(subscriber),
        error: subscriber.error.bind(subscriber),
        complete: noop3
      });
      this.refCount++;
      let innerSub;
      subscriber.add(() => {
        var _a;
        this.refCount--;
        innerSub.unsubscribe();
        if (this.refCount === 0) {
          this.currentValue = EMPTY_VALUE2;
          if (this.subscription) {
            this.subscription.unsubscribe();
          }
          teardown();
          (_a = this.subject) == null ? void 0 : _a.complete();
          this.subject = null;
          this.subscription = null;
          if (this.promise) {
            this.promise.rej(new NoSubscribersError());
            this.promise = null;
          }
        }
      });
      if (!this.subject) {
        this.subject = new Subject();
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        this.subscription = null;
        this.subscription = new Subscriber({
          next: (value2) => {
            if (this.promise && value2 !== SUSPENSE) {
              this.promise.res(value2);
              this.promise = null;
            }
            this.subject.next(this.currentValue = value2);
          },
          error: (err) => {
            var _a;
            this.subscription = null;
            const subject = this.subject;
            this.subject = null;
            this.currentValue = EMPTY_VALUE2;
            const rej = (_a = this.promise) == null ? void 0 : _a.rej;
            if (rej && err === SUSPENSE) {
              this.promise.rej = () => {
                rej(err);
              };
            }
            subject.error(err);
            if (rej && this.promise) {
              this.promise.rej = rej;
            }
          },
          complete: () => {
            this.subscription = null;
            if (this.promise) {
              this.promise.rej(new EmptyObservableError());
              this.promise = null;
            }
            if (this.currentValue !== EMPTY_VALUE2)
              return this.subject.complete();
            if (defaultValue === EMPTY_VALUE2) {
              const subject = this.subject;
              this.subject = null;
              return subject.error(new EmptyObservableError());
            }
            this.subject.next(this.currentValue = defaultValue);
            this.subject.complete();
          }
        });
        source$.subscribe(this.subscription);
        if (defaultValue !== EMPTY_VALUE2 && this.currentValue === EMPTY_VALUE2) {
          this.subject.next(this.currentValue = defaultValue);
        }
      } else {
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        if (this.currentValue !== EMPTY_VALUE2) {
          subscriber.next(this.currentValue);
        }
      }
    });
    this.defaultValue = defaultValue;
    __publicField8(this, "subject", null);
    __publicField8(this, "subscription", null);
    __publicField8(this, "refCount", 0);
    __publicField8(this, "currentValue", EMPTY_VALUE2);
    __publicField8(this, "promise", null);
    __publicField8(this, "pipeState", (...ops) => {
      const result = super.pipe(...ops);
      return result instanceof StateObservable ? result : new StateObservable(result, EMPTY_VALUE2);
    });
    __publicField8(this, "getRefCount", () => {
      return this.refCount;
    });
    __publicField8(this, "getValue", () => {
      if (this.promise)
        return this.promise.p;
      if (this.currentValue !== EMPTY_VALUE2 && this.currentValue !== SUSPENSE)
        return this.currentValue;
      if (this.defaultValue !== EMPTY_VALUE2)
        return this.defaultValue;
      if (this.refCount === 0)
        throw new NoSubscribersError();
      const promise = new StatePromise((res, rej) => {
        this.promise = { res, rej, p: null };
      });
      this.promise.p = promise;
      return promise;
    });
    __publicField8(this, "getDefaultValue", () => {
      return this.defaultValue;
    });
    if (defaultValue === EMPTY_VALUE2) {
      delete this.getDefaultValue;
    }
  }
};
function cloneProps(internal, external2) {
  external2.getValue = internal.getValue;
  external2.getRefCount = internal.getRefCount;
  external2.pipeState = internal.pipeState;
  if (internal.getDefaultValue) {
    ;
    external2.getDefaultValue = internal.getDefaultValue;
  }
}
function connectFactoryObservable(getObservable, defaultValue) {
  const cache = new NestedMap();
  const getDefaultValue = typeof defaultValue === "function" ? defaultValue : () => defaultValue;
  const getSharedObservables$ = (input) => {
    for (let i = input.length - 1; input[i] === void 0 && i > -1; i--) {
      input.splice(-1);
    }
    const keys = [input.length, ...input];
    const cachedVal = cache.get(keys);
    if (cachedVal !== void 0) {
      return cachedVal;
    }
    const sharedObservable$ = new StateObservable(getObservable(...input), getDefaultValue(...input), () => {
      cache.delete(keys);
    });
    const publicShared$ = new Observable((subscriber) => {
      const inCache = cache.get(keys);
      let source$ = sharedObservable$;
      if (!inCache) {
        cache.set(keys, result);
      } else if (inCache !== publicShared$) {
        source$ = inCache;
        cloneProps(source$, publicShared$);
      }
      return source$.subscribe(subscriber);
    });
    cloneProps(sharedObservable$, publicShared$);
    const result = publicShared$;
    cache.set(keys, result);
    return result;
  };
  return (...input) => getSharedObservables$(input);
}
var NestedMap = class {
  constructor() {
    __publicField8(this, "root");
    this.root = /* @__PURE__ */ new Map();
  }
  get(keys) {
    let current = this.root;
    for (let i = 0; i < keys.length; i++) {
      current = current.get(keys[i]);
      if (!current)
        return void 0;
    }
    return current;
  }
  set(keys, value2) {
    let current = this.root;
    let i;
    for (i = 0; i < keys.length - 1; i++) {
      let nextCurrent = current.get(keys[i]);
      if (!nextCurrent) {
        nextCurrent = /* @__PURE__ */ new Map();
        current.set(keys[i], nextCurrent);
      }
      current = nextCurrent;
    }
    current.set(keys[i], value2);
  }
  delete(keys) {
    const maps = [this.root];
    let current = this.root;
    for (let i = 0; i < keys.length - 1; i++) {
      maps.push(current = current.get(keys[i]));
    }
    let mapIdx = maps.length - 1;
    maps[mapIdx].delete(keys[mapIdx]);
    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {
      maps[mapIdx].delete(keys[mapIdx]);
    }
  }
};
function state(observable2, defaultValue) {
  return new StateObservable(observable2, defaultValue);
}
var state2 = (...args) => (typeof args[0] === "function" ? connectFactoryObservable : state)(args[0], args.length > 1 ? args[1] : EMPTY_VALUE2);

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/watch-entries.mjs
var getDiff = (_prev, _current, patch) => {
  const current = new Map(_current.map((x) => [x.key, x]));
  const prev = new Map(_prev.map((x) => [x.key, x]));
  const upserted = /* @__PURE__ */ new Map();
  const deleted = [];
  _current.forEach((value2) => {
    const { key } = value2;
    const prevVal = prev.get(key);
    if (!prevVal || prevVal.value !== value2.value)
      upserted.set(key, patch(value2));
  });
  _prev.forEach((x) => {
    if (!current.has(x.key)) deleted.push(x);
  });
  return {
    deltas: {
      deleted,
      upserted: [...upserted.values()]
    },
    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key))
  };
};
var findPrevious = (start, state22, pinned, includeStart = false) => {
  try {
    let target = includeStart ? start : pinned.blocks.get(start).parent;
    while (target && !state22[target]) target = pinned.blocks.get(target).parent;
    if (!target) return null;
    return state22[target];
  } catch {
    return null;
  }
};
var getPatcherFromRuntime = (pallet, entry2) => (runtime) => {
  const { keys, value: value2 } = runtime.dynamicBuilder.buildStorage(pallet, entry2);
  return (x) => {
    x.dec = {
      value: value2.dec(x.value),
      args: keys.dec(x.key)
    };
    return x;
  };
};
var createWatchEntries = (blocks$, storage, withRuntime) => {
  const getMemoryBlocks$ = state2(
    (pallet, entry2, storageKey) => {
      const getPatcher = getPatcherFromRuntime(pallet, entry2);
      const getNextMemoryBlock$ = (prev, block) => {
        const isNotCanonical$ = isBestOrFinalizedBlock(
          blocks$,
          block.hash
        ).pipe(
          filter((x) => !x),
          take(1)
        );
        return storage(
          block.hash,
          "closestDescendantMerkleValue",
          () => storageKey
        ).pipe(
          mergeMap((rootHash) => {
            if (rootHash === prev?.rootHash)
              return of({
                ...prev,
                block,
                deltas: null,
                prev: prev.block.hash
              });
            return storage(
              block.hash,
              "descendantsValues",
              () => storageKey
            ).pipe(
              withRuntime(() => block.hash),
              map(
                ([entries, runtimeCtx]) => [entries, getPatcher(runtimeCtx)]
              ),
              map(
                ([entries, patcher]) => ({
                  prev: prev && prev.block.hash,
                  rootHash,
                  block,
                  ...getDiff(
                    prev?.entries ?? [],
                    entries,
                    patcher
                  )
                })
              )
            );
          }),
          takeUntil(isNotCanonical$),
          catchError(
            (e) => e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e)
          )
        );
      };
      const initial$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.finalized === b.finalized),
        lossLessExhaustMap(
          ({ blocks, finalized }) => getNextMemoryBlock$(null, blocks.get(finalized))
        ),
        take(1),
        map(
          (x) => ({
            blocks: { [x.block.hash]: x },
            finalized: x.block.hash
          })
        )
      );
      const [_memoryBlocks$, connectMemoryBlocks] = selfDependent();
      const updates$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.best === b.best),
        withLatestFrom(_memoryBlocks$),
        lossLessExhaustMap(([pinned, memoryBlocks]) => {
          const { best } = pinned;
          const { blocks } = memoryBlocks;
          let target = !blocks[best] ? best : null;
          if (!target) return EMPTY;
          const previous = findPrevious(target, blocks, pinned);
          if (previous)
            return getNextMemoryBlock$(
              previous,
              pinned.blocks.get(target)
            ).pipe(
              map((x) => {
                blocks[target] = x;
                return memoryBlocks;
              })
            );
          target = pinned.finalized;
          return getNextMemoryBlock$(
            blocks[memoryBlocks.finalized],
            pinned.blocks.get(target)
          ).pipe(
            map((x) => {
              x.prev = null;
              return {
                blocks: { [target]: x },
                finalized: target
              };
            })
          );
        })
      );
      return merge(initial$, updates$).pipe(connectMemoryBlocks());
    }
  );
  const getBestOrFinalized = (isFinalized) => (pallet, entry2, storageKey) => {
    const memoryBlocks$ = getMemoryBlocks$(pallet, entry2, storageKey);
    const getPatcher = getPatcherFromRuntime(pallet, entry2);
    const prop = isFinalized ? "finalized" : "best";
    return combineLatest([
      memoryBlocks$.pipe(delay(0)),
      blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop]))
    ]).pipe(
      map(
        ([state22, blocks]) => findPrevious(blocks[prop], state22.blocks, blocks, true)
      ),
      filter(Boolean),
      distinctUntilChanged(),
      startWith(null),
      pairwise(),
      withLatestFrom(memoryBlocks$),
      withRuntime(([[, _latest]]) => _latest.block.hash),
      map(
        ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) => [
          prevUpdate,
          latest,
          memoryBlocks,
          getPatcher(runtimeCtx)
        ]
      ),
      mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {
        if (!prevUpdate) return [latest];
        let ancestor = latest;
        const updates = [];
        while (ancestor && ancestor.block.number > prevUpdate.block.number) {
          updates.unshift(ancestor);
          ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null;
        }
        if (isFinalized) {
          memoryBlocks.finalized = latest.block.hash;
          if (updates.length) {
            const { blocks } = memoryBlocks;
            Object.keys(blocks).forEach((key) => {
              if (blocks[key].block.number < updates[0].block.number)
                delete blocks[key];
            });
          }
        }
        if (prevUpdate === ancestor) return updates;
        return [
          {
            ...latest,
            ...prevUpdate.rootHash === latest.rootHash ? {
              entries: prevUpdate.entries,
              deltas: null
            } : getDiff(prevUpdate.entries, latest.entries, patcher)
          }
        ];
      })
    );
  };
  const getFinalized$ = state2(getBestOrFinalized(true));
  const getBest$ = state2(getBestOrFinalized(false));
  return (pallet, entry2, args, atBest) => {
    const fn = atBest ? getBest$ : getFinalized$;
    const storageKey$ = blocks$.pipe(
      take(1),
      mergeMap(
        (b) => b.runtimes[b.blocks.get(b[atBest ? "best" : "finalized"]).runtime].runtime
      ),
      map(
        (runtime) => runtime.dynamicBuilder.buildStorage(pallet, entry2).keys.enc(...args)
      )
    );
    return storageKey$.pipe(
      take(1),
      mergeMap((storageKey) => fn(pallet, entry2, storageKey)),
      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {
        const actualDeltas = idx > 0 ? deltas : { deleted: [], upserted: entries };
        return {
          block: { hash, number, parent },
          entries: entries.map(toDec),
          deltas: actualDeltas && {
            deleted: actualDeltas.deleted.map(toDec),
            upserted: actualDeltas.upserted.map(toDec)
          }
        };
      })
    );
  };
};
var toDec = (x) => x.dec;

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/viewFns.mjs
var RUNTIME_NAMESPACE = "RuntimeViewFunction";
var RUNTIME_METHOD = "execute_view_function";
var RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + "_" + RUNTIME_METHOD;
var createViewFnEntry = (pallet, entry2, chainHead2, {
  isCompatible: isCompatible2,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry2})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead2, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let apiCodec;
        try {
          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(
            RUNTIME_NAMESPACE,
            RUNTIME_METHOD
          );
        } catch {
          throw new Error(
            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`
          );
        }
        let viewCodec;
        try {
          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry2);
        } catch {
          throw new Error(`Runtime entry ViewFn(${pallet}.${entry2}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        const viewArgs = viewCodec.args.enc(args);
        const arg = mergeUint82([
          fromHex2(
            ctx.lookup.metadata.pallets.find(({ name }) => name === pallet).viewFns.find(({ name }) => name === entry2).id
          ),
          compactNumber.enc(viewArgs.length),
          viewArgs
        ]);
        return chainHead2.call$(at, RUNTIME_CALL_NAME, toHex(arg)).pipe(
          map((v) => {
            try {
              const decoded = apiCodec.value.dec(v);
              if (!("success" in decoded && "value" in decoded) || !("type" in decoded.value) && !("asBytes" in decoded.value))
                throw null;
              return decoded;
            } catch {
              throw new Error(
                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`
              );
            }
          }),
          map(({ success, value: value2 }) => {
            if (!success) throw new Error(`ViewFn API Error: ${value2.type}`);
            const decoded = viewCodec.value.dec(value2.asBytes());
            if (!valuesAreCompatible(runtime, ctx, decoded))
              throw compatibilityError();
            return decoded;
          })
        );
      }),
      chainHead2.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible: isCompatible2 });
};

// node_modules/.pnpm/polkadot-api@1.23.2_rxjs@7.8.2/node_modules/polkadot-api/dist/esm/client.mjs
var HEX_REGEX = /^(?:0x)?((?:[0-9a-fA-F][0-9a-fA-F])+)$/;
var createApi = (compatibilityToken, chainHead2, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead2.pinnedBlocks$,
    chainHead2.storage$,
    chainHead2.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead2,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          const item = getPallet(ctx, pallet)?.storage?.items.find(
            (s) => s.name === name
          );
          return item == null ? null : storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry2 = ctx.lookup(id);
    if (entry2.type !== "enum") throw new Error("Expected enum");
    if (entry2.value[name] == null) return null;
    const node = enumValueEntryPointNode(entry2.value[name]);
    return {
      args: side === "args" ? node : voidEntryPointNode,
      values: side === "args" ? voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead2,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Tx, pallet, name),
        (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls?.type, name)
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Event, pallet, name),
        (ctx) => getEnumEntry(
          ctx,
          "values",
          getPallet(ctx, pallet)?.events?.type,
          name
        )
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          const item = getPallet(ctx, pallet)?.constants.find(
            (c) => c.name === name
          )?.type;
          return item == null ? null : singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Api, api, method),
        (ctx) => {
          const item = ctx.lookup.metadata.apis.find((a) => a.name === api)?.methods.find((m) => m.name === method);
          return item == null ? null : runtimeCallEntryPoint(item);
        }
      )
    )
  );
  const view = createProxyPath(
    (pallet, entry2) => createViewFnEntry(
      pallet,
      entry2,
      chainHead2,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry2),
        (ctx) => {
          const item = ctx.lookup.metadata.pallets.find((a) => a.name === pallet)?.viewFns.find((m) => m.name === entry2);
          return item == null ? null : runtimeCallEntryPoint(item);
        }
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup: lookup2, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup2.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead2,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getEntryPoint(OpType.Tx, pallet, call),
          (ctx) => getEnumEntry(
            ctx,
            "args",
            getPallet(ctx, pallet)?.calls?.type,
            call
          )
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants,
    view
  };
};
function createClient3(provider, { getMetadata: getMetadata2, setMetadata } = {}) {
  const rawClient = createClient2(provider);
  const client2 = getObservableClient(rawClient, {
    getMetadata: getMetadata2 ? (codeHash) => from(getMetadata2(codeHash)) : void 0,
    setMetadata
  });
  const { getChainSpecData } = rawClient;
  const { genesis$, ..._chainHead } = client2.chainHead$();
  const archive = client2.archive(_chainHead.getRuntime$);
  const chainHead2 = {
    ..._chainHead,
    genesis$: defer(getChainSpecData).pipe(
      map(({ genesisHash }) => genesisHash),
      catchError(() => genesis$),
      shareReplay(1)
    ),
    storage$: withArchive(_chainHead.storage$, archive.storage$),
    body$: withArchive(_chainHead.body$, archive.body$),
    call$: withArchive(_chainHead.call$, archive.call$),
    header$: withArchive(_chainHead.header$, archive.header$),
    eventsAt$: withArchive(_chainHead.eventsAt$, archive.eventsAt$),
    storageQueries$: withArchive(
      _chainHead.storageQueries$,
      archive.storageQueries$
    ),
    getRuntimeContext$: withArchive(
      _chainHead.getRuntimeContext$,
      archive.getRuntimeContext$
    )
  };
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result2 = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead2);
    compatibilityToken.set(chainDefinition, result2);
    return result2;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead2));
  const { broadcastTx$ } = client2;
  const getMetadata$ = (at) => chainHead2.getRuntimeContext$(at).pipe(map((ctx) => ctx.metadataRaw));
  const result = {
    getChainSpecData,
    getMetadata$,
    getMetadata: (atBlock, signal) => firstValueFromWithSignal(getMetadata$(atBlock), signal),
    blocks$: chainHead2.newBlocks$,
    hodlBlock: (block) => chainHead2.holdBlock(block, true),
    finalizedBlock$: chainHead2.finalized$,
    getFinalizedBlock: () => firstValueFrom(chainHead2.finalized$),
    bestBlocks$: chainHead2.bestBlocks$,
    getBestBlocks: () => firstValueFrom(chainHead2.bestBlocks$),
    watchBlockBody: chainHead2.body$,
    getBlockBody: (hash) => firstValueFrom(chainHead2.body$(hash)),
    getBlockHeader: (hash) => firstValueFrom(chainHead2.header$(hash ?? null)),
    submit: (...args) => submit(chainHead2, broadcastTx$, ...args),
    submitAndWatch: (tx) => submit$(chainHead2, broadcastTx$, tx),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead2, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead2, broadcastTx$), {
        runtimeToken: token
      });
    },
    rawQuery: (key, { at, signal } = {}) => firstValueFromWithSignal(
      chainHead2.storage$(at ?? null, "value", () => {
        const hex = key.match(HEX_REGEX)?.[1];
        return hex ? `0x${hex}` : Binary.fromText(key).asHex();
      }),
      signal
    ),
    destroy: () => {
      chainHead2.unfollow();
      client2.destroy();
    },
    _request
  };
  result.___INTERNAL_DO_NOT_USE = chainHead2;
  return result;
}

// node_modules/.pnpm/@polkadot-api+ws-provider@0.7.4/node_modules/@polkadot-api/ws-provider/dist/index/esm/types-common.mjs
var WsEvent = /* @__PURE__ */ ((WsEvent2) => {
  WsEvent2[WsEvent2["CONNECTING"] = 0] = "CONNECTING";
  WsEvent2[WsEvent2["CONNECTED"] = 1] = "CONNECTED";
  WsEvent2[WsEvent2["ERROR"] = 2] = "ERROR";
  WsEvent2[WsEvent2["CLOSE"] = 3] = "CLOSE";
  return WsEvent2;
})(WsEvent || {});

// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.7/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/json-rpc-message.mjs
var jsonRpcMsg = (msg) => JSON.stringify({
  jsonrpc: "2.0",
  ...msg
});

// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.7/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/get-opaque-token.mjs
var count = 0;
var getOpaqueToken = () => `proxyOpaque${count++}`;

// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.7/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/get-proxy.mjs
var getInternalId = () => `___proxyInternalId__${getOpaqueToken()}`;
var getProxy = (toConsumer) => {
  let state3 = {
    type: 1,
    activeBroadcasts: /* @__PURE__ */ new Map(),
    pending: []
  };
  const onMsgFromProvider = (msg) => {
    let isActive = true;
    if (state3.type === 0) {
      const parsed = JSON.parse(msg);
      if ("id" in parsed) {
        const { id } = parsed;
        if (state3.pendingBroadcasts.has(id)) {
          const synToken = state3.pendingBroadcasts.get(id);
          const upToken = parsed.result;
          state3.pendingBroadcasts.delete(id);
          const activeBroadcast = state3.activeBroadcasts.get(synToken);
          if (activeBroadcast)
            state3.activeBroadcasts.get(synToken).upToken = upToken;
          else
            state3.connection.send(
              jsonRpcMsg({
                id: getInternalId(),
                method: "transaction_v1_stop",
                params: [upToken]
              })
            );
          return;
        }
        isActive = state3.onGoingRequests.has(id);
        if ("result" in parsed && state3.onGoingRequests.get(id)?.type === 0)
          state3.activeChainHeads.add(parsed.result);
        state3.onGoingRequests.delete(parsed.id);
      } else if ("params" in parsed) {
        const { subscription, result } = parsed.params;
        if (result?.event === "stop")
          state3.activeChainHeads.delete(subscription);
      }
    }
    if (isActive && state3.type !== 2) toConsumer(msg);
  };
  const send = (msg) => {
    if (state3.type === 2) return;
    const parsed = JSON.parse(msg);
    if ("id" in parsed) {
      const { method, id, params: params2 } = parsed;
      const [group, , methodName] = method.split("_");
      if (group === "transaction") {
        if (methodName === "stop") {
          const [synToken] = params2;
          const active = state3.activeBroadcasts.get(synToken);
          state3.activeBroadcasts.delete(synToken);
          toConsumer(
            jsonRpcMsg({
              id,
              result: null
            })
          );
          if (state3.type === 0 && active && active.upToken) {
            state3.connection.send(
              jsonRpcMsg({
                id,
                method,
                params: [active.upToken]
              })
            );
          }
          return;
        }
        if (methodName === "broadcast") {
          const synToken = getOpaqueToken();
          state3.activeBroadcasts.set(synToken, {
            tx: params2[0],
            synToken
          });
          if (state3.type === 0) {
            state3.pendingBroadcasts.set(id, synToken);
            state3.connection.send(msg);
          }
          toConsumer(
            jsonRpcMsg({
              id,
              result: synToken
            })
          );
          return;
        }
      }
    }
    if (state3.type === 1) {
      state3.pending.push(msg);
      return;
    }
    if (parsed.method === "chainHead_v1_unfollow")
      state3.activeChainHeads.delete(parsed.params[0]);
    if ("id" in parsed) {
      const { method, id } = parsed;
      const [group, , methodName] = method.split("_");
      const ongoingMsg = group === "chainHead" ? methodName === "follow" ? {
        type: 0,
        msg
      } : { type: 1, id } : { type: 2, msg };
      state3.onGoingRequests.set(id, ongoingMsg);
    }
    state3.connection.send(msg);
  };
  return {
    send,
    disconnect: () => {
      if (state3.type === 2) return;
      if (state3.type === 0) state3.connection.disconnect();
      state3 = {
        type: 2
        /* Done */
      };
    },
    connect: (cb) => {
      if (state3.type !== 1) throw new Error("Nonesense");
      const { pending, activeBroadcasts } = state3;
      const onGoingRequests = /* @__PURE__ */ new Map();
      const activeChainHeads = /* @__PURE__ */ new Set();
      const onHalt = () => {
        const activeBroadcasts2 = state3.type !== 2 ? state3.activeBroadcasts : /* @__PURE__ */ new Map();
        activeBroadcasts2.forEach((x) => x.upToken = void 0);
        state3 = {
          type: 1,
          activeBroadcasts: activeBroadcasts2,
          pending: []
        };
        activeChainHeads.forEach((subscription) => {
          onMsgFromProvider(
            jsonRpcMsg({
              params: {
                subscription,
                result: {
                  event: "stop",
                  internal: true
                }
              }
            })
          );
        });
        activeChainHeads.clear();
        for (const x of onGoingRequests.values()) {
          if (x.type === 1)
            onMsgFromProvider(
              jsonRpcMsg({
                id: x.id,
                error: { code: -32603, message: "Internal error" },
                internal: true
              })
            );
          else send(x.msg);
        }
        onGoingRequests.clear();
      };
      state3 = {
        type: 0,
        connection: null,
        activeBroadcasts,
        pendingBroadcasts: /* @__PURE__ */ new Map(),
        onGoingRequests,
        activeChainHeads
      };
      state3.connection = cb(onMsgFromProvider, onHalt);
      activeBroadcasts.forEach((broadcast) => {
        if (state3.type === 0) {
          const id = getInternalId();
          state3.pendingBroadcasts.set(id, broadcast.synToken);
          send(
            jsonRpcMsg({
              id,
              method: "transaction_v1_broadcast",
              params: [broadcast.tx]
            })
          );
        }
      });
      pending.forEach(send);
    }
  };
};

// node_modules/.pnpm/@polkadot-api+json-rpc-provider-proxy@0.2.7/node_modules/@polkadot-api/json-rpc-provider-proxy/dist/esm/get-sync-provider.mjs
var WAIT_BASE = 250;
var getSyncProvider = (input) => (onMessage) => {
  let proxy = getProxy(onMessage);
  let lastHalt = Date.now();
  let consecutiveHalts = 0;
  let token;
  const getWaitTime = () => consecutiveHalts && 2 ** Math.min(5, consecutiveHalts) * WAIT_BASE;
  const startNow = () => input().then((cb) => {
    if (!proxy) {
      try {
        cb(
          () => {
          },
          () => {
          }
        ).disconnect();
      } catch (_) {
      }
    } else
      proxy.connect((onMsg, onHalt) => {
        let isOn = true;
        return cb(onMsg, () => {
          if (isOn) {
            isOn = false;
            const diff = lastHalt - Date.now();
            consecutiveHalts += diff > WAIT_BASE + getWaitTime() ? -consecutiveHalts : 1;
            lastHalt += diff;
            onHalt();
            start();
          }
        });
      });
  }, start);
  const start = () => {
    token = setTimeout(startNow, getWaitTime());
  };
  startNow();
  return {
    send: (msg) => {
      proxy?.send(msg);
    },
    disconnect: () => {
      clearTimeout(token);
      const disconnect = proxy?.disconnect || (() => {
      });
      proxy = null;
      disconnect();
    }
  };
};

// node_modules/.pnpm/@polkadot-api+ws-provider@0.7.4/node_modules/@polkadot-api/ws-provider/dist/index/esm/follow-enhancer.mjs
var methods = {};
["v1", "unstable"].forEach((version) => {
  methods[`chainHead_${version}_follow`] = "follow";
  methods[`chainHead_${version}_unfollow`] = "unfollow";
});
var resetStops = () => ({ latest: Date.now(), count: 0 });
var followEnhancer = (base, forceDisconnect) => {
  const prematureStops = /* @__PURE__ */ new Set();
  const preOpId = /* @__PURE__ */ new Map();
  const onGoing = /* @__PURE__ */ new Set();
  let methodsRequestId;
  let nStops = resetStops();
  const result = (onMsg) => {
    const { send, disconnect } = base((fromProvider) => {
      const parsed = JSON.parse(fromProvider);
      if ("id" in parsed) {
        const { id, result: result2 } = parsed;
        if (id === methodsRequestId) {
          methodsRequestId = void 0;
          if (result2 && !result2.methods.some((x) => {
            const [group, , name] = x.split("_");
            return group === "chainHead" && name === "follow";
          })) {
            onMsg(fromProvider);
            forceDisconnect();
            return;
          }
        }
        const msg = preOpId.get(id);
        if (msg) {
          preOpId.delete(id);
          if (prematureStops.has(result2)) {
            prematureStops.delete(result2);
            return;
          }
          onGoing.add(result2);
          const currentSize = onGoing.size + preOpId.size;
          if (currentSize > 2)
            console.warn(
              `Too many chainHead follow subscriptions (${currentSize})`
            );
          else if (parsed.error) {
            console.warn(`chainHead follow failed on the ${currentSize} sub`);
            forceDisconnect();
            preOpId.set(id, msg);
            send(msg);
            return;
          }
        }
      } else {
        const { subscription, result: result2 } = parsed.params;
        if (result2?.event === "stop") {
          const diff = Date.now() - nStops.latest;
          nStops.latest += diff;
          nStops.count = diff < 1e3 ? nStops.count + 1 : 1;
          if (onGoing.has(subscription)) onGoing.delete(subscription);
          else prematureStops.add(subscription);
        }
      }
      onMsg(fromProvider);
      if (nStops.count > 2) {
        nStops = resetStops();
        forceDisconnect();
      }
    });
    return {
      send(toProvider) {
        const parsed = JSON.parse(toProvider);
        if (parsed.method === "rpc_methods") methodsRequestId = parsed.id;
        const method = methods[parsed.method];
        if (method === "follow") {
          preOpId.set(parsed.id, toProvider);
        } else if (method === "unfollow") {
          onGoing.delete(parsed.params[0]);
        }
        send(toProvider);
      },
      disconnect
    };
  };
  return Object.assign(result, {
    cleanup: () => {
      prematureStops.clear();
      preOpId.clear();
      onGoing.clear();
    }
  });
};

// node_modules/.pnpm/@polkadot-api+ws-provider@0.7.4/node_modules/@polkadot-api/ws-provider/dist/index/esm/default-provider.mjs
var timeoutError = {
  type: WsEvent.ERROR,
  event: { type: "timeout" }
};
var noop5 = () => {
};
var defaultConfig = {
  onStatusChanged: noop5,
  innerEnhancer: (x) => x,
  timeout: 5e3,
  heartbeatTimeout: 4e4
};
var mapEndpoints = (endpoints) => endpoints.map((x) => typeof x === "string" ? [x] : [x.uri, x.protocol]);
var getWsProvider = (endpoints, config2) => {
  const { onStatusChanged, innerEnhancer, timeout, heartbeatTimeout } = {
    ...defaultConfig,
    ...config2
  };
  const actualEndpoints = mapEndpoints(
    Array.isArray(endpoints) ? endpoints : [endpoints]
  );
  const WebsocketClass = config2?.websocketClass ?? globalThis.WebSocket;
  if (!WebsocketClass) throw new Error("Missing WebSocket class");
  let idx = 0;
  let status;
  let switchTo = null;
  let disconnect = noop5;
  let outerCleanup = noop5;
  const result = followEnhancer(
    getSyncProvider(async () => {
      const [uri, protocols] = switchTo || actualEndpoints[idx++ % endpoints.length];
      switchTo = null;
      const socket = new WebsocketClass(uri, protocols);
      const forceSocketClose = () => {
        try {
          socket.addEventListener("error", noop5, { once: true });
          socket.close();
        } catch {
        }
      };
      onStatusChanged(
        status = {
          type: WsEvent.CONNECTING,
          uri,
          protocols
        }
      );
      await new Promise((resolve, reject) => {
        const onOpen = () => {
          initialCleanup();
          resolve();
        };
        const onError = (e) => {
          initialCleanup();
          if (e == null) forceSocketClose();
          console.error(
            `Unable to connect to ${uri}${protocols ? ", protocols: " + protocols : ""}`
          );
          onStatusChanged(
            status = {
              type: e ? WsEvent.ERROR : WsEvent.CLOSE,
              event: e
            }
          );
          setTimeout(reject, e ? 300 : 0, e);
        };
        const timeoutToken = timeout !== Infinity ? setTimeout(() => {
          initialCleanup();
          forceSocketClose();
          onStatusChanged(status = timeoutError);
          reject(timeoutError.event);
        }, timeout) : void 0;
        const initialCleanup = () => {
          clearTimeout(timeoutToken);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("open", onOpen);
        };
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
        disconnect = () => {
          onError(null);
        };
      });
      onStatusChanged(
        status = {
          type: WsEvent.CONNECTED,
          uri,
          protocols
        }
      );
      let _onInnerMessage;
      const inner = innerEnhancer((onInnerMessage) => {
        _onInnerMessage = onInnerMessage;
        return {
          send: (m) => {
            socket.send(m);
          },
          disconnect: () => {
            disconnect();
          }
        };
      });
      return (onMessage, onHalt) => {
        let heartbeatToken;
        const heartbeat = () => {
          if (heartbeatTimeout > MAX_HB_TIMEOUT) return;
          clearTimeout(heartbeatToken);
          heartbeatToken = setTimeout(() => {
            console.warn(`Terminate: heartbeat timeout`);
            disconnect(true);
          }, heartbeatTimeout);
        };
        heartbeat();
        const connection = inner(onMessage);
        const _onMessage = (e) => {
          heartbeat();
          if (typeof e.data === "string") _onInnerMessage(e.data);
        };
        const innerHalt = (reason) => (e) => {
          clearTimeout(heartbeatToken);
          console.warn(`WS halt (${reason})`);
          onStatusChanged(
            status = {
              type: reason,
              event: e
            }
          );
          onHalt();
        };
        const onError = innerHalt(WsEvent.ERROR);
        const onClose = innerHalt(WsEvent.CLOSE);
        socket.addEventListener("ping", heartbeat);
        socket.addEventListener("message", _onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("close", onClose);
        disconnect = (withHalt) => {
          clearTimeout(heartbeatToken);
          outerCleanup();
          disconnect = noop5;
          socket.removeEventListener("ping", heartbeat);
          socket.removeEventListener("message", _onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("close", onClose);
          forceSocketClose();
          if (withHalt) onClose({});
          connection.disconnect();
        };
        return connection;
      };
    }),
    () => {
      switchFn();
    }
  );
  outerCleanup = result.cleanup;
  delete result.cleanup;
  const switchFn = (...args) => {
    if (status.type === WsEvent.CLOSE) return;
    if (args.length) switchTo = args;
    if (status.type !== WsEvent.ERROR) disconnect(true);
  };
  return Object.assign(result, { switch: switchFn, getStatus: () => status });
};
var MAX_HB_TIMEOUT = 2147483647;

// node_modules/.pnpm/@polkadot-api+logs-provider@0.0.6/node_modules/@polkadot-api/logs-provider/dist/esm/types.mjs
var OUT = ">>";
var IN = "<<";

// node_modules/.pnpm/@polkadot-api+logs-provider@0.0.6/node_modules/@polkadot-api/logs-provider/dist/esm/with-logs-recorder.mjs
var withLogsRecorder = (persistLog, input) => {
  let nextId = 1;
  let token;
  let tickDate = "";
  const setTickDate = () => {
    tickDate = (/* @__PURE__ */ new Date()).toISOString();
    token = setTimeout(setTickDate, 0);
  };
  return (onMsg) => {
    const clientId = nextId++;
    setTickDate();
    const result = input((msg) => {
      persistLog(`${clientId}-${tickDate}-${IN}-${msg}`);
      onMsg(msg);
    });
    return {
      ...result,
      send: (msg) => {
        persistLog(`${clientId}-${tickDate}-${OUT}-${msg}`);
        result.send(msg);
      },
      disconnect() {
        clearTimeout(token);
        result.disconnect();
      }
    };
  };
};

// src/websocket.ts
var getWs = (wsUrl, config2 = {}) => {
  const endpoints = typeof wsUrl === "string" ? wsUrl.split(",") : wsUrl;
  const wsProvider2 = getWsProvider(endpoints, {
    //innerEnhancer: withLegacy(),
    ...config2
  });
  withLogsRecorder((line) => console.log(line), wsProvider2);
  return wsProvider2;
};

// src/index.ts
var wsProvider = getWs("wss://hydration-rpc.n.dwellir.com", {
  onStatusChanged: (s) => {
    switch (s.type) {
      case 0:
        console.log("[WS] CONNECTING", s.uri);
        break;
      case 1:
        console.log("[WS] CONNECTED", s.uri);
        break;
      case 2:
        console.warn("[WS] CLOSED", s.event);
        break;
      case 3:
        console.error("[WS] ERROR", s);
        break;
    }
  }
});
function watchTokensBalance(address, label) {
  const query = client.getTypedApi(hydration_default).query.Tokens.Accounts;
  return defer(() => query.watchEntries(address, { at: "best" })).pipe(
    tap({
      next: (a) => console.log("Upserted", label, a.deltas?.upserted.length),
      error: (e) => console.log("Error", label, e),
      complete: () => console.log("Complete", label)
    }),
    map(({ deltas }) => {
      const result = [];
      deltas?.deleted.forEach((u) => {
        const [_, asset2] = u.args;
        result.push({
          id: asset2,
          balance: 0n
        });
      });
      deltas?.upserted.forEach((u) => {
        const [_, asset2] = u.args;
        result.push({
          id: asset2,
          balance: u.value.free
        });
      });
      return result;
    })
  );
}
var client = createClient3(wsProvider);
var ACC = "7L53bUTBbfuj14UpdCNPwmgzzHSsrsTWBHX5pys32mVWM3C1";
watchTokensBalance(ACC, "FIRST").subscribe((balances) => {
  console.log("FIRST", balances);
});
setTimeout(() => {
  watchTokensBalance(ACC, "SECOND").subscribe((balances) => {
    console.log("SECOND", balances);
  });
}, 3e3);
/*! Bundled license information:

@scure/base/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
